import { parseContent } from './parsers';
import defaultSchema from './schema';
const isEmptyInputValue = (value) => {
    // we don't check for string here so it also works with arrays
    return value === null || value.length === 0;
};
const hasValidLength = (value) => {
    // non-strict comparison is intentional, to check for both `null` and `undefined` values
    return value != null && typeof value.length === 'number';
};
const isDocEmpty = (doc) => {
    if (!doc) {
        return true;
    }
    const { childCount, firstChild } = doc;
    return Boolean(childCount === 1 && firstChild?.isTextblock && firstChild.content.size === 0);
};
// @dynamic
export class Validators {
    static required(userSchema) {
        return (control) => {
            const schema = userSchema || defaultSchema;
            const doc = parseContent(control.value, schema);
            const isEmpty = isDocEmpty(doc);
            if (!isEmpty) {
                return null;
            }
            return {
                required: true
            };
        };
    }
    static maxLength(maxLength, userSchema) {
        return (control) => {
            const schema = userSchema || defaultSchema;
            const doc = parseContent(control.value, schema);
            const value = doc.textContent;
            if (hasValidLength(value) && value.length > maxLength) {
                return {
                    maxlength: {
                        requiredLength: maxLength,
                        actualLength: value.length
                    }
                };
            }
            return null;
        };
    }
    static minLength(minLength, userSchema) {
        return (control) => {
            const schema = userSchema || defaultSchema;
            const doc = parseContent(control.value, schema);
            const value = doc.textContent;
            if (isEmptyInputValue(value) || !hasValidLength(value)) {
                // don't validate empty values to allow optional controls
                // don't validate values without `length` property
                return null;
            }
            if (value.length < minLength) {
                return {
                    minlength: {
                        requiredLength: minLength, actualLength: value.length
                    }
                };
            }
            return null;
        };
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmFsaWRhdG9ycy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3Byb2plY3RzL25neC1lZGl0b3Ivc3JjL2xpYi92YWxpZGF0b3JzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUdBLE9BQU8sRUFBRSxZQUFZLEVBQUUsTUFBTSxXQUFXLENBQUM7QUFDekMsT0FBTyxhQUFhLE1BQU0sVUFBVSxDQUFDO0FBSXJDLE1BQU0saUJBQWlCLEdBQUcsQ0FBQyxLQUFVLEVBQVcsRUFBRTtJQUNoRCw4REFBOEQ7SUFDOUQsT0FBTyxLQUFLLEtBQUssSUFBSSxJQUFJLEtBQUssQ0FBQyxNQUFNLEtBQUssQ0FBQyxDQUFDO0FBQzlDLENBQUMsQ0FBQztBQUVGLE1BQU0sY0FBYyxHQUFHLENBQUMsS0FBVSxFQUFXLEVBQUU7SUFDN0Msd0ZBQXdGO0lBQ3hGLE9BQU8sS0FBSyxJQUFJLElBQUksSUFBSSxPQUFPLEtBQUssQ0FBQyxNQUFNLEtBQUssUUFBUSxDQUFDO0FBQzNELENBQUMsQ0FBQztBQUVGLE1BQU0sVUFBVSxHQUFHLENBQUMsR0FBMkIsRUFBVyxFQUFFO0lBQzFELElBQUksQ0FBQyxHQUFHLEVBQUU7UUFDUixPQUFPLElBQUksQ0FBQztLQUNiO0lBRUQsTUFBTSxFQUFFLFVBQVUsRUFBRSxVQUFVLEVBQUUsR0FBRyxHQUFHLENBQUM7SUFDdkMsT0FBTyxPQUFPLENBQUMsVUFBVSxLQUFLLENBQUMsSUFBSSxVQUFVLEVBQUUsV0FBVyxJQUFJLFVBQVUsQ0FBQyxPQUFPLENBQUMsSUFBSSxLQUFLLENBQUMsQ0FBQyxDQUFDO0FBQy9GLENBQUMsQ0FBQztBQUVGLFdBQVc7QUFDWCxNQUFNLE9BQU8sVUFBVTtJQUVyQixNQUFNLENBQUMsUUFBUSxDQUFDLFVBQW1CO1FBQ2pDLE9BQU8sQ0FBQyxPQUF3QixFQUEyQixFQUFFO1lBRTNELE1BQU0sTUFBTSxHQUFHLFVBQVUsSUFBSSxhQUFhLENBQUM7WUFDM0MsTUFBTSxHQUFHLEdBQUcsWUFBWSxDQUFDLE9BQU8sQ0FBQyxLQUFLLEVBQUUsTUFBTSxDQUFDLENBQUM7WUFFaEQsTUFBTSxPQUFPLEdBQUcsVUFBVSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1lBRWhDLElBQUksQ0FBQyxPQUFPLEVBQUU7Z0JBQ1osT0FBTyxJQUFJLENBQUM7YUFDYjtZQUVELE9BQU87Z0JBQ0wsUUFBUSxFQUFFLElBQUk7YUFDZixDQUFDO1FBQ0osQ0FBQyxDQUFDO0lBQ0osQ0FBQztJQUVELE1BQU0sQ0FBQyxTQUFTLENBQUMsU0FBaUIsRUFBRSxVQUFtQjtRQUNyRCxPQUFPLENBQUMsT0FBd0IsRUFBMkIsRUFBRTtZQUMzRCxNQUFNLE1BQU0sR0FBRyxVQUFVLElBQUksYUFBYSxDQUFDO1lBQzNDLE1BQU0sR0FBRyxHQUFHLFlBQVksQ0FBQyxPQUFPLENBQUMsS0FBSyxFQUFFLE1BQU0sQ0FBQyxDQUFDO1lBRWhELE1BQU0sS0FBSyxHQUFHLEdBQUcsQ0FBQyxXQUFXLENBQUM7WUFFOUIsSUFBSSxjQUFjLENBQUMsS0FBSyxDQUFDLElBQUksS0FBSyxDQUFDLE1BQU0sR0FBRyxTQUFTLEVBQUU7Z0JBQ3JELE9BQU87b0JBQ0wsU0FBUyxFQUFFO3dCQUNULGNBQWMsRUFBRSxTQUFTO3dCQUN6QixZQUFZLEVBQUUsS0FBSyxDQUFDLE1BQU07cUJBQzNCO2lCQUNGLENBQUM7YUFDSDtZQUVELE9BQU8sSUFBSSxDQUFDO1FBQ2QsQ0FBQyxDQUFDO0lBQ0osQ0FBQztJQUVELE1BQU0sQ0FBQyxTQUFTLENBQUMsU0FBaUIsRUFBRSxVQUFtQjtRQUNyRCxPQUFPLENBQUMsT0FBd0IsRUFBMkIsRUFBRTtZQUUzRCxNQUFNLE1BQU0sR0FBRyxVQUFVLElBQUksYUFBYSxDQUFDO1lBQzNDLE1BQU0sR0FBRyxHQUFHLFlBQVksQ0FBQyxPQUFPLENBQUMsS0FBSyxFQUFFLE1BQU0sQ0FBQyxDQUFDO1lBRWhELE1BQU0sS0FBSyxHQUFHLEdBQUcsQ0FBQyxXQUFXLENBQUM7WUFFOUIsSUFBSSxpQkFBaUIsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLGNBQWMsQ0FBQyxLQUFLLENBQUMsRUFBRTtnQkFDdEQseURBQXlEO2dCQUN6RCxrREFBa0Q7Z0JBQ2xELE9BQU8sSUFBSSxDQUFDO2FBQ2I7WUFFRCxJQUFJLEtBQUssQ0FBQyxNQUFNLEdBQUcsU0FBUyxFQUFFO2dCQUM1QixPQUFPO29CQUNMLFNBQVMsRUFBRTt3QkFDVCxjQUFjLEVBQUUsU0FBUyxFQUFFLFlBQVksRUFBRSxLQUFLLENBQUMsTUFBTTtxQkFDdEQ7aUJBQ0YsQ0FBQzthQUNIO1lBRUQsT0FBTyxJQUFJLENBQUM7UUFDZCxDQUFDLENBQUM7SUFDSixDQUFDO0NBQ0YiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBBYnN0cmFjdENvbnRyb2wsIFZhbGlkYXRvckZuIH0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuaW1wb3J0IHsgU2NoZW1hLCBOb2RlIGFzIFByb3NlTWlycm9yTm9kZSB9IGZyb20gJ3Byb3NlbWlycm9yLW1vZGVsJztcblxuaW1wb3J0IHsgcGFyc2VDb250ZW50IH0gZnJvbSAnLi9wYXJzZXJzJztcbmltcG9ydCBkZWZhdWx0U2NoZW1hIGZyb20gJy4vc2NoZW1hJztcblxudHlwZSBWYWxpZGF0aW9uRXJyb3JzID0gUmVjb3JkPHN0cmluZywgYW55PjtcblxuY29uc3QgaXNFbXB0eUlucHV0VmFsdWUgPSAodmFsdWU6IGFueSk6IGJvb2xlYW4gPT4ge1xuICAvLyB3ZSBkb24ndCBjaGVjayBmb3Igc3RyaW5nIGhlcmUgc28gaXQgYWxzbyB3b3JrcyB3aXRoIGFycmF5c1xuICByZXR1cm4gdmFsdWUgPT09IG51bGwgfHwgdmFsdWUubGVuZ3RoID09PSAwO1xufTtcblxuY29uc3QgaGFzVmFsaWRMZW5ndGggPSAodmFsdWU6IGFueSk6IGJvb2xlYW4gPT4ge1xuICAvLyBub24tc3RyaWN0IGNvbXBhcmlzb24gaXMgaW50ZW50aW9uYWwsIHRvIGNoZWNrIGZvciBib3RoIGBudWxsYCBhbmQgYHVuZGVmaW5lZGAgdmFsdWVzXG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIHR5cGVvZiB2YWx1ZS5sZW5ndGggPT09ICdudW1iZXInO1xufTtcblxuY29uc3QgaXNEb2NFbXB0eSA9IChkb2M6IFByb3NlTWlycm9yTm9kZSB8IG51bGwpOiBib29sZWFuID0+IHtcbiAgaWYgKCFkb2MpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGNvbnN0IHsgY2hpbGRDb3VudCwgZmlyc3RDaGlsZCB9ID0gZG9jO1xuICByZXR1cm4gQm9vbGVhbihjaGlsZENvdW50ID09PSAxICYmIGZpcnN0Q2hpbGQ/LmlzVGV4dGJsb2NrICYmIGZpcnN0Q2hpbGQuY29udGVudC5zaXplID09PSAwKTtcbn07XG5cbi8vIEBkeW5hbWljXG5leHBvcnQgY2xhc3MgVmFsaWRhdG9ycyB7XG5cbiAgc3RhdGljIHJlcXVpcmVkKHVzZXJTY2hlbWE/OiBTY2hlbWEpOiBWYWxpZGF0b3JGbiB7XG4gICAgcmV0dXJuIChjb250cm9sOiBBYnN0cmFjdENvbnRyb2wpOiBWYWxpZGF0aW9uRXJyb3JzIHwgbnVsbCA9PiB7XG5cbiAgICAgIGNvbnN0IHNjaGVtYSA9IHVzZXJTY2hlbWEgfHwgZGVmYXVsdFNjaGVtYTtcbiAgICAgIGNvbnN0IGRvYyA9IHBhcnNlQ29udGVudChjb250cm9sLnZhbHVlLCBzY2hlbWEpO1xuXG4gICAgICBjb25zdCBpc0VtcHR5ID0gaXNEb2NFbXB0eShkb2MpO1xuXG4gICAgICBpZiAoIWlzRW1wdHkpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJlcXVpcmVkOiB0cnVlXG4gICAgICB9O1xuICAgIH07XG4gIH1cblxuICBzdGF0aWMgbWF4TGVuZ3RoKG1heExlbmd0aDogbnVtYmVyLCB1c2VyU2NoZW1hPzogU2NoZW1hKTogVmFsaWRhdG9yRm4ge1xuICAgIHJldHVybiAoY29udHJvbDogQWJzdHJhY3RDb250cm9sKTogVmFsaWRhdGlvbkVycm9ycyB8IG51bGwgPT4ge1xuICAgICAgY29uc3Qgc2NoZW1hID0gdXNlclNjaGVtYSB8fCBkZWZhdWx0U2NoZW1hO1xuICAgICAgY29uc3QgZG9jID0gcGFyc2VDb250ZW50KGNvbnRyb2wudmFsdWUsIHNjaGVtYSk7XG5cbiAgICAgIGNvbnN0IHZhbHVlID0gZG9jLnRleHRDb250ZW50O1xuXG4gICAgICBpZiAoaGFzVmFsaWRMZW5ndGgodmFsdWUpICYmIHZhbHVlLmxlbmd0aCA+IG1heExlbmd0aCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG1heGxlbmd0aDoge1xuICAgICAgICAgICAgcmVxdWlyZWRMZW5ndGg6IG1heExlbmd0aCxcbiAgICAgICAgICAgIGFjdHVhbExlbmd0aDogdmFsdWUubGVuZ3RoXG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICB9XG5cbiAgc3RhdGljIG1pbkxlbmd0aChtaW5MZW5ndGg6IG51bWJlciwgdXNlclNjaGVtYT86IFNjaGVtYSk6IFZhbGlkYXRvckZuIHtcbiAgICByZXR1cm4gKGNvbnRyb2w6IEFic3RyYWN0Q29udHJvbCk6IFZhbGlkYXRpb25FcnJvcnMgfCBudWxsID0+IHtcblxuICAgICAgY29uc3Qgc2NoZW1hID0gdXNlclNjaGVtYSB8fCBkZWZhdWx0U2NoZW1hO1xuICAgICAgY29uc3QgZG9jID0gcGFyc2VDb250ZW50KGNvbnRyb2wudmFsdWUsIHNjaGVtYSk7XG5cbiAgICAgIGNvbnN0IHZhbHVlID0gZG9jLnRleHRDb250ZW50O1xuXG4gICAgICBpZiAoaXNFbXB0eUlucHV0VmFsdWUodmFsdWUpIHx8ICFoYXNWYWxpZExlbmd0aCh2YWx1ZSkpIHtcbiAgICAgICAgLy8gZG9uJ3QgdmFsaWRhdGUgZW1wdHkgdmFsdWVzIHRvIGFsbG93IG9wdGlvbmFsIGNvbnRyb2xzXG4gICAgICAgIC8vIGRvbid0IHZhbGlkYXRlIHZhbHVlcyB3aXRob3V0IGBsZW5ndGhgIHByb3BlcnR5XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICBpZiAodmFsdWUubGVuZ3RoIDwgbWluTGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbWlubGVuZ3RoOiB7XG4gICAgICAgICAgICByZXF1aXJlZExlbmd0aDogbWluTGVuZ3RoLCBhY3R1YWxMZW5ndGg6IHZhbHVlLmxlbmd0aFxuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgfVxufVxuIl19