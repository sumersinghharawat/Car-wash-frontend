{"ast":null,"code":"import { CompressedStreamWriter } from '@syncfusion/ej2-compression';\nimport { Encoding, StreamWriter } from '@syncfusion/ej2-file-utils';\n/**\n * @private\n * @hidden\n */\n\nfunction defaultToString(item) {\n  // if (item === null) {\n  //     return 'COLLECTION_NULL';\n  // } else if (typeof item === 'undefined') {\n  //     return 'COLLECTION_UNDEFINED';\n  // } else if (Object.prototype.toString.call(item) === '[object String]') {\n  if (Object.prototype.toString.call(item) === '[object String]') {\n    return '$s' + item;\n  } else {\n    return '$o' + item.toString();\n  }\n}\n/**\n * Dictionary.ts class for EJ2-PDF\n * @private\n * @hidden\n */\n\n/**\n * @private\n * @hidden\n */\n\n\nclass Dictionary {\n  /**\n   * @private\n   * @hidden\n   */\n  constructor(toStringFunction) {\n    this.table = {};\n    this.nElements = 0;\n    this.toStr = toStringFunction || defaultToString;\n  }\n  /**\n   * @private\n   * @hidden\n   */\n\n\n  getValue(key) {\n    const pair = this.table['$' + this.toStr(key)];\n\n    if (typeof pair === 'undefined') {\n      return undefined;\n    }\n\n    return pair.value;\n  }\n  /**\n   * @private\n   * @hidden\n   */\n\n\n  setValue(key, value) {\n    // if (typeof key === 'undefined' || typeof value === 'undefined') {\n    //     return undefined;\n    // }\n    let ret;\n    const k = '$' + this.toStr(key);\n    const previousElement = this.table[k]; // if (typeof previousElement === 'undefined') {\n\n    this.nElements++;\n    ret = undefined; // }\n\n    this.table[k] = {\n      key: key,\n      value: value\n    };\n    return ret;\n  }\n  /**\n   * @private\n   * @hidden\n   */\n\n\n  remove(key) {\n    const k = '$' + this.toStr(key);\n    const previousElement = this.table[k]; // if (typeof previousElement !== 'undefined') {\n\n    delete this.table[k];\n    this.nElements--;\n    return previousElement.value; // }\n    // return undefined;\n  }\n  /**\n   * @private\n   * @hidden\n   */\n\n\n  keys() {\n    const keysArray = [];\n    let namesOfKeys = Object.keys(this.table);\n\n    for (let index1 = 0; index1 < namesOfKeys.length; index1++) {\n      // if (Object.prototype.hasOwnProperty.call(this.table, namesOfKeys[index1])) {\n      const pair1 = this.table[namesOfKeys[index1]];\n      keysArray.push(pair1.key); // }\n    }\n\n    return keysArray;\n  }\n  /**\n   * @private\n   * @hidden\n   */\n\n\n  values() {\n    const valuesArray = [];\n    let namesOfValues = Object.keys(this.table);\n\n    for (let index2 = 0; index2 < namesOfValues.length; index2++) {\n      // if (Object.prototype.hasOwnProperty.call(this.table, namesOfValues[index2])) {\n      const pair2 = this.table[namesOfValues[index2]];\n      valuesArray.push(pair2.value); // }\n    }\n\n    return valuesArray;\n  }\n  /**\n   * @private\n   * @hidden\n   */\n\n\n  containsKey(key) {\n    let retutnValue = true;\n\n    if (typeof this.getValue(key) === 'undefined') {\n      retutnValue = true;\n    } else {\n      retutnValue = false;\n    }\n\n    return !retutnValue;\n  }\n  /**\n   * @private\n   * @hidden\n   */\n\n\n  clear() {\n    this.table = {};\n    this.nElements = 0;\n  }\n  /**\n   * @private\n   * @hidden\n   */\n\n\n  size() {\n    return this.nElements;\n  }\n\n} // End of dictionary\n\n/**\n * `PdfName` class is used to perform name (element names) related primitive operations.\n * @private\n */\n\n\nlet PdfName = /*#__PURE__*/(() => {\n  class PdfName {\n    constructor(value) {\n      /**\n       * `Start symbol` of the name object.\n       * @default /\n       * @private\n       */\n      this.stringStartMark = '/';\n      /**\n       * `Value` of the element.\n       * @private\n       */\n\n      this.internalValue = '';\n      /**\n       * Indicates if the object is currently in `saving state or not`.\n       * @default false\n       * @private\n       */\n\n      this.isSaving6 = false;\n      /**\n       * Internal variable to store the `position`.\n       * @default -1\n       * @private\n       */\n\n      this.position6 = -1;\n      this.internalValue = this.normalizeValue(value);\n    } //property\n\n    /**\n     * Gets or sets the `Status` of the specified object.\n     * @private\n     */\n\n\n    get status() {\n      return this.status6;\n    }\n\n    set status(value) {\n      this.status6 = value;\n    }\n    /**\n     * Gets or sets a value indicating whether this document `is saving` or not.\n     * @private\n     */\n\n\n    get isSaving() {\n      return this.isSaving6;\n    }\n\n    set isSaving(value) {\n      this.isSaving6 = value;\n    }\n    /**\n     * Gets or sets the `index` value of the specified object.\n     * @private\n     */\n\n\n    get objectCollectionIndex() {\n      return this.index6;\n    }\n\n    set objectCollectionIndex(value) {\n      this.index6 = value;\n    }\n    /**\n     * Gets or sets the `position` of the object.\n     * @private\n     */\n\n\n    get position() {\n      return this.position6;\n    }\n\n    set position(value) {\n      this.position6 = value;\n    }\n    /**\n     * Returns `cloned object`.\n     * @private\n     */\n\n\n    get clonedObject() {\n      return null;\n    }\n    /**\n     * Gets or sets the `value` of the object.\n     * @private\n     */\n\n\n    get value() {\n      return this.internalValue;\n    }\n\n    set value(value) {\n      // if (value !== this.value) {\n      let val = value;\n\n      if (value !== null && value.length > 0) {\n        // val = (value.substring(0, 1) === this.stringStartMark) ? value.substring(1) : value;\n        val = value;\n        this.internalValue = this.normalizeValue(val);\n      } else {\n        this.internalValue = val;\n      } // }\n\n    } //public methods\n\n    /**\n     * `Saves` the name using the specified writer.\n     * @private\n     */\n\n\n    save(writer) {\n      // if (writer === null) {\n      //     throw new Error('ArgumentNullException : writer');\n      // }\n      writer.write(this.toString());\n    }\n    /**\n     * Gets `string` representation of the primitive.\n     * @private\n     */\n\n\n    toString() {\n      return this.stringStartMark + this.escapeString(this.value);\n    }\n    /**\n     * Creates a `copy of PdfName`.\n     * @private\n     */\n\n\n    clone(crossTable) {\n      let newName = new PdfName();\n      newName.value = this.internalValue;\n      return newName;\n    }\n    /**\n     * Replace some characters with its `escape sequences`.\n     * @private\n     */\n\n\n    escapeString(stringValue) {\n      // if (str === null) {\n      //     throw new Error('ArgumentNullException : str');\n      // }\n      // if (str === '') {\n      //     return str;\n      // }\n      let result = '';\n\n      for (let i = 0, len = stringValue.length; i < len; i++) {\n        let ch = stringValue[i];\n        let index = PdfName.delimiters.indexOf(ch); // switch (ch) {\n        //     case '\\r' :\n        //         result = result + '\\\\r';\n        //         break;\n        //     case '\\n' :\n        //         result = result + '\\n';\n        //         break;\n        //     case '(' :\n        //     case ')' :\n        //     case '\\\\' :\n        //         //result.Append( '\\\\' ).Append( ch );\n        //         result = result + ch;\n        //         break;\n        //     default :\n        //         result = result + ch;\n        //         break;\n        // }\n\n        result = result + ch;\n      }\n\n      return result;\n    } //methiods\n\n    /**\n     * Replace a symbol with its code with the precedence of the `sharp sign`.\n     * @private\n     */\n\n\n    normalizeValue(value, c) {\n      // if (typeof c === undefined) {\n      //     let str : string = value;\n      //     for (let i : number = 0; i < PdfName.replacements.length; i++) {\n      //         str = this.normalizeValue(str, c);\n      //     }\n      //     return str;\n      // } else {\n      return value; // }\n    }\n\n  }\n\n  /**\n   * PDF `special characters`.\n   * @private\n   */\n  PdfName.delimiters = '()<>[]{}/%}';\n  /**\n   * The symbols that are not allowed in PDF names and `should be replaced`.\n   * @private\n   */\n\n  PdfName.replacements = [' ', '\\t', '\\n', '\\r'];\n  /**\n   * PdfOperators.ts class for EJ2-PDF\n   * Class of string PDF common operators.\n   * @private\n   */\n\n  return PdfName;\n})();\nlet Operators = /*#__PURE__*/(() => {\n  class Operators {\n    /**\n     * Create an instance of `PdfOperator` class.\n     * @private\n     */\n    constructor() {\n      /**\n       * Specifies the value of `test`.\n       * @private\n       */\n      this.forTest = 'test';\n      this.forTest = Operators.obj;\n    }\n\n  }\n\n  /**\n   * Specifies the value of `obj`.\n   * @private\n   */\n  Operators.obj = 'obj';\n  /**\n   * Specifies the value of `endObj`.\n   * @private\n   */\n\n  Operators.endObj = 'endobj';\n  /**\n   * Specifies the value of `R`.\n   * @private\n   */\n\n  Operators.r = 'R';\n  /**\n   * Specifies the value of ` `.\n   * @private\n   */\n\n  Operators.whiteSpace = ' ';\n  /**\n   * Specifies the value of `/`.\n   * @private\n   */\n\n  Operators.slash = '/';\n  /**\n   * Specifies the value of `\\r\\n`.\n   * @private\n   */\n\n  Operators.newLine = '\\r\\n';\n  /**\n   * Specifies the value of `stream`.\n   * @private\n   */\n\n  Operators.stream = 'stream';\n  /**\n   * Specifies the value of `endStream`.\n   * @private\n   */\n\n  Operators.endStream = 'endstream';\n  /**\n   * Specifies the value of `xref`.\n   * @private\n   */\n\n  Operators.xref = 'xref';\n  /**\n   * Specifies the value of `f`.\n   * @private\n   */\n\n  Operators.f = 'f';\n  /**\n   * Specifies the value of `n`.\n   * @private\n   */\n\n  Operators.n = 'n';\n  /**\n   * Specifies the value of `trailer`.\n   * @private\n   */\n\n  Operators.trailer = 'trailer';\n  /**\n   * Specifies the value of `startxref`.\n   * @private\n   */\n\n  Operators.startxref = 'startxref';\n  /**\n   * Specifies the value of `eof`.\n   * @private\n   */\n\n  Operators.eof = '%%EOF';\n  /**\n   * Specifies the value of `header`.\n   * @private\n   */\n\n  Operators.header = '%PDF-1.5';\n  /**\n   * Specifies the value of `beginText`.\n   * @private\n   */\n\n  Operators.beginText = 'BT';\n  /**\n   * Specifies the value of `endText`.\n   * @private\n   */\n\n  Operators.endText = 'ET';\n  /**\n   * Specifies the value of `m`.\n   * @private\n   */\n\n  Operators.beginPath = 'm';\n  /**\n   * Specifies the value of `l`.\n   * @private\n   */\n\n  Operators.appendLineSegment = 'l';\n  /**\n   * Specifies the value of `S`.\n   * @private\n   */\n\n  Operators.stroke = 'S';\n  /**\n   * Specifies the value of `f`.\n   * @private\n   */\n\n  Operators.fill = 'f';\n  /**\n   * Specifies the value of `f*`.\n   * @private\n   */\n\n  Operators.fillEvenOdd = 'f*';\n  /**\n   * Specifies the value of `B`.\n   * @private\n   */\n\n  Operators.fillStroke = 'B';\n  /**\n   * Specifies the value of `B*`.\n   * @private\n   */\n\n  Operators.fillStrokeEvenOdd = 'B*';\n  /**\n   * Specifies the value of `c`.\n   * @private\n   */\n\n  Operators.appendbeziercurve = 'c';\n  /**\n   * Specifies the value of `re`.\n   * @private\n   */\n\n  Operators.appendRectangle = 're';\n  /**\n   * Specifies the value of `q`.\n   * @private\n   */\n\n  Operators.saveState = 'q';\n  /**\n   * Specifies the value of `Q`.\n   * @private\n   */\n\n  Operators.restoreState = 'Q';\n  /**\n   * Specifies the value of `Do`.\n   * @private\n   */\n\n  Operators.paintXObject = 'Do';\n  /**\n   * Specifies the value of `cm`.\n   * @private\n   */\n\n  Operators.modifyCtm = 'cm';\n  /**\n   * Specifies the value of `Tm`.\n   * @private\n   */\n\n  Operators.modifyTM = 'Tm';\n  /**\n   * Specifies the value of `w`.\n   * @private\n   */\n\n  Operators.setLineWidth = 'w';\n  /**\n   * Specifies the value of `J`.\n   * @private\n   */\n\n  Operators.setLineCapStyle = 'J';\n  /**\n   * Specifies the value of `j`.\n   * @private\n   */\n\n  Operators.setLineJoinStyle = 'j';\n  /**\n   * Specifies the value of `d`.\n   * @private\n   */\n\n  Operators.setDashPattern = 'd';\n  /**\n   * Specifies the value of `i`.\n   * @private\n   */\n\n  Operators.setFlatnessTolerance = 'i';\n  /**\n   * Specifies the value of `h`.\n   * @private\n   */\n\n  Operators.closePath = 'h';\n  /**\n   * Specifies the value of `s`.\n   * @private\n   */\n\n  Operators.closeStrokePath = 's';\n  /**\n   * Specifies the value of `b`.\n   * @private\n   */\n\n  Operators.closeFillStrokePath = 'b';\n  /**\n   * Specifies the value of `setCharacterSpace`.\n   * @private\n   */\n\n  Operators.setCharacterSpace = 'Tc';\n  /**\n   * Specifies the value of `setWordSpace`.\n   * @private\n   */\n\n  Operators.setWordSpace = 'Tw';\n  /**\n   * Specifies the value of `setHorizontalScaling`.\n   * @private\n   */\n\n  Operators.setHorizontalScaling = 'Tz';\n  /**\n   * Specifies the value of `setTextLeading`.\n   * @private\n   */\n\n  Operators.setTextLeading = 'TL';\n  /**\n   * Specifies the value of `setFont`.\n   * @private\n   */\n\n  Operators.setFont = 'Tf';\n  /**\n   * Specifies the value of `setRenderingMode`.\n   * @private\n   */\n\n  Operators.setRenderingMode = 'Tr';\n  /**\n   * Specifies the value of `setTextRise`.\n   * @private\n   */\n\n  Operators.setTextRise = 'Ts';\n  /**\n   * Specifies the value of `setTextScaling`.\n   * @private\n   */\n\n  Operators.setTextScaling = 'Tz';\n  /**\n   * Specifies the value of `setCoords`.\n   * @private\n   */\n\n  Operators.setCoords = 'Td';\n  /**\n   * Specifies the value of `goToNextLine`.\n   * @private\n   */\n\n  Operators.goToNextLine = 'T*';\n  /**\n   * Specifies the value of `setText`.\n   * @private\n   */\n\n  Operators.setText = 'Tj';\n  /**\n   * Specifies the value of `setTextWithFormatting`.\n   * @private\n   */\n\n  Operators.setTextWithFormatting = 'TJ';\n  /**\n   * Specifies the value of `setTextOnNewLine`.\n   * @private\n   */\n\n  Operators.setTextOnNewLine = '\\'';\n  /**\n   * Specifies the value of `selectcolorspaceforstroking`.\n   * @private\n   */\n\n  Operators.selectcolorspaceforstroking = 'CS';\n  /**\n   * Specifies the value of `selectcolorspacefornonstroking`.\n   * @private\n   */\n\n  Operators.selectcolorspacefornonstroking = 'cs';\n  /**\n   * Specifies the value of `setrbgcolorforstroking`.\n   * @private\n   */\n\n  Operators.setrbgcolorforstroking = 'RG';\n  /**\n   * Specifies the value of `setrbgcolorfornonstroking`.\n   * @private\n   */\n\n  Operators.setrbgcolorfornonstroking = 'rg';\n  /**\n   * Specifies the value of `K`.\n   * @private\n   */\n\n  Operators.setcmykcolorforstroking = 'K';\n  /**\n   * Specifies the value of `k`.\n   * @private\n   */\n\n  Operators.setcmykcolorfornonstroking = 'k';\n  /**\n   * Specifies the value of `G`.\n   * @private\n   */\n\n  Operators.setgraycolorforstroking = 'G';\n  /**\n   * Specifies the value of `g`.\n   * @private\n   */\n\n  Operators.setgraycolorfornonstroking = 'g';\n  /**\n   * Specifies the value of `W`.\n   * @private\n   */\n\n  Operators.clipPath = 'W';\n  /**\n   * Specifies the value of `clipPathEvenOdd`.\n   * @private\n   */\n\n  Operators.clipPathEvenOdd = 'W*';\n  /**\n   * Specifies the value of `n`.\n   * @private\n   */\n\n  Operators.endPath = 'n';\n  /**\n   * Specifies the value of `setGraphicsState`.\n   * @private\n   */\n\n  Operators.setGraphicsState = 'gs';\n  /**\n   * Specifies the value of `%`.\n   * @private\n   */\n\n  Operators.comment = '%';\n  /**\n   * Specifies the value of `*`.\n   * @private\n   */\n\n  Operators.evenOdd = '*';\n  /**\n   * Specifies the value of `M`.\n   * @private\n   */\n\n  Operators.setMiterLimit = 'M';\n  /**\n   * Same as SC, but also supports Pattern, Separation, DeviceN, and ICCBased color spaces. For non-stroking operations.\n   * @public\n   */\n\n  Operators.setColorAndPattern = 'scn';\n  /**\n   * Same as SC, but also supports Pattern, Separation, DeviceN, and ICCBased color spaces. For stroking.\n   */\n\n  Operators.setColorAndPatternStroking = 'SCN';\n  /**\n   * dictionaryProperties.ts class for EJ2-PDF\n   * PDF dictionary properties.\n   * @private\n   */\n\n  return Operators;\n})();\n\nclass DictionaryProperties {\n  /**\n   * Initialize an instance for `PdfDictionaryProperties` class.\n   * @private\n   */\n  constructor() {\n    /**\n     * Specifies the value of `Pages`.\n     * @private\n     */\n    this.pages = 'Pages';\n    /**\n     * Specifies the value of `Kids`.\n     * @private\n     */\n\n    this.kids = 'Kids';\n    /**\n     * Specifies the value of `Count`.\n     * @private\n     */\n\n    this.count = 'Count';\n    /**\n     * Specifies the value of `Resources`.\n     * @private\n     */\n\n    this.resources = 'Resources';\n    /**\n     * Specifies the value of `Type`.\n     * @private\n     */\n\n    this.type = 'Type';\n    /**\n     * Specifies the value of `Size`.\n     * @private\n     */\n\n    this.size = 'Size';\n    /**\n     * Specifies the value of `MediaBox`.\n     * @private\n     */\n\n    this.mediaBox = 'MediaBox';\n    /**\n     * Specifies the value of `Parent`.\n     * @private\n     */\n\n    this.parent = 'Parent';\n    /**\n     * Specifies the value of `Root`.\n     * @private\n     */\n\n    this.root = 'Root';\n    /**\n     * Specifies the value of `DecodeParms`.\n     * @private\n     */\n\n    this.decodeParms = 'DecodeParms';\n    /**\n     * Specifies the value of `Filter`.\n     * @private\n     */\n\n    this.filter = 'Filter';\n    /**\n     * Specifies the value of `Font`.\n     * @private\n     */\n\n    this.font = 'Font';\n    /**\n     * Specifies the value of `Type1`.\n     * @private\n     */\n\n    this.type1 = 'Type1';\n    /**\n     * Specifies the value of `BaseFont`.\n     * @private\n     */\n\n    this.baseFont = 'BaseFont';\n    /**\n     * Specifies the value of `Encoding`.\n     * @private\n     */\n\n    this.encoding = 'Encoding';\n    /**\n     * Specifies the value of `Subtype`.\n     * @private\n     */\n\n    this.subtype = 'Subtype';\n    /**\n     * Specifies the value of `Contents`.\n     * @private\n     */\n\n    this.contents = 'Contents';\n    /**\n     * Specifies the value of `ProcSet`.\n     * @private\n     */\n\n    this.procset = 'ProcSet';\n    /**\n     * Specifies the value of `ColorSpace`.\n     * @private\n     */\n\n    this.colorSpace = 'ColorSpace';\n    /**\n     * Specifies the value of `ExtGState`.\n     * @private\n     */\n\n    this.extGState = 'ExtGState';\n    /**\n     * Specifies the value of `Pattern`.\n     * @private\n     */\n\n    this.pattern = 'Pattern';\n    /**\n     * Specifies the value of `XObject`.\n     * @private\n     */\n\n    this.xObject = 'XObject';\n    /**\n     * Specifies the value of `Length`.\n     * @private\n     */\n\n    this.length = 'Length';\n    /**\n     * Specifies the value of `Width`.\n     * @private\n     */\n\n    this.width = 'Width';\n    /**\n     * Specifies the value of `Height`.\n     * @private\n     */\n\n    this.height = 'Height';\n    /**\n     * Specifies the value of `BitsPerComponent`.\n     * @private\n     */\n\n    this.bitsPerComponent = 'BitsPerComponent';\n    /**\n     * Specifies the value of `Image`.\n     * @private\n     */\n\n    this.image = 'Image';\n    /**\n     * Specifies the value of `dctdecode`.\n     * @private\n     */\n\n    this.dctdecode = 'DCTDecode';\n    /**\n     * Specifies the value of `Columns`.\n     * @private\n     */\n\n    this.columns = 'Columns';\n    /**\n     * Specifies the value of `BlackIs1`.\n     * @private\n     */\n\n    this.blackIs1 = 'BlackIs1';\n    /**\n     * Specifies the value of `K`.\n     * @private\n     */\n\n    this.k = 'K';\n    /**\n     * Specifies the value of `S`.\n     * @private\n     */\n\n    this.s = 'S';\n    /**\n     * Specifies the value of `Predictor`.\n     * @private\n     */\n\n    this.predictor = 'Predictor';\n    /**\n     * Specifies the value of `DeviceRGB`.\n     * @private\n     */\n\n    this.deviceRgb = 'DeviceRGB';\n    /**\n     * Specifies the value of `Next`.\n     * @private\n     */\n\n    this.next = 'Next';\n    /**\n     * Specifies the value of `Action`.\n     * @private\n     */\n\n    this.action = 'Action';\n    /**\n     * Specifies the value of `Link`.\n     * @private\n     */\n\n    this.link = 'Link';\n    /**\n     *\n     * Specifies the value of `A`.\n     * @private\n     */\n\n    this.a = 'A';\n    /**\n     * Specifies the value of `Annot`.\n     * @private\n     */\n\n    this.annot = 'Annot';\n    /**\n     * Specifies the value of `P`.\n     * @private\n     */\n\n    this.p = 'P';\n    /**\n     * Specifies the value of `C`.\n     * @private\n     */\n\n    this.c = 'C';\n    /**\n     * Specifies the value of `Rect`.\n     * @private\n     */\n\n    this.rect = 'Rect';\n    /**\n     * Specifies the value of `URI`.\n     * @private\n     */\n\n    this.uri = 'URI';\n    /**\n     * Specifies the value of `Annots`.\n     * @private\n     */\n\n    this.annots = 'Annots';\n    /**\n     * Specifies the value of `ca`.\n     * @private\n     */\n\n    this.ca = 'ca';\n    /**\n     * Specifies the value of `CA`.\n     * @private\n     */\n\n    this.CA = 'CA';\n    /**\n     * Specifies the value of `XYZ`.\n     * @private\n     */\n\n    this.xyz = 'XYZ';\n    /**\n     * Specifies the value of `Fit`.\n     * @private\n     */\n\n    this.fit = 'Fit';\n    /**\n     * Specifies the value of `Dest`.\n     * @private\n     */\n\n    this.dest = 'Dest';\n    /**\n     * Specifies the value of `BM`.\n     * @private\n     */\n\n    this.BM = 'BM';\n    /**\n     * Specifies the value of `flatedecode`.\n     * @private\n     */\n\n    this.flatedecode = 'FlateDecode';\n    /**\n     * Specifies the value of `Rotate`.\n     * @private\n     */\n\n    this.rotate = 'Rotate';\n    /**\n     * Specifies the value of 'bBox'.\n     * @private\n     */\n\n    this.bBox = 'BBox';\n    /**\n     * Specifies the value of 'form'.\n     * @private\n     */\n\n    this.form = 'Form';\n    /**\n     * Specifies the value of 'w'.\n     * @private\n     */\n\n    this.w = 'W';\n    /**\n     * Specifies the value of 'cIDFontType2'.\n     * @private\n     */\n\n    this.cIDFontType2 = 'CIDFontType2';\n    /**\n     * Specifies the value of 'cIDToGIDMap'.\n     * @private\n     */\n\n    this.cIDToGIDMap = 'CIDToGIDMap';\n    /**\n     * Specifies the value of 'identity'.\n     * @private\n     */\n\n    this.identity = 'Identity';\n    /**\n     * Specifies the value of 'dw'.\n     * @private\n     */\n\n    this.dw = 'DW';\n    /**\n     * Specifies the value of 'fontDescriptor'.\n     * @private\n     */\n\n    this.fontDescriptor = 'FontDescriptor';\n    /**\n     * Specifies the value of 'cIDSystemInfo'.\n     * @private\n     */\n\n    this.cIDSystemInfo = 'CIDSystemInfo';\n    /**\n     * Specifies the value of 'fontName'.\n     * @private\n     */\n\n    this.fontName = 'FontName';\n    /**\n     * Specifies the value of 'flags'.\n     * @private\n     */\n\n    this.flags = 'Flags';\n    /**\n     * Specifies the value of 'fontBBox'.\n     * @private\n     */\n\n    this.fontBBox = 'FontBBox';\n    /**\n     * Specifies the value of 'missingWidth'.\n     * @private\n     */\n\n    this.missingWidth = 'MissingWidth';\n    /**\n     * Specifies the value of 'stemV'.\n     * @private\n     */\n\n    this.stemV = 'StemV';\n    /**\n     * Specifies the value of 'italicAngle'.\n     * @private\n     */\n\n    this.italicAngle = 'ItalicAngle';\n    /**\n     * Specifies the value of 'capHeight'.\n     * @private\n     */\n\n    this.capHeight = 'CapHeight';\n    /**\n     * Specifies the value of 'ascent'.\n     * @private\n     */\n\n    this.ascent = 'Ascent';\n    /**\n     * Specifies the value of 'descent'.\n     * @private\n     */\n\n    this.descent = 'Descent';\n    /**\n     * Specifies the value of 'leading'.\n     * @private\n     */\n\n    this.leading = 'Leading';\n    /**\n     * Specifies the value of 'avgWidth'.\n     * @private\n     */\n\n    this.avgWidth = 'AvgWidth';\n    /**\n     * Specifies the value of 'fontFile2'.\n     * @private\n     */\n\n    this.fontFile2 = 'FontFile2';\n    /**\n     * Specifies the value of 'maxWidth'.\n     * @private\n     */\n\n    this.maxWidth = 'MaxWidth';\n    /**\n     * Specifies the value of 'xHeight'.\n     * @private\n     */\n\n    this.xHeight = 'XHeight';\n    /**\n     * Specifies the value of 'stemH'.\n     * @private\n     */\n\n    this.stemH = 'StemH';\n    /**\n     * Specifies the value of 'registry'.\n     * @private\n     */\n\n    this.registry = 'Registry';\n    /**\n     * Specifies the value of 'ordering'.\n     * @private\n     */\n\n    this.ordering = 'Ordering';\n    /**\n     * Specifies the value of 'supplement'.\n     * @private\n     */\n\n    this.supplement = 'Supplement';\n    /**\n     * Specifies the value of 'type0'.\n     * @private\n     */\n\n    this.type0 = 'Type0';\n    /**\n     * Specifies the value of 'identityH'.\n     * @private\n     */\n\n    this.identityH = 'Identity-H';\n    /**\n     * Specifies the value of 'toUnicode'.\n     * @private\n     */\n\n    this.toUnicode = 'ToUnicode';\n    /**\n     * Specifies the value of 'descendantFonts'.\n     * @private\n     */\n\n    this.descendantFonts = 'DescendantFonts';\n    /**\n     * Specifies the value of 'background'.\n     * @private\n     */\n\n    this.background = 'Background';\n    /**\n     * Specifies the value of 'shading'.\n     * @private\n     */\n\n    this.shading = 'Shading';\n    /**\n     * Specifies the value of 'matrix'.\n     * @private\n     */\n\n    this.matrix = 'Matrix';\n    /**\n     * Specifies the value of 'antiAlias'.\n     * @private\n     */\n\n    this.antiAlias = 'AntiAlias';\n    /**\n     * Specifies the value of 'function'.\n     * @private\n     */\n\n    this.function = 'Function';\n    /**\n     * Specifies the value of 'extend'.\n     * @private\n     */\n\n    this.extend = 'Extend';\n    /**\n     * Specifies the value of 'shadingType'.\n     * @private\n     */\n\n    this.shadingType = 'ShadingType';\n    /**\n     * Specifies the value of 'coords'.\n     * @private\n     */\n\n    this.coords = 'Coords';\n    /**\n     * Specifies the value of 'domain'.\n     * @private\n     */\n\n    this.domain = 'Domain';\n    /**\n     * Specifies the value of 'range'.\n     * @private\n     */\n\n    this.range = 'Range';\n    /**\n     * Specifies the value of 'functionType'.\n     * @private\n     */\n\n    this.functionType = 'FunctionType';\n    /**\n     * Specifies the value of 'bitsPerSample'.\n     * @private\n     */\n\n    this.bitsPerSample = 'BitsPerSample';\n    /**\n     * Specifies the value of 'patternType'.\n     * @private\n     */\n\n    this.patternType = 'PatternType';\n    /**\n     * Specifies the value of 'paintType'.\n     * @private\n     */\n\n    this.paintType = 'PaintType';\n    /**\n     * Specifies the value of 'tilingType'.\n     * @private\n     */\n\n    this.tilingType = 'TilingType';\n    /**\n     * Specifies the value of 'xStep'.\n     * @private\n     */\n\n    this.xStep = 'XStep';\n    /**\n     * Specifies the value of 'yStep'.\n     * @private\n     */\n\n    this.yStep = 'YStep'; //\n  }\n\n}\n/**\n * `PdfDictionary` class is used to perform primitive operations.\n * @private\n */\n\n\nclass PdfDictionary {\n  constructor(dictionary) {\n    /**\n     * Internal variable to store the `position`.\n     * @default -1\n     * @private\n     */\n    this.position7 = -1;\n    /**\n     * The `IPdfSavable` with the specified key.\n     * @private\n     */\n\n    this.primitiveItems = new Dictionary();\n    /**\n     * `Start marker` for dictionary.\n     * @private\n     */\n\n    this.prefix = '<<';\n    /**\n     * `End marker` for dictionary.\n     * @private\n     */\n\n    this.suffix = '>>';\n    /**\n     * @hidden\n     * @private\n     */\n\n    this.resources = [];\n    /**\n     * Internal variable to hold `cloned object`.\n     * @default null\n     * @private\n     */\n\n    this.object = null;\n    /**\n     * Flag for PDF file formar 1.5 is dictionary `archiving` needed.\n     * @default true\n     * @private\n     */\n\n    this.archive = true;\n    /**\n     * Represents the Font dictionary.\n     * @hidden\n     * @private\n     */\n\n    this.isFont = false;\n\n    if (typeof dictionary === 'undefined') {\n      this.primitiveItems = new Dictionary();\n      this.encrypt = true;\n      this.dictionaryProperties = new DictionaryProperties();\n    } else {\n      this.primitiveItems = new Dictionary();\n      let keys = dictionary.items.keys();\n      let values = dictionary.items.values();\n\n      for (let index = 0; index < dictionary.items.size(); index++) {\n        this.primitiveItems.setValue(keys[index], values[index]);\n      }\n\n      this.status = dictionary.status;\n      this.freezeChanges(this);\n      this.encrypt = true;\n      this.dictionaryProperties = new DictionaryProperties();\n    }\n  } //Properties\n\n  /**\n   * Gets or sets the `IPdfSavable` with the specified key.\n   * @private\n   */\n\n\n  get items() {\n    return this.primitiveItems;\n  }\n  /**\n   * Gets or sets the `Status` of the specified object.\n   * @private\n   */\n\n\n  get status() {\n    return this.status7;\n  }\n\n  set status(value) {\n    this.status7 = value;\n  }\n  /**\n   * Gets or sets a value indicating whether this document `is saving` or not.\n   * @private\n   */\n\n\n  get isSaving() {\n    return this.isSaving7;\n  }\n\n  set isSaving(value) {\n    this.isSaving7 = value;\n  }\n  /**\n   * Gets or sets the `index` value of the specified object.\n   * @private\n   */\n\n\n  get objectCollectionIndex() {\n    return this.index7;\n  }\n\n  set objectCollectionIndex(value) {\n    this.index7 = value;\n  }\n  /**\n   * Returns `cloned object`.\n   * @private\n   */\n\n\n  get clonedObject() {\n    return this.object;\n  }\n  /**\n   * Gets or sets the `position` of the object.\n   * @private\n   */\n\n\n  get position() {\n    return this.position7;\n  }\n\n  set position(value) {\n    this.position7 = value;\n  }\n  /**\n   * Gets the `count`.\n   * @private\n   */\n\n\n  get Count() {\n    return this.primitiveItems.size();\n  }\n  /**\n   * Collection of `items` in the object.\n   * @private\n   */\n\n\n  get Dictionary() {\n    return this;\n  }\n  /**\n   * Get flag if need to `archive` dictionary.\n   * @private\n   */\n\n\n  getArchive() {\n    return this.archive;\n  }\n  /**\n   * Set flag if need to `archive` dictionary.\n   * @private\n   */\n\n\n  setArchive(value) {\n    this.archive = value;\n  }\n  /**\n   * Sets flag if `encryption` is needed.\n   * @private\n   */\n\n\n  setEncrypt(value) {\n    this.encrypt = value;\n    this.modify();\n  }\n  /**\n   * Gets flag if `encryption` is needed.\n   * @private\n   */\n\n\n  getEncrypt() {\n    return this.encrypt;\n  }\n  /**\n   * `Freezes` the changes.\n   * @private\n   */\n\n\n  freezeChanges(freezer) {\n    this.bChanged = false;\n  }\n  /**\n   * Creates a `copy of PdfDictionary`.\n   * @private\n   */\n\n\n  clone(crossTable) {\n    //Need to add more codings\n    let newDict = new PdfDictionary();\n    return newDict;\n  }\n  /**\n   * `Mark` this instance modified.\n   * @private\n   */\n\n\n  modify() {\n    this.bChanged = true;\n  }\n  /**\n   * `Removes` the specified key.\n   * @private\n   */\n\n\n  remove(key) {\n    if (typeof key !== 'string') {\n      this.primitiveItems.remove(key.value);\n      this.modify();\n    } else {\n      this.remove(new PdfName(key));\n    }\n  }\n  /**\n   * `Determines` whether the dictionary contains the key.\n   * @private\n   */\n\n\n  containsKey(key) {\n    let returnValue = false;\n    returnValue = this.primitiveItems.containsKey(key.toString());\n    return returnValue;\n  }\n  /**\n   * Raises event `BeginSave`.\n   * @private\n   */\n\n\n  onBeginSave() {\n    this.beginSave.sender.beginSave();\n  }\n  /**\n   * Raises event `Font Dictionary BeginSave`.\n   * @private\n   */\n\n\n  onFontDictionaryBeginSave() {\n    this.fontDictionaryBeginSave.sender.fontDictionaryBeginSave();\n  }\n  /**\n   * Raises event `Descendant Font BeginSave`.\n   * @private\n   */\n\n\n  onDescendantFontBeginSave() {\n    this.descendantFontBeginSave.sender.descendantFontBeginSave();\n  }\n  /**\n   * Raises event 'BeginSave'.\n   * @private\n   */\n\n\n  onTemplateBeginSave() {\n    this.pageBeginDrawTemplate.sender.pageBeginSave();\n  }\n  /**\n   * Raises event `BeginSave`.\n   * @private\n   */\n\n\n  onBeginAnnotationSave() {\n    this.annotationBeginSave.sender.beginSave();\n  }\n  /**\n   * Raises event `BeginSave`.\n   * @private\n   */\n\n\n  onSectionBeginSave(writer) {\n    let saveEvent = this.sectionBeginSave;\n    saveEvent.sender.beginSave(saveEvent.state, writer);\n  }\n\n  save(writer, bRaiseEvent) {\n    if (typeof bRaiseEvent === 'undefined') {\n      this.save(writer, true);\n    } else {\n      writer.write(this.prefix);\n\n      if (typeof this.beginSave !== 'undefined') {\n        this.onBeginSave();\n      }\n\n      if (typeof this.descendantFontBeginSave !== 'undefined') {\n        this.onDescendantFontBeginSave();\n      }\n\n      if (typeof this.fontDictionaryBeginSave !== 'undefined') {\n        this.onFontDictionaryBeginSave();\n      }\n\n      if (typeof this.annotationBeginSave !== 'undefined') {\n        this.onBeginAnnotationSave();\n      }\n\n      if (typeof this.sectionBeginSave !== 'undefined') {\n        this.onSectionBeginSave(writer);\n      }\n\n      if (typeof this.pageBeginDrawTemplate !== 'undefined') {\n        this.onTemplateBeginSave();\n      } // }\n\n\n      if (this.Count > 0) {\n        this.saveItems(writer);\n      }\n\n      writer.write(this.suffix);\n      writer.write(Operators.newLine);\n    }\n  }\n  /**\n   * `Save dictionary items`.\n   * @private\n   */\n\n\n  saveItems(writer) {\n    writer.write(Operators.newLine);\n    let keys = this.primitiveItems.keys();\n    let values = this.primitiveItems.values();\n\n    for (let index = 0; index < keys.length; index++) {\n      let key = keys[index];\n      let name = new PdfName(key);\n      name.save(writer);\n      writer.write(Operators.whiteSpace);\n      let resources = values[index];\n      resources.save(writer);\n      writer.write(Operators.newLine);\n    }\n  }\n\n}\n\nclass SaveSectionCollectionEventHandler {\n  /**\n   * New instance for `save section collection event handler` class.\n   * @private\n   */\n  constructor(sender) {\n    this.sender = sender;\n  }\n\n}\n\nclass SaveDescendantFontEventHandler {\n  /**\n   * New instance for `save section collection event handler` class.\n   * @private\n   */\n  constructor(sender) {\n    this.sender = sender;\n  }\n\n}\n\nclass SaveFontDictionaryEventHandler {\n  /**\n   * New instance for `save section collection event handler` class.\n   * @private\n   */\n  constructor(sender) {\n    this.sender = sender;\n  }\n\n}\n\nclass SaveAnnotationEventHandler {\n  /**\n   * New instance for `save annotation event handler` class.\n   * @private\n   */\n  constructor(sender) {\n    this.sender = sender;\n  }\n\n}\n\nclass SaveSectionEventHandler {\n  // constructors\n\n  /**\n   * New instance for `save section event handler` class.\n   * @private\n   */\n  constructor(sender, state) {\n    this.sender = sender;\n    this.state = state;\n  }\n\n}\n/**\n * SaveTemplateEventHandler class used to store information about template elements.\n * @private\n * @hidden\n */\n\n\nclass SaveTemplateEventHandler {\n  /**\n   * New instance for save section collection event handler class.\n   * @public\n   */\n  constructor(sender) {\n    this.sender = sender;\n  }\n\n}\n/**\n * `PdfNumber` class is used to perform number related primitive operations.\n * @private\n */\n\n\nclass PdfNumber {\n  /**\n   * Initializes a new instance of the `PdfNumber` class.\n   * @private\n   */\n  constructor(value) {\n    /**\n     * Sotres the `position`.\n     * @default -1\n     * @private\n     */\n    this.position5 = -1;\n    this.value = value;\n  }\n  /**\n   * Gets or sets the `integer` value.\n   * @private\n   */\n\n\n  get intValue() {\n    return this.value;\n  }\n\n  set intValue(value) {\n    this.value = value;\n  }\n  /**\n   * Gets or sets a value indicating whether this instance `is integer`.\n   * @private\n   */\n\n\n  get isInteger() {\n    return this.integer;\n  }\n\n  set isInteger(value) {\n    this.integer = value;\n  }\n  /**\n   * Gets or sets the `Status` of the specified object.\n   * @private\n   */\n\n\n  get status() {\n    return this.status5;\n  }\n\n  set status(value) {\n    this.status5 = value;\n  }\n  /**\n   * Gets or sets a value indicating whether this document `is saving` or not.\n   * @private\n   */\n\n\n  get isSaving() {\n    return this.isSaving5;\n  }\n\n  set isSaving(value) {\n    this.isSaving5 = value;\n  }\n  /**\n   * Gets or sets the `index` value of the specified object.\n   * @private\n   */\n\n\n  get objectCollectionIndex() {\n    return this.index5;\n  }\n\n  set objectCollectionIndex(value) {\n    this.index5 = value;\n  }\n  /**\n   * Gets or sets the `position` of the object.\n   * @private\n   */\n\n\n  get position() {\n    return this.position5;\n  }\n\n  set position(value) {\n    this.position5 = value;\n  }\n  /**\n   * Returns `cloned object`.\n   * @private\n   */\n\n\n  get clonedObject() {\n    let rValue = null;\n    return rValue;\n  }\n  /**\n   * `Saves the object`.\n   * @private\n   */\n\n\n  save(writer) {\n    writer.write(this.intValue.toString()); //tostring(CultureInfo.InletiantCulture)\n  }\n  /**\n   * Creates a `copy of PdfNumber`.\n   * @private\n   */\n\n\n  clone(crossTable) {\n    let newNumber = new PdfNumber(this.value);\n    return newNumber;\n  }\n  /**\n   * Converts a `float value to a string` using Adobe PDF rules.\n   * @private\n   */\n\n\n  static floatToString(number) {\n    // let tempString1 : string = number.toString();\n    // let tempString2 : string = tempString1.indexOf('.') != -1 ? tempString1.substring(0, tempString1.indexOf('.')) : tempString1;\n    let returnString = number.toFixed(2);\n\n    if (returnString === '0.00') {\n      returnString = '.00';\n    } // let prefixLength : number = (22 - tempString2.length) >= 0 ? (22 - tempString2.length) : 0;\n    // for (let index : number = 0; index < prefixLength; index++) {\n    //     returnString += '0';\n    // }\n    // returnString += tempString2 + '.00';\n    // returnString += (tempString3.length > 6) ? tempString3.substring(0,6) : tempString3;\n    // let suffixLength : number = (6 - tempString3.length) >= 0 ? (6 - tempString3.length) : 0;\n    // for (let index : number = 0; index < suffixLength; index++) {\n    //     returnString += '0';\n    // }\n\n\n    return returnString;\n  }\n  /**\n   * Determines the `minimum of the three values`.\n   * @private\n   */\n\n\n  static min(x, y, z) {\n    let r = Math.min(x, y);\n    return Math.min(z, r);\n  }\n\n}\n/**\n * `PdfArray` class is used to perform array related primitive operations.\n * @private\n */\n\n\nclass PdfArray {\n  constructor(array) {\n    //Fields\n\n    /**\n     * `startMark` - '['\n     * @private\n     */\n    this.startMark = '[';\n    /**\n     * `endMark` - ']'.\n     * @private\n     */\n\n    this.endMark = ']';\n    /**\n     * Internal variable to store the `position`.\n     * @default -1\n     * @private\n     */\n\n    this.position9 = -1;\n    /**\n     * Internal variable to hold `cloned object`.\n     * @default null\n     * @private\n     */\n\n    this.clonedObject9 = null;\n    /**\n     * Represents the Font dictionary.\n     * @hidden\n     * @private\n     */\n\n    this.isFont = false;\n\n    if (typeof array === 'undefined') {\n      this.internalElements = [];\n    } else {\n      if (typeof array !== 'undefined' && !(array instanceof PdfArray)) {\n        let tempNumberArray = array;\n\n        for (let index = 0; index < tempNumberArray.length; index++) {\n          let pdfNumber = new PdfNumber(tempNumberArray[index]);\n          this.add(pdfNumber);\n        } // } else if (typeof array !== 'undefined' && (array instanceof PdfArray)) {\n\n      } else {\n        let tempArray = array; // if (tempArray.Elements.length > 0) {\n\n        this.internalElements = [];\n\n        for (let index = 0; index < tempArray.elements.length; index++) {\n          this.internalElements.push(tempArray.elements[index]);\n        } // }\n\n      }\n    }\n  } //property\n\n  /**\n   * Gets the `IPdfSavable` at the specified index.\n   * @private\n   */\n\n\n  items(index) {\n    // if (index < 0 || index >= this.Count) {\n    //     throw new Error('ArgumentOutOfRangeException : index, The index can\"t be less then zero or greater then Count.');\n    // }\n    return this.internalElements[index];\n  }\n  /**\n   * Gets the `count`.\n   * @private\n   */\n\n\n  get count() {\n    return this.internalElements.length;\n  }\n  /**\n   * Gets or sets the `Status` of the specified object.\n   * @private\n   */\n\n\n  get status() {\n    return this.status9;\n  }\n\n  set status(value) {\n    this.status9 = value;\n  }\n  /**\n   * Gets or sets a value indicating whether this document `is saving` or not.\n   * @private\n   */\n\n\n  get isSaving() {\n    return this.isSaving9;\n  }\n\n  set isSaving(value) {\n    this.isSaving9 = value;\n  }\n  /**\n   * Returns `cloned object`.\n   * @private\n   */\n\n\n  get clonedObject() {\n    return this.clonedObject9;\n  }\n  /**\n   * Gets or sets the `position` of the object.\n   * @private\n   */\n\n\n  get position() {\n    return this.position9;\n  }\n\n  set position(value) {\n    this.position9 = value;\n  }\n  /**\n   * Gets or sets the `index` value of the specified object.\n   * @private\n   */\n\n\n  get objectCollectionIndex() {\n    return this.index9;\n  }\n\n  set objectCollectionIndex(value) {\n    this.index9 = value;\n  }\n  /**\n   * Returns `PdfCrossTable` associated with the object.\n   * @private\n   */\n\n\n  get CrossTable() {\n    return this.pdfCrossTable;\n  }\n  /**\n   * Gets the `elements` of the Pdf Array.\n   * @private\n   */\n\n\n  get elements() {\n    return this.internalElements;\n  }\n  /**\n   * `Adds` the specified element to the PDF array.\n   * @private\n   */\n\n\n  add(element) {\n    // if (element === null) {\n    //     throw new Error('ArgumentNullException : obj');\n    // }\n    if (typeof this.internalElements === 'undefined') {\n      this.internalElements = [];\n    }\n\n    this.internalElements.push(element);\n    this.markedChange();\n  }\n  /**\n   * `Marks` the object changed.\n   * @private\n   */\n\n\n  markedChange() {\n    this.bChanged = true;\n  }\n  /**\n   * `Determines` whether the specified element is within the array.\n   * @private\n   */\n\n\n  contains(element) {\n    let returnValue = false;\n\n    for (let index = 0; index < this.internalElements.length; index++) {\n      let tempElement = this.internalElements[index];\n      let inputElement = element;\n\n      if (tempElement != null && typeof tempElement !== 'undefined' && inputElement != null && typeof inputElement !== 'undefined') {\n        if (tempElement.value === inputElement.value) {\n          return true;\n        }\n      } // if (this.internalElements[index] === element) {\n      //     returnValue = true;\n      // }\n\n    }\n\n    return returnValue;\n  }\n  /**\n   * Returns the `primitive object` of input index.\n   * @private\n   */\n\n\n  getItems(index) {\n    // if (index < 0 || index >= this.Count) {\n    //     throw new Error('ArgumentOutOfRangeException : index , The index can\"t be less then zero or greater then Count.');\n    // }\n    return this.internalElements[index];\n  }\n  /**\n   * `Saves` the object using the specified writer.\n   * @private\n   */\n\n\n  save(writer) {\n    // if (writer === null) {\n    //     throw new Error('ArgumentNullException : writer');\n    // }\n    writer.write(this.startMark);\n\n    for (let i = 0, len = this.count; i < len; i++) {\n      this.getItems(i).save(writer);\n\n      if (i + 1 !== len) {\n        writer.write(Operators.whiteSpace);\n      }\n    }\n\n    writer.write(this.endMark);\n  }\n  /**\n   * Creates a `copy of PdfArray`.\n   * @private\n   */\n\n\n  clone(crossTable) {\n    // if (this.clonedObject9 !== null && this.clonedObject9.CrossTable === crossTable) {\n    //     return this.clonedObject9;\n    // } else {\n    this.clonedObject9 = null; // Else clone the object.\n\n    let newArray = new PdfArray();\n\n    for (let index = 0; index < this.internalElements.length; index++) {\n      let obj = this.internalElements[index];\n      newArray.add(obj.clone(crossTable));\n    }\n\n    newArray.pdfCrossTable = crossTable;\n    this.clonedObject9 = newArray;\n    return newArray;\n  }\n  /**\n   * Creates filled PDF array `from the rectangle`.\n   * @private\n   */\n\n\n  static fromRectangle(bounds) {\n    let values = [bounds.x, bounds.y, bounds.width, bounds.height];\n    let array = new PdfArray(values);\n    return array;\n  } // /**\n  //  * Creates the rectangle from filled PDF array.\n  //  * @private\n  //  */\n  // public ToRectangle() : RectangleF {\n  //     if (this.Count < 4) {\n  //         throw Error('InvalidOperationException-Can not convert to rectangle.');\n  //     }\n  //     let x1 : number;\n  //     let x2 : number;\n  //     let y1 : number;\n  //     let y2 : number;\n  //     let num : PdfNumber = this.getItems(0) as PdfNumber;\n  //     x1 = num.IntValue;\n  //     num = this.getItems(1) as PdfNumber;\n  //     y1 = num.IntValue;\n  //     num = this.getItems(2) as PdfNumber;\n  //     x2 = num.IntValue;\n  //     num = this.getItems(3) as PdfNumber;\n  //     y2 = num.IntValue;\n  //     let x : number = Math.min(x1, x2);\n  //     let y : number = Math.min(y1, y2);\n  //     let width : number = Math.abs(x1 - x2);\n  //     let height : number = Math.abs(y1 - y2);\n  //     let rect : RectangleF = new RectangleF(new PointF(x, y), new SizeF(width, height));\n  //     return rect;\n  // }\n\n  /**\n   * `Inserts` the element into the array.\n   * @private\n   */\n\n\n  insert(index, element) {\n    if (index < this.internalElements.length && index > 0) {\n      let tempElements = [];\n\n      for (let i = 0; i < index; i++) {\n        tempElements.push(this.internalElements[i]);\n      }\n\n      tempElements.push(element);\n\n      for (let i = index; i < this.internalElements.length; i++) {\n        tempElements.push(this.internalElements[i]);\n      }\n\n      this.internalElements = tempElements;\n    } else {\n      this.internalElements.push(element);\n    }\n\n    this.markChanged();\n  }\n  /**\n   * `Checks whether array contains the element`.\n   * @private\n   */\n\n\n  indexOf(element) {\n    return this.internalElements.indexOf(element);\n  }\n  /**\n   * `Removes` element from the array.\n   * @private\n   */\n\n\n  remove(element) {\n    // if (element === null) {\n    //     throw new Error('ArgumentNullException : element');\n    // }\n    let index = this.internalElements.indexOf(element); // if (index >= 0 && index < this.internalElements.length) {\n\n    this.internalElements[index] = null; // }\n\n    this.markChanged();\n  }\n  /**\n   * `Remove` the element from the array by its index.\n   * @private\n   */\n\n\n  removeAt(index) {\n    // this.internalElements.RemoveAt(index);\n    if (this.internalElements.length > index) {\n      let tempArray = [];\n\n      for (let i = 0; i < index; i++) {\n        tempArray.push(this.internalElements[i]);\n      }\n\n      for (let i = index + 1; i < this.internalElements.length; i++) {\n        tempArray.push(this.internalElements[i]);\n      }\n\n      this.internalElements = tempArray;\n    }\n\n    this.markChanged();\n  }\n  /**\n   * `Clear` the array.\n   * @private\n   */\n\n\n  clear() {\n    this.internalElements = [];\n    this.markChanged();\n  }\n  /**\n   * `Marks` the object changed.\n   * @private\n   */\n\n\n  markChanged() {\n    this.bChanged = true;\n  }\n\n}\n/**\n * `PdfStream` class is used to perform stream related primitive operations.\n * @private\n */\n\n\nclass PdfStream extends PdfDictionary {\n  constructor(dictionary, data) {\n    super(dictionary); //Constants\n\n    /**\n     * @hidden\n     * @private\n     */\n\n    this.dicPrefix = 'stream';\n    /**\n     * @hidden\n     * @private\n     */\n\n    this.dicSuffix = 'endstream';\n    /**\n     * Internal variable to hold `cloned object`.\n     * @private\n     */\n\n    this.clonedObject2 = null;\n    /**\n     * @hidden\n     * @private\n     */\n\n    this.bCompress = true;\n    /**\n     * @hidden\n     * @private\n     */\n\n    this.isImageStream = false;\n    /**\n     * @hidden\n     * @private\n     */\n\n    this.isFontStream = false;\n\n    if (typeof dictionary !== 'undefined' || typeof data !== 'undefined') {\n      this.dataStream2 = [];\n      this.dataStream2 = data;\n      this.bCompress2 = false;\n    } else {\n      this.dataStream2 = [];\n      this.bCompress2 = true; //Pending\n    }\n  }\n  /**\n   * Gets the `internal` stream.\n   * @private\n   */\n\n\n  get internalStream() {\n    return this.dataStream2;\n  }\n\n  set internalStream(value) {\n    this.dataStream2 = [];\n    this.dataStream2 = value;\n    this.modify();\n  }\n  /**\n   * Gets or sets 'is image' flag.\n   * @private\n   */\n\n\n  get isImage() {\n    return this.isImageStream;\n  }\n\n  set isImage(value) {\n    this.isImageStream = value;\n  }\n  /**\n   * Gets or sets 'is font' flag.\n   * @private\n   */\n\n\n  get isFont() {\n    return this.isFontStream;\n  }\n\n  set isFont(value) {\n    this.isFontStream = value;\n  }\n  /**\n   * Gets or sets `compression` flag.\n   * @private\n   */\n\n\n  get compress() {\n    return this.bCompress;\n  }\n\n  set compress(value) {\n    this.bCompress = value;\n    this.modify();\n  }\n  /**\n   * Gets or sets the `data`.\n   * @private\n   */\n\n\n  get data() {\n    return this.dataStream2;\n  }\n\n  set data(value) {\n    this.dataStream2 = [];\n    this.dataStream2 = value;\n    this.modify();\n  }\n  /**\n   * `Clear` the internal stream.\n   * @private\n   */\n\n\n  clearStream() {\n    this.internalStream = [];\n\n    if (this.items.containsKey(this.dictionaryProperties.filter)) {\n      this.remove(this.dictionaryProperties.filter);\n    }\n\n    this.bCompress = true;\n    this.modify();\n  }\n  /**\n   * `Writes` the specified string.\n   * @private\n   */\n\n\n  write(text) {\n    if (text == null) {\n      throw new Error('ArgumentNullException:text');\n    }\n\n    if (text.length <= 0) {\n      throw new Error('ArgumentException: Can not write an empty string, text');\n    }\n\n    this.dataStream2.push(text);\n    this.modify();\n  }\n  /**\n   * `Writes` the specified bytes.\n   * @private\n   */\n\n\n  writeBytes(data) {\n    if (data === null) {\n      throw new Error('ArgumentNullException:data');\n    }\n\n    if (data.length <= 0) {\n      throw new Error('ArgumentException: Can not write an empty bytes, data');\n    }\n\n    let text = '';\n\n    for (let i = 0; i < data.length; i++) {\n      text += String.fromCharCode(data[i]);\n    }\n\n    this.dataStream2.push(text);\n    this.modify();\n  }\n  /**\n   * Raises event `Cmap BeginSave`.\n   * @private\n   */\n\n\n  onCmapBeginSave() {\n    this.cmapBeginSave.sender.cmapBeginSave();\n  }\n  /**\n   * Raises event `Font Program BeginSave`.\n   * @private\n   */\n\n\n  onFontProgramBeginSave() {\n    this.fontProgramBeginSave.sender.fontProgramBeginSave();\n  }\n  /**\n   * `Compresses the content` if it's required.\n   * @private\n   */\n\n\n  compressContent(data, writer) {\n    if (this.bCompress) {\n      let byteArray = [];\n\n      for (let i = 0; i < data.length; i++) {\n        byteArray.push(data.charCodeAt(i));\n      }\n\n      let dataArray = new Uint8Array(byteArray);\n      let sw = new CompressedStreamWriter(); // data = 'Hello World!!!';\n\n      sw.write(dataArray, 0, dataArray.length);\n      sw.close();\n      data = sw.getCompressedString;\n      this.addFilter(this.dictionaryProperties.flatedecode);\n    }\n\n    return data;\n  }\n  /**\n   * `Adds a filter` to the filter array.\n   * @private\n   */\n\n\n  addFilter(filterName) {\n    let obj = this.items.getValue(this.dictionaryProperties.filter);\n\n    if (obj instanceof PdfReferenceHolder) {\n      let rh = obj;\n      obj = rh.object;\n    }\n\n    let array = obj;\n    let name = obj;\n\n    if (name != null) {\n      array = new PdfArray();\n      array.insert(0, name);\n      this.items.setValue(this.dictionaryProperties.filter, array);\n    }\n\n    name = new PdfName(filterName);\n\n    if (array == null) {\n      this.items.setValue(this.dictionaryProperties.filter, name);\n    } else {\n      array.insert(0, name);\n    }\n  }\n  /**\n   * `Saves` the object using the specified writer.\n   * @private\n   */\n\n\n  save(writer) {\n    if (typeof this.cmapBeginSave !== 'undefined') {\n      this.onCmapBeginSave();\n    }\n\n    if (typeof this.fontProgramBeginSave !== 'undefined') {\n      this.onFontProgramBeginSave();\n    }\n\n    let data = '';\n\n    for (let i = 0; i < this.data.length; i++) {\n      data = data + this.data[i];\n    }\n\n    if (data.length > 1 && !this.isImage && !this.isFont) {\n      data = 'q\\r\\n' + data + 'Q\\r\\n';\n    }\n\n    data = this.compressContent(data, writer);\n    let length = data.length;\n    this.items.setValue(this.dictionaryProperties.length, new PdfNumber(length));\n    super.save(writer, false);\n    writer.write(this.dicPrefix);\n    writer.write(Operators.newLine);\n\n    if (data.length > 0) {\n      writer.write(data);\n    }\n\n    writer.write(Operators.newLine);\n    writer.write(this.dicSuffix);\n    writer.write(Operators.newLine);\n  }\n  /**\n   * Converts `bytes to string`.\n   * @private\n   */\n\n\n  static bytesToString(byteArray) {\n    let output = '';\n\n    for (let i = 0; i < byteArray.length; i++) {\n      output = output + String.fromCharCode(byteArray[i]);\n    }\n\n    return output;\n  }\n\n}\n\nclass SaveCmapEventHandler {\n  /**\n   * New instance for `save section collection event handler` class.\n   * @private\n   */\n  constructor(sender) {\n    this.sender = sender;\n  }\n\n}\n\nclass SaveFontProgramEventHandler {\n  /**\n   * New instance for `save section collection event handler` class.\n   * @private\n   */\n  constructor(sender) {\n    this.sender = sender;\n  }\n\n}\n/**\n * `PdfString` class is used to perform string related primitive operations.\n * @private\n */\n\n\nvar InternalEnum;\n\n(function (InternalEnum) {\n  //Internals\n\n  /**\n   * public Enum for `ForceEncoding`.\n   * @private\n   */\n  let ForceEncoding;\n\n  (function (ForceEncoding) {\n    /**\n     * Specifies the type of `None`.\n     * @private\n     */\n    ForceEncoding[ForceEncoding[\"None\"] = 0] = \"None\";\n    /**\n     * Specifies the type of `Ascii`.\n     * @private\n     */\n\n    ForceEncoding[ForceEncoding[\"Ascii\"] = 1] = \"Ascii\";\n    /**\n     * Specifies the type of `Unicode`.\n     * @private\n     */\n\n    ForceEncoding[ForceEncoding[\"Unicode\"] = 2] = \"Unicode\";\n  })(ForceEncoding = InternalEnum.ForceEncoding || (InternalEnum.ForceEncoding = {}));\n  /**\n   * public Enum for `SourceType`.\n   * @private\n   */\n\n\n  let SourceType;\n\n  (function (SourceType) {\n    /**\n     * Specifies the type of `StringValue`.\n     * @private\n     */\n    SourceType[SourceType[\"StringValue\"] = 0] = \"StringValue\";\n    /**\n     * Specifies the type of `ByteBuffer`.\n     * @private\n     */\n\n    SourceType[SourceType[\"ByteBuffer\"] = 1] = \"ByteBuffer\";\n  })(SourceType || (SourceType = {}));\n})(InternalEnum || (InternalEnum = {}));\n\nlet PdfString = /*#__PURE__*/(() => {\n  class PdfString {\n    constructor(value) {\n      /**\n       * Value indicating whether the string was converted to hex.\n       * @default false\n       * @private\n       */\n      this.bHex = false;\n      /**\n       * Internal variable to store the `position`.\n       * @default -1\n       * @private\n       */\n\n      this.position1 = -1;\n      /**\n       * Internal variable to hold `cloned object`.\n       * @default null\n       * @private\n       */\n\n      this.clonedObject1 = null;\n      /**\n       * `Shows` if the data of the stream was decrypted.\n       * @default false\n       * @private\n       */\n\n      this.bDecrypted = false;\n      /**\n       * Shows if the data of the stream `was decrypted`.\n       * @default false\n       * @private\n       */\n\n      this.isParentDecrypted = false;\n      /**\n       * Gets a value indicating whether the object is `packed or not`.\n       * @default false\n       * @private\n       */\n\n      this.isPacked = false;\n      /**\n       * @hidden\n       * @private\n       */\n\n      this.isFormField = false;\n      /**\n       * @hidden\n       * @private\n       */\n\n      this.isColorSpace = false;\n      /**\n       * @hidden\n       * @private\n       */\n\n      this.isHexString = true;\n\n      if (typeof value === 'undefined') {\n        this.bHex = false;\n      } else {\n        if (!(value.length > 0 && value[0] === '0xfeff')) {\n          this.stringValue = value;\n          this.data = [];\n\n          for (let i = 0; i < value.length; ++i) {\n            this.data.push(value.charCodeAt(i));\n          }\n        }\n      }\n    } //Property\n\n    /**\n     * Gets a value indicating whether string is in `hex`.\n     * @private\n     */\n\n\n    get hex() {\n      return this.bHex;\n    }\n    /**\n     * Gets or sets string `value` of the object.\n     * @private\n     */\n\n\n    get value() {\n      return this.stringValue;\n    }\n\n    set value(value) {\n      this.stringValue = value;\n      this.data = null;\n    }\n    /**\n     * Gets or sets the `Status` of the specified object.\n     * @private\n     */\n\n\n    get status() {\n      return this.status1;\n    }\n\n    set status(value) {\n      this.status1 = value;\n    }\n    /**\n     * Gets or sets a value indicating whether this document `is saving` or not.\n     * @private\n     */\n\n\n    get isSaving() {\n      return this.isSaving1;\n    }\n\n    set isSaving(value) {\n      this.isSaving1 = value;\n    }\n    /**\n     * Gets or sets the `index` value of the specified object.\n     * @private\n     */\n\n\n    get objectCollectionIndex() {\n      return this.index1;\n    }\n\n    set objectCollectionIndex(value) {\n      this.index1 = value;\n    }\n    /**\n     * Returns `cloned object`.\n     * @private\n     */\n\n\n    get clonedObject() {\n      return this.clonedObject1;\n    }\n    /**\n     * Gets or sets the `position` of the object.\n     * @private\n     */\n\n\n    get position() {\n      return this.position1;\n    }\n\n    set position(value) {\n      this.position1 = value;\n    }\n    /**\n     * Returns `PdfCrossTable` associated with the object.\n     * @private\n     */\n\n\n    get CrossTable() {\n      return this.crossTable;\n    }\n    /**\n     * Gets a value indicating whether to check if the value has unicode characters.\n     * @private\n     */\n\n\n    get converted() {\n      return this.bConverted;\n    }\n    /**\n     * sets a value indicating whether to check if the value has unicode characters.\n     * @private\n     */\n\n\n    set converted(value) {\n      this.bConverted = value;\n    }\n    /**\n     * Gets value indicating whether we should convert data to Unicode.\n     */\n\n\n    get encode() {\n      return this.bForceEncoding;\n    }\n\n    set encode(value) {\n      this.bForceEncoding = value;\n    } //Methods\n\n    /**\n     * Converts `bytes to string using hex format` for representing string.\n     * @private\n     */\n\n\n    static bytesToHex(bytes) {\n      if (bytes == null) {\n        return '';\n      }\n\n      let builder = '';\n      return builder;\n    }\n    /**\n     * `Saves` the object using the specified writer.\n     * @private\n     */\n\n\n    save(writer) {\n      if (writer === null) {\n        throw new Error('ArgumentNullException : writer');\n      }\n\n      if (this.encode !== undefined && this.encode === InternalEnum.ForceEncoding.Ascii) {\n        writer.write(this.pdfEncode());\n      } else {\n        writer.write(PdfString.stringMark[0] + this.value + PdfString.stringMark[1]);\n      }\n    }\n\n    pdfEncode() {\n      let result = '';\n\n      if (this.encode !== undefined && this.encode === InternalEnum.ForceEncoding.Ascii) {\n        let data = this.escapeSymbols(this.value);\n\n        for (let i = 0; i < data.length; i++) {\n          result += String.fromCharCode(data[i]);\n        }\n\n        result = PdfString.stringMark[0] + result + PdfString.stringMark[1];\n      } else {\n        result = this.value;\n      }\n\n      return result;\n    }\n\n    escapeSymbols(value) {\n      let data = [];\n\n      for (let i = 0; i < value.length; i++) {\n        let currentData = value.charCodeAt(i);\n\n        switch (currentData) {\n          case 40:\n          case 41:\n            data.push(92);\n            data.push(currentData);\n            break;\n\n          case 13:\n            data.push(92);\n            data.push(114);\n            break;\n\n          case 92:\n            data.push(92);\n            data.push(currentData);\n            break;\n\n          default:\n            data.push(currentData);\n            break;\n        }\n      }\n\n      return data;\n    }\n    /**\n     * Creates a `copy of PdfString`.\n     * @private\n     */\n\n\n    clone(crossTable) {\n      if (this.clonedObject1 !== null && this.clonedObject1.CrossTable === crossTable) {\n        return this.clonedObject1;\n      } else {\n        this.clonedObject1 = null;\n      }\n\n      let newString = new PdfString(this.stringValue);\n      newString.bHex = this.bHex;\n      newString.crossTable = crossTable;\n      newString.isColorSpace = this.isColorSpace;\n      this.clonedObject1 = newString;\n      return newString;\n    }\n    /**\n     * Converts string to array of unicode symbols.\n     */\n\n\n    static toUnicodeArray(value, bAddPrefix) {\n      if (value == null) {\n        throw new Error('Argument Null Exception : value');\n      }\n\n      let output = [];\n\n      for (let i = 0; i < value.length; i++) {\n        let code = value.charCodeAt(i);\n        output.push(code / 256 >>> 0);\n        output.push(code & 0xff);\n      }\n\n      return output;\n    }\n    /**\n     * Converts byte data to string.\n     */\n\n\n    static byteToString(data) {\n      if (data == null) {\n        throw new Error('Argument Null Exception : stream');\n      }\n\n      let result = '';\n\n      for (let i = 0; i < data.length; ++i) {\n        result += String.fromCharCode(data[i]);\n      }\n\n      return result;\n    }\n\n  }\n\n  //constants = ;\n\n  /**\n   * `General markers` for string.\n   * @private\n   */\n  PdfString.stringMark = '()';\n  /**\n   * `Hex markers` for string.\n   * @private\n   */\n\n  PdfString.hexStringMark = '<>';\n  /**\n   * Format of password data.\n   * @private\n   */\n\n  PdfString.hexFormatPattern = '{0:X2}';\n  /**\n   * `PdfReference` class is used to perform reference related primitive operations.\n   * @private\n   */\n\n  return PdfString;\n})();\n\nclass PdfReference {\n  constructor(objNumber, genNumber) {\n    /**\n     * Holds the `index` number of the object.\n     * @default -1\n     * @private\n     */\n    this.index3 = -1;\n    /**\n     * Internal variable to store the `position`.\n     * @default -1\n     * @private\n     */\n\n    this.position3 = -1;\n    /**\n     * Holds the `object number`.\n     * @default 0\n     * @private\n     */\n\n    this.objNumber = 0;\n    /**\n     * Holds the `generation number` of the object.\n     * @default 0\n     * @private\n     */\n\n    this.genNumber = 0;\n\n    if (typeof objNumber === 'number' && typeof genNumber === 'number') {\n      this.objNumber = objNumber;\n      this.genNumber = genNumber; // } else if (typeof objNum === 'string' && typeof genNum === 'string') {\n    } else {\n      this.objNumber = Number(objNumber);\n      this.genNumber = Number(genNumber);\n    }\n  } //Property\n\n  /**\n   * Gets or sets the `Status` of the specified object.\n   * @private\n   */\n\n\n  get status() {\n    return this.status3;\n  }\n\n  set status(value) {\n    this.status3 = value;\n  }\n  /**\n   * Gets or sets a value indicating whether this document `is saving` or not.\n   * @private\n   */\n\n\n  get isSaving() {\n    return this.isSaving3;\n  }\n\n  set isSaving(value) {\n    this.isSaving3 = value;\n  }\n  /**\n   * Gets or sets the `index` value of the specified object.\n   * @private\n   */\n\n\n  get objectCollectionIndex() {\n    return this.index3;\n  }\n\n  set objectCollectionIndex(value) {\n    this.index3 = value;\n  }\n  /**\n   * Gets or sets the `position` of the object.\n   * @private\n   */\n\n\n  get position() {\n    return this.position3;\n  }\n\n  set position(value) {\n    this.position3 = value;\n  }\n  /**\n   * Returns `cloned object`.\n   * @private\n   */\n\n\n  get clonedObject() {\n    let returnObject3 = null;\n    return returnObject3;\n  } //IPdfPrimitives methods\n\n  /**\n   * `Saves` the object.\n   * @private\n   */\n\n\n  save(writer) {\n    writer.write(this.toString());\n  }\n  /**\n   * Returns a `string` representing the object.\n   * @private\n   */\n\n\n  toString() {\n    return this.objNumber.toString() + ' ' + this.genNumber.toString() + ' R';\n  }\n  /**\n   * Creates a `deep copy` of the IPdfPrimitive object.\n   * @private\n   */\n\n\n  clone(crossTable) {\n    return null;\n  }\n\n}\n/**\n * `PdfReferenceHolder` class is used to perform reference holder related primitive operations.\n * @private\n */\n\n\nclass PdfReferenceHolder {\n  constructor(obj1, obj2) {\n    /**\n     * Holds the `index` number of the object.\n     * @default -1\n     * @private\n     */\n    this.index4 = -1;\n    /**\n     * Internal variable to store the `position`.\n     * @default -1\n     * @private\n     */\n\n    this.position4 = -1;\n    /**\n     * The `index` of the object within the object collection.\n     * @default -1\n     * @private\n     */\n\n    this.objectIndex = -1;\n    /**\n     * @hidden\n     * @private\n     */\n\n    this.dictionaryProperties = new DictionaryProperties(); // if (typeof obj2 === 'undefined') {\n\n    this.initialize(obj1); // }\n    // else {\n    //     if (obj2 === null) {\n    //         throw new Error('ArgumentNullException : crossTable');\n    //     }\n    //     if (obj1 === null) {\n    //         throw new Error('ArgumentNullException : reference');\n    //     }\n    //     this.crossTable = obj2;\n    //     let tempObj1 : PdfReference = <PdfReference>obj1;\n    //     this.reference = tempObj1;\n    // }\n  } //Properties\n\n  /**\n   * Gets or sets the `Status` of the specified object.\n   * @private\n   */\n\n\n  get status() {\n    return this.status4;\n  }\n\n  set status(value) {\n    this.status4 = value;\n  }\n  /**\n   * Gets or sets a value indicating whether this document `is saving` or not.\n   * @private\n   */\n\n\n  get isSaving() {\n    return this.isSaving4;\n  }\n\n  set isSaving(value) {\n    this.isSaving4 = value;\n  }\n  /**\n   * Gets or sets the `index` value of the specified object.\n   * @private\n   */\n\n\n  get objectCollectionIndex() {\n    return this.index4;\n  }\n\n  set objectCollectionIndex(value) {\n    this.index4 = value;\n  }\n  /**\n   * Gets or sets the `position` of the object.\n   * @private\n   */\n\n\n  get position() {\n    return this.position4;\n  }\n\n  set position(value) {\n    this.position4 = value;\n  }\n  /**\n   * Returns `cloned object`.\n   * @private\n   */\n\n\n  get clonedObject() {\n    return null;\n  }\n  /**\n   * Gets the `object` the reference is of.\n   * @private\n   */\n\n\n  get object() {\n    // if ((this.reference != null) || (this.object == null)) {\n    //     this.object = this.GetterObject();\n    // }\n    return this.primitiveObject;\n  }\n  /**\n   * Gets the `reference`.\n   * @private\n   */\n\n\n  get reference() {\n    return this.pdfReference;\n  }\n  /**\n   * Gets the `index` of the object.\n   * @private\n   */\n\n\n  get index() {\n    // let items : PdfMainObjectCollection = this.crossTable.PdfObjects;\n    // this.objectIndex = items.GetObjectIndex(this.reference);\n    // if (this.objectIndex < 0) {\n    //     let obj : IPdfPrimitive = this.crossTable.GetObject(this.reference);\n    //     this.objectIndex = items.Count - 1;\n    // }\n    return this.objectIndex;\n  }\n  /**\n   * Gets the `element`.\n   * @private\n   */\n\n\n  get element() {\n    return this.primitiveObject;\n  }\n\n  initialize(obj1) {\n    if (obj1 instanceof PdfArray || obj1 instanceof PdfDictionary || obj1 instanceof PdfName || obj1 instanceof PdfNumber || obj1 instanceof PdfStream || obj1 instanceof PdfReference || obj1 instanceof PdfString) {\n      this.primitiveObject = obj1;\n    } else {\n      let tempObj = obj1;\n      this.initialize(tempObj.element);\n    }\n  }\n  /**\n   * `Writes` a reference into a PDF document.\n   * @private\n   */\n\n\n  save(writer) {\n    // if (writer == null) {\n    //     throw new Error('ArgumentNullException : writer');\n    // }\n    let position = writer.position;\n    let cTable = writer.document.crossTable; // if (cTable.Document instanceof PdfDocument) {\n\n    this.object.isSaving = true; // }\n\n    let reference = null; // if (writer.Document.FileStructure.IncrementalUpdate === true && writer.Document.isStreamCopied === true) {\n    //     if (this.reference === null) {\n    //         reference = cTable.GetReference(this.Object);\n    //     } else {\n    //         reference = this.reference;\n    //     }\n    // } else {\n    //     reference = cTable.GetReference(this.Object);\n    // }\n    // if (!(writer.Document.FileStructure.IncrementalUpdate === true && writer.Document.isStreamCopied === true)) {\n\n    reference = cTable.getReference(this.object); // }\n    // if (writer.Position !== position) {\n    //     writer.Position = position;\n    // }\n\n    reference.save(writer);\n  }\n  /**\n   * Creates a `copy of PdfReferenceHolder`.\n   * @private\n   */\n\n\n  clone(crossTable) {\n    return null;\n  }\n\n}\n/**\n * `PdfAction` class represents base class for all action types.\n * @private\n */\n\n\nclass PdfAction {\n  // Constructors\n\n  /**\n   * Initialize instance for `Action` class.\n   * @private\n   */\n  constructor() {\n    /**\n     * Specifies the Next `action` to perform.\n     * @private\n     */\n    this.action = null;\n    /**\n     * Specifies the Internal variable to store `dictionary properties`.\n     * @private\n     */\n\n    this.dictionaryProperties = new DictionaryProperties(); // super(); -> Object()\n\n    this.initialize();\n  } // Properties\n\n  /**\n   * Gets and Sets the `Next` action to perform.\n   * @private\n   */\n\n\n  get next() {\n    return this.action;\n  }\n\n  set next(value) {\n    // if (this.action !== value) {\n    this.action = value;\n    this.dictionary.items.setValue(this.dictionaryProperties.next, new PdfReferenceHolder(this.action)); // }\n  }\n  /**\n   * Gets and Sets the instance of PdfDictionary class for `Dictionary`.\n   * @private\n   */\n\n\n  get dictionary() {\n    if (typeof this.pdfDictionary === 'undefined') {\n      this.pdfDictionary = new PdfDictionary();\n    }\n\n    return this.pdfDictionary;\n  } // Implementation\n\n  /**\n   * `Initialize` the action type.\n   * @private\n   */\n\n\n  initialize() {\n    this.dictionary.items.setValue(this.dictionaryProperties.type, new PdfName(this.dictionaryProperties.action));\n  } // IPdfWrapper Members\n\n  /**\n   * Gets the `Element` as IPdfPrimitive class.\n   * @private\n   */\n\n\n  get element() {\n    return this.dictionary;\n  }\n\n}\n/**\n * `PdfUriAction` class for initialize the uri related internals.\n * @private\n */\n\n\nclass PdfUriAction extends PdfAction {\n  constructor(uri) {\n    super(); // Fields\n\n    /**\n     * Specifies the `uri` string.\n     * @default ''.\n     * @private\n     */\n\n    this.uniformResourceIdentifier = '';\n  } // Properties\n\n  /**\n   * Gets and Sets the value of `Uri`.\n   * @private\n   */\n\n\n  get uri() {\n    return this.uniformResourceIdentifier;\n  }\n\n  set uri(value) {\n    this.uniformResourceIdentifier = value;\n    this.dictionary.items.setValue(this.dictionaryProperties.uri, new PdfString(this.uniformResourceIdentifier));\n  } // Implementation\n\n  /**\n   * `Initialize` the internals.\n   * @private\n   */\n\n\n  initialize() {\n    super.initialize();\n    this.dictionary.items.setValue(this.dictionaryProperties.s, new PdfName(this.dictionaryProperties.uri));\n  }\n\n}\n/**\n * public Enum for `PdfHorizontalAlignment`.\n * @private\n */\n\n\nvar PdfHorizontalAlignment = /*#__PURE__*/(() => {\n  (function (PdfHorizontalAlignment) {\n    /**\n     * Specifies the type of `Left`.\n     * @private\n     */\n    PdfHorizontalAlignment[PdfHorizontalAlignment[\"Left\"] = 0] = \"Left\";\n    /**\n     * Specifies the type of `Center`.\n     * @private\n     */\n\n    PdfHorizontalAlignment[PdfHorizontalAlignment[\"Center\"] = 1] = \"Center\";\n    /**\n     * Specifies the type of `Right`.\n     * @private\n     */\n\n    PdfHorizontalAlignment[PdfHorizontalAlignment[\"Right\"] = 2] = \"Right\";\n  })(PdfHorizontalAlignment || (PdfHorizontalAlignment = {}));\n\n  return PdfHorizontalAlignment;\n})();\n\n/**\n * public Enum for `PdfVerticalAlignment`.\n * @private\n */\nvar PdfVerticalAlignment = /*#__PURE__*/(() => {\n  (function (PdfVerticalAlignment) {\n    /**\n     * Specifies the type of `Top`.\n     * @private\n     */\n    PdfVerticalAlignment[PdfVerticalAlignment[\"Top\"] = 0] = \"Top\";\n    /**\n     * Specifies the type of `Middle`.\n     * @private\n     */\n\n    PdfVerticalAlignment[PdfVerticalAlignment[\"Middle\"] = 1] = \"Middle\";\n    /**\n     * Specifies the type of `Bottom`.\n     * @private\n     */\n\n    PdfVerticalAlignment[PdfVerticalAlignment[\"Bottom\"] = 2] = \"Bottom\";\n  })(PdfVerticalAlignment || (PdfVerticalAlignment = {}));\n\n  return PdfVerticalAlignment;\n})();\n\n/**\n * public Enum for `public`.\n * @private\n */\nvar PdfTextAlignment = /*#__PURE__*/(() => {\n  (function (PdfTextAlignment) {\n    /**\n     * Specifies the type of `Left`.\n     * @private\n     */\n    PdfTextAlignment[PdfTextAlignment[\"Left\"] = 0] = \"Left\";\n    /**\n     * Specifies the type of `Center`.\n     * @private\n     */\n\n    PdfTextAlignment[PdfTextAlignment[\"Center\"] = 1] = \"Center\";\n    /**\n     * Specifies the type of `Right`.\n     * @private\n     */\n\n    PdfTextAlignment[PdfTextAlignment[\"Right\"] = 2] = \"Right\";\n    /**\n     * Specifies the type of `Justify`.\n     * @private\n     */\n\n    PdfTextAlignment[PdfTextAlignment[\"Justify\"] = 3] = \"Justify\";\n  })(PdfTextAlignment || (PdfTextAlignment = {}));\n\n  return PdfTextAlignment;\n})();\n\n/**\n * public Enum for `TextRenderingMode`.\n * @private\n */\nvar TextRenderingMode = /*#__PURE__*/(() => {\n  (function (TextRenderingMode) {\n    /**\n     * Specifies the type of `Fill`.\n     * @private\n     */\n    TextRenderingMode[TextRenderingMode[\"Fill\"] = 0] = \"Fill\";\n    /**\n     * Specifies the type of `Stroke`.\n     * @private\n     */\n\n    TextRenderingMode[TextRenderingMode[\"Stroke\"] = 1] = \"Stroke\";\n    /**\n     * Specifies the type of `FillStroke`.\n     * @private\n     */\n\n    TextRenderingMode[TextRenderingMode[\"FillStroke\"] = 2] = \"FillStroke\";\n    /**\n     * Specifies the type of `None`.\n     * @private\n     */\n\n    TextRenderingMode[TextRenderingMode[\"None\"] = 3] = \"None\";\n    /**\n     * Specifies the type of `ClipFlag`.\n     * @private\n     */\n\n    TextRenderingMode[TextRenderingMode[\"ClipFlag\"] = 4] = \"ClipFlag\";\n    /**\n     * Specifies the type of `ClipFill`.\n     * @private\n     */\n\n    TextRenderingMode[TextRenderingMode[\"ClipFill\"] = 4] = \"ClipFill\";\n    /**\n     * Specifies the type of `ClipStroke`.\n     * @private\n     */\n\n    TextRenderingMode[TextRenderingMode[\"ClipStroke\"] = 5] = \"ClipStroke\";\n    /**\n     * Specifies the type of `ClipFillStroke`.\n     * @private\n     */\n\n    TextRenderingMode[TextRenderingMode[\"ClipFillStroke\"] = 6] = \"ClipFillStroke\";\n    /**\n     * Specifies the type of `Clip`.\n     * @private\n     */\n\n    TextRenderingMode[TextRenderingMode[\"Clip\"] = 7] = \"Clip\";\n  })(TextRenderingMode || (TextRenderingMode = {}));\n\n  return TextRenderingMode;\n})();\n\n/**\n * public Enum for `PdfLineJoin`.\n * @private\n */\nvar PdfLineJoin = /*#__PURE__*/(() => {\n  (function (PdfLineJoin) {\n    /**\n     * Specifies the type of `Miter`.\n     * @private\n     */\n    PdfLineJoin[PdfLineJoin[\"Miter\"] = 0] = \"Miter\";\n    /**\n     * Specifies the type of `Round`.\n     * @private\n     */\n\n    PdfLineJoin[PdfLineJoin[\"Round\"] = 1] = \"Round\";\n    /**\n     * Specifies the type of `Bevel`.\n     * @private\n     */\n\n    PdfLineJoin[PdfLineJoin[\"Bevel\"] = 2] = \"Bevel\";\n  })(PdfLineJoin || (PdfLineJoin = {}));\n\n  return PdfLineJoin;\n})();\n\n/**\n * public Enum for `PdfLineCap`.\n * @private\n */\nvar PdfLineCap = /*#__PURE__*/(() => {\n  (function (PdfLineCap) {\n    /**\n     * Specifies the type of `Flat`.\n     * @private\n     */\n    PdfLineCap[PdfLineCap[\"Flat\"] = 0] = \"Flat\";\n    /**\n     * Specifies the type of `Round`.\n     * @private\n     */\n\n    PdfLineCap[PdfLineCap[\"Round\"] = 1] = \"Round\";\n    /**\n     * Specifies the type of `Square`.\n     * @private\n     */\n\n    PdfLineCap[PdfLineCap[\"Square\"] = 2] = \"Square\";\n  })(PdfLineCap || (PdfLineCap = {}));\n\n  return PdfLineCap;\n})();\n\n/**\n * public Enum for `PdfDashStyle`.\n * @private\n */\nvar PdfDashStyle = /*#__PURE__*/(() => {\n  (function (PdfDashStyle) {\n    /**\n     * Specifies the type of `Solid`.\n     * @private\n     */\n    PdfDashStyle[PdfDashStyle[\"Solid\"] = 0] = \"Solid\";\n    /**\n     * Specifies the type of `Dash`.\n     * @private\n     */\n\n    PdfDashStyle[PdfDashStyle[\"Dash\"] = 1] = \"Dash\";\n    /**\n     * Specifies the type of `Dot`.\n     * @private\n     */\n\n    PdfDashStyle[PdfDashStyle[\"Dot\"] = 2] = \"Dot\";\n    /**\n     * Specifies the type of `DashDot`.\n     * @private\n     */\n\n    PdfDashStyle[PdfDashStyle[\"DashDot\"] = 3] = \"DashDot\";\n    /**\n     * Specifies the type of `DashDotDot`.\n     * @private\n     */\n\n    PdfDashStyle[PdfDashStyle[\"DashDotDot\"] = 4] = \"DashDotDot\";\n    /**\n     * Specifies the type of `Custom`.\n     * @private\n     */\n\n    PdfDashStyle[PdfDashStyle[\"Custom\"] = 5] = \"Custom\";\n  })(PdfDashStyle || (PdfDashStyle = {}));\n\n  return PdfDashStyle;\n})();\n\n/**\n * public Enum for `PdfFillMode`.\n * @private\n */\nvar PdfFillMode = /*#__PURE__*/(() => {\n  (function (PdfFillMode) {\n    /**\n     * Specifies the type of `Winding`.\n     * @private\n     */\n    PdfFillMode[PdfFillMode[\"Winding\"] = 0] = \"Winding\";\n    /**\n     * Specifies the type of `Alternate`.\n     * @private\n     */\n\n    PdfFillMode[PdfFillMode[\"Alternate\"] = 1] = \"Alternate\";\n  })(PdfFillMode || (PdfFillMode = {}));\n\n  return PdfFillMode;\n})();\n\n/**\n * public Enum for `PdfColorSpace`.\n * @private\n */\nvar PdfColorSpace = /*#__PURE__*/(() => {\n  (function (PdfColorSpace) {\n    /**\n     * Specifies the type of `Rgb`.\n     * @private\n     */\n    PdfColorSpace[PdfColorSpace[\"Rgb\"] = 0] = \"Rgb\";\n    /**\n     * Specifies the type of `Cmyk`.\n     * @private\n     */\n\n    PdfColorSpace[PdfColorSpace[\"Cmyk\"] = 1] = \"Cmyk\";\n    /**\n     * Specifies the type of `GrayScale`.\n     * @private\n     */\n\n    PdfColorSpace[PdfColorSpace[\"GrayScale\"] = 2] = \"GrayScale\";\n    /**\n     * Specifies the type of `Indexed`.\n     * @private\n     */\n\n    PdfColorSpace[PdfColorSpace[\"Indexed\"] = 3] = \"Indexed\";\n  })(PdfColorSpace || (PdfColorSpace = {}));\n\n  return PdfColorSpace;\n})();\n\n/**\n * public Enum for `PdfBlendMode`.\n * @private\n */\nvar PdfBlendMode = /*#__PURE__*/(() => {\n  (function (PdfBlendMode) {\n    /**\n     * Specifies the type of `Normal`.\n     * @private\n     */\n    PdfBlendMode[PdfBlendMode[\"Normal\"] = 0] = \"Normal\";\n    /**\n     * Specifies the type of `Multiply`.\n     * @private\n     */\n\n    PdfBlendMode[PdfBlendMode[\"Multiply\"] = 1] = \"Multiply\";\n    /**\n     * Specifies the type of `Screen`.\n     * @private\n     */\n\n    PdfBlendMode[PdfBlendMode[\"Screen\"] = 2] = \"Screen\";\n    /**\n     * Specifies the type of `Overlay`.\n     * @private\n     */\n\n    PdfBlendMode[PdfBlendMode[\"Overlay\"] = 3] = \"Overlay\";\n    /**\n     * Specifies the type of `Darken`.\n     * @private\n     */\n\n    PdfBlendMode[PdfBlendMode[\"Darken\"] = 4] = \"Darken\";\n    /**\n     * Specifies the type of `Lighten`.\n     * @private\n     */\n\n    PdfBlendMode[PdfBlendMode[\"Lighten\"] = 5] = \"Lighten\";\n    /**\n     * Specifies the type of `ColorDodge`.\n     * @private\n     */\n\n    PdfBlendMode[PdfBlendMode[\"ColorDodge\"] = 6] = \"ColorDodge\";\n    /**\n     * Specifies the type of `ColorBurn`.\n     * @private\n     */\n\n    PdfBlendMode[PdfBlendMode[\"ColorBurn\"] = 7] = \"ColorBurn\";\n    /**\n     * Specifies the type of `HardLight`.\n     * @private\n     */\n\n    PdfBlendMode[PdfBlendMode[\"HardLight\"] = 8] = \"HardLight\";\n    /**\n     * Specifies the type of `SoftLight`.\n     * @private\n     */\n\n    PdfBlendMode[PdfBlendMode[\"SoftLight\"] = 9] = \"SoftLight\";\n    /**\n     * Specifies the type of `Difference`.\n     * @private\n     */\n\n    PdfBlendMode[PdfBlendMode[\"Difference\"] = 10] = \"Difference\";\n    /**\n     * Specifies the type of `Exclusion`.\n     * @private\n     */\n\n    PdfBlendMode[PdfBlendMode[\"Exclusion\"] = 11] = \"Exclusion\";\n    /**\n     * Specifies the type of `Hue`.\n     * @private\n     */\n\n    PdfBlendMode[PdfBlendMode[\"Hue\"] = 12] = \"Hue\";\n    /**\n     * Specifies the type of `Saturation`.\n     * @private\n     */\n\n    PdfBlendMode[PdfBlendMode[\"Saturation\"] = 13] = \"Saturation\";\n    /**\n     * Specifies the type of `Color`.\n     * @private\n     */\n\n    PdfBlendMode[PdfBlendMode[\"Color\"] = 14] = \"Color\";\n    /**\n     * Specifies the type of `Luminosity`.\n     * @private\n     */\n\n    PdfBlendMode[PdfBlendMode[\"Luminosity\"] = 15] = \"Luminosity\";\n  })(PdfBlendMode || (PdfBlendMode = {}));\n\n  return PdfBlendMode;\n})();\n\n/**\n * public Enum for `PdfGraphicsUnit`.\n * @private\n */\nvar PdfGraphicsUnit = /*#__PURE__*/(() => {\n  (function (PdfGraphicsUnit) {\n    /**\n     * Specifies the type of `Centimeter`.\n     * @private\n     */\n    PdfGraphicsUnit[PdfGraphicsUnit[\"Centimeter\"] = 0] = \"Centimeter\";\n    /**\n     * Specifies the type of `Pica`.\n     * @private\n     */\n\n    PdfGraphicsUnit[PdfGraphicsUnit[\"Pica\"] = 1] = \"Pica\";\n    /**\n     * Specifies the type of `Pixel`.\n     * @private\n     */\n\n    PdfGraphicsUnit[PdfGraphicsUnit[\"Pixel\"] = 2] = \"Pixel\";\n    /**\n     * Specifies the type of `Point`.\n     * @private\n     */\n\n    PdfGraphicsUnit[PdfGraphicsUnit[\"Point\"] = 3] = \"Point\";\n    /**\n     * Specifies the type of `Inch`.\n     * @private\n     */\n\n    PdfGraphicsUnit[PdfGraphicsUnit[\"Inch\"] = 4] = \"Inch\";\n    /**\n     * Specifies the type of `Document`.\n     * @private\n     */\n\n    PdfGraphicsUnit[PdfGraphicsUnit[\"Document\"] = 5] = \"Document\";\n    /**\n     * Specifies the type of `Millimeter`.\n     * @private\n     */\n\n    PdfGraphicsUnit[PdfGraphicsUnit[\"Millimeter\"] = 6] = \"Millimeter\";\n  })(PdfGraphicsUnit || (PdfGraphicsUnit = {}));\n\n  return PdfGraphicsUnit;\n})();\n\n/**\n * public Enum for `PdfGridImagePosition`.\n * @private\n */\nvar PdfGridImagePosition = /*#__PURE__*/(() => {\n  (function (PdfGridImagePosition) {\n    /**\n     * Specifies the type of `Fit`.\n     * @private\n     */\n    PdfGridImagePosition[PdfGridImagePosition[\"Fit\"] = 0] = \"Fit\";\n    /**\n     * Specifies the type of `Center`.\n     * @private\n     */\n\n    PdfGridImagePosition[PdfGridImagePosition[\"Center\"] = 1] = \"Center\";\n    /**\n     * Specifies the type of `Stretch`.\n     * @private\n     */\n\n    PdfGridImagePosition[PdfGridImagePosition[\"Stretch\"] = 2] = \"Stretch\";\n    /**\n     * Specifies the type of `Tile`.\n     * @private\n     */\n\n    PdfGridImagePosition[PdfGridImagePosition[\"Tile\"] = 3] = \"Tile\";\n  })(PdfGridImagePosition || (PdfGridImagePosition = {}));\n\n  return PdfGridImagePosition;\n})();\n\n/**\n * public Enum for `the text rendering direction`.\n * @private\n */\nvar PdfTextDirection = /*#__PURE__*/(() => {\n  (function (PdfTextDirection) {\n    /**\n     * Specifies the type of `None`.\n     * @private\n     */\n    PdfTextDirection[PdfTextDirection[\"None\"] = 0] = \"None\";\n    /**\n     * Specifies the type of `LeftToRight`.\n     * @private\n     */\n\n    PdfTextDirection[PdfTextDirection[\"LeftToRight\"] = 1] = \"LeftToRight\";\n    /**\n     * Specifies the type of `RightToLeft`.\n     * @private\n     */\n\n    PdfTextDirection[PdfTextDirection[\"RightToLeft\"] = 2] = \"RightToLeft\";\n  })(PdfTextDirection || (PdfTextDirection = {}));\n\n  return PdfTextDirection;\n})();\n\n/**\n * Implements structures and routines working with `color`.\n * ```typescript\n * // create a new PDF document\n * let document : PdfDocument = new PdfDocument();\n * // add a new page to the document\n * let page1 : PdfPage = document.pages.add();\n * // set the font\n * let font : PdfStandardFont = new PdfStandardFont(PdfFontFamily.Helvetica, 20);\n * //\n * // set color\n * let brushColor : PdfColor = new PdfColor(0, 0, 0);\n * //\n * // create black brush\n * let blackBrush : PdfSolidBrush = new PdfSolidBrush(brushColor);\n * // draw the text\n * page1.graphics.drawString('Hello World', font, blackBrush, new PointF(0, 0));\n * // save the document\n * document.save('output.pdf');\n * // destroy the document\n * document.destroy();\n * ```\n * @default black color\n */\nclass PdfColor {\n  constructor(color1, color2, color3, color4) {\n    if (typeof color1 === 'undefined') {\n      if (typeof color2 !== 'undefined' && typeof color3 !== 'undefined' && typeof color4 !== 'undefined') {\n        this.assignRGB(color2, color3, color4);\n      } else {\n        this.filled = false;\n      }\n    } else if (color1 instanceof PdfColor) {\n      this.redColor = color1.r;\n      this.greenColor = color1.g;\n      this.blueColor = color1.b;\n      this.grayColor = color1.gray;\n      this.alpha = color1.alpha;\n      this.filled = this.alpha !== 0;\n      /* tslint:disable-next-line:max-line-length */\n    } else if (typeof color1 === 'number' && typeof color2 === 'undefined' && typeof color3 === 'undefined' && typeof color4 === 'undefined') {\n      if (color1 < 0) {\n        color1 = 0;\n      }\n\n      if (color1 > 1) {\n        color1 = 1;\n      }\n\n      this.redColor = color1 * PdfColor.maxColourChannelValue;\n      this.greenColor = color1 * PdfColor.maxColourChannelValue;\n      this.blueColor = color1 * PdfColor.maxColourChannelValue;\n      this.cyanColor = color1;\n      this.magentaColor = color1;\n      this.yellowColor = color1;\n      this.blackColor = color1;\n      this.grayColor = color1;\n      this.alpha = PdfColor.maxColourChannelValue;\n      this.filled = true;\n    } else if (typeof color4 === 'undefined') {\n      this.assignRGB(color1, color2, color3);\n    } else {\n      this.assignRGB(color2, color3, color4, color1);\n    }\n  }\n  /**\n   * `Assign` red, green, blue colors with alpha value..\n   * @private\n   */\n\n\n  assignRGB(r, g, b, a) {\n    if (typeof r === 'undefined' || typeof g === 'undefined' || typeof b === 'undefined') {\n      this.filled = false;\n    } else {\n      this.cyanColor = 0;\n      this.magentaColor = 0;\n      this.yellowColor = 0;\n      this.blackColor = 0;\n      this.grayColor = 0;\n      this.redColor = r;\n      this.greenColor = g;\n      this.blueColor = b;\n\n      if (typeof a === 'undefined') {\n        this.alpha = PdfColor.maxColourChannelValue;\n      } else {\n        this.alpha = a;\n      }\n\n      this.filled = true;\n      this.assignCMYK(r, g, b);\n    }\n  }\n  /**\n   * `Calculate and assign` cyan, megenta, yellow colors from rgb values..\n   * @private\n   */\n\n\n  assignCMYK(r, g, b) {\n    let red = r / PdfColor.maxColourChannelValue;\n    let green = g / PdfColor.maxColourChannelValue;\n    let blue = b / PdfColor.maxColourChannelValue;\n    let black = PdfNumber.min(1 - red, 1 - green, 1 - blue);\n    let cyan = black === 1.0 ? 0 : (1 - red - black) / (1 - black);\n    let magenta = black === 1.0 ? 0 : (1 - green - black) / (1 - black);\n    let yellow = black === 1.0 ? 0 : (1 - blue - black) / (1 - black);\n    this.blackColor = black;\n    this.cyanColor = cyan;\n    this.magentaColor = magenta;\n    this.yellowColor = yellow;\n  } //Properties\n  // public static get Empty():PdfColor\n  // {\n  //     return this.s_emptyColor\n  // }\n\n  /**\n   * Gets or sets `Red` channel value.\n   * @private\n   */\n\n\n  get r() {\n    return this.redColor;\n  }\n\n  set r(value) {\n    this.redColor = value;\n    this.assignCMYK(this.redColor, this.greenColor, this.blueColor);\n    this.filled = true;\n  }\n  /**\n   * Gets the `Red` color\n   * @private\n   */\n\n\n  get red() {\n    return this.r / PdfColor.maxColourChannelValue;\n  }\n  /**\n   * Gets or sets `Blue` channel value.\n   * @private\n   */\n\n\n  get b() {\n    return this.blueColor;\n  }\n\n  set b(value) {\n    this.blueColor = value;\n    this.assignCMYK(this.redColor, this.greenColor, this.blueColor);\n    this.filled = true;\n  }\n  /**\n   * Gets the `blue` color.\n   * @private\n   */\n\n\n  get blue() {\n    return this.b / PdfColor.maxColourChannelValue;\n  }\n  /**\n   * Gets or sets `Cyan` channel value.\n   * @private\n   */\n\n\n  get c() {\n    return this.cyanColor;\n  }\n\n  set c(value) {\n    if (value < 0) {\n      this.cyanColor = 0;\n    } else if (value > 1) {\n      this.cyanColor = 1;\n    } else {\n      this.cyanColor = value;\n    }\n\n    this.assignRGB(this.cyanColor, this.magentaColor, this.yellowColor, this.blackColor);\n    this.filled = true;\n  }\n  /**\n   * Gets or sets `Black` channel value.\n   * @private\n   */\n\n\n  get k() {\n    return this.blackColor;\n  }\n\n  set k(value) {\n    if (value < 0) {\n      this.blackColor = 0;\n    } else if (value > 1) {\n      this.blackColor = 1;\n    } else {\n      this.blackColor = value;\n    }\n\n    this.assignRGB(this.cyanColor, this.magentaColor, this.yellowColor, this.blackColor);\n    this.filled = true;\n  }\n  /**\n   * Gets or sets `Magenta` channel value.\n   * @private\n   */\n\n\n  get m() {\n    return this.magentaColor;\n  }\n\n  set m(value) {\n    if (value < 0) {\n      this.magentaColor = 0;\n    } else if (value > 1) {\n      this.magentaColor = 1;\n    } else {\n      this.magentaColor = value;\n    }\n\n    this.assignRGB(this.cyanColor, this.magentaColor, this.yellowColor, this.blackColor);\n    this.filled = true;\n  }\n  /**\n   * Gets or sets `Yellow` channel value.\n   * @private\n   */\n\n\n  get y() {\n    return this.yellowColor;\n  }\n\n  set y(value) {\n    if (value < 0) {\n      this.yellowColor = 0;\n    } else if (value > 1) {\n      this.yellowColor = 1;\n    } else {\n      this.yellowColor = value;\n    }\n\n    this.assignRGB(this.cyanColor, this.magentaColor, this.yellowColor, this.blackColor);\n    this.filled = true;\n  }\n  /**\n   *  Gets or sets `Green` channel value.\n   * @private\n   */\n\n\n  get g() {\n    return this.greenColor;\n  }\n\n  set g(value) {\n    this.greenColor = value;\n    this.assignCMYK(this.redColor, this.greenColor, this.blueColor);\n    this.filled = true;\n  }\n  /**\n   * Gets the `Green` color.\n   * @private\n   */\n\n\n  get green() {\n    return this.g / PdfColor.maxColourChannelValue;\n  }\n  /**\n   * Gets or sets `Gray` channel value.\n   * @private\n   */\n\n\n  get gray() {\n    return (this.redColor + this.greenColor + this.blueColor) / (PdfColor.maxColourChannelValue * 3);\n  }\n\n  set gray(value) {\n    if (value < 0) {\n      this.grayColor = 0;\n    } else if (value > 1) {\n      this.grayColor = 1;\n    } else {\n      this.grayColor = value;\n    }\n\n    this.r = this.grayColor * PdfColor.maxColourChannelValue;\n    this.g = this.grayColor * PdfColor.maxColourChannelValue;\n    this.b = this.grayColor * PdfColor.maxColourChannelValue;\n    this.assignCMYK(this.redColor, this.greenColor, this.blueColor);\n    this.filled = true;\n  }\n  /**\n   * Gets whether the PDFColor `is Empty` or not.\n   * @private\n   */\n\n\n  get isEmpty() {\n    return !this.filled;\n  }\n  /**\n   * Gets or sets `Alpha` channel value.\n   * @private\n   */\n\n\n  get a() {\n    return this.alpha;\n  }\n\n  set a(value) {\n    if (value < 0) {\n      this.alpha = 0;\n    } else {\n      // if (this.alpha !== value) {\n      this.alpha = value; // }\n    }\n\n    this.filled = true;\n  } //Public methods\n\n  /**\n   * Converts `PDFColor to PDF string` representation.\n   * @private\n   */\n\n\n  toString(colorSpace, stroke) {\n    if (this.isEmpty) {\n      return '';\n    }\n\n    let str = '';\n\n    switch (colorSpace) {\n      case PdfColorSpace.Rgb:\n        str = this.rgbToString(stroke);\n        break;\n\n      case PdfColorSpace.GrayScale:\n        str = this.grayScaleToString(stroke);\n        break;\n\n      case PdfColorSpace.Cmyk:\n        str = this.cmykToString(stroke);\n        break;\n    }\n\n    return str;\n  }\n  /**\n   * Sets `GrayScale` color.\n   * @private\n   */\n\n\n  grayScaleToString(ifStroking) {\n    let gray = this.gray;\n    let colour = '';\n    let obj = null;\n    /* tslint:disable-next-line:max-line-length */\n\n    obj = ifStroking ? PdfColor.grayStringsSroke.containsKey(gray) ? PdfColor.grayStringsSroke.getValue(gray) : null : PdfColor.grayStringsFill.containsKey(gray) ? PdfColor.grayStringsFill.getValue(gray) : null;\n\n    if (obj == null) {\n      if (ifStroking) {\n        colour = gray.toString() + ' G';\n        PdfColor.grayStringsSroke.setValue(gray, colour);\n      }\n    } else {\n      colour = obj.toString();\n    }\n\n    return colour + Operators.newLine;\n  }\n  /**\n   * Sets `RGB` color.\n   * @private\n   */\n\n\n  rgbToString(ifStroking) {\n    let r = this.r;\n    let g = this.g;\n    let b = this.b;\n    let key = (r << 16) + (g << 8) + b;\n\n    if (ifStroking) {\n      key += 1 << 24;\n    }\n\n    let colour = '';\n    let obj = null;\n\n    if (PdfColor.rgbStrings.containsKey(key)) {\n      obj = PdfColor.rgbStrings.getValue(key);\n    }\n\n    if (obj == null) {\n      let red = r / PdfColor.maxColourChannelValue;\n      let green = g / PdfColor.maxColourChannelValue;\n      let blue = b / PdfColor.maxColourChannelValue;\n\n      if (ifStroking) {\n        colour = red.toString() + ' ' + green.toString() + ' ' + blue.toString() + ' RG';\n      } else {\n        colour = red.toString() + ' ' + green.toString() + ' ' + blue.toString() + ' rg';\n      }\n\n      PdfColor.rgbStrings.setValue(key, colour);\n    } else {\n      colour = obj.toString();\n    }\n\n    return colour + Operators.newLine;\n  }\n  /***\n   * Sets `CMYK` color.\n   * @private\n   */\n\n\n  cmykToString(ifStroking) {\n    let cyan = this.c;\n    let magenta = this.m;\n    let yellow = this.y;\n    let black = this.b;\n    let colour = '';\n    colour = cyan.toString() + ' ' + magenta.toString() + ' ' + yellow.toString() + ' ' + black.toString() + ' K';\n    return colour + Operators.newLine;\n  }\n  /**\n   * Converts `colour to a PDF array`.\n   * @private\n   */\n\n\n  toArray(colorSpace) {\n    let array = new PdfArray();\n\n    switch (colorSpace) {\n      case PdfColorSpace.Rgb:\n        array.add(new PdfNumber(this.red));\n        array.add(new PdfNumber(this.green));\n        array.add(new PdfNumber(this.blue));\n        break;\n    }\n\n    return array;\n  }\n\n} //Fields\n\n/**\n * Holds `RGB colors` converted into strings.\n * @private\n */\n\n\nPdfColor.rgbStrings = new Dictionary();\n/**\n * Holds Gray scale colors converted into strings for `stroking`.\n * @private\n */\n\nPdfColor.grayStringsSroke = new Dictionary();\n/**\n * Holds Gray scale colors converted into strings for `filling`.\n * @private\n */\n\nPdfColor.grayStringsFill = new Dictionary();\n/**\n * `Max value` of color channel.\n * @private\n */\n\nPdfColor.maxColourChannelValue = 255.0;\n/**\n * Coordinates of Position for `PointF`.\n * @private\n */\n\nclass PointF {\n  constructor(x, y) {\n    if (typeof x === 'undefined') {\n      this.x = 0;\n      this.y = 0;\n    } else {\n      if (x !== null) {\n        this.x = x;\n      } else {\n        this.x = 0;\n      }\n\n      if (y !== null) {\n        this.y = y;\n      } else {\n        this.y = 0;\n      }\n    }\n  }\n\n}\n/**\n * Width and Height as `Size`.\n * @private\n */\n\n\nclass SizeF {\n  constructor(width, height) {\n    if (typeof height === 'undefined') {\n      this.height = 0;\n      this.width = 0;\n    } else {\n      if (height !== null) {\n        this.height = height;\n      } else {\n        this.height = 0;\n      }\n\n      if (width !== null) {\n        this.width = width;\n      } else {\n        this.width = 0;\n      }\n    }\n  }\n\n}\n/**\n * `RectangleF` with Position and size.\n * @private\n */\n\n\nclass RectangleF {\n  constructor(arg1, arg2, arg3, arg4) {\n    if (typeof arg1 === typeof arg1 && typeof arg1 === 'undefined') {\n      this.x = 0;\n      this.y = 0;\n      this.height = 0;\n      this.width = 0;\n    } else {\n      if (arg1 instanceof PointF && arg2 instanceof SizeF && typeof arg3 === 'undefined') {\n        let pointf = arg1;\n        this.x = pointf.x;\n        this.y = pointf.y;\n        let sizef = arg2;\n        this.height = sizef.height;\n        this.width = sizef.width;\n      } else {\n        let x = arg1;\n        let y = arg2;\n        let width = arg3;\n        let height = arg4;\n        this.x = x;\n        this.y = y;\n        this.height = height;\n        this.width = width;\n      }\n    }\n  }\n\n}\n/**\n * `Rectangle` with left, right, top and bottom.\n * @private\n */\n\n\nclass Rectangle {\n  /**\n   * Instance of `RectangleF` class with X, Y, Width and Height.\n   * @private\n   */\n  constructor(left, top, right, bottom) {\n    this.left = left;\n    this.top = top;\n    this.right = right;\n    this.bottom = bottom;\n  }\n  /**\n   * Gets a value of width\n   */\n\n\n  get width() {\n    return this.right - this.left;\n  }\n  /**\n   * Gets a value of height\n   */\n\n\n  get height() {\n    return this.bottom - this.top;\n  }\n  /**\n   * Gets a value of Top and Left\n   */\n\n\n  get topLeft() {\n    return new PointF(this.left, this.top);\n  }\n  /**\n   * Gets a value of size\n   */\n\n\n  get size() {\n    return new SizeF(this.width, this.height);\n  }\n\n  toString() {\n    return this.topLeft + 'x' + this.size;\n  }\n\n}\n/**\n * `PdfBrush` class provides objects used to fill the interiors of graphical shapes such as rectangles,\n * ellipses, pies, polygons, and paths.\n * @private\n */\n\n\nclass PdfBrush {\n  /**\n   * Creates instanceof `PdfBrush` class.\n   * @hidden\n   * @private\n   */\n  constructor() {//\n  } //IClonable implementation\n\n\n  clone() {\n    return this;\n  }\n\n}\n/**\n * Represents a brush that fills any object with a solid color.\n * ```typescript\n * // create a new PDF document\n * let document : PdfDocument = new PdfDocument();\n * // add a pages to the document\n * let page1 : PdfPage = document.pages.add();\n * // set font\n * let font : PdfStandardFont = new PdfStandardFont(PdfFontFamily.Helvetica, 20);\n * // set brush\n * let blackBrush : PdfSolidBrush = new PdfSolidBrush(new PdfColor(0, 0, 0));\n * // draw the text\n * page1.graphics.drawString('Hello World', font, blackBrush, new PointF(10, 10));\n * // save the document\n * document.save('output.pdf');\n * // destroy the document\n * document.destroy();\n * ```\n */\n\n\nclass PdfSolidBrush extends PdfBrush {\n  //Constructors\n\n  /**\n   * Initializes a new instance of the `PdfSolidBrush` class.\n   * ```typescript\n   * // create a new PDF document\n   * let document : PdfDocument = new PdfDocument();\n   * // add a pages to the document\n   * let page1 : PdfPage = document.pages.add();\n   * // set font\n   * let font : PdfStandardFont = new PdfStandardFont(PdfFontFamily.Helvetica, 20);\n   * // set brush\n   * let blackBrush : PdfSolidBrush = new PdfSolidBrush(new PdfColor(0, 0, 0));\n   * // draw the text\n   * page1.graphics.drawString('Hello World', font, blackBrush, new PointF(10, 10));\n   * // save the document\n   * document.save('output.pdf');\n   * // destroy the document\n   * document.destroy();\n   * ```\n   * @param color color of the brush\n   */\n  constructor(color) {\n    super();\n    this.pdfColor = color;\n  } //Properties\n\n  /**\n   * Gets or sets the `color` of the brush.\n   * @private\n   */\n\n\n  get color() {\n    return this.pdfColor;\n  }\n\n  set color(value) {\n    this.pdfColor = value;\n  } //Implementation\n\n  /**\n   * `Monitors` the changes of the brush and modify PDF state respectively.\n   * @private\n   */\n\n\n  monitorChanges(brush, streamWriter, getResources, saveChanges, currentColorSpace) {\n    if (streamWriter == null) {\n      throw new Error('ArgumentNullException:streamWriter');\n    }\n\n    let diff = false;\n\n    if (brush == null) {\n      diff = true;\n      streamWriter.setColorAndSpace(this.pdfColor, currentColorSpace, false);\n      return diff;\n    } else {\n      diff = true;\n      streamWriter.setColorAndSpace(this.pdfColor, currentColorSpace, false);\n      return diff;\n    }\n  }\n  /**\n   * `Resets` the changes, which were made by the brush.\n   * @private\n   */\n\n\n  resetChanges(streamWriter) {\n    streamWriter.setColorAndSpace(new PdfColor(0, 0, 0), PdfColorSpace.Rgb, false);\n  }\n\n}\n/**\n * public Enum for `PdfFontStyle`.\n * @private\n */\n\n\nvar PdfFontStyle = /*#__PURE__*/(() => {\n  (function (PdfFontStyle) {\n    /**\n     * Specifies the type of `Regular`.\n     * @private\n     */\n    PdfFontStyle[PdfFontStyle[\"Regular\"] = 0] = \"Regular\";\n    /**\n     * Specifies the type of `Bold`.\n     * @private\n     */\n\n    PdfFontStyle[PdfFontStyle[\"Bold\"] = 1] = \"Bold\";\n    /**\n     * Specifies the type of `Italic`.\n     * @private\n     */\n\n    PdfFontStyle[PdfFontStyle[\"Italic\"] = 2] = \"Italic\";\n    /**\n     * Specifies the type of `Underline`.\n     * @private\n     */\n\n    PdfFontStyle[PdfFontStyle[\"Underline\"] = 4] = \"Underline\";\n    /**\n     * Specifies the type of `Strikeout`.\n     * @private\n     */\n\n    PdfFontStyle[PdfFontStyle[\"Strikeout\"] = 8] = \"Strikeout\";\n  })(PdfFontStyle || (PdfFontStyle = {}));\n\n  return PdfFontStyle;\n})();\n\n/**\n * Specifies the font family from the standard font.\n * ```typescript\n * // create a new PDF document\n * let document : PdfDocument = new PdfDocument();\n * // add a new page to the document\n * let page1 : PdfPage = document.pages.add();\n * // create new standard font\n * let font : PdfStandardFont = new PdfStandardFont(PdfFontFamily.Helvetica, 20);\n * // create black brush\n * let blackBrush : PdfSolidBrush = new PdfSolidBrush(new PdfColor(0, 0, 0));\n * // draw the text\n * page1.graphics.drawString('Hello World', font, blackBrush, new PointF(0, 0));\n * // save the document\n * document.save('output.pdf');\n * ```\n */\nvar PdfFontFamily = /*#__PURE__*/(() => {\n  (function (PdfFontFamily) {\n    /**\n     * Specifies the `Helvetica` font.\n     */\n    PdfFontFamily[PdfFontFamily[\"Helvetica\"] = 0] = \"Helvetica\";\n    /**\n     * Specifies the `Courier` font.\n     */\n\n    PdfFontFamily[PdfFontFamily[\"Courier\"] = 1] = \"Courier\";\n    /**\n     * Specifies the `TimesRoman` font.\n     */\n\n    PdfFontFamily[PdfFontFamily[\"TimesRoman\"] = 2] = \"TimesRoman\";\n    /**\n     * Specifies the `Symbol` font.\n     */\n\n    PdfFontFamily[PdfFontFamily[\"Symbol\"] = 3] = \"Symbol\";\n    /**\n     * Specifies the `ZapfDingbats` font.\n     */\n\n    PdfFontFamily[PdfFontFamily[\"ZapfDingbats\"] = 4] = \"ZapfDingbats\";\n  })(PdfFontFamily || (PdfFontFamily = {}));\n\n  return PdfFontFamily;\n})();\n\n/**\n * public Enum for `PdfFontType`.\n * @private\n */\nvar PdfFontType = /*#__PURE__*/(() => {\n  (function (PdfFontType) {\n    /**\n     * Specifies the type of `Standard`.\n     * @private\n     */\n    PdfFontType[PdfFontType[\"Standard\"] = 0] = \"Standard\";\n    /**\n     * Specifies the type of `TrueType`.\n     * @private\n     */\n\n    PdfFontType[PdfFontType[\"TrueType\"] = 1] = \"TrueType\";\n    /**\n     * Specifies the type of `TrueTypeEmbedded`.\n     * @private\n     */\n\n    PdfFontType[PdfFontType[\"TrueTypeEmbedded\"] = 2] = \"TrueTypeEmbedded\";\n  })(PdfFontType || (PdfFontType = {}));\n\n  return PdfFontType;\n})();\n\n/**\n * public Enum for `PdfWordWrapType`.\n * @private\n */\nvar PdfWordWrapType = /*#__PURE__*/(() => {\n  (function (PdfWordWrapType) {\n    /**\n     * Specifies the type of `None`.\n     * @private\n     */\n    PdfWordWrapType[PdfWordWrapType[\"None\"] = 0] = \"None\";\n    /**\n     * Specifies the type of `Word`.\n     * @private\n     */\n\n    PdfWordWrapType[PdfWordWrapType[\"Word\"] = 1] = \"Word\";\n    /**\n     * Specifies the type of `WordOnly`.\n     * @private\n     */\n\n    PdfWordWrapType[PdfWordWrapType[\"WordOnly\"] = 2] = \"WordOnly\";\n    /**\n     * Specifies the type of `Character`.\n     * @private\n     */\n\n    PdfWordWrapType[PdfWordWrapType[\"Character\"] = 3] = \"Character\";\n  })(PdfWordWrapType || (PdfWordWrapType = {}));\n\n  return PdfWordWrapType;\n})();\n\n/**\n * public Enum for `PdfSubSuperScript`.\n * @private\n */\nvar PdfSubSuperScript = /*#__PURE__*/(() => {\n  (function (PdfSubSuperScript) {\n    /**\n     * Specifies the type of `None`.\n     * @private\n     */\n    PdfSubSuperScript[PdfSubSuperScript[\"None\"] = 0] = \"None\";\n    /**\n     * Specifies the type of `SuperScript`.\n     * @private\n     */\n\n    PdfSubSuperScript[PdfSubSuperScript[\"SuperScript\"] = 1] = \"SuperScript\";\n    /**\n     * Specifies the type of `SubScript`.\n     * @private\n     */\n\n    PdfSubSuperScript[PdfSubSuperScript[\"SubScript\"] = 2] = \"SubScript\";\n  })(PdfSubSuperScript || (PdfSubSuperScript = {}));\n\n  return PdfSubSuperScript;\n})();\n\n/**\n * public Enum for `FontEncoding`.\n * @private\n */\nvar FontEncoding = /*#__PURE__*/(() => {\n  (function (FontEncoding) {\n    /**\n     * Specifies the type of `Unknown`.\n     * @private\n     */\n    FontEncoding[FontEncoding[\"Unknown\"] = 0] = \"Unknown\";\n    /**\n     * Specifies the type of `StandardEncoding`.\n     * @private\n     */\n\n    FontEncoding[FontEncoding[\"StandardEncoding\"] = 1] = \"StandardEncoding\";\n    /**\n     * Specifies the type of `MacRomanEncoding`.\n     * @private\n     */\n\n    FontEncoding[FontEncoding[\"MacRomanEncoding\"] = 2] = \"MacRomanEncoding\";\n    /**\n     * Specifies the type of `MacExpertEncoding`.\n     * @private\n     */\n\n    FontEncoding[FontEncoding[\"MacExpertEncoding\"] = 3] = \"MacExpertEncoding\";\n    /**\n     * Specifies the type of `WinAnsiEncoding`.\n     * @private\n     */\n\n    FontEncoding[FontEncoding[\"WinAnsiEncoding\"] = 4] = \"WinAnsiEncoding\";\n    /**\n     * Specifies the type of `PdfDocEncoding`.\n     * @private\n     */\n\n    FontEncoding[FontEncoding[\"PdfDocEncoding\"] = 5] = \"PdfDocEncoding\";\n    /**\n     * Specifies the type of `IdentityH`.\n     * @private\n     */\n\n    FontEncoding[FontEncoding[\"IdentityH\"] = 6] = \"IdentityH\";\n  })(FontEncoding || (FontEncoding = {}));\n\n  return FontEncoding;\n})();\n\n/**\n * public Enum for `TtfCmapFormat`.\n * @private\n */\nvar TtfCmapFormat = /*#__PURE__*/(() => {\n  (function (TtfCmapFormat) {\n    /**\n     * This is the Apple standard character to glyph index mapping table.\n     * @private\n     */\n    TtfCmapFormat[TtfCmapFormat[\"Apple\"] = 0] = \"Apple\";\n    /**\n     * This is the Microsoft standard character to glyph index mapping table.\n     * @private\n     */\n\n    TtfCmapFormat[TtfCmapFormat[\"Microsoft\"] = 4] = \"Microsoft\";\n    /**\n     * Format 6: Trimmed table mapping.\n     * @private\n     */\n\n    TtfCmapFormat[TtfCmapFormat[\"Trimmed\"] = 6] = \"Trimmed\";\n  })(TtfCmapFormat || (TtfCmapFormat = {}));\n\n  return TtfCmapFormat;\n})();\n\n/**\n * Enumerator that implements CMAP encodings.\n * @private\n */\nvar TtfCmapEncoding = /*#__PURE__*/(() => {\n  (function (TtfCmapEncoding) {\n    /**\n     * Unknown encoding.\n     * @private\n     */\n    TtfCmapEncoding[TtfCmapEncoding[\"Unknown\"] = 0] = \"Unknown\";\n    /**\n     * When building a symbol font for Windows.\n     * @private\n     */\n\n    TtfCmapEncoding[TtfCmapEncoding[\"Symbol\"] = 1] = \"Symbol\";\n    /**\n     * When building a Unicode font for Windows.\n     * @private\n     */\n\n    TtfCmapEncoding[TtfCmapEncoding[\"Unicode\"] = 2] = \"Unicode\";\n    /**\n     * For font that will be used on a Macintosh.\n     * @private\n     */\n\n    TtfCmapEncoding[TtfCmapEncoding[\"Macintosh\"] = 3] = \"Macintosh\";\n  })(TtfCmapEncoding || (TtfCmapEncoding = {}));\n\n  return TtfCmapEncoding;\n})();\n\n/**\n * Ttf platform ID.\n * @private\n */\nvar TtfPlatformID = /*#__PURE__*/(() => {\n  (function (TtfPlatformID) {\n    /**\n     * Apple platform.\n     * @private\n     */\n    TtfPlatformID[TtfPlatformID[\"AppleUnicode\"] = 0] = \"AppleUnicode\";\n    /**\n     * Macintosh platform.\n     * @private\n     */\n\n    TtfPlatformID[TtfPlatformID[\"Macintosh\"] = 1] = \"Macintosh\";\n    /**\n     * Iso platform.\n     * @private\n     */\n\n    TtfPlatformID[TtfPlatformID[\"Iso\"] = 2] = \"Iso\";\n    /**\n     * Microsoft platform.\n     * @private\n     */\n\n    TtfPlatformID[TtfPlatformID[\"Microsoft\"] = 3] = \"Microsoft\";\n  })(TtfPlatformID || (TtfPlatformID = {}));\n\n  return TtfPlatformID;\n})();\n\n/**\n * Microsoft encoding ID.\n * @private\n */\nvar TtfMicrosoftEncodingID = /*#__PURE__*/(() => {\n  (function (TtfMicrosoftEncodingID) {\n    /**\n     * Undefined encoding.\n     * @private\n     */\n    TtfMicrosoftEncodingID[TtfMicrosoftEncodingID[\"Undefined\"] = 0] = \"Undefined\";\n    /**\n     * Unicode encoding.\n     * @private\n     */\n\n    TtfMicrosoftEncodingID[TtfMicrosoftEncodingID[\"Unicode\"] = 1] = \"Unicode\";\n  })(TtfMicrosoftEncodingID || (TtfMicrosoftEncodingID = {}));\n\n  return TtfMicrosoftEncodingID;\n})();\n\n/**\n * Macintosh encoding ID.\n * @private\n */\nvar TtfMacintoshEncodingID = /*#__PURE__*/(() => {\n  (function (TtfMacintoshEncodingID) {\n    /**\n     * Roman encoding.\n     * @private\n     */\n    TtfMacintoshEncodingID[TtfMacintoshEncodingID[\"Roman\"] = 0] = \"Roman\";\n    /**\n     * Japanese encoding.\n     * @private\n     */\n\n    TtfMacintoshEncodingID[TtfMacintoshEncodingID[\"Japanese\"] = 1] = \"Japanese\";\n    /**\n     * Chinese encoding.\n     * @private\n     */\n\n    TtfMacintoshEncodingID[TtfMacintoshEncodingID[\"Chinese\"] = 2] = \"Chinese\";\n  })(TtfMacintoshEncodingID || (TtfMacintoshEncodingID = {}));\n\n  return TtfMacintoshEncodingID;\n})();\n\n/**\n * Enumerator that implements font descriptor flags.\n * @private\n */\nvar FontDescriptorFlags = /*#__PURE__*/(() => {\n  (function (FontDescriptorFlags) {\n    /**\n     * All glyphs have the same width (as opposed to proportional or variable-pitch fonts, which have different widths).\n     * @private\n     */\n    FontDescriptorFlags[FontDescriptorFlags[\"FixedPitch\"] = 1] = \"FixedPitch\";\n    /**\n     * Glyphs have serifs, which are short strokes drawn at an angle on the top and\n     * bottom of glyph stems (as opposed to sans serif fonts, which do not).\n     * @private\n     */\n\n    FontDescriptorFlags[FontDescriptorFlags[\"Serif\"] = 2] = \"Serif\";\n    /**\n     * Font contains glyphs outside the Adobe standard Latin character set. The\n     * flag and the nonsymbolic flag cannot both be set or both be clear.\n     * @private\n     */\n\n    FontDescriptorFlags[FontDescriptorFlags[\"Symbolic\"] = 4] = \"Symbolic\";\n    /**\n     * Glyphs resemble cursive handwriting.\n     * @private\n     */\n\n    FontDescriptorFlags[FontDescriptorFlags[\"Script\"] = 8] = \"Script\";\n    /**\n     * Font uses the Adobe standard Latin character set or a subset of it.\n     * @private\n     */\n\n    FontDescriptorFlags[FontDescriptorFlags[\"Nonsymbolic\"] = 32] = \"Nonsymbolic\";\n    /**\n     * Glyphs have dominant vertical strokes that are slanted.\n     * @private\n     */\n\n    FontDescriptorFlags[FontDescriptorFlags[\"Italic\"] = 64] = \"Italic\";\n    /**\n     * Bold font.\n     * @private\n     */\n\n    FontDescriptorFlags[FontDescriptorFlags[\"ForceBold\"] = 262144] = \"ForceBold\";\n  })(FontDescriptorFlags || (FontDescriptorFlags = {}));\n\n  return FontDescriptorFlags;\n})();\n\n/**\n * true type font composite glyph flags.\n * @private\n */\nvar TtfCompositeGlyphFlags = /*#__PURE__*/(() => {\n  (function (TtfCompositeGlyphFlags) {\n    /**\n     * The Arg1And2AreWords.\n     * @private\n     */\n    TtfCompositeGlyphFlags[TtfCompositeGlyphFlags[\"Arg1And2AreWords\"] = 1] = \"Arg1And2AreWords\";\n    /**\n     * The ArgsAreXyValues.\n     * @private\n     */\n\n    TtfCompositeGlyphFlags[TtfCompositeGlyphFlags[\"ArgsAreXyValues\"] = 2] = \"ArgsAreXyValues\";\n    /**\n     * The RoundXyToGrid.\n     * @private\n     */\n\n    TtfCompositeGlyphFlags[TtfCompositeGlyphFlags[\"RoundXyToGrid\"] = 4] = \"RoundXyToGrid\";\n    /**\n     * The WeHaveScale.\n     * @private\n     */\n\n    TtfCompositeGlyphFlags[TtfCompositeGlyphFlags[\"WeHaveScale\"] = 8] = \"WeHaveScale\";\n    /**\n     * The Reserved.\n     * @private\n     */\n\n    TtfCompositeGlyphFlags[TtfCompositeGlyphFlags[\"Reserved\"] = 16] = \"Reserved\";\n    /**\n     * The MoreComponents.\n     * @private\n     */\n\n    TtfCompositeGlyphFlags[TtfCompositeGlyphFlags[\"MoreComponents\"] = 32] = \"MoreComponents\";\n    /**\n     * The WeHaveAnXyScale.\n     * @private\n     */\n\n    TtfCompositeGlyphFlags[TtfCompositeGlyphFlags[\"WeHaveAnXyScale\"] = 64] = \"WeHaveAnXyScale\";\n    /**\n     * The WeHaveTwoByTwo\n     */\n\n    TtfCompositeGlyphFlags[TtfCompositeGlyphFlags[\"WeHaveTwoByTwo\"] = 128] = \"WeHaveTwoByTwo\";\n    /**\n     * The WeHaveInstructions.\n     */\n\n    TtfCompositeGlyphFlags[TtfCompositeGlyphFlags[\"WeHaveInstructions\"] = 256] = \"WeHaveInstructions\";\n    /**\n     * The UseMyMetrics.\n     */\n\n    TtfCompositeGlyphFlags[TtfCompositeGlyphFlags[\"UseMyMetrics\"] = 512] = \"UseMyMetrics\";\n  })(TtfCompositeGlyphFlags || (TtfCompositeGlyphFlags = {}));\n\n  return TtfCompositeGlyphFlags;\n})();\n\n/**\n * PdfStringFormat.ts class for EJ2-PDF\n */\n\n/**\n * `PdfStringFormat` class represents the text layout information on PDF.\n * ```typescript\n * // create a new PDF document\n * let document : PdfDocument = new PdfDocument();\n * // add a pages to the document\n * let page1 : PdfPage = document.pages.add();\n * // set font\n * let font : PdfStandardFont = new PdfStandardFont(PdfFontFamily.Helvetica, 20);\n * // set brush\n * let blackBrush : PdfSolidBrush = new PdfSolidBrush(new PdfColor(0, 0, 0));\n * //\n * // set the format for string\n * let stringFormat : PdfStringFormat = new PdfStringFormat();\n * // set the text alignment\n * stringFormat.alignment = PdfTextAlignment.Center;\n * // set the vertical alignment\n * stringFormat.lineAlignment = PdfVerticalAlignment.Middle;\n * //\n * // draw the text\n * page1.graphics.drawString('Hello World', font, blackBrush, new PointF(10, 10), stringFormat);\n * // save the document\n * document.save('output.pdf');\n * // destroy the document\n * document.destroy();\n * ```\n */\nclass PdfStringFormat {\n  constructor(arg1, arg2) {\n    /**\n     * The `scaling factor` of the text being drawn.\n     * @private\n     */\n    this.scalingFactor = 100.0;\n    /**\n     * Indicates text `wrapping` type.\n     * @private\n     */\n\n    this.wordWrapType = PdfWordWrapType.Word;\n    this.internalLineLimit = true;\n    this.wordWrapType = PdfWordWrapType.Word;\n\n    if (typeof arg1 !== 'undefined' && typeof arg1 !== 'string') {\n      this.textAlignment = arg1;\n    }\n\n    if (typeof arg2 !== 'undefined') {\n      this.verticalAlignment = arg2;\n    }\n  } //Properties\n\n  /**\n   * Gets or sets the `horizontal` text alignment\n   * ```typescript\n   * // create a new PDF document\n   * let document : PdfDocument = new PdfDocument();\n   * // add a pages to the document\n   * let page1 : PdfPage = document.pages.add();\n   * // set font\n   * let font : PdfStandardFont = new PdfStandardFont(PdfFontFamily.Helvetica, 20);\n   * // set brush\n   * let blackBrush : PdfSolidBrush = new PdfSolidBrush(new PdfColor(0, 0, 0));\n   * //\n   * // set the format for string\n   * let stringFormat : PdfStringFormat = new PdfStringFormat();\n   * // set the text alignment\n   * stringFormat.alignment = PdfTextAlignment.Center;\n   * //\n   * // draw the text\n   * page1.graphics.drawString('Hello World', font, blackBrush, new PointF(10, 10), stringFormat);\n   * // save the document\n   * document.save('output.pdf');\n   * // destroy the document\n   * document.destroy();\n   * ```\n   */\n\n\n  get alignment() {\n    return this.textAlignment;\n  }\n\n  set alignment(value) {\n    this.textAlignment = value;\n  }\n\n  get textDirection() {\n    return this.direction;\n  }\n\n  set textDirection(value) {\n    this.direction = value;\n  }\n  /**\n   * Gets or sets the `vertical` text alignment.\n   * ```typescript\n   * // create a new PDF document\n   * let document : PdfDocument = new PdfDocument();\n   * // add a pages to the document\n   * let page1 : PdfPage = document.pages.add();\n   * // set font\n   * let font : PdfStandardFont = new PdfStandardFont(PdfFontFamily.Helvetica, 20);\n   * // set brush\n   * let blackBrush : PdfSolidBrush = new PdfSolidBrush(new PdfColor(0, 0, 0));\n   * //\n   * // set the format for string\n   * let stringFormat : PdfStringFormat = new PdfStringFormat();\n   * // set the vertical alignment\n   * stringFormat.lineAlignment = PdfVerticalAlignment.Middle;\n   * //\n   * // draw the text\n   * page1.graphics.drawString('Hello World', font, blackBrush, new PointF(10, 10), stringFormat);\n   * // save the document\n   * document.save('output.pdf');\n   * // destroy the document\n   * document.destroy();\n   * ```\n   */\n\n\n  get lineAlignment() {\n    if (typeof this.verticalAlignment === 'undefined' || this.verticalAlignment == null) {\n      return PdfVerticalAlignment.Top;\n    } else {\n      return this.verticalAlignment;\n    }\n  }\n\n  set lineAlignment(value) {\n    this.verticalAlignment = value;\n  }\n  /**\n   * Gets or sets the value that indicates text `direction` mode.\n   * @private\n   */\n\n\n  get rightToLeft() {\n    if (typeof this.isRightToLeft === 'undefined' || this.isRightToLeft == null) {\n      return false;\n    } else {\n      return this.isRightToLeft;\n    }\n  }\n\n  set rightToLeft(value) {\n    this.isRightToLeft = value;\n  }\n  /**\n   * Gets or sets value that indicates a `size` among the characters in the text.\n   * ```typescript\n   * // create a new PDF document\n   * let document : PdfDocument = new PdfDocument();\n   * // add a pages to the document\n   * let page1 : PdfPage = document.pages.add();\n   * // set font\n   * let font : PdfStandardFont = new PdfStandardFont(PdfFontFamily.Helvetica, 20);\n   * // set brush\n   * let blackBrush : PdfSolidBrush = new PdfSolidBrush(new PdfColor(0, 0, 0));\n   * //\n   * // set the format for string\n   * let stringFormat : PdfStringFormat = new PdfStringFormat();\n   * // set character spacing\n   * stringFormat.characterSpacing = 10;\n   * //\n   * // draw the text\n   * page1.graphics.drawString('Hello World', font, blackBrush, new PointF(10, 10), stringFormat);\n   * // save the document\n   * document.save('output.pdf');\n   * // destroy the document\n   * document.destroy();\n   * ```\n   */\n\n\n  get characterSpacing() {\n    if (typeof this.internalCharacterSpacing === 'undefined' || this.internalCharacterSpacing == null) {\n      return 0;\n    } else {\n      return this.internalCharacterSpacing;\n    }\n  }\n\n  set characterSpacing(value) {\n    this.internalCharacterSpacing = value;\n  }\n  /**\n   * Gets or sets value that indicates a `size` among the words in the text.\n   * ```typescript\n   * // create a new PDF document\n   * let document : PdfDocument = new PdfDocument();\n   * // add a pages to the document\n   * let page1 : PdfPage = document.pages.add();\n   * // set font\n   * let font : PdfStandardFont = new PdfStandardFont(PdfFontFamily.Helvetica, 20);\n   * // set brush\n   * let blackBrush : PdfSolidBrush = new PdfSolidBrush(new PdfColor(0, 0, 0));\n   * //\n   * // set the format for string\n   * let stringFormat : PdfStringFormat = new PdfStringFormat();\n   * // set word spacing\n   * stringFormat.wordSpacing = 10;\n   * //\n   * // draw the text\n   * page1.graphics.drawString('Hello World', font, blackBrush, new PointF(10, 10), stringFormat);\n   * // save the document\n   * document.save('output.pdf');\n   * // destroy the document\n   * document.destroy();\n   * ```\n   */\n\n\n  get wordSpacing() {\n    if (typeof this.internalWordSpacing === 'undefined' || this.internalWordSpacing == null) {\n      return 0;\n    } else {\n      return this.internalWordSpacing;\n    }\n  }\n\n  set wordSpacing(value) {\n    this.internalWordSpacing = value;\n  }\n  /**\n   * Gets or sets value that indicates the `vertical distance` between the baselines of adjacent lines of text.\n   * ```typescript\n   * // create a new PDF document\n   * let document : PdfDocument = new PdfDocument();\n   * // add a pages to the document\n   * let page1 : PdfPage = document.pages.add();\n   * // set font\n   * let font : PdfStandardFont = new PdfStandardFont(PdfFontFamily.Helvetica, 20);\n   * // set brush\n   * let blackBrush : PdfSolidBrush = new PdfSolidBrush(new PdfColor(0, 0, 0));\n   * // set string\n   * let text : string = 'Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor\n   * incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitati';\n   * // set rectangle bounds\n   * let rectangle : RectangleF = new RectangleF({x : 0, y : 0}, {width : 300, height : 100})\n   * //\n   * // set the format for string\n   * let stringFormat : PdfStringFormat = new PdfStringFormat();\n   * // set line spacing\n   * stringFormat.lineSpacing = 10;\n   * //\n   * // draw the text\n   * page1.graphics.drawString(text, font, blackBrush, rectangle, stringFormat);\n   * // save the document\n   * document.save('output.pdf');\n   * // destroy the document\n   * document.destroy();\n   * ```\n   */\n\n\n  get lineSpacing() {\n    if (typeof this.leading === 'undefined' || this.leading == null) {\n      return 0;\n    } else {\n      return this.leading;\n    }\n  }\n\n  set lineSpacing(value) {\n    this.leading = value;\n  }\n  /**\n   * Gets or sets a value indicating whether the text is `clipped` or not.\n   * @private\n   */\n\n\n  get clipPath() {\n    if (typeof this.clip === 'undefined' || this.clip == null) {\n      return false;\n    } else {\n      return this.clip;\n    }\n  }\n\n  set clipPath(value) {\n    this.clip = value;\n  }\n  /**\n   * Gets or sets value indicating whether the text is in `subscript or superscript` mode.\n   * @private\n   */\n\n\n  get subSuperScript() {\n    if (typeof this.pdfSubSuperScript === 'undefined' || this.pdfSubSuperScript == null) {\n      return PdfSubSuperScript.None;\n    } else {\n      return this.pdfSubSuperScript;\n    }\n  }\n\n  set subSuperScript(value) {\n    this.pdfSubSuperScript = value;\n  }\n  /**\n   * Gets or sets the `indent` of the first line in the paragraph.\n   * @private\n   */\n\n\n  get paragraphIndent() {\n    if (typeof this.internalParagraphIndent === 'undefined' || this.internalParagraphIndent == null) {\n      return 0;\n    } else {\n      return this.internalParagraphIndent;\n    }\n  }\n\n  set paragraphIndent(value) {\n    this.internalParagraphIndent = value;\n    this.firstLineIndent = value;\n  }\n  /**\n   * Gets or sets a value indicating whether [`line limit`].\n   * @private\n   */\n\n\n  get lineLimit() {\n    return this.internalLineLimit;\n  }\n\n  set lineLimit(value) {\n    this.internalLineLimit = value;\n  }\n  /**\n   * Gets or sets a value indicating whether [`measure trailing spaces`].\n   * @private\n   */\n\n\n  get measureTrailingSpaces() {\n    if (typeof this.trailingSpaces === 'undefined' || this.trailingSpaces == null) {\n      return false;\n    } else {\n      return this.trailingSpaces;\n    }\n  }\n\n  set measureTrailingSpaces(value) {\n    this.trailingSpaces = value;\n  }\n  /**\n   * Gets or sets a value indicating whether [`no clip`].\n   * @private\n   */\n\n\n  get noClip() {\n    if (typeof this.isNoClip === 'undefined' || this.isNoClip == null) {\n      return false;\n    } else {\n      return this.isNoClip;\n    }\n  }\n\n  set noClip(value) {\n    this.isNoClip = value;\n  }\n  /**\n   * Gets or sets value indicating type of the text `wrapping`.\n   * @private\n   */\n\n\n  get wordWrap() {\n    // if (typeof this.wrapType === 'undefined' || this.wrapType == null) {\n    //     return PdfWordWrapType.Word;\n    // } else {\n    return this.wordWrapType; // }\n  }\n\n  set wordWrap(value) {\n    this.wordWrapType = value;\n  }\n  /**\n   * Gets or sets the `scaling factor`.\n   * @private\n   */\n\n\n  get horizontalScalingFactor() {\n    // if (typeof this.scalingFactor === 'undefined' || this.scalingFactor == null) {\n    //     return 100;\n    // } else {\n    return this.scalingFactor; // }\n  }\n\n  set horizontalScalingFactor(value) {\n    if (value <= 0) {\n      throw new Error('ArgumentOutOfRangeException:The scaling factor cant be less of equal to zero, ScalingFactor');\n    }\n\n    this.scalingFactor = value;\n  }\n  /**\n   * Gets or sets the `indent` of the first line in the text.\n   * @private\n   */\n\n\n  get firstLineIndent() {\n    if (typeof this.initialLineIndent === 'undefined' || this.initialLineIndent == null) {\n      return 0;\n    } else {\n      return this.initialLineIndent;\n    }\n  }\n\n  set firstLineIndent(value) {\n    this.initialLineIndent = value;\n  }\n  /**\n   * `Clones` the object.\n   * @private\n   */\n  //IClonable implementation\n\n\n  clone() {\n    let format = this;\n    return format;\n  }\n\n}\n/**\n * StringTokenizer.ts class for EJ2-PDF\n * Utility class for working with strings.\n * @private\n */\n\n\nclass StringTokenizer {\n  // Constructors\n\n  /**\n   * Initializes a new instance of the `StringTokenizer` class.\n   * @private\n   */\n  constructor(textValue) {\n    /**\n     * Current `position`.\n     * @private\n     */\n    this.currentPosition = 0;\n\n    if (textValue == null) {\n      throw new Error('ArgumentNullException:text');\n    }\n\n    this.text = textValue;\n  } // Properties\n\n  /**\n   * Gets text `length`.\n   * @private\n   */\n\n\n  get length() {\n    return this.text.length;\n  }\n\n  get end() {\n    return this.currentPosition === this.text.length;\n  }\n  /**\n   * Gets or sets the position.\n   * @private\n   */\n\n\n  get position() {\n    return this.currentPosition;\n  }\n\n  set position(value) {\n    this.currentPosition = value;\n  }\n\n  static getCharsCount(text, symbols) {\n    if (typeof symbols === 'string') {\n      if (text == null) {\n        throw new Error('ArgumentNullException:wholeText');\n      }\n\n      let numSymbols = 0;\n      let curIndex = 0;\n\n      for (;;) {\n        curIndex = text.indexOf(symbols, curIndex);\n\n        if (curIndex === -1) {\n          break;\n        } else {\n          numSymbols++;\n          curIndex++;\n        }\n      }\n\n      return numSymbols;\n    } else {\n      if (text == null) {\n        throw new Error('ArgumentNullException:text');\n      }\n\n      if (symbols == null) {\n        throw new Error('ArgumentNullException:symbols');\n      }\n\n      let count = 0;\n\n      for (let i = 0, len = text.length; i < len; i++) {\n        let ch = text[i];\n\n        if (this.contains(symbols, ch)) {\n          count++;\n        }\n      }\n\n      return count;\n    }\n  }\n  /**\n   * Reads line of the text.\n   * @private\n   */\n\n\n  readLine() {\n    let pos = this.currentPosition;\n\n    while (pos < this.length) {\n      let ch = this.text[pos];\n\n      switch (ch) {\n        case '\\r':\n        case '\\n':\n          {\n            let text = this.text.substr(this.currentPosition, pos - this.currentPosition);\n            this.currentPosition = pos + 1;\n\n            if (ch === '\\r' && this.currentPosition < this.length && this.text[this.currentPosition] === '\\n') {\n              this.currentPosition++;\n            }\n\n            return text;\n          }\n      }\n\n      pos++;\n    } // The remaining text.\n\n\n    if (pos > this.currentPosition) {\n      let text2 = this.text.substr(this.currentPosition, pos - this.currentPosition);\n      this.currentPosition = pos;\n      return text2;\n    }\n\n    return null;\n  }\n  /**\n   * Reads line of the text.\n   * @private\n   */\n\n\n  peekLine() {\n    let pos = this.currentPosition;\n    let line = this.readLine();\n    this.currentPosition = pos;\n    return line;\n  }\n  /**\n   * Reads a word from the text.\n   * @private\n   */\n\n\n  readWord() {\n    let pos = this.currentPosition;\n\n    while (pos < this.length) {\n      let ch = this.text[pos];\n\n      switch (ch) {\n        case '\\r':\n        case '\\n':\n          let textValue = this.text.substr(this.currentPosition, pos - this.currentPosition);\n          this.currentPosition = pos + 1;\n\n          if (ch === '\\r' && this.currentPosition < this.length && this.text[this.currentPosition] === '\\n') {\n            this.currentPosition++;\n          }\n\n          return textValue;\n\n        case ' ':\n        case '\\t':\n          {\n            if (pos === this.currentPosition) {\n              pos++;\n            }\n\n            let text = this.text.substr(this.currentPosition, pos - this.currentPosition);\n            this.currentPosition = pos;\n            return text;\n          }\n      }\n\n      pos++;\n    } // The remaining text.\n\n\n    if (pos > this.currentPosition) {\n      let text2 = this.text.substr(this.currentPosition, pos - this.currentPosition);\n      this.currentPosition = pos;\n      return text2;\n    }\n\n    return null;\n  }\n  /**\n   * Peeks a word from the text.\n   * @private\n   */\n\n\n  peekWord() {\n    let pos = this.currentPosition;\n    let word = this.readWord();\n    this.currentPosition = pos;\n    return word;\n  }\n\n  read(count) {\n    if (typeof count === 'undefined') {\n      let ch = '0';\n\n      if (!this.end) {\n        ch = this.text[this.currentPosition];\n        this.currentPosition++;\n      }\n\n      return ch;\n    } else {\n      let num = 0;\n      let builder = '';\n\n      while (!this.end && num < count) {\n        let ch = this.read();\n        builder = builder + ch;\n        num++;\n      }\n\n      return builder;\n    }\n  }\n  /**\n   * Peeks char form the data.\n   * @private\n   */\n\n\n  peek() {\n    let ch = '0';\n\n    if (!this.end) {\n      ch = this.text[this.currentPosition];\n    }\n\n    return ch;\n  }\n  /**\n   * Closes a reader.\n   * @private\n   */\n\n\n  close() {\n    this.text = null;\n  }\n\n  readToEnd() {\n    let text;\n\n    if (this.currentPosition === 0) {\n      text = this.text;\n    } else {\n      text = this.text.substr(this.currentPosition, this.length - this.currentPosition);\n    }\n\n    this.currentPosition = this.length;\n    return text;\n  } //Implementation\n\n  /**\n   * Checks whether array contains a symbol.\n   * @private\n   */\n\n\n  static contains(array, symbol) {\n    let contains = false;\n\n    for (let i = 0; i < array.length; i++) {\n      if (array[i] === symbol) {\n        contains = true;\n        break;\n      }\n    }\n\n    return contains;\n  }\n\n} // Constants\n\n/**\n * `Whitespace` symbol.\n * @private\n */\n\n\nStringTokenizer.whiteSpace = ' ';\n/**\n * `tab` symbol.\n * @private\n */\n\nStringTokenizer.tab = '\\t';\n/**\n * Array of `spaces`.\n * @private\n */\n\nStringTokenizer.spaces = [StringTokenizer.whiteSpace, StringTokenizer.tab];\n/**\n * `Pattern` for WhiteSpace.\n * @private\n */\n\nStringTokenizer.whiteSpacePattern = '^[ \\t]+$';\n/**\n * Class `lay outing the text`.\n */\n\nclass PdfStringLayouter {\n  // Constructors\n\n  /**\n   * Initializes a new instance of the `StringLayouter` class.\n   * @private\n   */\n  constructor() {\n    /**\n     * Checks whether the x co-ordinate is need to set as client size or not.\n     * @hidden\n     * @private\n     */\n    this.isOverloadWithPosition = false; //\n  }\n\n  layout(arg1, arg2, arg3, arg4, arg5, arg6, arg7) {\n    if (arg4 instanceof RectangleF) {\n      this.initialize(arg1, arg2, arg3, arg4, arg5);\n      this.isOverloadWithPosition = arg6;\n      this.clientSize = arg7;\n      let result = this.doLayout();\n      this.clear();\n      return result;\n    } else {\n      this.initialize(arg1, arg2, arg3, arg4);\n      this.isOverloadWithPosition = arg5;\n      this.clientSize = arg6;\n      let result = this.doLayout();\n      this.clear();\n      return result;\n    }\n  }\n\n  initialize(text, font, format, rectSize, pageHeight) {\n    if (typeof pageHeight === 'number') {\n      if (text == null) {\n        throw new Error('ArgumentNullException:text');\n      }\n\n      if (font == null) {\n        throw new Error('ArgumentNullException:font');\n      }\n\n      this.text = text;\n      this.font = font;\n      this.format = format;\n      this.size = new SizeF(rectSize.width, rectSize.height);\n      this.rectangle = rectSize;\n      this.pageHeight = pageHeight;\n      this.reader = new StringTokenizer(text);\n    } else {\n      this.initialize(text, font, format, new RectangleF(new PointF(0, 0), rectSize), 0);\n    }\n  }\n  /**\n   * `Clear` all resources.\n   * @private\n   */\n\n\n  clear() {\n    this.font = null;\n    this.format = null;\n    this.reader.close();\n    this.reader = null;\n    this.text = null;\n  }\n  /**\n   * `Layouts` the text.\n   * @private\n   */\n\n\n  doLayout() {\n    let result = new PdfStringLayoutResult();\n    let lineResult = new PdfStringLayoutResult();\n    let lines = [];\n    let line = this.reader.peekLine();\n    let lineIndent = this.getLineIndent(true);\n\n    while (line != null) {\n      lineResult = this.layoutLine(line, lineIndent);\n\n      if (lineResult !== null || typeof lineResult !== 'undefined') {\n        let numSymbolsInserted = 0;\n        /* tslint:disable */\n\n        let returnedValue = this.copyToResult(result, lineResult, lines,\n        /*out*/\n        numSymbolsInserted);\n        /* tslint:enable */\n\n        let success = returnedValue.success;\n        numSymbolsInserted = returnedValue.numInserted;\n\n        if (!success) {\n          this.reader.read(numSymbolsInserted);\n          break;\n        }\n      } // if (lineResult.textRemainder != null && lineResult.textRemainder.length > 0 ) {\n      //     break;\n      // }\n\n\n      this.reader.readLine();\n      line = this.reader.peekLine();\n      lineIndent = this.getLineIndent(false);\n    }\n\n    this.finalizeResult(result, lines);\n    return result;\n  }\n  /**\n   * Returns `line indent` for the line.\n   * @private\n   */\n\n\n  getLineIndent(firstLine) {\n    let lineIndent = 0;\n\n    if (this.format != null) {\n      lineIndent = firstLine ? this.format.firstLineIndent : this.format.paragraphIndent;\n      lineIndent = this.size.width > 0 ? Math.min(this.size.width, lineIndent) : lineIndent;\n    }\n\n    return lineIndent;\n  }\n  /**\n   * Calculates `height` of the line.\n   * @private\n   */\n\n\n  getLineHeight() {\n    let height = this.font.height;\n\n    if (this.format != null && this.format.lineSpacing !== 0) {\n      height = this.format.lineSpacing + this.font.height;\n    }\n\n    return height;\n  }\n  /**\n   * Calculates `width` of the line.\n   * @private\n   */\n\n\n  getLineWidth(line) {\n    let width = this.font.getLineWidth(line, this.format);\n    return width;\n  } // tslint:disable\n\n  /**\n   * `Layouts` line.\n   * @private\n   */\n\n\n  layoutLine(line, lineIndent) {\n    let lineResult = new PdfStringLayoutResult();\n    lineResult.layoutLineHeight = this.getLineHeight();\n    let lines = [];\n    let maxWidth = this.size.width;\n    let lineWidth = this.getLineWidth(line) + lineIndent;\n    let lineType = LineType.FirstParagraphLine;\n    let readWord = true; // line is in bounds.\n\n    if (maxWidth <= 0 || Math.round(lineWidth) <= Math.round(maxWidth)) {\n      this.addToLineResult(lineResult, lines, line, lineWidth, LineType.NewLineBreak | lineType);\n    } else {\n      let builder = '';\n      let curLine = '';\n      lineWidth = lineIndent;\n      let curIndent = lineIndent;\n      let reader = new StringTokenizer(line);\n      let word = reader.peekWord();\n\n      if (word.length !== reader.length) {\n        if (word === ' ') {\n          curLine = curLine + word;\n          builder = builder + word;\n          reader.position += 1;\n          word = reader.peekWord();\n        }\n      }\n\n      while (word != null) {\n        curLine = curLine + word;\n        let curLineWidth = this.getLineWidth(curLine.toString()) + curIndent;\n\n        if (curLine.toString() === ' ') {\n          curLine = '';\n          curLineWidth = 0;\n        }\n\n        if (curLineWidth > maxWidth) {\n          if (this.getWrapType() === PdfWordWrapType.None) {\n            break;\n          }\n\n          if (curLine.length === word.length) {\n            //  Character wrap is disabled or one symbol is greater than bounds.\n            if (this.getWrapType() === PdfWordWrapType.WordOnly) {\n              lineResult.textRemainder = line.substring(reader.position);\n              break;\n            } else if (curLine.length === 1) {\n              builder = builder + word;\n              break;\n            } else {\n              readWord = false;\n              curLine = '';\n              word = reader.peek().toString();\n              continue;\n            }\n          } else {\n            if (this.getLineWidth(word.toString()) > maxWidth) {\n              this.format.wordWrap = PdfWordWrapType.Character;\n            } else {\n              if (typeof this.format !== 'undefined' && this.format !== null) {\n                this.format.wordWrap = PdfWordWrapType.Word;\n              }\n            }\n\n            if (this.getWrapType() !== PdfWordWrapType.Character || !readWord) {\n              let ln = builder.toString(); // if (ln.indexOf(' ') === -1) {\n              //     isSingleWord = true;\n              //     this.addToLineResult(lineResult, lines, curLine, lineWidth, LineType.LayoutBreak | lineType);\n              // } else {\n              //     this.addToLineResult(lineResult, lines, ln, lineWidth, LineType.LayoutBreak | lineType);\n              // }                          \n\n              if (ln !== ' ') {\n                this.addToLineResult(lineResult, lines, ln, lineWidth, LineType.LayoutBreak | lineType);\n              }\n\n              if (this.isOverloadWithPosition) {\n                maxWidth = this.clientSize.width;\n              }\n\n              curLine = '';\n              builder = '';\n              lineWidth = 0;\n              curIndent = 0;\n              curLineWidth = 0;\n              lineType = LineType.None; // if (isSingleWord) {\n              //     reader.readWord();\n              //     readWord = false;\n              // }\n\n              word = readWord ? word : reader.peekWord(); //isSingleWord = false;\n\n              readWord = true;\n            } else {\n              readWord = false;\n              curLine = '';\n              curLine = curLine + builder.toString();\n              word = reader.peek().toString();\n            }\n\n            continue;\n          }\n        }\n        /*tslint:disable:max-func-body-length */\n\n\n        builder = builder + word;\n        lineWidth = curLineWidth;\n\n        if (readWord) {\n          reader.readWord();\n          word = reader.peekWord(); //isSingleWord = false;\n        } else {\n          reader.read();\n          word = reader.peek().toString();\n        }\n      }\n\n      if (builder.length > 0) {\n        let ln = builder.toString();\n        this.addToLineResult(lineResult, lines, ln, lineWidth, LineType.NewLineBreak | LineType.LastParagraphLine);\n      }\n\n      reader.close();\n    }\n\n    lineResult.layoutLines = [];\n\n    for (let index = 0; index < lines.length; index++) {\n      lineResult.layoutLines.push(lines[index]);\n    }\n\n    lines = [];\n    return lineResult;\n  }\n  /**\n   * `Adds` line to line result.\n   * @private\n   */\n\n\n  addToLineResult(lineResult, lines, line, lineWidth, breakType) {\n    let info = new LineInfo();\n    info.text = line;\n    info.width = lineWidth;\n    info.lineType = breakType;\n    lines.push(info);\n    let size = lineResult.actualSize;\n    size.height += this.getLineHeight();\n    size.width = Math.max(size.width, lineWidth);\n    lineResult.size = size;\n  }\n  /**\n   * `Copies` layout result from line result to entire result. Checks whether we can proceed lay outing or not.\n   * @private\n   */\n\n\n  copyToResult(result, lineResult, lines,\n  /*out*/\n  numInserted) {\n    let success = true;\n    let allowPartialLines = this.format != null && !this.format.lineLimit;\n    let height = result.actualSize.height;\n    let maxHeight = this.size.height;\n\n    if (this.pageHeight > 0 && maxHeight + this.rectangle.y > this.pageHeight) {\n      maxHeight = this.rectangle.y - this.pageHeight;\n      maxHeight = Math.max(maxHeight, -maxHeight);\n    }\n\n    numInserted = 0;\n\n    if (lineResult.lines != null) {\n      for (let i = 0, len = lineResult.lines.length; i < len; i++) {\n        let expHeight = height + lineResult.lineHeight;\n\n        if (expHeight <= maxHeight || maxHeight <= 0 || allowPartialLines) {\n          let info = lineResult.lines[i];\n          numInserted += info.text.length;\n          info = this.trimLine(info, lines.length === 0);\n          lines.push(info); // Update width.\n\n          let size = result.actualSize;\n          size.width = Math.max(size.width, info.width);\n          result.size = size; // The part of the line fits only and it's allowed to use partial lines.\n          // if (expHeight >= maxHeight && maxHeight > 0 && allowPartialLines)\n          // {\n          //     let shouldClip : boolean = (this.format == null || !this.format.noClip);\n          //     if (shouldClip)\n          //     {\n          //         let exceededHeight : number = expHeight - maxHeight;\n          //         let fitHeight : number  = /*Utils.Round(*/ lineResult.lineHeight - exceededHeight /*)*/;\n          //         height = /*Utils.Round(*/ height + fitHeight /*)*/;\n          //     }\n          //     else\n          //     {\n          //         height = expHeight;\n          //     }\n          //     success = false;\n          //     break;\n          // } else {\n\n          height = expHeight; // }\n        } else {\n          success = false;\n          break;\n        }\n      }\n    }\n\n    if (height != result.size.height) {\n      let size1 = result.actualSize;\n      size1.height = height;\n      result.size = size1;\n    }\n\n    return {\n      success: success,\n      numInserted: numInserted\n    };\n  }\n  /**\n   * `Finalizes` final result.\n   * @private\n   */\n\n\n  finalizeResult(result, lines) {\n    result.layoutLines = [];\n\n    for (let index = 0; index < lines.length; index++) {\n      result.layoutLines.push(lines[index]);\n    }\n\n    result.layoutLineHeight = this.getLineHeight();\n\n    if (!this.reader.end) {\n      result.textRemainder = this.reader.readToEnd();\n    }\n\n    lines = [];\n  }\n  /**\n   * `Trims` whitespaces at the line.\n   * @private\n   */\n\n\n  trimLine(info, firstLine) {\n    let line = info.text;\n    let lineWidth = info.width; // Trim start whitespaces if the line is not a start of the paragraph only.\n\n    let trimStartSpaces = (info.lineType & LineType.FirstParagraphLine) === 0;\n    let start = this.format == null || !this.format.rightToLeft;\n    line = start ? line.trim() : line.trim(); // Recalculate line width.\n\n    if (line.length !== info.text.length) {\n      lineWidth = this.getLineWidth(line);\n\n      if ((info.lineType & LineType.FirstParagraphLine) > 0) {\n        lineWidth += this.getLineIndent(firstLine);\n      }\n    }\n\n    info.text = line;\n    info.width = lineWidth;\n    return info;\n  }\n  /**\n   * Returns `wrap` type.\n   * @private\n   */\n\n\n  getWrapType() {\n    let wrapType = this.format != null ? this.format.wordWrap : PdfWordWrapType.Word;\n    return wrapType;\n  }\n\n} //Internal declaration\n\n\nclass PdfStringLayoutResult {\n  // Properties\n\n  /**\n   * Gets the `text` which is not lay outed.\n   * @private\n   */\n  get remainder() {\n    return this.textRemainder;\n  }\n  /**\n   * Gets the actual layout text `bounds`.\n   * @private\n   */\n\n\n  get actualSize() {\n    if (typeof this.size === 'undefined') {\n      this.size = new SizeF(0, 0);\n    }\n\n    return this.size;\n  }\n  /**\n   * Gets layout `lines` information.\n   * @private\n   */\n\n\n  get lines() {\n    return this.layoutLines;\n  }\n  /**\n   * Gets the `height` of the line.\n   * @private\n   */\n\n\n  get lineHeight() {\n    return this.layoutLineHeight;\n  }\n  /**\n   * Gets value that indicates whether any layout text [`empty`].\n   * @private\n   */\n\n\n  get empty() {\n    return this.layoutLines == null || this.layoutLines.length === 0;\n  }\n  /**\n   * Gets `number of` the layout lines.\n   * @private\n   */\n\n\n  get lineCount() {\n    let count = !this.empty ? this.layoutLines.length : 0;\n    return count;\n  }\n\n}\n\nclass LineInfo {\n  //Properties\n\n  /**\n   * Gets the `type` of the line text.\n   * @private\n   */\n  get lineType() {\n    return this.type;\n  }\n\n  set lineType(value) {\n    this.type = value;\n  }\n  /**\n   * Gets the line `text`.\n   * @private\n   */\n\n\n  get text() {\n    return this.content;\n  }\n\n  set text(value) {\n    this.content = value;\n  }\n  /**\n   * Gets `width` of the line text.\n   * @private\n   */\n\n\n  get width() {\n    return this.lineWidth;\n  }\n\n  set width(value) {\n    this.lineWidth = value;\n  }\n\n}\n/**\n* Break type of the `line`.\n* @private\n*/\n\n\nvar LineType = /*#__PURE__*/(() => {\n  (function (LineType) {\n    /**\n     * Specifies the type of `None`.\n     * @private\n     */\n    LineType[LineType[\"None\"] = 0] = \"None\";\n    /**\n     * Specifies the type of `NewLineBreak`.\n     * @private\n     */\n\n    LineType[LineType[\"NewLineBreak\"] = 1] = \"NewLineBreak\";\n    /**\n     * Specifies the type of `LayoutBreak`.\n     * @private\n     */\n\n    LineType[LineType[\"LayoutBreak\"] = 2] = \"LayoutBreak\";\n    /**\n     * Specifies the type of `FirstParagraphLine`.\n     * @private\n     */\n\n    LineType[LineType[\"FirstParagraphLine\"] = 4] = \"FirstParagraphLine\";\n    /**\n     * Specifies the type of `LastParagraphLine`.\n     * @private\n     */\n\n    LineType[LineType[\"LastParagraphLine\"] = 8] = \"LastParagraphLine\";\n  })(LineType || (LineType = {}));\n\n  return LineType;\n})();\n\n/**\n * PdfFont.ts class for EJ2-PDF\n */\n\n/**\n * Defines a particular format for text, including font face, size, and style attributes.\n * @private\n */\nclass PdfFont {\n  constructor(size, style) {\n    /**\n     * `Style` of the font.\n     * @private\n     */\n    this.fontStyle = PdfFontStyle.Regular;\n\n    if (typeof size === 'number' && typeof style === 'undefined') {\n      this.fontSize = size;\n    } else {\n      this.fontSize = size;\n      this.setStyle(style);\n    }\n  } //Properties\n\n  /**\n   * Gets the face name of this Font.\n   * @private\n   */\n\n\n  get name() {\n    return this.metrics.name;\n  }\n  /**\n   * Gets the size of this font.\n   * @private\n   */\n\n\n  get size() {\n    return this.fontSize;\n  }\n  /**\n   * Gets the height of the font in points.\n   * @private\n   */\n\n\n  get height() {\n    return this.metrics.getHeight(null);\n  }\n  /**\n   * Gets the style information for this font.\n   * @private\n   */\n\n\n  get style() {\n    return this.fontStyle;\n  }\n\n  set style(value) {\n    this.fontStyle = value;\n  }\n  /**\n   * Gets a value indicating whether this `PdfFont` is `bold`.\n   * @private\n   */\n\n\n  get bold() {\n    return (this.style & PdfFontStyle.Bold) > 0;\n  }\n  /**\n   * Gets a value indicating whether this `PdfFont` has the `italic` style applied.\n   * @private\n   */\n\n\n  get italic() {\n    return (this.style & PdfFontStyle.Italic) > 0;\n  }\n  /**\n   * Gets a value indicating whether this `PdfFont` is `strikeout`.\n   * @private\n   */\n\n\n  get strikeout() {\n    return (this.style & PdfFontStyle.Strikeout) > 0;\n  }\n  /**\n   * Gets a value indicating whether this `PdfFont` is `underline`.\n   * @private\n   */\n\n\n  get underline() {\n    return (this.style & PdfFontStyle.Underline) > 0;\n  }\n  /**\n   * Gets or sets the `metrics` for this font.\n   * @private\n   */\n\n\n  get metrics() {\n    return this.fontMetrics;\n  }\n\n  set metrics(value) {\n    this.fontMetrics = value;\n  } // /**\n  //  * Gets and Sets the font `internals`.\n  //  * @private\n  //  */\n  // public get fontInternal() : IPdfPrimitive {\n  //     return this.pdfFontInternals;\n  // }\n  // public set fontInternal(value : IPdfPrimitive) {\n  //     this.pdfFontInternals = value;\n  // }\n  //IPdfWrapper Members\n\n  /**\n   * Gets the `element` representing the font.\n   * @private\n   */\n\n\n  get element() {\n    return this.pdfFontInternals;\n  }\n\n  measureString(text, arg2, arg3, arg4, arg5) {\n    if (typeof text === 'string' && typeof arg2 === 'undefined') {\n      return this.measureString(text, null);\n    } else if (typeof text === 'string' && (arg2 instanceof PdfStringFormat || arg2 == null) && typeof arg3 === 'undefined' && typeof arg4 === 'undefined') {\n      let temparg2 = arg2;\n      let charactersFitted = 0;\n      let linesFilled = 0;\n      return this.measureString(text, temparg2, charactersFitted, linesFilled);\n    } else if (typeof text === 'string' && (arg2 instanceof PdfStringFormat || arg2 == null) && typeof arg3 === 'number' && typeof arg4 === 'number') {\n      let temparg2 = arg2;\n      return this.measureString(text, 0, temparg2, arg3, arg4); // } else if (typeof text === 'string' && typeof arg2 === 'number' && typeof arg3 === 'undefined') {\n      //     return this.measureString(text, arg2, null);\n      // } else if (typeof text === 'string' && typeof arg2 === 'number' && (arg3 instanceof PdfStringFormat || arg3 == null) && typeof arg4 === 'undefined' && typeof arg5 === 'undefined') {\n      //     let temparg3 : PdfStringFormat = arg3 as PdfStringFormat;\n      //     let charactersFitted : number = 0;\n      //     let linesFilled : number = 0;\n      //     return this.measureString(text, arg2, temparg3, charactersFitted, linesFilled);\n    } else if (typeof text === 'string' && typeof arg2 === 'number' && (arg3 instanceof PdfStringFormat || arg3 == null) && typeof arg4 === 'number' && typeof arg5 === 'number') {\n      let layoutArea = new SizeF(arg2, 0);\n      let temparg3 = arg3;\n      return this.measureString(text, layoutArea, temparg3, arg4, arg5); // } else if (typeof text === 'string' && arg2 instanceof SizeF && typeof arg3 === 'undefined') {\n      //     return this.measureString(text, arg2, null);\n      // } else if (typeof text === 'string' && arg2 instanceof SizeF && (arg3 instanceof PdfStringFormat || arg3 == null) && typeof arg4 === 'undefined' && typeof arg5 === 'undefined') {\n      //     let temparg3 : PdfStringFormat = arg3 as PdfStringFormat;\n      //     let charactersFitted : number = 0;\n      //     let linesFilled : number = 0;\n      //     return this.measureString(text, arg2, temparg3, charactersFitted, linesFilled);\n    } else {\n      if (text == null) {\n        throw Error(`ArgumentNullException(\"text\")`);\n      }\n\n      let temparg2 = arg2;\n      let temparg3 = arg3;\n      let layouter = new PdfStringLayouter();\n      let result = layouter.layout(text, this, temparg3, temparg2, false, new SizeF(0, 0)); // arg4 = (result.Remainder == null) ? text.length : text.length - result.Remainder.length;\n\n      arg4 = text.length;\n      arg5 = result.empty ? 0 : result.lines.length;\n      return result.actualSize;\n    }\n  }\n  /* tslint:enable */\n  //IPdfCache Members\n\n  /**\n   * `Checks` whether the object is similar to another object.\n   * @private\n   */\n\n\n  equalsTo(obj) {\n    let result = this.equalsToFont(obj);\n    return result;\n  }\n  /**\n   * Returns `internals` of the object.\n   * @private\n   */\n\n\n  getInternals() {\n    return this.pdfFontInternals;\n  }\n  /**\n   * Sets `internals` to the object.\n   * @private\n   */\n\n\n  setInternals(internals) {\n    if (internals == null) {\n      throw new Error('ArgumentNullException:internals');\n    }\n\n    this.pdfFontInternals = internals;\n  }\n  /**\n   * Sets the `style` of the font.\n   * @private\n   */\n\n\n  setStyle(style) {\n    this.fontStyle = style;\n  }\n  /**\n   * Applies `settings` to the default line width.\n   * @private\n   */\n\n\n  applyFormatSettings(line, format, width) {\n    // if (line == null) {\n    //     throw new Error(`ArgumentNullException:line`);\n    // }\n    let realWidth = width;\n\n    if (format != null && width > 0) {\n      // Space among characters is not default.\n      if (format.characterSpacing !== 0) {\n        realWidth += (line.length - 1) * format.characterSpacing;\n      } // Space among words is not default.\n\n\n      if (format.wordSpacing !== 0) {\n        let symbols = StringTokenizer.spaces;\n        let whitespacesCount = StringTokenizer.getCharsCount(line, symbols);\n        realWidth += whitespacesCount * format.wordSpacing;\n      }\n    }\n\n    return realWidth;\n  }\n\n} //Constants\n\n/**\n * `Multiplier` of the symbol width.\n * @default 0.001\n * @private\n */\n\n\nPdfFont.charSizeMultiplier = 0.001;\n/**\n * `Synchronization` object.\n * @private\n */\n\nPdfFont.syncObject = new Object();\n/**\n * Used to `write a string` into output file.\n * @private\n */\n\nclass PdfWriter {\n  /**\n   * Initialize an instance of `PdfWriter` class.\n   * @private\n   */\n  constructor(stream) {\n    this.streamWriter = stream;\n  } //properties\n\n  /**\n   * Gets and Sets the `document`.\n   * @private\n   */\n\n\n  get document() {\n    return this.pdfDocument;\n  }\n\n  set document(value) {\n    this.pdfDocument = value;\n  }\n  /**\n   * Gets the `position`.\n   * @private\n   */\n\n\n  get position() {\n    return this.streamWriter.buffer.size;\n  }\n  /**\n   * Gets  the `length` of the stream'.\n   * @private\n   */\n\n\n  get length() {\n    return this.streamWriter.buffer.size;\n  }\n  /**\n   * Gets the `stream`.\n   * @private\n   */\n\n\n  get stream() {\n    let result = this.streamWriter;\n    return result;\n  } //public Methods\n\n  /**\n   * `Writes the specified data`.\n   * @private\n   */\n\n\n  write(overload) {\n    let tempOverload = overload;\n    this.streamWriter.write(tempOverload);\n  }\n\n}\n/**\n * public Enum for `CompositeFontType`.\n * @private\n */\n\n\nvar ObjectStatus = /*#__PURE__*/(() => {\n  (function (ObjectStatus) {\n    /**\n     * Specifies the type of `None`.\n     * @private\n     */\n    ObjectStatus[ObjectStatus[\"None\"] = 0] = \"None\";\n    /**\n     * Specifies the type of `Registered`.\n     * @private\n     */\n\n    ObjectStatus[ObjectStatus[\"Registered\"] = 1] = \"Registered\";\n  })(ObjectStatus || (ObjectStatus = {}));\n\n  return ObjectStatus;\n})();\n\n/**\n * PdfMainObjectCollection.ts class for EJ2-PDF\n */\n\n/**\n * The collection of all `objects` within a PDF document.\n * @private\n */\nclass PdfMainObjectCollection {\n  constructor() {\n    //Fields\n\n    /**\n     * The collection of the `indirect objects`.\n     * @default []\n     * @private\n     */\n    this.objectCollections = [];\n    /**\n     * The collection of the `Indirect objects`.\n     * @default new Dictionary<number, ObjectInfo>()\n     * @private\n     */\n\n    this.mainObjectCollection = new Dictionary();\n    /**\n     * The collection of `primitive objects`.\n     * @private\n     */\n\n    this.primitiveObjectCollection = new Dictionary();\n  } //Properties\n\n  /**\n   * Gets the `count`.\n   * @private\n   */\n\n\n  get count() {\n    return this.objectCollections.length;\n  }\n  /**\n   * Gets the value of `ObjectInfo` from object collection.\n   * @private\n   */\n\n\n  items(index) {\n    return this.objectCollections[index];\n  } //Methods\n\n  /**\n   * Specifies the value of `IsNew`.\n   * @private\n   */\n\n\n  get outIsNew() {\n    return this.isNew;\n  }\n  /**\n   * `Adds` the specified element.\n   * @private\n   */\n\n\n  add(element) {\n    let objInfo = new ObjectInfo(element);\n    this.objectCollections.push(objInfo);\n\n    if (!this.primitiveObjectCollection.containsKey(element)) {\n      this.primitiveObjectCollection.setValue(element, this.objectCollections.length - 1);\n    }\n\n    element.position = this.index = this.objectCollections.length - 1;\n    element.status = ObjectStatus.Registered;\n  }\n  /**\n   * `Looks` through the collection for the object specified.\n   * @private\n   */\n\n\n  lookFor(obj) {\n    let index = -1;\n\n    if (obj.position !== -1) {\n      return obj.position;\n    }\n\n    if (this.primitiveObjectCollection.containsKey(obj) && this.count === this.primitiveObjectCollection.size()) {\n      index = this.primitiveObjectCollection.getValue(obj);\n    } else {\n      for (let i = this.count - 1; i >= 0; i--) {\n        let oi = this.objectCollections[i];\n\n        if (oi.object === obj) {\n          index = i;\n          break;\n        }\n      }\n    }\n\n    return index;\n  }\n  /**\n   * Gets the `reference of the object`.\n   * @private\n   */\n\n\n  getReference(index, isNew) {\n    this.index = this.lookFor(index);\n    let reference;\n    this.isNew = false;\n    let oi = this.objectCollections[this.index];\n    reference = oi.reference;\n    let obj = {\n      reference: reference,\n      wasNew: isNew\n    };\n    return obj;\n  }\n  /**\n   * Tries to set the `reference to the object`.\n   * @private\n   */\n\n\n  trySetReference(obj, reference, found) {\n    let result = true;\n    found = true;\n    this.index = this.lookFor(obj);\n    let oi = this.objectCollections[this.index];\n    oi.setReference(reference);\n    return result;\n  }\n\n  destroy() {\n    for (let obj of this.objectCollections) {\n      if (obj !== undefined) {\n        obj.pdfObject.position = -1;\n        obj.pdfObject.isSaving = undefined;\n        obj.pdfObject.objectCollectionIndex = undefined;\n        obj.pdfObject.position = undefined;\n      }\n    }\n\n    this.objectCollections = [];\n    this.mainObjectCollection = new Dictionary();\n    this.primitiveObjectCollection = new Dictionary();\n  }\n\n}\n\nclass ObjectInfo {\n  constructor(obj, reference) {\n    this.pdfObject = obj;\n    this.pdfReference = reference;\n  } //Properties\n\n  /**\n   * Gets the `object`.\n   * @private\n   */\n\n\n  get object() {\n    return this.pdfObject;\n  }\n\n  set object(value) {\n    this.pdfObject = value;\n  }\n  /**\n   * Gets the `reference`.\n   * @private\n   */\n\n\n  get reference() {\n    return this.pdfReference;\n  }\n  /**\n   * Sets the `reference`.\n   * @private\n   */\n\n\n  setReference(reference) {\n    this.pdfReference = reference;\n  }\n\n}\n/**\n * `PdfDocumentBase` class represent common properties of PdfDocument classes.\n * @private\n */\n\n\nclass PdfDocumentBase {\n  constructor(document) {\n    /**\n     * If the stream is copied,  then it specifies true.\n     * @private\n     */\n    this.isStreamCopied = false;\n\n    if (document instanceof PdfDocument) {\n      this.document = document;\n    }\n  } //Prpperties\n\n  /**\n   * Gets the `PDF objects` collection, which stores all objects and references to it..\n   * @private\n   */\n\n\n  get pdfObjects() {\n    return this.objects;\n  }\n  /**\n   * Gets the `cross-reference` table.\n   * @private\n   */\n\n\n  get crossTable() {\n    return this.pdfCrossTable;\n  }\n  /**\n   * Gets or sets the current saving `object number`.\n   * @private\n   */\n\n\n  get currentSavingObj() {\n    return this.currentSavingObject;\n  }\n\n  set currentSavingObj(value) {\n    this.currentSavingObject = value;\n  }\n  /**\n   * Gets the PDF document `catalog`.\n   * @private\n   */\n\n\n  get catalog() {\n    return this.pdfCatalog;\n  }\n\n  set catalog(value) {\n    this.pdfCatalog = value;\n  } //Public methods\n\n  /**\n   * Sets the `main object collection`.\n   * @private\n   */\n\n\n  setMainObjectCollection(mainObjectCollection) {\n    this.objects = mainObjectCollection;\n  }\n  /**\n   * Sets the `cross table`.\n   * @private\n   */\n\n\n  setCrossTable(cTable) {\n    this.pdfCrossTable = cTable;\n  }\n  /**\n   * Sets the `catalog`.\n   * @private\n   */\n\n\n  setCatalog(catalog) {\n    this.pdfCatalog = catalog;\n  }\n\n  save(filename) {\n    let encoding = new Encoding(true);\n    let SW = new StreamWriter(encoding);\n\n    if (typeof filename === 'undefined') {\n      let encoding = new Encoding(true);\n      let SW = new StreamWriter(encoding);\n      return new Promise((resolve, reject) => {\n        /* tslint:disable-next-line:no-any */\n        let obj = {};\n        obj.blobData = new Blob([this.document.docSave(SW, true)], {\n          type: 'application/pdf'\n        });\n        resolve(obj);\n      });\n    } else {\n      this.document.docSave(SW, filename, true);\n    }\n  }\n  /**\n   * `Clone` of parent object - PdfDocument.\n   * @private\n   */\n\n\n  clone() {\n    return this.document;\n  }\n\n}\n/**\n * public Enum for `ObjectType`.\n * @private\n */\n\n\nvar ObjectType = /*#__PURE__*/(() => {\n  (function (ObjectType) {\n    /**\n     * Specifies the type of `Free`.\n     * @private\n     */\n    ObjectType[ObjectType[\"Free\"] = 0] = \"Free\";\n    /**\n     * Specifies the type of `Normal`.\n     * @private\n     */\n\n    ObjectType[ObjectType[\"Normal\"] = 1] = \"Normal\";\n    /**\n     * Specifies the type of `Packed`.\n     * @private\n     */\n\n    ObjectType[ObjectType[\"Packed\"] = 2] = \"Packed\";\n  })(ObjectType || (ObjectType = {}));\n\n  return ObjectType;\n})();\n\n/**\n * PdfCatalog.ts class for EJ2-PDF\n */\n\n/**\n * `PdfCatalog` class represents internal catalog of the Pdf document.\n * @private\n */\nclass PdfCatalog extends PdfDictionary {\n  //constructor\n\n  /**\n   * Initializes a new instance of the `PdfCatalog` class.\n   * @private\n   */\n  constructor() {\n    super(); //fields\n\n    /**\n     * Internal variable to store collection of `sections`.\n     * @default null\n     * @private\n     */\n\n    this.sections = null;\n    /**\n     * Internal variable for accessing fields from `DictionryProperties` class.\n     * @private\n     */\n\n    this.tempDictionaryProperties = new DictionaryProperties();\n    this.items.setValue(new DictionaryProperties().type, new PdfName('Catalog'));\n  } //Properties\n\n  /**\n   * Gets or sets the sections, which contain `pages`.\n   * @private\n   */\n\n\n  get pages() {\n    return this.sections;\n  }\n\n  set pages(value) {\n    let dictionary = value.element; // if (this.sections !== value) {\n    //     this.sections = value;\n    //     this.Items.setValue(this.tempDictionaryProperties.pages, new PdfReferenceHolder(value));\n    // }\n\n    this.sections = value;\n    this.items.setValue(this.tempDictionaryProperties.pages, new PdfReferenceHolder(value));\n  }\n\n}\n/**\n * `PdfCrossTable` is responsible for intermediate level parsing\n * and savingof a PDF document.\n * @private\n */\n\n\nclass PdfCrossTable {\n  constructor() {\n    /**\n     * The modified `objects` that should be saved.\n     * @private\n     */\n    this.objects = new Dictionary();\n    /**\n     * Holds `maximal generation number` or offset to object.\n     * @default 0\n     * @private\n     */\n\n    this.maxGenNumIndex = 0;\n    /**\n     * The `number of the objects`.\n     * @default 0\n     * @private\n     */\n\n    this.objectCount = 0;\n    /**\n     * Internal variable for accessing fields from `DictionryProperties` class.\n     * @default new PdfDictionaryProperties()\n     * @private\n     */\n\n    this.dictionaryProperties = new DictionaryProperties();\n  } //Properties\n\n  /**\n   * Gets or sets if the document `is merged`.\n   * @private\n   */\n\n\n  get isMerging() {\n    return this.merging;\n  }\n\n  set isMerging(value) {\n    this.merging = value;\n  }\n  /**\n   * Gets the `trailer`.\n   * @private\n   */\n\n\n  get trailer() {\n    if (this.internalTrailer == null) {\n      this.internalTrailer = new PdfStream();\n    }\n\n    return this.internalTrailer;\n  }\n  /**\n   * Gets or sets the main `PdfDocument` class instance.\n   * @private\n   */\n\n\n  get document() {\n    return this.pdfDocument;\n  }\n\n  set document(value) {\n    this.pdfDocument = value;\n    this.items = this.pdfDocument.pdfObjects;\n  }\n  /**\n   * Gets the catched `PDF object` main collection.\n   * @private\n   */\n\n\n  get pdfObjects() {\n    return this.items;\n  }\n  /**\n   * Gets the `object collection`.\n   * @private\n   */\n\n\n  get objectCollection() {\n    return this.pdfDocument.pdfObjects;\n  }\n  /**\n   * Gets or sets the `number of the objects` within the document.\n   * @private\n   */\n\n\n  get count() {\n    return this.objectCount;\n  }\n\n  set count(value) {\n    this.objectCount = value;\n  }\n  /**\n   * Returns `next available object number`.\n   * @private\n   */\n\n\n  get nextObjNumber() {\n    this.count = this.count + 1;\n    return this.count;\n  }\n\n  save(writer, filename) {\n    this.saveHead(writer);\n    this.mappedReferences = null;\n    this.objects.clear();\n    this.markTrailerReferences();\n    this.saveObjects(writer);\n    let saveCount = this.count;\n    let xrefPos = writer.position;\n    this.registerObject(0, new PdfReference(0, -1), true);\n    let prevXRef = 0;\n    writer.write(Operators.xref);\n    writer.write(Operators.newLine);\n    this.saveSections(writer);\n    this.saveTrailer(writer, this.count, prevXRef);\n    this.saveTheEndess(writer, xrefPos);\n    this.count = saveCount;\n\n    for (let i = 0; i < this.objectCollection.count; ++i) {\n      let oi = this.objectCollection.items(i);\n      oi.object.isSaving = false;\n    }\n\n    if (typeof filename === 'undefined') {\n      return writer.stream.buffer;\n    } else {\n      writer.stream.save(filename);\n    }\n  }\n  /**\n   * `Saves the endess` of the file.\n   * @private\n   */\n\n\n  saveTheEndess(writer, xrefPos) {\n    writer.write(Operators.newLine + Operators.startxref + Operators.newLine);\n    writer.write(xrefPos.toString() + Operators.newLine);\n    writer.write(Operators.eof + Operators.newLine);\n  }\n  /**\n   * `Saves the new trailer` dictionary.\n   * @private\n   */\n\n\n  saveTrailer(writer, count, prevXRef) {\n    writer.write(Operators.trailer + Operators.newLine); // Save the dictionary.\n\n    let trailer = this.trailer;\n    trailer.items.setValue(this.dictionaryProperties.size, new PdfNumber(this.objectCount + 1));\n    trailer = new PdfDictionary(trailer); // Make it real dictionary.\n\n    trailer.setEncrypt(false);\n    trailer.save(writer);\n  }\n  /**\n   * `Saves the xref section`.\n   * @private\n   */\n\n\n  saveSections(writer) {\n    let objectNum = 0;\n    let count = 0;\n\n    do {\n      count = this.prepareSubsection(objectNum);\n      this.saveSubsection(writer, objectNum, count);\n      objectNum += count;\n    } while (count !== 0);\n  }\n  /**\n   * `Saves a subsection`.\n   * @private\n   */\n\n\n  saveSubsection(writer, objectNum, count) {\n    if (count <= 0 || objectNum >= this.count) {\n      return;\n    }\n\n    writer.write(objectNum + ' ' + (count + 1) + Operators.newLine);\n\n    for (let i = objectNum; i <= objectNum + count; ++i) {\n      let obj = this.objects.getValue(i);\n      let str = '';\n\n      if (obj.type === ObjectType.Free) {\n        str = this.getItem(obj.offset, 65535, true);\n      } else {\n        str = this.getItem(obj.offset, obj.generation, false);\n      }\n\n      writer.write(str);\n    }\n  }\n  /**\n   * Generates string for `xref table item`.\n   * @private\n   */\n\n\n  getItem(offset, genNumber, isFree) {\n    let returnString = '';\n    let addOffsetLength = 10 - offset.toString().length;\n\n    if (genNumber <= 0) {\n      genNumber = 0;\n    }\n\n    let addGenNumberLength = 5 - genNumber.toString().length <= 0 ? 0 : 5 - genNumber.toString().length;\n\n    for (let index = 0; index < addOffsetLength; index++) {\n      returnString = returnString + '0';\n    }\n\n    returnString = returnString + offset.toString() + ' ';\n\n    for (let index = 0; index < addGenNumberLength; index++) {\n      returnString = returnString + '0';\n    }\n\n    returnString = returnString + genNumber.toString() + ' ';\n    returnString = returnString + (isFree ? Operators.f : Operators.n) + Operators.newLine;\n    return returnString;\n  }\n  /**\n   * `Prepares a subsection` of the current section within the cross-reference table.\n   * @private\n   */\n\n\n  prepareSubsection(objectNum) {\n    let count = 0;\n    let i;\n    let total = this.count;\n\n    for (let k = 0; k < this.document.pdfObjects.count; k++) {\n      let reference = this.document.pdfObjects.items(k).reference;\n      let refString = reference.toString();\n      let refArray = refString.split(' ');\n    }\n\n    if (objectNum >= total) {\n      return count;\n    } // search for first changed indirect object.\n\n\n    for (i = objectNum; i < total; ++i) {\n      break;\n    }\n\n    objectNum = i; // look up for all indirect objects in one subsection.\n\n    for (; i < total; ++i) {\n      ++count;\n    }\n\n    return count;\n  }\n  /**\n   * `Marks the trailer references` being saved.\n   * @private\n   */\n\n\n  markTrailerReferences() {\n    let keys = this.trailer.items.keys();\n    let values = this.trailer.items.values();\n  }\n  /**\n   * `Saves the head`.\n   * @private\n   */\n\n\n  saveHead(writer) {\n    let version = this.generateFileVersion(writer.document);\n    writer.write('%PDF-' + version);\n    writer.write(Operators.newLine);\n  }\n  /**\n   * Generates the `version` of the file.\n   * @private\n   */\n\n\n  generateFileVersion(document) {\n    let iVersion = 4;\n    let version = '1.' + iVersion.toString();\n    return version;\n  }\n\n  getReference(obj, bNew) {\n    if (typeof bNew === 'undefined') {\n      let wasNew = false;\n      return this.getReference(obj, wasNew);\n    } else {\n      //code splitted for reducing lines of code exceeds 100.\n      return this.getSubReference(obj, bNew);\n    }\n  }\n  /**\n   * Retrieves the `reference` of the object given.\n   * @private\n   */\n\n\n  getSubReference(obj, bNew) {\n    let isNew = false;\n    let wasNew;\n    let reference = null; // if (obj.IsSaving) {\n\n    if (this.items.count > 0 && obj.objectCollectionIndex > 0 && this.items.count > obj.objectCollectionIndex - 1) {\n      let tempObj = this.document.pdfObjects.getReference(obj, wasNew);\n      reference = tempObj.reference;\n      wasNew = tempObj.wasNew;\n    }\n\n    if (reference == null) {\n      if (obj.status === ObjectStatus.Registered) {\n        wasNew = false;\n      } else {\n        wasNew = true;\n      }\n    } else {\n      wasNew = false;\n    } // need to add mapped reference code\n\n\n    if (reference == null) {\n      let objnumber = this.nextObjNumber;\n      reference = new PdfReference(objnumber, 0);\n      let found;\n\n      if (wasNew) {\n        this.document.pdfObjects.add(obj);\n        this.document.pdfObjects.trySetReference(obj, reference, found);\n        let tempIndex = this.document.pdfObjects.count - 1;\n        let tempkey = this.document.pdfObjects.objectCollections[tempIndex].reference.objNumber;\n        let tempvalue = this.document.pdfObjects.objectCollections[this.document.pdfObjects.count - 1];\n        this.document.pdfObjects.mainObjectCollection.setValue(tempkey, tempvalue);\n        obj.position = -1;\n      } else {\n        this.document.pdfObjects.trySetReference(obj, reference, found);\n      }\n\n      obj.objectCollectionIndex = reference.objNumber;\n      obj.status = ObjectStatus.None;\n      isNew = true;\n    }\n\n    bNew = isNew || this.bForceNew;\n    return reference;\n  }\n  /**\n   * `Saves all objects` in the collection.\n   * @private\n   */\n\n\n  saveObjects(writer) {\n    let objectCollection = this.objectCollection;\n\n    for (let i = 0; i < objectCollection.count; ++i) {\n      let oi = objectCollection.items(i);\n      let obj = oi.object;\n      obj.isSaving = true;\n      this.saveIndirectObject(obj, writer);\n    }\n  }\n  /**\n   * `Saves indirect object`.\n   * @private\n   */\n\n\n  saveIndirectObject(obj, writer) {\n    let reference = this.getReference(obj);\n\n    if (obj instanceof PdfCatalog) {\n      this.trailer.items.setValue(this.dictionaryProperties.root, reference);\n    } // NOTE :  This is needed for correct string objects encryption.\n\n\n    this.pdfDocument.currentSavingObj = reference;\n    let tempArchive = false;\n    tempArchive = obj.getArchive();\n    this.registerObject(writer.position, reference);\n    this.doSaveObject(obj, reference, writer);\n  }\n  /**\n   * Performs `real saving` of the save object.\n   * @private\n   */\n\n\n  doSaveObject(obj, reference, writer) {\n    let correctPosition = writer.length;\n    writer.write(reference.objNumber.toString());\n    writer.write(Operators.whiteSpace);\n    writer.write(reference.genNumber.toString());\n    writer.write(Operators.whiteSpace);\n    writer.write(Operators.obj);\n    writer.write(Operators.newLine);\n    obj.save(writer);\n    let stream = writer.stream;\n    writer.write(Operators.endObj);\n    writer.write(Operators.newLine);\n  }\n\n  registerObject(offset, reference, free) {\n    if (typeof free === 'boolean') {\n      // Register the object by its number.\n      this.objects.setValue(reference.objNumber, new RegisteredObject(offset, reference, free));\n      this.maxGenNumIndex = Math.max(this.maxGenNumIndex, reference.genNumber);\n    } else if (typeof free === 'undefined') {\n      // Register the object by its number.\n      this.objects.setValue(reference.objNumber, new RegisteredObject(offset, reference));\n      this.maxGenNumIndex = Math.max(this.maxGenNumIndex, reference.genNumber);\n    }\n  }\n  /**\n   * `Dereferences` the specified primitive object.\n   * @private\n   */\n\n\n  static dereference(obj) {\n    let rh = obj;\n\n    if (rh != null) {\n      obj = rh.object;\n    }\n\n    return obj;\n  }\n\n}\n\nclass RegisteredObject {\n  //Properties\n\n  /**\n   * Gets the `object number`.\n   * @private\n   */\n  get objectNumber() {\n    return this.object;\n  }\n  /**\n   * Gets the `offset`.\n   * @private\n   */\n\n\n  get offset() {\n    let result;\n    result = this.offsetNumber;\n    return result;\n  }\n\n  constructor(offset, reference, free) {\n    let tempOffset = offset;\n    this.offsetNumber = tempOffset;\n    let tempReference = reference;\n    this.generation = tempReference.genNumber;\n    this.object = tempReference.objNumber;\n\n    if (typeof free === 'undefined') {\n      this.type = ObjectType.Normal;\n    } else {\n      this.type = ObjectType.Free;\n    }\n  }\n\n}\n/**\n * PdfPageSize.ts class for EJ2-PDF\n */\n\n/**\n * Represents information about various predefined `page sizes`.\n */\n\n\nclass PdfPageSize {\n  //constructor\n\n  /**\n   * Initialize an instance for `PdfPageSize` class.\n   * @private\n   */\n  constructor() {// \n  }\n\n}\n/**\n * Specifies the size of `letter`.\n * @private\n */\n\n\nPdfPageSize.letter = new SizeF(612, 792);\n/**\n * Specifies the size of `note`.\n * @private\n */\n\nPdfPageSize.note = new SizeF(540, 720);\n/**\n * Specifies the size of `legal`.\n * @private\n */\n\nPdfPageSize.legal = new SizeF(612, 1008);\n/**\n * Specifies the size of `a0`.\n * @private\n */\n\nPdfPageSize.a0 = new SizeF(2380, 3368);\n/**\n * Specifies the size of `a1`.\n * @private\n */\n\nPdfPageSize.a1 = new SizeF(1684, 2380);\n/**\n * Specifies the size of `a2`.\n * @private\n */\n\nPdfPageSize.a2 = new SizeF(1190, 1684);\n/**\n * Specifies the size of `a3`.\n * @private\n */\n\nPdfPageSize.a3 = new SizeF(842, 1190);\n/**\n * Specifies the size of `a4`.\n * @private\n */\n\nPdfPageSize.a4 = new SizeF(595, 842);\n/**\n * Specifies the size of `a5`.\n * @private\n */\n\nPdfPageSize.a5 = new SizeF(421, 595);\n/**\n * Specifies the size of `a6`.\n * @private\n */\n\nPdfPageSize.a6 = new SizeF(297, 421);\n/**\n * Specifies the size of `a7`.\n * @private\n */\n\nPdfPageSize.a7 = new SizeF(210, 297);\n/**\n * Specifies the size of `a8`.\n * @private\n */\n\nPdfPageSize.a8 = new SizeF(148, 210);\n/**\n * Specifies the size of `a9`.\n * @private\n */\n\nPdfPageSize.a9 = new SizeF(105, 148);\n/**\n * Specifies the size of `a10`.\n * @private\n */\n\nPdfPageSize.a10 = new SizeF(74, 105);\n/**\n * Specifies the size of `b0`.\n * @private\n */\n\nPdfPageSize.b0 = new SizeF(2836, 4008);\n/**\n * Specifies the size of `b1`.\n * @private\n */\n\nPdfPageSize.b1 = new SizeF(2004, 2836);\n/**\n * Specifies the size of `b2`.\n * @private\n */\n\nPdfPageSize.b2 = new SizeF(1418, 2004);\n/**\n * Specifies the size of `b3`.\n * @private\n */\n\nPdfPageSize.b3 = new SizeF(1002, 1418);\n/**\n * Specifies the size of `b4`.\n * @private\n */\n\nPdfPageSize.b4 = new SizeF(709, 1002);\n/**\n * Specifies the size of `b5`.\n * @private\n */\n\nPdfPageSize.b5 = new SizeF(501, 709);\n/**\n * Specifies the size of `archE`.\n * @private\n */\n\nPdfPageSize.archE = new SizeF(2592, 3456);\n/**\n * Specifies the size of `archD`.\n * @private\n */\n\nPdfPageSize.archD = new SizeF(1728, 2592);\n/**\n * Specifies the size of `archC`.\n * @private\n */\n\nPdfPageSize.archC = new SizeF(1296, 1728);\n/**\n * Specifies the size of `archB`.\n * @private\n */\n\nPdfPageSize.archB = new SizeF(864, 1296);\n/**\n * Specifies the size of `archA`.\n * @private\n */\n\nPdfPageSize.archA = new SizeF(648, 864);\n/**\n * Specifies the size of `flsa`.\n * @private\n */\n\nPdfPageSize.flsa = new SizeF(612, 936);\n/**\n * Specifies the size of `halfLetter`.\n * @private\n */\n\nPdfPageSize.halfLetter = new SizeF(396, 612);\n/**\n * Specifies the size of `letter11x17`.\n * @private\n */\n\nPdfPageSize.letter11x17 = new SizeF(792, 1224);\n/**\n * Specifies the size of `ledger`.\n * @private\n */\n\nPdfPageSize.ledger = new SizeF(1224, 792);\n/**\n * public Enum for `PdfPageOrientation`.\n * @private\n */\n\nvar PdfPageOrientation = /*#__PURE__*/(() => {\n  (function (PdfPageOrientation) {\n    /**\n     * Specifies the type of `Portrait`.\n     * @private\n     */\n    PdfPageOrientation[PdfPageOrientation[\"Portrait\"] = 0] = \"Portrait\";\n    /**\n     * Specifies the type of `Landscape`.\n     * @private\n     */\n\n    PdfPageOrientation[PdfPageOrientation[\"Landscape\"] = 1] = \"Landscape\";\n  })(PdfPageOrientation || (PdfPageOrientation = {}));\n\n  return PdfPageOrientation;\n})();\n\n/**\n * public Enum for `PdfPageRotateAngle`.\n * @private\n */\nvar PdfPageRotateAngle = /*#__PURE__*/(() => {\n  (function (PdfPageRotateAngle) {\n    /**\n     * Specifies the type of `RotateAngle0`.\n     * @private\n     */\n    PdfPageRotateAngle[PdfPageRotateAngle[\"RotateAngle0\"] = 0] = \"RotateAngle0\";\n    /**\n     * Specifies the type of `RotateAngle90`.\n     * @private\n     */\n\n    PdfPageRotateAngle[PdfPageRotateAngle[\"RotateAngle90\"] = 1] = \"RotateAngle90\";\n    /**\n     * Specifies the type of `RotateAngle180`.\n     * @private\n     */\n\n    PdfPageRotateAngle[PdfPageRotateAngle[\"RotateAngle180\"] = 2] = \"RotateAngle180\";\n    /**\n     * Specifies the type of `RotateAngle270`.\n     * @private\n     */\n\n    PdfPageRotateAngle[PdfPageRotateAngle[\"RotateAngle270\"] = 3] = \"RotateAngle270\";\n  })(PdfPageRotateAngle || (PdfPageRotateAngle = {}));\n\n  return PdfPageRotateAngle;\n})();\n\n/**\n * public Enum for `PdfNumberStyle`.\n * @private\n */\nvar PdfNumberStyle = /*#__PURE__*/(() => {\n  (function (PdfNumberStyle) {\n    /**\n     * Specifies the type of `None`.\n     * @private\n     */\n    PdfNumberStyle[PdfNumberStyle[\"None\"] = 0] = \"None\";\n    /**\n     * Specifies the type of `Numeric`.\n     * @private\n     */\n\n    PdfNumberStyle[PdfNumberStyle[\"Numeric\"] = 1] = \"Numeric\";\n    /**\n     * Specifies the type of `LowerLatin`.\n     * @private\n     */\n\n    PdfNumberStyle[PdfNumberStyle[\"LowerLatin\"] = 2] = \"LowerLatin\";\n    /**\n     * Specifies the type of `LowerRoman`.\n     * @private\n     */\n\n    PdfNumberStyle[PdfNumberStyle[\"LowerRoman\"] = 3] = \"LowerRoman\";\n    /**\n     * Specifies the type of `UpperLatin`.\n     * @private\n     */\n\n    PdfNumberStyle[PdfNumberStyle[\"UpperLatin\"] = 4] = \"UpperLatin\";\n    /**\n     * Specifies the type of `UpperRoman`.\n     * @private\n     */\n\n    PdfNumberStyle[PdfNumberStyle[\"UpperRoman\"] = 5] = \"UpperRoman\";\n  })(PdfNumberStyle || (PdfNumberStyle = {}));\n\n  return PdfNumberStyle;\n})();\n\n/**\n * public Enum for `PdfDockStyle`.\n * @private\n */\nvar PdfDockStyle = /*#__PURE__*/(() => {\n  (function (PdfDockStyle) {\n    /**\n     * Specifies the type of `None`.\n     * @private\n     */\n    PdfDockStyle[PdfDockStyle[\"None\"] = 0] = \"None\";\n    /**\n     * Specifies the type of `Bottom`.\n     * @private\n     */\n\n    PdfDockStyle[PdfDockStyle[\"Bottom\"] = 1] = \"Bottom\";\n    /**\n     * Specifies the type of `Top`.\n     * @private\n     */\n\n    PdfDockStyle[PdfDockStyle[\"Top\"] = 2] = \"Top\";\n    /**\n     * Specifies the type of `Left`.\n     * @private\n     */\n\n    PdfDockStyle[PdfDockStyle[\"Left\"] = 3] = \"Left\";\n    /**\n     * Specifies the type of `Right`.\n     * @private\n     */\n\n    PdfDockStyle[PdfDockStyle[\"Right\"] = 4] = \"Right\";\n    /**\n     * Specifies the type of `Fill`.\n     * @private\n     */\n\n    PdfDockStyle[PdfDockStyle[\"Fill\"] = 5] = \"Fill\";\n  })(PdfDockStyle || (PdfDockStyle = {}));\n\n  return PdfDockStyle;\n})();\n\n/**\n * public Enum for `PdfAlignmentStyle`.\n * @private\n */\nvar PdfAlignmentStyle = /*#__PURE__*/(() => {\n  (function (PdfAlignmentStyle) {\n    /**\n     * Specifies the type of `None`.\n     * @private\n     */\n    PdfAlignmentStyle[PdfAlignmentStyle[\"None\"] = 0] = \"None\";\n    /**\n     * Specifies the type of `TopLeft`.\n     * @private\n     */\n\n    PdfAlignmentStyle[PdfAlignmentStyle[\"TopLeft\"] = 1] = \"TopLeft\";\n    /**\n     * Specifies the type of `TopCenter`.\n     * @private\n     */\n\n    PdfAlignmentStyle[PdfAlignmentStyle[\"TopCenter\"] = 2] = \"TopCenter\";\n    /**\n     * Specifies the type of `TopRight`.\n     * @private\n     */\n\n    PdfAlignmentStyle[PdfAlignmentStyle[\"TopRight\"] = 3] = \"TopRight\";\n    /**\n     * Specifies the type of `MiddleLeft`.\n     * @private\n     */\n\n    PdfAlignmentStyle[PdfAlignmentStyle[\"MiddleLeft\"] = 4] = \"MiddleLeft\";\n    /**\n     * Specifies the type of `MiddleCenter`.\n     * @private\n     */\n\n    PdfAlignmentStyle[PdfAlignmentStyle[\"MiddleCenter\"] = 5] = \"MiddleCenter\";\n    /**\n     * Specifies the type of `MiddleRight`.\n     * @private\n     */\n\n    PdfAlignmentStyle[PdfAlignmentStyle[\"MiddleRight\"] = 6] = \"MiddleRight\";\n    /**\n     * Specifies the type of `BottomLeft`.\n     * @private\n     */\n\n    PdfAlignmentStyle[PdfAlignmentStyle[\"BottomLeft\"] = 7] = \"BottomLeft\";\n    /**\n     * Specifies the type of `BottomCenter`.\n     * @private\n     */\n\n    PdfAlignmentStyle[PdfAlignmentStyle[\"BottomCenter\"] = 8] = \"BottomCenter\";\n    /**\n     * Specifies the type of `BottomRight`.\n     * @private\n     */\n\n    PdfAlignmentStyle[PdfAlignmentStyle[\"BottomRight\"] = 9] = \"BottomRight\";\n  })(PdfAlignmentStyle || (PdfAlignmentStyle = {}));\n\n  return PdfAlignmentStyle;\n})();\n\n/**\n * public Enum for `TemplateType`.\n * @private\n */\nvar TemplateType = /*#__PURE__*/(() => {\n  (function (TemplateType) {\n    /**\n     * Specifies the type of `None`.\n     * @private\n     */\n    TemplateType[TemplateType[\"None\"] = 0] = \"None\";\n    /**\n     * Specifies the type of `Top`.\n     * @private\n     */\n\n    TemplateType[TemplateType[\"Top\"] = 1] = \"Top\";\n    /**\n     * Specifies the type of `Bottom`.\n     * @private\n     */\n\n    TemplateType[TemplateType[\"Bottom\"] = 2] = \"Bottom\";\n    /**\n     * Specifies the type of `Left`.\n     * @private\n     */\n\n    TemplateType[TemplateType[\"Left\"] = 3] = \"Left\";\n    /**\n     * Specifies the type of `Right`.\n     * @private\n     */\n\n    TemplateType[TemplateType[\"Right\"] = 4] = \"Right\";\n  })(TemplateType || (TemplateType = {}));\n\n  return TemplateType;\n})();\n\n/**\n * PdfMargins.ts class for EJ2-PDF\n * A class representing PDF page margins.\n */\nclass PdfMargins {\n  /**\n   * Initializes a new instance of the `PdfMargins` class.\n   * @private\n   */\n  constructor() {\n    /**\n     * Represents the `Default Page Margin` value.\n     * @default 0.0\n     * @private\n     */\n    this.pdfMargin = 40.0;\n    this.setMargins(this.pdfMargin);\n  } //Properties\n\n  /**\n   * Gets or sets the `left margin` size.\n   * @private\n   */\n\n\n  get left() {\n    return this.leftMargin;\n  }\n\n  set left(value) {\n    this.leftMargin = value;\n  }\n  /**\n   * Gets or sets the `top margin` size.\n   * @private\n   */\n\n\n  get top() {\n    return this.topMargin;\n  }\n\n  set top(value) {\n    this.topMargin = value;\n  }\n  /**\n   * Gets or sets the `right margin` size.\n   * @private\n   */\n\n\n  get right() {\n    return this.rightMargin;\n  }\n\n  set right(value) {\n    this.rightMargin = value;\n  }\n  /**\n   * Gets or sets the `bottom margin` size.\n   * @private\n   */\n\n\n  get bottom() {\n    return this.bottomMargin;\n  }\n\n  set bottom(value) {\n    this.bottomMargin = value;\n  }\n  /**\n   * Sets the `margins`.\n   * @private\n   */\n\n\n  set all(value) {\n    this.setMargins(value);\n  }\n\n  setMargins(margin1, margin2, margin3, margin4) {\n    if (typeof margin2 === 'undefined') {\n      this.leftMargin = this.topMargin = this.rightMargin = this.bottomMargin = margin1;\n    } else {\n      if (typeof margin3 === 'undefined') {\n        this.leftMargin = this.rightMargin = margin1;\n        this.bottomMargin = this.topMargin = margin2;\n      } else {\n        this.leftMargin = margin1;\n        this.topMargin = margin2;\n        this.rightMargin = margin3;\n        this.bottomMargin = margin4;\n      }\n    }\n  }\n  /**\n   * `Clones` the object.\n   * @private\n   */\n\n\n  clone() {\n    return this;\n  }\n\n}\n/**\n * PdfPageSettings.ts class for EJ2-PDF\n */\n\n/**\n * The class provides various `setting` related with PDF pages.\n */\n\n\nclass PdfPageSettings {\n  constructor(margins) {\n    //Fields\n\n    /**\n     * The page `margins`.\n     * @private\n     */\n    this.pageMargins = new PdfMargins();\n    /**\n     * The page `size`.\n     * @default a4\n     * @private\n     */\n\n    this.pageSize = PdfPageSize.a4;\n    /**\n     * The page `rotation angle`.\n     * @default PdfPageRotateAngle.RotateAngle0\n     * @private\n     */\n\n    this.rotateAngle = PdfPageRotateAngle.RotateAngle0;\n    /**\n     * The page `orientation`.\n     * @default PdfPageOrientation.Portrait\n     * @private\n     */\n\n    this.pageOrientation = PdfPageOrientation.Portrait;\n    /**\n     * The page `origin`.\n     * @default 0,0\n     * @private\n     */\n\n    this.pageOrigin = new PointF(0, 0);\n    /**\n     * Checks the Whether the `rotation` is applied or not.\n     * @default false\n     * @private\n     */\n\n    this.isRotation = false;\n\n    if (typeof margins === 'number') {\n      this.pageMargins.setMargins(margins);\n    }\n  } //Properties\n\n  /**\n   * Gets or sets the `size` of the page.\n   * @private\n   */\n\n\n  get size() {\n    return this.pageSize;\n  }\n\n  set size(value) {\n    this.setSize(value);\n  }\n  /**\n   * Gets or sets the page `orientation`.\n   * @private\n   */\n\n\n  get orientation() {\n    return this.pageOrientation;\n  }\n\n  set orientation(orientation) {\n    if (this.pageOrientation !== orientation) {\n      this.pageOrientation = orientation;\n      this.updateSize(orientation);\n    }\n  }\n  /**\n   * Gets or sets the `margins` of the page.\n   * @private\n   */\n\n\n  get margins() {\n    return this.pageMargins;\n  }\n\n  set margins(value) {\n    this.pageMargins = value;\n  }\n  /**\n   * Gets or sets the `width` of the page.\n   * @private\n   */\n\n\n  get width() {\n    return this.pageSize.width;\n  }\n\n  set width(value) {\n    this.pageSize.width = value;\n  }\n  /**\n   * Gets or sets the `height` of the page.\n   * @private\n   */\n\n\n  get height() {\n    return this.pageSize.height;\n  }\n\n  set height(value) {\n    this.pageSize.height = value;\n  }\n  /**\n   * Gets or sets the `origin` of the page.\n   * @private\n   */\n\n\n  get origin() {\n    return this.pageOrigin;\n  }\n\n  set origin(value) {\n    this.pageOrigin = value;\n  }\n  /**\n   * Gets or sets the number of degrees by which the page should be `rotated` clockwise when displayed or printed.\n   * @private\n   */\n\n\n  get rotate() {\n    return this.rotateAngle;\n  }\n\n  set rotate(value) {\n    this.rotateAngle = value;\n    this.isRotation = true;\n  } //Methods\n\n  /**\n   * `Update page size` depending on orientation.\n   * @private\n   */\n\n\n  updateSize(orientation) {\n    let min = Math.min(this.pageSize.width, this.pageSize.height);\n    let max = Math.max(this.pageSize.width, this.pageSize.height);\n\n    switch (orientation) {\n      case PdfPageOrientation.Portrait:\n        this.pageSize = new SizeF(min, max);\n        break;\n\n      case PdfPageOrientation.Landscape:\n        this.pageSize = new SizeF(max, min);\n        break;\n    }\n  }\n  /**\n   * Creates a `clone` of the object.\n   * @private\n   */\n\n\n  clone() {\n    let settings = this;\n    settings.pageMargins = this.pageMargins.clone(); // if (GetTransition() != null)\n    // {\n    //     settings.Transition = (PdfPageTransition)Transition.clone();\n    // }\n\n    return settings;\n  }\n  /**\n   * Returns `size`, shrinked by the margins.\n   * @private\n   */\n\n\n  getActualSize() {\n    let width = this.width - (this.margins.left + this.margins.right);\n    let height = this.height - (this.margins.top + this.margins.bottom);\n    let size = new SizeF(width, height);\n    return size;\n  }\n  /**\n   * Sets `size` to the page aaccording to the orientation.\n   * @private\n   */\n\n\n  setSize(size) {\n    let min = Math.min(size.width, size.height);\n    let max = Math.max(size.width, size.height);\n\n    if (this.orientation === PdfPageOrientation.Portrait) {\n      this.pageSize = new SizeF(min, max);\n    } else {\n      this.pageSize = new SizeF(max, min);\n    }\n  }\n\n}\n/**\n * Helper class to `write PDF graphic streams` easily.\n * @private\n */\n\n\nclass PdfStreamWriter {\n  /**\n   * Initialize an instance of `PdfStreamWriter` class.\n   * @private\n   */\n  constructor(stream) {\n    if (stream == null) {\n      throw new Error('ArgumentNullException:stream');\n    }\n\n    this.stream = stream;\n  } //Implementation\n\n  /**\n   * `Clear` the stream.\n   * @public\n   */\n\n\n  clear() {\n    this.stream.clearStream();\n  }\n\n  setGraphicsState(dictionaryName) {\n    if (dictionaryName instanceof PdfName) {\n      this.stream.write(dictionaryName.toString());\n      this.stream.write(Operators.whiteSpace);\n      this.writeOperator(Operators.setGraphicsState);\n    } else {\n      this.stream.write(Operators.slash);\n      this.stream.write(dictionaryName);\n      this.stream.write(Operators.whiteSpace);\n      this.writeOperator(Operators.setGraphicsState);\n    }\n  }\n  /**\n   * `Executes the XObject`.\n   * @private\n   */\n\n\n  executeObject(name) {\n    this.stream.write(name.toString());\n    this.stream.write(Operators.whiteSpace);\n    this.writeOperator(Operators.paintXObject);\n    this.stream.write(Operators.newLine);\n  }\n  /**\n   * `Closes path object`.\n   * @private\n   */\n\n\n  closePath() {\n    this.writeOperator(Operators.closePath);\n  }\n  /**\n   * `Clips the path`.\n   * @private\n   */\n\n\n  clipPath(useEvenOddRule) {\n    this.stream.write(Operators.clipPath);\n\n    if (useEvenOddRule) {\n      this.stream.write(Operators.evenOdd);\n    }\n\n    this.stream.write(Operators.whiteSpace);\n    this.stream.write(Operators.endPath);\n    this.stream.write(Operators.newLine);\n  }\n  /**\n   * `Closes, then fills and strokes the path`.\n   * @private\n   */\n\n\n  closeFillStrokePath(useEvenOddRule) {\n    this.stream.write(Operators.closeFillStrokePath);\n\n    if (useEvenOddRule) {\n      this.stream.write(Operators.evenOdd);\n      this.stream.write(Operators.newLine);\n    } else {\n      this.stream.write(Operators.newLine);\n    }\n  }\n  /**\n   * `Fills and strokes path`.\n   * @private\n   */\n\n\n  fillStrokePath(useEvenOddRule) {\n    this.stream.write(Operators.fillStroke);\n\n    if (useEvenOddRule) {\n      this.stream.write(Operators.evenOdd);\n      this.stream.write(Operators.newLine);\n    } else {\n      this.stream.write(Operators.newLine);\n    }\n  }\n  /**\n   * `Fills path`.\n   * @private\n   */\n\n\n  fillPath(useEvenOddRule) {\n    this.stream.write(Operators.fill);\n\n    if (useEvenOddRule) {\n      this.stream.write(Operators.evenOdd);\n      this.stream.write(Operators.newLine);\n    } else {\n      this.stream.write(Operators.newLine);\n    }\n  }\n  /**\n   * `Ends the path`.\n   * @private\n   */\n\n\n  endPath() {\n    this.writeOperator(Operators.n);\n  }\n  /**\n   * `Closes and fills the path`.\n   * @private\n   */\n\n\n  closeFillPath(useEvenOddRule) {\n    this.writeOperator(Operators.closePath);\n    this.stream.write(Operators.fill);\n\n    if (useEvenOddRule) {\n      this.stream.write(Operators.evenOdd);\n      this.stream.write(Operators.newLine);\n    } else {\n      this.stream.write(Operators.newLine);\n    }\n  }\n  /**\n   * `Closes and strokes the path`.\n   * @private\n   */\n\n\n  closeStrokePath() {\n    this.writeOperator(Operators.closeStrokePath);\n  }\n  /**\n   * `Sets the text scaling`.\n   * @private\n   */\n\n\n  setTextScaling(textScaling) {\n    this.stream.write(PdfNumber.floatToString(textScaling));\n    this.stream.write(Operators.whiteSpace);\n    this.writeOperator(Operators.setTextScaling);\n  }\n  /**\n   * `Strokes path`.\n   * @private\n   */\n\n\n  strokePath() {\n    this.writeOperator(Operators.stroke);\n  }\n  /**\n   * `Restores` the graphics state.\n   * @private\n   */\n\n\n  restoreGraphicsState() {\n    this.writeOperator(Operators.restoreState);\n  }\n  /**\n   * `Saves` the graphics state.\n   * @private\n   */\n\n\n  saveGraphicsState() {\n    this.writeOperator(Operators.saveState);\n  }\n\n  startNextLine(arg1, arg2) {\n    if (typeof arg1 === 'undefined') {\n      this.writeOperator(Operators.goToNextLine);\n    } else if (arg1 instanceof PointF) {\n      this.writePoint(arg1);\n      this.writeOperator(Operators.setCoords);\n    } else {\n      this.writePoint(arg1, arg2);\n      this.writeOperator(Operators.setCoords);\n    }\n  }\n  /**\n   * Shows the `text`.\n   * @private\n   */\n\n\n  showText(text) {\n    this.checkTextParam(text);\n    this.writeText(text);\n    this.writeOperator(Operators.setText);\n  }\n  /**\n   * Sets `text leading`.\n   * @private\n   */\n\n\n  setLeading(leading) {\n    this.stream.write(PdfNumber.floatToString(leading));\n    this.stream.write(Operators.whiteSpace);\n    this.writeOperator(Operators.setTextLeading);\n  }\n  /**\n   * `Begins the path`.\n   * @private\n   */\n\n\n  beginPath(x, y) {\n    this.writePoint(x, y);\n    this.writeOperator(Operators.beginPath);\n  }\n  /**\n   * `Begins text`.\n   * @private\n   */\n\n\n  beginText() {\n    this.writeOperator(Operators.beginText);\n  }\n  /**\n   * `Ends text`.\n   * @private\n   */\n\n\n  endText() {\n    this.writeOperator(Operators.endText);\n  }\n\n  appendRectangle(arg1, arg2, arg3, arg4) {\n    if (arg1 instanceof RectangleF) {\n      this.appendRectangle(arg1.x, arg1.y, arg1.width, arg1.height);\n    } else {\n      this.writePoint(arg1, arg2);\n      this.writePoint(arg3, arg4);\n      this.writeOperator(Operators.appendRectangle);\n    }\n  }\n\n  appendLineSegment(arg1, arg2) {\n    if (arg1 instanceof PointF) {\n      this.appendLineSegment(arg1.x, arg1.y);\n    } else {\n      this.writePoint(arg1, arg2);\n      this.writeOperator(Operators.appendLineSegment);\n    }\n  }\n  /**\n   * Sets the `text rendering mode`.\n   * @private\n   */\n\n\n  setTextRenderingMode(renderingMode) {\n    this.stream.write(renderingMode.toString());\n    this.stream.write(Operators.whiteSpace);\n    this.writeOperator(Operators.setRenderingMode);\n  }\n  /**\n   * Sets the `character spacing`.\n   * @private\n   */\n\n\n  setCharacterSpacing(charSpacing) {\n    this.stream.write(PdfNumber.floatToString(charSpacing));\n    this.stream.write(Operators.whiteSpace);\n    this.stream.write(Operators.setCharacterSpace);\n    this.stream.write(Operators.newLine);\n  }\n  /**\n   * Sets the `word spacing`.\n   * @private\n   */\n\n\n  setWordSpacing(wordSpacing) {\n    this.stream.write(PdfNumber.floatToString(wordSpacing));\n    this.stream.write(Operators.whiteSpace);\n    this.writeOperator(Operators.setWordSpace);\n  }\n\n  showNextLineText(arg1, arg2) {\n    if (arg1 instanceof PdfString) {\n      this.checkTextParam(arg1);\n      this.writeText(arg1);\n      this.writeOperator(Operators.setTextOnNewLine);\n    } else {\n      this.checkTextParam(arg1);\n      this.writeText(arg1, arg2);\n      this.writeOperator(Operators.setTextOnNewLine);\n    }\n  }\n\n  setColorSpace(arg1, arg2) {\n    if (arg1 instanceof PdfName && typeof arg2 === 'boolean') {\n      let temparg1 = arg1;\n      let temparg2 = arg2; // if (temparg1 == null) {\n      //     throw new Error('ArgumentNullException:name');\n      // }\n\n      let op = temparg2 ? Operators.selectcolorspaceforstroking : Operators.selectcolorspacefornonstroking;\n      this.stream.write(temparg1.toString());\n      this.stream.write(Operators.whiteSpace);\n      this.stream.write(op);\n      this.stream.write(Operators.newLine);\n    } else {\n      let temparg1 = arg1;\n      let temparg2 = arg2;\n      this.setColorSpace(new PdfName(temparg1), temparg2);\n    }\n  }\n  /**\n   * Modifies current `transformation matrix`.\n   * @private\n   */\n\n\n  modifyCtm(matrix) {\n    if (matrix == null) {\n      throw new Error('ArgumentNullException:matrix');\n    }\n\n    this.stream.write(matrix.toString());\n    this.stream.write(Operators.whiteSpace);\n    this.writeOperator(Operators.modifyCtm);\n  }\n\n  setFont(font, name, size) {\n    if (typeof name === 'string') {\n      this.setFont(font, new PdfName(name), size);\n    } else {\n      if (font == null) {\n        throw new Error('ArgumentNullException:font');\n      }\n\n      this.stream.write(name.toString());\n      this.stream.write(Operators.whiteSpace);\n      this.stream.write(PdfNumber.floatToString(size));\n      this.stream.write(Operators.whiteSpace);\n      this.writeOperator(Operators.setFont);\n    }\n  }\n  /**\n   * `Writes the operator`.\n   * @private\n   */\n\n\n  writeOperator(opcode) {\n    this.stream.write(opcode);\n    this.stream.write(Operators.newLine);\n  }\n\n  checkTextParam(text) {\n    if (text == null) {\n      throw new Error('ArgumentNullException:text');\n    }\n\n    if (typeof text === 'string' && text === '') {\n      throw new Error('ArgumentException:The text can not be an empty string, text');\n    }\n  }\n\n  writeText(arg1, arg2) {\n    if (arg1 instanceof PdfString && typeof arg2 === 'undefined') {\n      this.stream.write(arg1.pdfEncode());\n    } else {\n      let start;\n      let end;\n\n      if (arg2) {\n        start = PdfString.hexStringMark[0];\n        end = PdfString.hexStringMark[1];\n      } else {\n        start = PdfString.stringMark[0];\n        end = PdfString.stringMark[1];\n      }\n\n      this.stream.write(start);\n      this.stream.write(arg1);\n      this.stream.write(end);\n    }\n  }\n\n  writePoint(arg1, arg2) {\n    if (arg1 instanceof PointF && typeof arg2 === 'undefined') {\n      this.writePoint(arg1.x, arg1.y);\n    } else {\n      let temparg1 = arg1;\n      this.stream.write(PdfNumber.floatToString(temparg1));\n      this.stream.write(Operators.whiteSpace); // NOTE: Change Y co-ordinate because we shifted co-ordinate system only.\n\n      arg2 = this.updateY(arg2);\n      this.stream.write(PdfNumber.floatToString(arg2));\n      this.stream.write(Operators.whiteSpace);\n    }\n  }\n  /**\n   * `Updates y` co-ordinate.\n   * @private\n   */\n\n\n  updateY(arg) {\n    return -arg;\n  }\n  /**\n   * `Writes string` to the file.\n   * @private\n   */\n\n\n  write(string) {\n    let builder = '';\n    builder += string;\n    builder += Operators.newLine;\n    this.writeOperator(builder);\n  }\n  /**\n   * `Writes comment` to the file.\n   * @private\n   */\n\n\n  writeComment(comment) {\n    if (comment != null && comment.length > 0) {\n      let builder = '';\n      builder += Operators.comment;\n      builder += Operators.whiteSpace;\n      builder += comment; //builder.Append( Operators.NewLine );\n\n      this.writeOperator(builder);\n    } else {\n      throw new Error('Invalid comment');\n    }\n  }\n  /**\n   * Sets the `color and space`.\n   * @private\n   */\n\n\n  setColorAndSpace(color, colorSpace, forStroking) {\n    if (!color.isEmpty) {\n      // bool test = color is PdfExtendedColor;\n      this.stream.write(color.toString(colorSpace, forStroking));\n      this.stream.write(Operators.newLine);\n    }\n  } // public setLineDashPattern(pattern : number[], patternOffset : number) : void\n  // {\n  //     let pat : PdfArray = new PdfArray(pattern);\n  //     let off : PdfNumber = new PdfNumber(patternOffset);\n  //     this.setLineDashPatternHelper(pat, off);\n  // }\n  // private setLineDashPatternHelper(pattern : PdfArray, patternOffset : PdfNumber) : void\n  // {\n  //     pattern.Save(this);\n  //     this.m_stream.write(Operators.whiteSpace);\n  //     patternOffset.Save(this);\n  //     this.m_stream.write(Operators.whiteSpace);\n  //     this.writeOperator(Operators.setDashPattern);\n  // }\n\n  /**\n   * Sets the `line dash pattern`.\n   * @private\n   */\n\n\n  setLineDashPattern(pattern, patternOffset) {\n    // let pat : PdfArray = new PdfArray(pattern);\n    // let off : PdfNumber = new PdfNumber(patternOffset);\n    // this.setLineDashPatternHelper(pat, off);\n    this.setLineDashPatternHelper(pattern, patternOffset);\n  }\n  /**\n   * Sets the `line dash pattern`.\n   * @private\n   */\n\n\n  setLineDashPatternHelper(pattern, patternOffset) {\n    let tempPattern = '[';\n\n    if (pattern.length > 1) {\n      for (let index = 0; index < pattern.length; index++) {\n        if (index === pattern.length - 1) {\n          tempPattern += pattern[index].toString();\n        } else {\n          tempPattern += pattern[index].toString() + ' ';\n        }\n      }\n    }\n\n    tempPattern += '] ';\n    tempPattern += patternOffset.toString();\n    tempPattern += ' ' + Operators.setDashPattern;\n    this.stream.write(tempPattern);\n    this.stream.write(Operators.newLine);\n  }\n  /**\n   * Sets the `miter limit`.\n   * @private\n   */\n\n\n  setMiterLimit(miterLimit) {\n    this.stream.write(PdfNumber.floatToString(miterLimit));\n    this.stream.write(Operators.whiteSpace);\n    this.writeOperator(Operators.setMiterLimit);\n  }\n  /**\n   * Sets the `width of the line`.\n   * @private\n   */\n\n\n  setLineWidth(width) {\n    this.stream.write(PdfNumber.floatToString(width));\n    this.stream.write(Operators.whiteSpace);\n    this.writeOperator(Operators.setLineWidth);\n  }\n  /**\n   * Sets the `line cap`.\n   * @private\n   */\n\n\n  setLineCap(lineCapStyle) {\n    this.stream.write(lineCapStyle.toString());\n    this.stream.write(Operators.whiteSpace);\n    this.writeOperator(Operators.setLineCapStyle);\n  }\n  /**\n   * Sets the `line join`.\n   * @private\n   */\n\n\n  setLineJoin(lineJoinStyle) {\n    this.stream.write(lineJoinStyle.toString());\n    this.stream.write(Operators.whiteSpace);\n    this.writeOperator(Operators.setLineJoinStyle);\n  } //IPdfWriter members\n\n  /**\n   * Gets or sets the current `position` within the stream.\n   * @private\n   */\n\n\n  get position() {\n    return this.stream.position;\n  }\n  /**\n   * Gets `stream length`.\n   * @private\n   */\n\n\n  get length() {\n    let returnValue = 0;\n\n    if (this.stream.data.length !== 0 && this.stream.data.length !== -1) {\n      for (let index = 0; index < this.stream.data.length; index++) {\n        returnValue += this.stream.data[index].length;\n      }\n    }\n\n    return returnValue;\n  }\n  /**\n   * Gets and Sets the `current document`.\n   * @private\n   */\n\n\n  get document() {\n    return null;\n  }\n  /* tslint:disable-next-line:max-line-length */\n\n\n  appendBezierSegment(arg1, arg2, arg3, arg4, arg5, arg6) {\n    if (arg1 instanceof PointF && arg2 instanceof PointF && arg3 instanceof PointF) {\n      this.writePoint(arg1.x, arg1.y);\n      this.writePoint(arg2.x, arg2.y);\n      this.writePoint(arg3.x, arg3.y);\n    } else {\n      this.writePoint(arg1, arg2);\n      this.writePoint(arg3, arg4);\n      this.writePoint(arg5, arg6);\n    }\n\n    this.writeOperator(Operators.appendbeziercurve);\n  }\n\n  setColourWithPattern(colours, patternName, forStroking) {\n    if (colours != null) {\n      let count = colours.length;\n      let i = 0;\n\n      for (i = 0; i < count; ++i) {\n        this.stream.write(colours[i].toString());\n        this.stream.write(Operators.whiteSpace);\n      }\n    }\n\n    if (patternName != null) {\n      this.stream.write(patternName.toString());\n      this.stream.write(Operators.whiteSpace);\n    }\n\n    if (forStroking) {\n      this.writeOperator(Operators.setColorAndPatternStroking);\n    } else {\n      this.writeOperator(Operators.setColorAndPattern);\n    }\n  }\n\n}\n/**\n * PdfPen.ts class for EJ2-PDF\n */\n\n/**\n * `PdfPen` class defining settings for drawing operations, that determines the color,\n * width, and style of the drawing elements.\n * ```typescript\n * // create a new PDF document\n * let document : PdfDocument = new PdfDocument();\n * // create a new page\n * let page1 : PdfPage = document.pages.add();\n * // set pen\n * let pen : PdfPen = new PdfPen(new PdfColor(0, 0, 0));\n * // draw rectangle\n * page1.graphics.drawRectangle(pen, new RectangleF({x : 0, y : 0}, {width : 100, height : 50}));\n * // save the document.\n * document.save('output.pdf');\n * // destroy the document\n * document.destroy();\n * ```\n */\n\n\nclass PdfPen {\n  constructor(arg1, arg2) {\n    //Fields\n\n    /**\n     * Specifies the `color of the pen`.\n     * @default new PdfColor()\n     * @private\n     */\n    this.pdfColor = new PdfColor(0, 0, 0);\n    /**\n     * Specifies the `dash offset of the pen`.\n     * @default 0\n     * @private\n     */\n\n    this.dashOffsetValue = 0;\n    /**\n     * Specifies the `dash pattern of the pen`.\n     * @default [0]\n     * @private\n     */\n\n    this.penDashPattern = [0];\n    /**\n     * Specifies the `dash style of the pen`.\n     * @default Solid\n     * @private\n     */\n\n    this.pdfDashStyle = PdfDashStyle.Solid;\n    /**\n     * Specifies the `line cap of the pen`.\n     * @default 0\n     * @private\n     */\n\n    this.pdfLineCap = 0;\n    /**\n     * Specifies the `line join of the pen`.\n     * @default 0\n     * @private\n     */\n\n    this.pdfLineJoin = 0;\n    /**\n     * Specifies the `width of the pen`.\n     * @default 1.0\n     * @private\n     */\n\n    this.penWidth = 1.0;\n    /**\n     * Specifies the `mitter limit of the pen`.\n     * @default 0.0\n     * @private\n     */\n\n    this.internalMiterLimit = 0.0;\n    /**\n     * Stores the `colorspace` value.\n     * @default Rgb\n     * @private\n     */\n\n    this.colorSpace = PdfColorSpace.Rgb;\n\n    if (arg1 instanceof PdfBrush) {\n      this.setBrush(arg1);\n    } else if (arg1 instanceof PdfColor) {\n      this.color = arg1;\n    }\n\n    if (typeof arg2 === 'number') {\n      this.width = arg2;\n    }\n  } //Properties\n\n  /**\n   * Gets or sets the `color of the pen`.\n   * @private\n   */\n\n\n  get color() {\n    return this.pdfColor;\n  }\n\n  set color(value) {\n    this.pdfColor = value;\n  }\n  /**\n   * Gets or sets the `dash offset of the pen`.\n   * @private\n   */\n\n\n  get dashOffset() {\n    if (typeof this.dashOffsetValue === 'undefined' || this.dashOffsetValue == null) {\n      return 0;\n    } else {\n      return this.dashOffsetValue;\n    }\n  }\n\n  set dashOffset(value) {\n    this.dashOffsetValue = value;\n  }\n  /**\n   * Gets or sets the `dash pattern of the pen`.\n   * @private\n   */\n\n\n  get dashPattern() {\n    return this.penDashPattern;\n  }\n\n  set dashPattern(value) {\n    this.penDashPattern = value;\n  }\n  /**\n   * Gets or sets the `dash style of the pen`.\n   * ```typescript\n   * // create a new PDF document\n   * let document : PdfDocument = new PdfDocument();\n   * // create a new page\n   * let page1 : PdfPage = document.pages.add();\n   * // set pen\n   * let pen : PdfPen = new PdfPen(new PdfColor(0, 0, 0));\n   * //\n   * // set pen style\n   * pen.dashStyle = PdfDashStyle.DashDot;\n   * // get pen style\n   * let style : PdfDashStyle = pen.dashStyle;\n   * //\n   * // draw rectangle\n   * page1.graphics.drawRectangle(pen, new RectangleF({x : 0, y : 0}, {width : 100, height : 50}));\n   * // save the document.\n   * document.save('output.pdf');\n   * // destroy the document\n   * document.destroy();\n   * ```\n   */\n\n\n  get dashStyle() {\n    return this.pdfDashStyle;\n  }\n\n  set dashStyle(value) {\n    if (this.pdfDashStyle !== value) {\n      this.pdfDashStyle = value;\n\n      switch (this.pdfDashStyle) {\n        case PdfDashStyle.Custom:\n          break;\n\n        case PdfDashStyle.Dash:\n          this.penDashPattern = [3, 1];\n          break;\n\n        case PdfDashStyle.Dot:\n          this.penDashPattern = [1, 1];\n          break;\n\n        case PdfDashStyle.DashDot:\n          this.penDashPattern = [3, 1, 1, 1];\n          break;\n\n        case PdfDashStyle.DashDotDot:\n          this.penDashPattern = [3, 1, 1, 1, 1, 1];\n          break;\n\n        case PdfDashStyle.Solid:\n          break;\n\n        default:\n          this.pdfDashStyle = PdfDashStyle.Solid;\n          this.penDashPattern = [0];\n          break;\n      }\n    }\n  }\n  /**\n   * Gets or sets the `line cap of the pen`.\n   * @private\n   */\n\n\n  get lineCap() {\n    return this.pdfLineCap;\n  }\n\n  set lineCap(value) {\n    this.pdfLineCap = value;\n  }\n  /**\n   * Gets or sets the `line join style of the pen`.\n   * @private\n   */\n\n\n  get lineJoin() {\n    return this.pdfLineJoin;\n  }\n\n  set lineJoin(value) {\n    this.pdfLineJoin = value;\n  }\n  /**\n   * Gets or sets the `miter limit`.\n   * @private\n   */\n\n\n  get miterLimit() {\n    return this.internalMiterLimit;\n  }\n\n  set miterLimit(value) {\n    this.internalMiterLimit = value;\n  }\n  /**\n   * Gets or sets the `width of the pen`.\n   * ```typescript\n   * // create a new PDF document\n   * let document : PdfDocument = new PdfDocument();\n   * // create a new page\n   * let page1 : PdfPage = document.pages.add();\n   * // set pen\n   * let pen : PdfPen = new PdfPen(new PdfColor(0, 0, 0));\n   * //\n   * // set pen width\n   * pen.width = 2;\n   * //\n   * // draw rectangle\n   * page1.graphics.drawRectangle(pen, new RectangleF({x : 0, y : 0}, {width : 100, height : 50}));\n   * // save the document.\n   * document.save('output.pdf');\n   * // destroy the document\n   * document.destroy();\n   * ```\n   */\n\n\n  get width() {\n    return this.penWidth;\n  }\n\n  set width(value) {\n    this.penWidth = value;\n  } //Helper\n\n  /**\n   * `Clones` this instance of PdfPen class.\n   * @private\n   */\n\n\n  clone() {\n    let pen = this;\n    return pen;\n  }\n  /**\n   * `Sets the brush`.\n   * @private\n   */\n\n\n  setBrush(brush) {\n    let sBrush = brush;\n\n    if (sBrush != null && sBrush instanceof PdfSolidBrush) {\n      this.color = sBrush.color;\n      this.pdfBrush = sBrush;\n    }\n\n    this.color = sBrush.color;\n    this.pdfBrush = sBrush;\n  }\n  /**\n   * `Monitors the changes`.\n   * @private\n   */\n\n\n  monitorChanges(currentPen, streamWriter, getResources, saveState, currentColorSpace, matrix) {\n    let diff = false;\n    saveState = true;\n\n    if (currentPen == null) {\n      diff = true;\n    }\n\n    diff = this.dashControl(currentPen, saveState, streamWriter);\n    streamWriter.setLineWidth(this.width);\n    streamWriter.setLineJoin(this.lineJoin);\n    streamWriter.setLineCap(this.lineCap);\n    let miterLimit = this.miterLimit;\n\n    if (miterLimit > 0) {\n      streamWriter.setMiterLimit(miterLimit);\n      diff = true;\n    }\n\n    let brush = this.pdfBrush;\n    streamWriter.setColorAndSpace(this.color, currentColorSpace, true);\n    diff = true;\n    return diff;\n  }\n  /**\n   * `Controls the dash style` and behaviour of each line.\n   * @private\n   */\n\n\n  dashControl(pen, saveState, streamWriter) {\n    saveState = true;\n    let lineWidth = this.width;\n    let pattern = this.getPattern();\n    streamWriter.setLineDashPattern(pattern, this.dashOffset * lineWidth);\n    return saveState;\n  }\n  /**\n   * `Gets the pattern` of PdfPen.\n   * @private\n   */\n\n\n  getPattern() {\n    let pattern = this.dashPattern;\n\n    for (let i = 0; i < pattern.length; ++i) {\n      pattern[i] *= this.width;\n    }\n\n    return pattern;\n  }\n\n}\n/**\n * PdfTransformationMatrix.ts class for EJ2-PDF\n */\n\n/**\n * Class for representing Root `transformation matrix`.\n */\n\n\nclass PdfTransformationMatrix {\n  constructor(value) {\n    /**\n     * Value for `angle converting`.\n     * @default 180.0 / Math.PI\n     * @private\n     */\n    this.radDegFactor = 180.0 / Math.PI;\n\n    if (typeof value === 'undefined') {\n      this.transformationMatrix = new Matrix(1.00, 0.00, 0.00, 1.00, 0.00, 0.00);\n    } else {\n      this.transformationMatrix = new Matrix(1.00, 0.00, 0.00, -1.00, 0.00, 0.00);\n    }\n  } // Properties\n\n  /**\n   * Gets or sets the `internal matrix object`.\n   * @private\n   */\n\n\n  get matrix() {\n    return this.transformationMatrix;\n  }\n\n  set matrix(value) {\n    this.transformationMatrix = value;\n  } // Public methods\n\n  /**\n   * `Translates` coordinates by specified coordinates.\n   * @private\n   */\n\n\n  translate(offsetX, offsetY) {\n    this.transformationMatrix.translate(offsetX, offsetY);\n  }\n  /**\n   * `Scales` coordinates by specified coordinates.\n   * @private\n   */\n\n\n  scale(scaleX, scaleY) {\n    this.transformationMatrix.elements[0] = scaleX;\n    this.transformationMatrix.elements[3] = scaleY;\n  }\n  /**\n   * `Rotates` coordinate system in counterclockwise direction.\n   * @private\n   */\n\n\n  rotate(angle) {\n    //Convert from degree to radian \n    angle = angle * Math.PI / 180; //Rotation \n\n    this.transformationMatrix.elements[0] = Math.cos(angle);\n    this.transformationMatrix.elements[1] = Math.sin(angle);\n    this.transformationMatrix.elements[2] = -Math.sin(angle);\n    this.transformationMatrix.elements[3] = Math.cos(angle);\n  } // Overrides\n\n  /**\n   * Gets `PDF representation`.\n   * @private\n   */\n\n\n  toString() {\n    let builder = '';\n    let whitespace = ' ';\n\n    for (let i = 0, len = this.transformationMatrix.elements.length; i < len; i++) {\n      let temp = this.matrix.elements[i];\n      builder += PdfNumber.floatToString(this.transformationMatrix.elements[i]);\n      builder += whitespace;\n    }\n\n    return builder;\n  } // Implementation\n\n  /**\n   * `Multiplies` matrices (changes coordinate system.)\n   * @private\n   */\n\n\n  multiply(matrix) {\n    this.transformationMatrix.multiply(matrix.matrix);\n  }\n  /**\n   * Converts `degrees to radians`.\n   * @private\n   */\n\n\n  static degreesToRadians(degreesX) {\n    return this.degRadFactor * degreesX;\n  }\n  /**\n   * Converts `radians to degrees`.\n   * @private\n   */\n\n\n  radiansToDegrees(radians) {\n    return this.radDegFactor * radians;\n  }\n  /**\n   * `Clones` this instance of PdfTransformationMatrix.\n   * @private\n   */\n\n\n  clone() {\n    return this;\n  }\n\n} // Constants\n\n/**\n * Value for `angle converting`.\n * @default Math.PI / 180.0\n * @private\n */\n\n\nPdfTransformationMatrix.degRadFactor = Math.PI / 180.0;\n\nclass Matrix {\n  constructor(arg1, arg2, arg3, arg4, arg5, arg6) {\n    if (typeof arg1 === 'undefined') {\n      this.metrixElements = [];\n    } else if (typeof arg1 === 'number') {\n      this.metrixElements = [];\n      this.metrixElements.push(arg1);\n      this.metrixElements.push(arg2);\n      this.metrixElements.push(arg3);\n      this.metrixElements.push(arg4);\n      this.metrixElements.push(arg5);\n      this.metrixElements.push(arg6);\n    } else {\n      this.metrixElements = arg1;\n    }\n  } // Properties\n\n  /**\n   * Gets the `elements`.\n   * @private\n   */\n\n\n  get elements() {\n    return this.metrixElements;\n  }\n  /**\n   * Gets the off set `X`.\n   * @private\n   */\n\n\n  get offsetX() {\n    return this.metrixElements[4];\n  }\n  /**\n   * Gets the off set `Y`.\n   * @private\n   */\n\n\n  get offsetY() {\n    return this.metrixElements[5];\n  } // Implementation\n\n  /**\n   * `Translates` coordinates by specified coordinates.\n   * @private\n   */\n\n\n  translate(offsetX, offsetY) {\n    this.metrixElements[4] = offsetX;\n    this.metrixElements[5] = offsetY;\n  }\n  /**\n   * `Translates` the specified offset X.\n   * @private\n   */\n\n\n  transform(point) {\n    let x = point.x;\n    let y = point.y;\n    let x2 = x * this.elements[0] + y * this.elements[2] + this.offsetX;\n    let y2 = x * this.elements[1] + y * this.elements[3] + this.offsetY;\n    return new PointF(x2, y2);\n  }\n  /**\n   * `Multiplies matrices` (changes coordinate system.)\n   * @private\n   */\n\n\n  multiply(matrix) {\n    let tempMatrix = [];\n    tempMatrix.push(this.elements[0] * matrix.elements[0] + this.elements[1] * matrix.elements[2]);\n    tempMatrix[1] = this.elements[0] * matrix.elements[1] + this.elements[1] * matrix.elements[3];\n    tempMatrix[2] = this.elements[2] * matrix.elements[0] + this.elements[3] * matrix.elements[2];\n    tempMatrix[3] = this.elements[2] * matrix.elements[1] + this.elements[3] * matrix.elements[3];\n    tempMatrix[4] = this.offsetX * matrix.elements[0] + this.offsetY * matrix.elements[2] + matrix.offsetX;\n    tempMatrix[5] = this.offsetX * matrix.elements[1] + this.offsetY * matrix.elements[3] + matrix.offsetY;\n\n    for (let i = 0; i < tempMatrix.length; i++) {\n      this.elements[i] = tempMatrix[i];\n    }\n  } // IDisposable Members\n\n  /**\n   * `Dispose` this instance of PdfTransformationMatrix class.\n   * @private\n   */\n\n\n  dispose() {\n    this.metrixElements = null;\n  } // ICloneable Members\n\n  /**\n   * `Clones` this instance of PdfTransformationMatrix class.\n   * @private\n   */\n\n\n  clone() {\n    let m = new Matrix(this.metrixElements);\n    return m;\n  }\n\n}\n/**\n * `constants.ts` class for EJ2-PDF\n * @private\n */\n\n\nclass ProcedureSets {\n  constructor() {\n    /**\n     * Specifies the `PDF` procedure set.\n     * @private\n     */\n    this.pdf = 'PDF';\n    /**\n     * Specifies the `Text` procedure set.\n     * @private\n     */\n\n    this.text = 'Text';\n    /**\n     * Specifies the `ImageB` procedure set.\n     * @private\n     */\n\n    this.imageB = 'ImageB';\n    /**\n     * Specifies the `ImageC` procedure set.\n     * @private\n     */\n\n    this.imageC = 'ImageC';\n    /**\n     * Specifies the `ImageI` procedure set.\n     * @private\n     */\n\n    this.imageI = 'ImageI';\n  }\n\n}\n/**\n * Dictionary class\n * @private\n * @hidden\n */\n\n\nclass TemporaryDictionary {\n  constructor() {\n    /**\n     * @hidden\n     * @private\n     */\n    this.mKeys = [];\n    /**\n     * @hidden\n     * @private\n     */\n\n    this.mValues = [];\n  }\n  /**\n   * @hidden\n   * @private\n   */\n\n\n  size() {\n    return this.mKeys.length;\n  }\n  /**\n   * @hidden\n   * @private\n   */\n\n\n  add(key, value) {\n    if (key === undefined || key === null || value === undefined || value === null) {\n      throw new ReferenceError('Provided key or value is not valid.');\n    }\n\n    let index = this.mKeys.indexOf(key);\n\n    if (index < 0) {\n      this.mKeys.push(key);\n      this.mValues.push(value);\n      return 1;\n    } else {\n      throw new RangeError('An item with the same key has already been added.');\n    }\n  }\n  /**\n   * @hidden\n   * @private\n   */\n\n\n  keys() {\n    return this.mKeys;\n  }\n  /**\n   * @hidden\n   * @private\n   */\n\n\n  values() {\n    return this.mValues;\n  }\n  /**\n   * @hidden\n   * @private\n   */\n\n\n  getValue(key) {\n    if (key === undefined || key === null) {\n      throw new ReferenceError('Provided key is not valid.');\n    }\n\n    let index = this.mKeys.indexOf(key);\n\n    if (index < 0) {\n      throw new RangeError('No item with the specified key has been added.');\n    } else {\n      return this.mValues[index];\n    }\n  }\n  /**\n   * @hidden\n   * @private\n   */\n\n\n  setValue(key, value) {\n    if (key === undefined || key === null) {\n      throw new ReferenceError('Provided key is not valid.');\n    }\n\n    let index = this.mKeys.indexOf(key);\n\n    if (index < 0) {\n      this.mKeys.push(key);\n      this.mValues.push(value);\n    } else {\n      this.mValues[index] = value;\n    }\n  }\n  /**\n   * @hidden\n   * @private\n   */\n\n\n  remove(key) {\n    if (key === undefined || key === null) {\n      throw new ReferenceError('Provided key is not valid.');\n    }\n\n    let index = this.mKeys.indexOf(key);\n\n    if (index < 0) {\n      throw new RangeError('No item with the specified key has been added.');\n    } else {\n      this.mKeys.splice(index, 1);\n      this.mValues.splice(index, 1);\n      return true;\n    }\n  }\n  /**\n   * @hidden\n   * @private\n   */\n\n\n  containsKey(key) {\n    if (key === undefined || key === null) {\n      throw new ReferenceError('Provided key is not valid.');\n    }\n\n    let index = this.mKeys.indexOf(key);\n\n    if (index < 0) {\n      return false;\n    }\n\n    return true;\n  }\n  /**\n   * @hidden\n   * @private\n   */\n\n\n  clear() {\n    this.mKeys = [];\n    this.mValues = [];\n  }\n\n}\n/**\n * Represents a simple `transparency`.\n * @private\n */\n\n\nclass PdfTransparency {\n  // Properties\n  // /**\n  //  * Gets the `stroke` operation alpha value.\n  //  * @private\n  //  */\n  // public get stroke() : number {\n  //     let result : number = this.getNumber(this.dictionaryProperties.CA);\n  //     return result;\n  // }\n  // /**\n  //  * Gets the `fill` operation alpha value.\n  //  * @private\n  //  */\n  // public get fill() : number {\n  //     let result : number = this.getNumber(this.dictionaryProperties.ca);\n  //     return result;\n  // }\n  // /**\n  //  * Gets the `blend mode`.\n  //  * @private\n  //  */\n  // public get mode() : PdfBlendMode {\n  //     let result : string = this.getName(this.dictionaryProperties.ca);\n  //     return PdfBlendMode.Normal;\n  // }\n  // Constructors\n\n  /**\n   * Initializes a new instance of the `Transparency` class.\n   * @private\n   */\n  constructor(stroke, fill, mode) {\n    // Fields\n\n    /**\n     * Internal variable to store `dictionary`.\n     * @default new PdfDictionary()\n     * @private\n     */\n    this.dictionary = new PdfDictionary();\n    /**\n     * Internal variable for accessing fields from `DictionryProperties` class.\n     * @default new DictionaryProperties()\n     * @private\n     */\n\n    this.dictionaryProperties = new DictionaryProperties();\n    this.dictionary.items.setValue(this.dictionaryProperties.CA, new PdfNumber(stroke));\n    this.dictionary.items.setValue(this.dictionaryProperties.ca, new PdfNumber(fill));\n    this.dictionary.items.setValue(this.dictionaryProperties.BM, new PdfName(mode.toString()));\n  } // // Implementation\n  // /**\n  //  * Gets the `number value`.\n  //  * @private\n  //  */\n  // private getNumber(keyName : string) : number {\n  //     let result : number = 0.0;\n  //     let numb : PdfNumber = this.dictionary.items.getValue(keyName) as PdfNumber;\n  //     result = numb.intValue;\n  //     return result;\n  // }\n  // /**\n  //  * Gets the `name value`.\n  //  * @private\n  //  */\n  // private getName(keyName : string) : string {\n  //     let result : string = null;\n  //     let name : PdfName = this.dictionary.items.getValue(keyName) as PdfName;\n  //     result = name.value;\n  //     return result;\n  // }\n  // IPdfWrapper Members\n\n  /**\n   * Gets the `element`.\n   * @private\n   */\n\n\n  get element() {\n    return this.dictionary;\n  }\n\n}\n/**\n * Represent a `collection of automatic fields information`.\n * @private\n */\n\n\nclass PdfAutomaticFieldInfoCollection {\n  /**\n   * Initializes a new instance of the 'PdfPageNumberFieldInfoCollection' class.\n   * @private\n   */\n  constructor() {\n    /**\n     * Internal variable to store instance of `pageNumberFields` class.\n     * @private\n     */\n    this.automaticFieldsInformation = []; //\n  }\n  /**\n   * Gets the `page number fields collection`.\n   * @private\n   */\n\n\n  get automaticFields() {\n    return this.automaticFieldsInformation;\n  } // Public methods\n  /// Adds the specified field info.\n\n  /**\n   * Add page number field into collection.\n   * @private\n   */\n\n\n  add(fieldInfo) {\n    return this.automaticFields.push(fieldInfo);\n  }\n\n}\n/**\n * Represents a base class for all page graphics elements.\n */\n\n\nclass PdfGraphicsElement {\n  // Constructors\n  constructor() {//\n  }\n  /**\n   * `Draws` the page number field.\n   * @public\n   */\n\n\n  drawHelper(graphics, x, y) {\n    let bNeedSave = x !== 0 || y !== 0;\n    let gState = null; // Translate co-ordinates.\n\n    if (bNeedSave) {\n      // Save state.\n      gState = graphics.save();\n      graphics.translateTransform(x, y);\n    }\n\n    this.drawInternal(graphics);\n\n    if (bNeedSave) {\n      // Restore state.\n      graphics.restore(gState);\n    }\n  }\n\n}\n/**\n * PdfAutomaticField.ts class for EJ2-PDF\n */\n\n/**\n * Represents a fields which is calculated before the document saves.\n */\n\n\nclass PdfAutomaticField extends PdfGraphicsElement {\n  // Constructors\n  constructor() {\n    super(); // Fields\n\n    this.internalBounds = new RectangleF(0, 0, 0, 0);\n    this.internalTemplateSize = new SizeF(0, 0);\n  } // Properties\n\n\n  get bounds() {\n    return this.internalBounds;\n  }\n\n  set bounds(value) {\n    this.internalBounds = value;\n  }\n\n  get size() {\n    return new SizeF(this.bounds.width, this.bounds.height);\n  }\n\n  set size(value) {\n    this.bounds.width = value.width;\n    this.bounds.height = value.height;\n  }\n\n  get location() {\n    return new PointF(this.bounds.x, this.bounds.y);\n  }\n\n  set location(value) {\n    this.bounds.x = value.x;\n    this.bounds.y = value.y;\n  }\n\n  get font() {\n    return this.internalFont;\n  }\n\n  set font(value) {\n    this.internalFont = value;\n  }\n\n  get brush() {\n    return this.internalBrush;\n  }\n\n  set brush(value) {\n    this.internalBrush = value;\n  }\n\n  get pen() {\n    return this.internalPen;\n  }\n\n  set pen(value) {\n    this.internalPen = value;\n  }\n\n  get stringFormat() {\n    return this.internalStringFormat;\n  }\n\n  set stringFormat(value) {\n    this.internalStringFormat = value;\n  }\n\n  performDrawHelper(graphics, location, scalingX, scalingY) {\n    if (this.bounds.height === 0 || this.bounds.width === 0) {\n      let text = this.getValue(graphics);\n      this.internalTemplateSize = this.getFont().measureString(text, this.size, this.stringFormat);\n    }\n  }\n\n  draw(arg1, arg2, arg3) {\n    if (typeof arg2 === 'undefined') {\n      let location = new PointF(0, 0);\n      this.draw(arg1, location);\n    } else if (arg2 instanceof PointF) {\n      this.draw(arg1, arg2.x, arg2.y);\n    } else {\n      this.drawHelper(arg1, arg2, arg3);\n      let info = new PdfAutomaticFieldInfo(this, new PointF(arg2, arg3));\n      arg1.automaticFields.add(info);\n    }\n  }\n\n  getSize() {\n    if (this.bounds.height === 0 || this.bounds.width === 0) {\n      return this.internalTemplateSize;\n    } else {\n      return this.size;\n    }\n  }\n\n  drawInternal(graphics) {//\n  }\n  /* tslint:disable */\n\n\n  getBrush() {\n    return typeof this.internalBrush === 'undefined' || this.internalBrush == null ? new PdfSolidBrush(new PdfColor(0, 0, 0)) : this.internalBrush;\n  }\n\n  getFont() {\n    return typeof this.internalFont === 'undefined' || this.internalFont == null ? PdfDocument.defaultFont : this.internalFont;\n  }\n  /* tslint:enable */\n\n\n  getPageFromGraphics(graphics) {\n    if (typeof graphics.page !== 'undefined' && graphics.page !== null) {\n      let page = graphics.page;\n      return page;\n    } else {\n      let page = graphics.currentPage;\n      return page;\n    }\n  }\n\n}\n/**\n * PdfAutomaticFieldInfo.ts class for EJ2-PDF\n * @private\n */\n\n/**\n * Represents information about the automatic field.\n * @private\n */\n\n\nclass PdfAutomaticFieldInfo {\n  constructor(field, location, scaleX, scaleY) {\n    // Fields\n\n    /**\n     * Internal variable to store location of the field.\n     * @private\n     */\n    this.pageNumberFieldLocation = new PointF();\n    /**\n     * Internal variable to store field.\n     * @private\n     */\n\n    this.pageNumberField = null;\n    /**\n     * Internal variable to store x scaling factor.\n     * @private\n     */\n\n    this.scaleX = 1;\n    /**\n     * Internal variable to store y scaling factor.\n     * @private\n     */\n\n    this.scaleY = 1;\n\n    if (typeof location === 'undefined' && field instanceof PdfAutomaticFieldInfo) {\n      this.pageNumberField = field.field;\n      this.pageNumberFieldLocation = field.location;\n      this.scaleX = field.scalingX;\n      this.scaleY = field.scalingY;\n    } else if (typeof scaleX === 'undefined' && location instanceof PointF && field instanceof PdfAutomaticField) {\n      this.pageNumberField = field;\n      this.pageNumberFieldLocation = location;\n    } else {\n      this.pageNumberField = field;\n      this.pageNumberFieldLocation = location;\n      this.scaleX = scaleX;\n      this.scaleY = scaleY;\n    }\n  }\n  /* tslint:enable */\n  // Properties\n\n  /**\n   * Gets or sets the location.\n   * @private\n   */\n\n\n  get location() {\n    return this.pageNumberFieldLocation;\n  }\n\n  set location(value) {\n    this.pageNumberFieldLocation = value;\n  }\n  /**\n   * Gets or sets the field.\n   * @private\n   */\n\n\n  get field() {\n    return this.pageNumberField;\n  }\n\n  set field(value) {\n    this.pageNumberField = value;\n  }\n  /**\n   * Gets or sets the scaling X factor.\n   * @private\n   */\n\n\n  get scalingX() {\n    return this.scaleX;\n  }\n\n  set scalingX(value) {\n    this.scaleX = value;\n  }\n  /**\n   * Gets or sets the scaling Y factor.\n   * @private\n   */\n\n\n  get scalingY() {\n    return this.scaleY;\n  }\n\n  set scalingY(value) {\n    this.scaleY = value;\n  }\n\n}\n/**\n * ByteArray class\n * Used to keep information about image stream as byte array.\n * @private\n */\n\n\nclass ByteArray {\n  /**\n   * Initialize the new instance for `byte-array` class\n   * @hidden\n   * @private\n   */\n  constructor(length) {\n    /**\n     * Current stream `position`.\n     * @default 0\n     * @private\n     */\n    this.mPosition = 0;\n    this.buffer = new Uint8Array(length);\n    this.dataView = new DataView(this.buffer.buffer);\n  }\n  /**\n   * Gets and Sets a current `position` of byte array.\n   * @hidden\n   * @private\n   */\n\n\n  get position() {\n    return this.mPosition;\n  }\n\n  set position(value) {\n    this.mPosition = value;\n  }\n  /**\n   * `Read` from current stream position.\n   * @default 0\n   * @hidden\n   * @private\n   */\n\n\n  read(buffer, offset, count) {\n    for (let index = offset; index < count; index++) {\n      let position = this.position;\n      buffer.buffer[index] = this.readByte(position);\n      this.position++;\n    }\n  }\n  /**\n   * @hidden\n   */\n\n\n  getBuffer(index) {\n    return this.buffer[index];\n  }\n  /**\n   * @hidden\n   */\n\n\n  writeFromBase64String(base64) {\n    let arr = this.encodedString(base64);\n    this.buffer = arr;\n  }\n  /**\n   * @hidden\n   */\n\n\n  encodedString(input) {\n    let keyStr = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\n    let chr1;\n    let chr2;\n    let chr3;\n    let enc1;\n    let enc2;\n    let enc3;\n    let enc4;\n    let i = 0;\n    let resultIndex = 0;\n    input = input.replace(/[^A-Za-z0-9\\+\\/\\=]/g, '');\n    let totalLength = input.length * 3 / 4;\n\n    if (input.charAt(input.length - 1) === keyStr.charAt(64)) {\n      totalLength--;\n    }\n\n    let output = new Uint8Array(totalLength | 0);\n\n    while (i < input.length) {\n      enc1 = keyStr.indexOf(input.charAt(i++));\n      enc2 = keyStr.indexOf(input.charAt(i++));\n      enc3 = keyStr.indexOf(input.charAt(i++));\n      enc4 = keyStr.indexOf(input.charAt(i++));\n      chr1 = enc1 << 2 | enc2 >> 4;\n      chr2 = (enc2 & 15) << 4 | enc3 >> 2;\n      chr3 = (enc3 & 3) << 6 | enc4;\n      output[resultIndex++] = chr1;\n      output[resultIndex++] = chr2;\n      output[resultIndex++] = chr3;\n    }\n\n    return output;\n  }\n  /**\n   * @hidden\n   */\n\n\n  readByte(offset) {\n    return this.buffer[offset];\n  }\n  /**\n   * @hidden\n   */\n\n\n  get internalBuffer() {\n    return this.buffer;\n  }\n  /**\n   * @hidden\n   */\n\n\n  get count() {\n    return this.buffer.byteLength;\n  }\n  /**\n   * 'readNextTwoBytes' stream\n   * @hidden\n   * @private\n   */\n\n\n  readNextTwoBytes(stream) {\n    let data = stream.readByte(this.position);\n    this.position++;\n    data <<= 8;\n    data |= stream.readByte(this.position);\n    this.position++;\n    return data;\n  }\n\n}\n/**\n * `PdfBoolean` class is used to perform boolean related primitive operations.\n * @private\n */\n\n\nclass PdfBoolean {\n  //constructor\n\n  /**\n   * Initializes a new instance of the `PdfBoolean` class.\n   * @private\n   */\n  constructor(value) {\n    /**\n     * Internal variable to store the `position`.\n     * @default -1\n     * @private\n     */\n    this.currentPosition = -1;\n    this.value = value;\n  } //Properties\n\n  /**\n   * Gets or sets the `Status` of the specified object.\n   * @private\n   */\n\n\n  get status() {\n    return this.objectStatus;\n  }\n\n  set status(value) {\n    this.objectStatus = value;\n  }\n  /**\n   * Gets or sets a value indicating whether this document `is saving` or not.\n   * @private\n   */\n\n\n  get isSaving() {\n    return this.saving;\n  }\n\n  set isSaving(value) {\n    this.saving = value;\n  }\n  /**\n   * Gets or sets the `index` value of the specified object.\n   * @private\n   */\n\n\n  get objectCollectionIndex() {\n    return this.index;\n  }\n\n  set objectCollectionIndex(value) {\n    this.index = value;\n  }\n  /**\n   * Gets or sets the `position` of the object.\n   * @private\n   */\n\n\n  get position() {\n    return this.currentPosition;\n  }\n\n  set position(value) {\n    this.currentPosition = value;\n  }\n  /**\n   * Returns `cloned object`.\n   * @private\n   */\n\n\n  get clonedObject() {\n    let rValue = null;\n    return rValue;\n  }\n  /**\n   * `Saves` the object using the specified writer.\n   * @private\n   */\n\n\n  save(writer) {\n    writer.write(this.boolToStr(this.value));\n  }\n  /**\n   * Creates a `copy of PdfBoolean`.\n   * @private\n   */\n\n\n  clone(crossTable) {\n    let newNumber = new PdfBoolean(this.value);\n    return newNumber;\n  } // Implementation\n\n  /**\n   * Converts `boolean to string` - 0/1 'true'/'false'.\n   * @private\n   */\n\n\n  boolToStr(value) {\n    return value ? 'true' : 'false';\n  }\n\n}\n/**\n * ImageDecoder class\n */\n\n/**\n * Specifies the image `format`.\n * @private\n */\n\n\nvar ImageFormat = /*#__PURE__*/(() => {\n  (function (ImageFormat) {\n    /**\n     * Specifies the type of `Unknown`.\n     * @hidden\n     * @private\n     */\n    ImageFormat[ImageFormat[\"Unknown\"] = 0] = \"Unknown\";\n    /**\n     * Specifies the type of `Bmp`.\n     * @hidden\n     * @private\n     */\n\n    ImageFormat[ImageFormat[\"Bmp\"] = 1] = \"Bmp\";\n    /**\n     * Specifies the type of `Emf`.\n     * @hidden\n     * @private\n     */\n\n    ImageFormat[ImageFormat[\"Emf\"] = 2] = \"Emf\";\n    /**\n     * Specifies the type of `Gif`.\n     * @hidden\n     * @private\n     */\n\n    ImageFormat[ImageFormat[\"Gif\"] = 3] = \"Gif\";\n    /**\n     * Specifies the type of `Jpeg`.\n     * @hidden\n     * @private\n     */\n\n    ImageFormat[ImageFormat[\"Jpeg\"] = 4] = \"Jpeg\";\n    /**\n     * Specifies the type of `Png`.\n     * @hidden\n     * @private\n     */\n\n    ImageFormat[ImageFormat[\"Png\"] = 5] = \"Png\";\n    /**\n     * Specifies the type of `Wmf`.\n     * @hidden\n     * @private\n     */\n\n    ImageFormat[ImageFormat[\"Wmf\"] = 6] = \"Wmf\";\n    /**\n     * Specifies the type of `Icon`.\n     * @hidden\n     * @private\n     */\n\n    ImageFormat[ImageFormat[\"Icon\"] = 7] = \"Icon\";\n  })(ImageFormat || (ImageFormat = {}));\n\n  return ImageFormat;\n})();\n\n/**\n * `Decode the image stream`.\n * @private\n */\nlet ImageDecoder = /*#__PURE__*/(() => {\n  class ImageDecoder {\n    /**\n     * Initialize the new instance for `image-decoder` class.\n     * @private\n     */\n    constructor(stream) {\n      /**\n       * Start of file markers.\n       * @hidden\n       * @private\n       */\n      this.sof1Marker = 0x00C1;\n      this.sof2Marker = 0x00C2;\n      this.sof3Marker = 0x00C3;\n      this.sof5Marker = 0x00C5;\n      this.sof6Marker = 0x00C6;\n      this.sof7Marker = 0x00C7;\n      this.sof9Marker = 0x00C9;\n      this.sof10Marker = 0x00CA;\n      this.sof11Marker = 0x00CB;\n      this.sof13Marker = 0x00CD;\n      this.sof14Marker = 0x00CE;\n      this.sof15Marker = 0x00CF;\n      /**\n       * Specifies `format` of image.\n       * @hidden\n       * @private\n       */\n\n      this.mFormat = ImageFormat.Unknown;\n      /**\n       * `Bits per component`.\n       * @default 8\n       * @hidden\n       * @private\n       */\n\n      this.mbitsPerComponent = 8;\n      /**\n       * Internal variable for accessing fields from `DictionryProperties` class.\n       * @hidden\n       * @private\n       */\n\n      this.dictionaryProperties = new DictionaryProperties();\n      this.mStream = stream;\n      this.initialize();\n    }\n    /**\n     * Gets the `height` of image.\n     * @hidden\n     * @private\n     */\n\n\n    get height() {\n      return this.mHeight;\n    }\n    /**\n     * Gets the `width` of image.\n     * @hidden\n     * @private\n     */\n\n\n    get width() {\n      return this.mWidth;\n    }\n    /**\n     * Gets `bits per component`.\n     * @hidden\n     * @private\n     */\n\n\n    get bitsPerComponent() {\n      return this.mbitsPerComponent;\n    }\n    /**\n     * Gets the `size` of an image data.\n     * @hidden\n     * @private\n     */\n\n\n    get size() {\n      return this.mImageData.count;\n    }\n    /**\n     * Gets the value of an `image data`.\n     * @hidden\n     * @private\n     */\n\n\n    get imageData() {\n      return this.mImageData;\n    }\n    /**\n     * Gets the value of an `image data as number array`.\n     * @hidden\n     * @private\n     */\n\n\n    get imageDataAsNumberArray() {\n      return this.mImageData.internalBuffer.buffer;\n    }\n    /**\n     * `Initialize` image data and image stream.\n     * @hidden\n     * @private\n     */\n\n\n    initialize() {\n      if (this.mFormat === ImageFormat.Unknown && this.checkIfJpeg()) {\n        this.mFormat = ImageFormat.Jpeg;\n        this.parseJpegImage();\n      }\n\n      this.reset();\n      this.mImageData = new ByteArray(this.mStream.count);\n      this.mStream.read(this.mImageData, 0, this.mImageData.count);\n    }\n    /**\n     * `Reset` stream position into 0.\n     * @hidden\n     * @private\n     */\n\n\n    reset() {\n      this.mStream.position = 0;\n    }\n    /**\n     * `Parse` Jpeg image.\n     * @hidden\n     * @private\n     */\n\n\n    parseJpegImage() {\n      this.reset();\n      let imgData = new ByteArray(this.mStream.count);\n      this.mStream.read(imgData, 0, imgData.count);\n      let i = 4;\n      let isLengthExceed = false;\n      /* tslint:disable */\n\n      let length = imgData.getBuffer(i) * 256 + imgData.getBuffer(i + 1);\n\n      while (i < imgData.count) {\n        i += length;\n\n        if (i < imgData.count) {\n          if (imgData.getBuffer(i + 1) === 192) {\n            this.mHeight = imgData.getBuffer(i + 5) * 256 + imgData.getBuffer(i + 6);\n            this.mWidth = imgData.getBuffer(i + 7) * 256 + imgData.getBuffer(i + 8);\n            return;\n          } else {\n            i += 2;\n            length = imgData.getBuffer(i) * 256 + imgData.getBuffer(i + 1);\n          }\n        } else {\n          isLengthExceed = true;\n          break;\n        }\n      }\n\n      if (isLengthExceed) {\n        this.mStream.position = 0;\n        this.skip(this.mStream, 2);\n        this.readExceededJPGImage(this.mStream);\n      }\n      /* tslint:enable */\n\n    }\n    /**\n     * Gets the image `format`.\n     * @private\n     * @hidden\n     */\n\n\n    get format() {\n      return this.mFormat;\n    }\n    /**\n     * `Checks if JPG`.\n     * @private\n     * @hidden\n     */\n\n\n    checkIfJpeg() {\n      this.reset();\n\n      for (let i = 0; i < ImageDecoder.mJpegHeader.length; i++) {\n        if (ImageDecoder.mJpegHeader[i] !== this.mStream.readByte(i)) {\n          return false;\n        }\n\n        this.mStream.position++;\n      }\n\n      return true;\n    }\n    /**\n     * Return image `dictionary`.\n     * @hidden\n     * @private\n     */\n\n\n    getImageDictionary() {\n      if (this.mFormat === ImageFormat.Jpeg) {\n        let tempArrayBuffer = this.imageData.internalBuffer.length;\n        this.imageStream = new PdfStream();\n        this.imageStream.isImage = true;\n        let tempString = '';\n        let decodedString = '';\n\n        for (let i = 0; i < this.imageDataAsNumberArray.byteLength; i++) {\n          tempString += String.fromCharCode(null, this.mStream.readByte(i));\n        }\n\n        for (let i = 0; i < tempString.length; i++) {\n          if (i % 2 !== 0) {\n            decodedString += tempString[i];\n          }\n        }\n\n        this.imageStream.data = [decodedString];\n        this.imageStream.compress = false;\n        this.imageStream.items.setValue(this.dictionaryProperties.type, new PdfName(this.dictionaryProperties.xObject));\n        this.imageStream.items.setValue(this.dictionaryProperties.subtype, new PdfName(this.dictionaryProperties.image));\n        this.imageStream.items.setValue(this.dictionaryProperties.width, new PdfNumber(this.width));\n        this.imageStream.items.setValue(this.dictionaryProperties.height, new PdfNumber(this.height));\n        this.imageStream.items.setValue(this.dictionaryProperties.bitsPerComponent, new PdfNumber(this.bitsPerComponent));\n        this.imageStream.items.setValue(this.dictionaryProperties.filter, new PdfName(this.dictionaryProperties.dctdecode));\n        this.imageStream.items.setValue(this.dictionaryProperties.colorSpace, new PdfName(this.getColorSpace()));\n        this.imageStream.items.setValue(this.dictionaryProperties.decodeParms, this.getDecodeParams());\n        return this.imageStream;\n      } else {\n        return this.imageStream;\n      }\n    }\n    /**\n     * Return `colorSpace` of an image.\n     * @hidden\n     * @private\n     */\n\n\n    getColorSpace() {\n      return this.dictionaryProperties.deviceRgb;\n    }\n    /**\n     * Return `decode parameters` of an image.\n     * @hidden\n     * @private\n     */\n\n\n    getDecodeParams() {\n      let decodeParams = new PdfDictionary();\n      decodeParams.items.setValue(this.dictionaryProperties.columns, new PdfNumber(this.width));\n      decodeParams.items.setValue(this.dictionaryProperties.blackIs1, new PdfBoolean(true));\n      decodeParams.items.setValue(this.dictionaryProperties.k, new PdfNumber(-1));\n      decodeParams.items.setValue(this.dictionaryProperties.predictor, new PdfNumber(15));\n      decodeParams.items.setValue(this.dictionaryProperties.bitsPerComponent, new PdfNumber(this.bitsPerComponent));\n      return decodeParams;\n    }\n    /**\n     * 'readExceededJPGImage' stream\n     * @hidden\n     * @private\n     */\n\n\n    readExceededJPGImage(stream) {\n      this.mStream = stream;\n      let isContinueReading = true;\n\n      while (isContinueReading) {\n        let marker = this.getMarker(stream);\n\n        switch (marker) {\n          case this.sof1Marker:\n          case this.sof2Marker:\n          case this.sof3Marker:\n          case this.sof5Marker:\n          case this.sof6Marker:\n          case this.sof7Marker:\n          case this.sof9Marker:\n          case this.sof10Marker:\n          case this.sof11Marker:\n          case this.sof13Marker:\n          case this.sof14Marker:\n          case this.sof15Marker:\n            stream.position += 3;\n            this.mHeight = this.mStream.readNextTwoBytes(stream);\n            this.mWidth = this.mStream.readNextTwoBytes(stream);\n            isContinueReading = false;\n            break;\n\n          default:\n            this.skipStream(stream);\n            break;\n        }\n      }\n    }\n    /**\n     * 'skip' stream\n     * @hidden\n     * @private\n     */\n\n\n    skip(stream, noOfBytes) {\n      this.mStream = stream;\n      let temp = new ByteArray(noOfBytes);\n      this.mStream.read(temp, 0, temp.count);\n    }\n    /**\n     * 'getMarker' stream\n     * @hidden\n     * @private\n     */\n\n\n    getMarker(stream) {\n      let marker = 32;\n      marker = stream.readByte(this.mStream.position);\n      stream.position++;\n\n      while (marker !== 255) {\n        marker = stream.readByte(this.mStream.position);\n        stream.position++;\n      }\n\n      do {\n        marker = stream.readByte(this.mStream.position);\n        stream.position++;\n      } while (marker === 255);\n\n      return marker;\n    }\n    /**\n     * 'skipStream' stream\n     * @hidden\n     * @private\n     */\n\n\n    skipStream(stream) {\n      let markerLength = this.mStream.readNextTwoBytes(stream) - 2;\n\n      if (markerLength > 0) {\n        stream.position += markerLength;\n      }\n    }\n\n  }\n\n  /**\n   * Number array for `png header`.\n   * @hidden\n   * @private\n   */\n  ImageDecoder.mPngHeader = [137, 80, 78, 71, 13, 10, 26, 10];\n  /**\n   * Number Array for `jpeg header`.\n   * @hidden\n   * @private\n   */\n\n  ImageDecoder.mJpegHeader = [255, 216];\n  /**\n   * Number array for `gif header`.\n   * @hidden\n   * @private\n   */\n\n  ImageDecoder.GIF_HEADER = 'G,I,F,8';\n  /**\n   * Number array for `bmp header.`\n   * @hidden\n   * @private\n   */\n\n  ImageDecoder.BMP_HEADER = 'B,M';\n  /**\n   * Used to perform `convertion between pixels and points`.\n   * @private\n   */\n\n  return ImageDecoder;\n})();\nlet PdfUnitConverter = /*#__PURE__*/(() => {\n  class PdfUnitConverter {\n    //constructors\n\n    /**\n     * Initializes a new instance of the `UnitConvertor` class with DPI value.\n     * @private\n     */\n    constructor(dpi) {\n      this.updateProportionsHelper(dpi);\n    }\n    /**\n     * `Converts` the value, from one graphics unit to another graphics unit.\n     * @private\n     */\n\n\n    convertUnits(value, from, to) {\n      return this.convertFromPixels(this.convertToPixels(value, from), to);\n    }\n    /**\n     * Converts the value `to pixel` from specified graphics unit.\n     * @private\n     */\n\n\n    convertToPixels(value, from) {\n      let index = from;\n      let result = value * this.proportions[index];\n      return result;\n    }\n    /**\n     * Converts value, to specified graphics unit `from Pixel`.\n     * @private\n     */\n\n\n    convertFromPixels(value, to) {\n      let index = to;\n      let result = value / this.proportions[index];\n      return result;\n    }\n    /**\n     * `Update proportions` matrix according to Graphics settings.\n     * @private\n     */\n\n\n    updateProportionsHelper(pixelPerInch) {\n      this.proportions = [pixelPerInch / 2.54, pixelPerInch / 6.0, 1, pixelPerInch / 72.0, pixelPerInch, pixelPerInch / 300.0, pixelPerInch / 25.4 // Millimeter\n      ];\n    }\n\n  }\n\n  //Fields\n\n  /**\n   * Indicates default `horizontal resolution`.\n   * @default 96\n   * @private\n   */\n  PdfUnitConverter.horizontalResolution = 96;\n  /**\n   * Indicates default `vertical resolution`.\n   * @default 96\n   * @private\n   */\n\n  PdfUnitConverter.verticalResolution = 96;\n  /**\n   * `PdfImage` class represents the base class for images and provides functionality for the 'PdfBitmap' class.\n   * @private\n   */\n\n  return PdfUnitConverter;\n})();\n\nclass PdfImage {\n  /**\n   * Gets and Sets the `width` of an image.\n   * @private\n   */\n  get width() {\n    return this.imageWidth;\n  }\n\n  set width(value) {\n    this.imageWidth = value;\n  }\n  /**\n   * Gets and Sets the `height` of an image.\n   * @private\n   */\n\n\n  get height() {\n    return this.imageHeight;\n  }\n\n  set height(value) {\n    this.imageHeight = value;\n  }\n  /**\n   * Gets or sets the size of the image.\n   * @private\n   */\n\n\n  set size(value) {\n    this.width = value.width;\n    this.height = value.height;\n  }\n  /**\n   * Gets the `physical dimension` of an image.\n   * @private\n   */\n\n\n  get physicalDimension() {\n    this.imagePhysicalDimension = this.getPointSize(this.width, this.height, this.horizontalResolution, this.verticalResolution);\n    return new SizeF(this.width, this.height);\n  } // /**\n  //  * Gets the `image stream as string`.\n  //  * @private\n  //  */\n  // public static fromString(string : string) : PdfImage {\n  //     let image : PdfImage = new PdfBitmap(string);\n  //     return image;\n  // }\n\n  /**\n   * Gets the `element` image stream.\n   * @private\n   */\n\n\n  get element() {\n    return this.imageStream;\n  }\n\n  getPointSize(width, height, horizontalResolution, verticalResolution) {\n    if (typeof horizontalResolution === 'undefined') {\n      let dpiX = PdfUnitConverter.horizontalResolution;\n      let dpiY = PdfUnitConverter.verticalResolution;\n      let size = this.getPointSize(width, height, dpiX, dpiY);\n      return size;\n    } else {\n      let ucX = new PdfUnitConverter(horizontalResolution);\n      let ucY = new PdfUnitConverter(verticalResolution);\n      let ptWidth = ucX.convertUnits(width, PdfGraphicsUnit.Pixel, PdfGraphicsUnit.Point);\n      let ptHeight = ucY.convertUnits(height, PdfGraphicsUnit.Pixel, PdfGraphicsUnit.Point);\n      let size = new SizeF(ptWidth, ptHeight);\n      return size;\n    }\n  }\n\n}\n/**\n * PdfBitmap.ts class for EJ2-PDF\n */\n\n/**\n * The 'PdfBitmap' contains methods and properties to handle the Bitmap images.\n * ```typescript\n * // create a new PDF document.\n * let document : PdfDocument = new PdfDocument();\n * // add a page to the document.\n * let page1 : PdfPage = document.pages.add();\n * // base64 string of an image\n * let imageString : string = '/9j/3+2w7em7HzY/KiijFw  1OEYRUYrQ45yc5OUtz/9k=';\n * // load the image from the base64 string of original image.\n * let image : PdfBitmap = new PdfBitmap(imageString);\n * // draw the image\n * page1.graphics.drawImage(image, new RectangleF({x : 10, y : 10}, {width : 200, height : 200}));\n * // save the document.\n * document.save('output.pdf');\n * // destroy the document\n * document.destroy();\n * ```\n */\n\n\nclass PdfBitmap extends PdfImage {\n  /**\n   * Create an instance for `PdfBitmap` class.\n   * @param encodedString Base64 string of an image.\n   * ```typescript\n   * // create a new PDF document.\n   * let document : PdfDocument = new PdfDocument();\n   * // add a page to the document.\n   * let page1 : PdfPage = document.pages.add();\n   * // base64 string of an image\n   * let imageString : string = '/9j/3+2w7em7HzY/KiijFw  1OEYRUYrQ45yc5OUtz/9k=';\n   * //\n   * // load the image from the base64 string of original image.\n   * let image : PdfBitmap = new PdfBitmap(imageString);\n   * //\n   * // draw the image\n   * page1.graphics.drawImage(image, new RectangleF({x : 10, y : 10}, {width : 200, height : 200}));\n   * // save the document.\n   * document.save('output.pdf');\n   * // destroy the document\n   * document.destroy();\n   * ```\n   */\n  constructor(encodedString) {\n    super(); //Fields\n\n    /**\n     * Specifies the `status` of an image.\n     * @default true.\n     * @hidden\n     * @private\n     */\n\n    this.imageStatus = true;\n    /**\n     * Internal variable for accessing fields from `DictionryProperties` class.\n     * @hidden\n     * @private\n     */\n\n    this.dictionaryProperties = new DictionaryProperties();\n    this.loadImage(encodedString);\n  }\n  /**\n   * `Load image`.\n   * @hidden\n   * @private\n   */\n\n\n  loadImage(encodedString) {\n    let task = this.initializeAsync(encodedString);\n  }\n  /**\n   * `Initialize` image parameters.\n   * @private\n   */\n\n\n  initializeAsync(encodedString) {\n    let byteArray = new ByteArray(encodedString.length);\n    byteArray.writeFromBase64String(encodedString);\n    this.decoder = new ImageDecoder(byteArray);\n    this.height = this.decoder.height;\n    this.width = this.decoder.width; // FrameCount = BitmapImageDecoder.FrameCount;\n\n    this.bitsPerComponent = this.decoder.bitsPerComponent;\n  }\n  /**\n   * `Saves` the image into stream.\n   * @private\n   */\n\n\n  save() {\n    this.imageStatus = true;\n    this.imageStream = this.decoder.getImageDictionary();\n  }\n\n}\n/**\n * Images classes\n * @hidden\n */\n\n/**\n * TtfTableInfo.ts class for EJ2-PDF\n */\n\n\nclass TtfTableInfo {\n  //Properties\n\n  /**\n   * Gets a value indicating whether this table is empty.\n   * @private\n   */\n  get empty() {\n    let empty = this.offset === this.length && this.length === this.checksum && this.checksum === 0;\n    return empty;\n  }\n\n}\n\nclass TtfNameTable {}\n/**\n * TtfNameRecord.ts class for EJ2-PDF\n */\n\n\nclass TtfNameRecord {}\n/**\n * TtfHeadTable.ts class for EJ2-PDF\n */\n\n\nclass TtfHeadTable {}\n\nclass TtfMetrics {\n  //Properties\n\n  /**\n   * Gets a value indicating whether this instance is italic.\n   */\n  get isItalic() {\n    return (this.macStyle & 2) !== 0;\n  }\n  /**\n   * Gets a value indicating whether this instance is bold.\n   */\n\n\n  get isBold() {\n    return (this.macStyle & 1) !== 0;\n  }\n\n}\n/**\n * TtfHorizontalHeaderTable.ts class for EJ2-PDF\n */\n\n\nclass TtfHorizontalHeaderTable {}\n/**\n * TtfOS2Table.ts class for EJ2-PDF\n * The OS/2 table consists of a set of metrics that are required by Windows and OS/2.\n */\n\n\nclass TtfOS2Table {}\n/**\n * TtfPostTable.ts class for EJ2-PDF\n */\n\n\nclass TtfPostTable {}\n/**\n * TtfLongHorMetric.ts class for EJ2-PDF\n */\n\n\nclass TtfLongHorMetric {}\n/**\n * TtfCmapSubTable.ts class for EJ2-PDF\n */\n\n\nclass TtfCmapSubTable {}\n/**\n * TtfCmapTable.ts class for EJ2-PDF\n */\n\n\nclass TtfCmapTable {}\n/**\n * TtfGlyphInfo.ts class for EJ2-PDF\n */\n\n\nclass TtfGlyphInfo {\n  //Properties\n\n  /**\n   * Gets a value indicating whether this TtfGlyphInfo is empty.\n   */\n  get empty() {\n    let empty = this.index === this.width && this.width === this.charCode && this.charCode === 0;\n    return empty;\n  } //IComparable implementation\n\n  /**\n   * Compares two WidthDescriptor objects.\n   */\n\n\n  compareTo(obj) {\n    let glyph = obj;\n    return this.index - glyph.index;\n  }\n\n}\n/**\n * TtfLocaTable.ts class for EJ2-PDF\n */\n\n\nclass TtfLocaTable {}\n/**\n * TtfAppleCmapSubTable.ts class for EJ2-PDF\n */\n\n\nclass TtfAppleCmapSubTable {}\n/**\n * TtfMicrosoftCmapSubTable.ts class for EJ2-PDF\n */\n\n\nclass TtfMicrosoftCmapSubTable {}\n/**\n * TtfTrimmedCmapSubTable.ts class for EJ2-PDF\n */\n\n\nclass TtfTrimmedCmapSubTable {}\n/**\n * TtfLocaTable.ts class for EJ2-PDF\n */\n\n\nclass TtfGlyphHeader {}\n/**\n * Writes data in BigEndian order.\n */\n\n\nclass BigEndianWriter {\n  //Constructors\n\n  /**\n   * Creates a new writer.\n   */\n  constructor(capacity) {\n    //Constants\n\n    /**\n     * Size of Int32 type.\n     */\n    this.int32Size = 4;\n    /**\n     * Size of Int16 type.\n     */\n\n    this.int16Size = 2;\n    /**\n     * Size of long type.\n     */\n\n    this.int64Size = 8;\n    this.bufferLength = capacity;\n    this.buffer = [];\n  } //Properties\n\n  /**\n   * Gets data written to the writer.\n   */\n\n\n  get data() {\n    if (this.buffer.length < this.bufferLength) {\n      let length = this.bufferLength - this.buffer.length;\n\n      for (let i = 0; i < length; i++) {\n        this.buffer.push(0);\n      }\n    }\n\n    return this.buffer;\n  } /// <summary>\n  /// Gets position of the internal buffer.\n  /// </summary>\n\n\n  get position() {\n    if (this.internalPosition === undefined || this.internalPosition === null) {\n      this.internalPosition = 0;\n    }\n\n    return this.internalPosition;\n  }\n  /**\n   * Writes short value.\n   */\n\n\n  writeShort(value) {\n    let bytes = [(value & 0x0000ff00) >> 8, value & 0x000000ff];\n    this.flush(bytes);\n  }\n  /**\n   * Writes int value.\n   */\n\n\n  writeInt(value) {\n    let bytes = [(value & 0xff000000) >> 24, (value & 0x00ff0000) >> 16, (value & 0x0000ff00) >> 8, value & 0x000000ff];\n    this.flush(bytes);\n  }\n  /**\n   * Writes u int value.\n   */\n\n\n  writeUInt(value) {\n    let buff = [(value & 0xff000000) >> 24, (value & 0x00ff0000) >> 16, (value & 0x0000ff00) >> 8, value & 0x000000ff];\n    this.flush(buff);\n  }\n  /**\n   * Writes string value.\n   */\n\n\n  writeString(value) {\n    if (value == null) {\n      throw new Error('Argument Null Exception : value');\n    }\n\n    let bytes = [];\n\n    for (let i = 0; i < value.length; i++) {\n      bytes.push(value.charCodeAt(i));\n    }\n\n    this.flush(bytes);\n  }\n  /**\n   * Writes byte[] value.\n   */\n\n\n  writeBytes(value) {\n    this.flush(value);\n  } // //Implementation\n\n\n  flush(buff) {\n    if (buff === null) {\n      throw new Error('Argument Null Exception : buff');\n    }\n\n    let position = this.position;\n\n    for (let i = 0; i < buff.length; i++) {\n      this.buffer[position] = buff[i];\n      position++;\n    }\n\n    this.internalPosition += buff.length;\n  }\n\n}\n/**\n * TtfReader.ts class for EJ2-PDF\n */\n\n\nclass TtfReader {\n  //Constructors\n  constructor(fontData) {\n    this.int32Size = 4;\n    this.isTtcFont = false;\n    this.isMacTtf = false;\n    this.metricsName = '';\n    this.isMacTTF = false;\n    this.missedGlyphs = 0;\n    this.tableNames = ['cvt ', 'fpgm', 'glyf', 'head', 'hhea', 'hmtx', 'loca', 'maxp', 'prep'];\n    this.entrySelectors = [0, 0, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4];\n    this.fontData = fontData;\n    this.initialize();\n  } //Properties\n\n  /**\n   * Gets glyphs for Macintosh or Symbol fonts (char - key, glyph - value).\n   */\n\n\n  get macintosh() {\n    if (this.macintoshDictionary === null || this.macintoshDictionary === undefined) {\n      this.macintoshDictionary = new Dictionary();\n    }\n\n    return this.macintoshDictionary;\n  }\n  /**\n   * Gets glyphs for Microsoft or Symbol fonts (char - key, glyph - value).\n   */\n\n\n  get microsoft() {\n    if (this.microsoftDictionary === null || this.microsoftDictionary === undefined) {\n      this.microsoftDictionary = new Dictionary();\n    }\n\n    return this.microsoftDictionary;\n  }\n  /**\n   * Gets glyphs for Macintosh or Symbol fonts (glyph index - key, glyph - value).\n   */\n\n\n  get macintoshGlyphs() {\n    if (this.internalMacintoshGlyphs === null || this.internalMacintoshGlyphs === undefined) {\n      this.internalMacintoshGlyphs = new Dictionary();\n    }\n\n    return this.internalMacintoshGlyphs;\n  }\n  /**\n   * Gets glyphs for Microsoft Unicode fonts (glyph index - key, glyph - value).\n   */\n\n\n  get microsoftGlyphs() {\n    if (this.internalMicrosoftGlyphs === null || this.internalMicrosoftGlyphs === undefined) {\n      this.internalMicrosoftGlyphs = new Dictionary();\n    }\n\n    return this.internalMicrosoftGlyphs;\n  } //Implementation\n\n\n  initialize() {\n    if (this.metrics === undefined) {\n      this.metrics = new TtfMetrics();\n    }\n\n    this.readFontDictionary();\n    let nameTable = this.readNameTable();\n    let headTable = this.readHeadTable();\n    this.initializeFontName(nameTable);\n    this.metrics.macStyle = headTable.macStyle;\n  }\n\n  readFontDictionary() {\n    this.offset = 0;\n    let version = this.checkPreambula(); //this.offset += 4;\n\n    let numTables = this.readInt16(this.offset);\n    let searchRange = this.readInt16(this.offset);\n    let entrySelector = this.readInt16(this.offset);\n    let rangeShift = this.readInt16(this.offset);\n\n    if (this.tableDirectory === undefined) {\n      this.tableDirectory = new Dictionary();\n    }\n\n    for (let i = 0; i < numTables; ++i) {\n      let table = new TtfTableInfo();\n      let tableKey = this.readString(this.int32Size);\n      table.checksum = this.readInt32(this.offset);\n      table.offset = this.readInt32(this.offset);\n      table.length = this.readInt32(this.offset);\n      this.tableDirectory.setValue(tableKey, table);\n    }\n\n    this.lowestPosition = this.offset;\n\n    if (!this.isTtcFont) {\n      this.fixOffsets();\n    }\n  }\n\n  fixOffsets() {\n    let minOffset = Number.MAX_VALUE; // Search for a smallest offset and compare it with the lowest position found.\n\n    let tableKeys = this.tableDirectory.keys();\n\n    for (let i = 0; i < tableKeys.length; i++) {\n      let value = this.tableDirectory.getValue(tableKeys[i]);\n      let offset = value.offset;\n\n      if (minOffset > offset) {\n        minOffset = offset;\n\n        if (minOffset <= this.lowestPosition) {\n          break;\n        }\n      }\n    }\n\n    let shift = minOffset - this.lowestPosition;\n\n    if (shift !== 0) {\n      let table = new Dictionary();\n\n      for (let i = 0; i < tableKeys.length; i++) {\n        let value = this.tableDirectory.getValue(tableKeys[i]);\n        value.offset -= shift;\n        table.setValue(tableKeys[i], value);\n      }\n\n      this.tableDirectory = table;\n    }\n  }\n\n  checkPreambula() {\n    let version = this.readInt32(this.offset);\n    this.isMacTtf = version === 0x74727565 ? true : false;\n\n    if (version !== 0x10000 && version !== 0x74727565 && version !== 0x4f54544f) {\n      this.isTtcFont = true;\n      this.offset = 0;\n      let fontTag = this.readString(4);\n\n      if (fontTag !== 'ttcf') {\n        throw new Error('Can not read TTF font data');\n      } //skip 4\n\n\n      this.offset += 4;\n      let ttcIdentificationNumber = this.readInt32(this.offset);\n\n      if (ttcIdentificationNumber < 0) {\n        throw new Error('Can not read TTF font data');\n      }\n\n      this.offset = this.readInt32(this.offset);\n      version = this.readInt32(this.offset);\n    }\n\n    return version;\n  }\n\n  readNameTable() {\n    let tableInfo = this.getTable('name');\n    this.offset = tableInfo.offset;\n    let table = new TtfNameTable();\n    table.formatSelector = this.readUInt16(this.offset);\n    table.recordsCount = this.readUInt16(this.offset);\n    table.offset = this.readUInt16(this.offset);\n    table.nameRecords = [];\n    let recordSize = 12;\n    let position = this.offset;\n\n    for (let i = 0; i < table.recordsCount; i++) {\n      this.offset = position;\n      let record = new TtfNameRecord();\n      record.platformID = this.readUInt16(this.offset);\n      record.encodingID = this.readUInt16(this.offset);\n      record.languageID = this.readUInt16(this.offset);\n      record.nameID = this.readUInt16(this.offset);\n      record.length = this.readUInt16(this.offset);\n      record.offset = this.readUInt16(this.offset);\n      this.offset = tableInfo.offset + table.offset + record.offset;\n      let unicode = record.platformID === 0 || record.platformID === 3;\n      record.name = this.readString(record.length, unicode);\n      table.nameRecords[i] = record;\n      position += recordSize;\n    }\n\n    return table;\n  }\n\n  readHeadTable() {\n    let tableInfo = this.getTable('head');\n    this.offset = tableInfo.offset;\n    let table = new TtfHeadTable();\n    table.version = this.readFixed(this.offset);\n    table.fontRevision = this.readFixed(this.offset);\n    table.checkSumAdjustment = this.readUInt32(this.offset);\n    table.magicNumber = this.readUInt32(this.offset);\n    table.flags = this.readUInt16(this.offset);\n    table.unitsPerEm = this.readUInt16(this.offset);\n    table.created = this.readInt64(this.offset);\n    table.modified = this.readInt64(this.offset);\n    table.xMin = this.readInt16(this.offset);\n    table.yMin = this.readInt16(this.offset);\n    table.xMax = this.readInt16(this.offset);\n    table.yMax = this.readInt16(this.offset);\n    table.macStyle = this.readUInt16(this.offset);\n    table.lowestReadableSize = this.readUInt16(this.offset);\n    table.fontDirectionHint = this.readInt16(this.offset);\n    table.indexToLocalFormat = this.readInt16(this.offset);\n    table.glyphDataFormat = this.readInt16(this.offset);\n    return table;\n  }\n\n  readHorizontalHeaderTable() {\n    let tableInfo = this.getTable('hhea');\n    this.offset = tableInfo.offset;\n    let table = new TtfHorizontalHeaderTable();\n    table.version = this.readFixed(this.offset);\n    table.ascender = this.readInt16(this.offset);\n    table.descender = this.readInt16(this.offset);\n    table.lineGap = this.readInt16(this.offset);\n    table.advanceWidthMax = this.readUInt16(this.offset);\n    table.minLeftSideBearing = this.readInt16(this.offset);\n    table.minRightSideBearing = this.readInt16(this.offset);\n    table.xMaxExtent = this.readInt16(this.offset);\n    table.caretSlopeRise = this.readInt16(this.offset);\n    table.caretSlopeRun = this.readInt16(this.offset); //skip 2 * 5\n\n    this.offset += 10;\n    table.metricDataFormat = this.readInt16(this.offset);\n    table.numberOfHMetrics = this.readUInt16(this.offset);\n    return table;\n  }\n\n  readOS2Table() {\n    let tableInfo = this.getTable('OS/2');\n    this.offset = tableInfo.offset;\n    let table = new TtfOS2Table();\n    table.version = this.readUInt16(this.offset);\n    table.xAvgCharWidth = this.readInt16(this.offset);\n    table.usWeightClass = this.readUInt16(this.offset);\n    table.usWidthClass = this.readUInt16(this.offset);\n    table.fsType = this.readInt16(this.offset);\n    table.ySubscriptXSize = this.readInt16(this.offset);\n    table.ySubscriptYSize = this.readInt16(this.offset);\n    table.ySubscriptXOffset = this.readInt16(this.offset);\n    table.ySubscriptYOffset = this.readInt16(this.offset);\n    table.ySuperscriptXSize = this.readInt16(this.offset);\n    table.ySuperscriptYSize = this.readInt16(this.offset);\n    table.ySuperscriptXOffset = this.readInt16(this.offset);\n    table.ySuperscriptYOffset = this.readInt16(this.offset);\n    table.yStrikeoutSize = this.readInt16(this.offset);\n    table.yStrikeoutPosition = this.readInt16(this.offset);\n    table.sFamilyClass = this.readInt16(this.offset);\n    table.panose = this.readBytes(10);\n    table.ulUnicodeRange1 = this.readUInt32(this.offset);\n    table.ulUnicodeRange2 = this.readUInt32(this.offset);\n    table.ulUnicodeRange3 = this.readUInt32(this.offset);\n    table.ulUnicodeRange4 = this.readUInt32(this.offset);\n    table.vendorIdentifier = this.readBytes(4);\n    table.fsSelection = this.readUInt16(this.offset);\n    table.usFirstCharIndex = this.readUInt16(this.offset);\n    table.usLastCharIndex = this.readUInt16(this.offset);\n    table.sTypoAscender = this.readInt16(this.offset);\n    table.sTypoDescender = this.readInt16(this.offset);\n    table.sTypoLineGap = this.readInt16(this.offset);\n    table.usWinAscent = this.readUInt16(this.offset);\n    table.usWinDescent = this.readUInt16(this.offset);\n    table.ulCodePageRange1 = this.readUInt32(this.offset);\n    table.ulCodePageRange2 = this.readUInt32(this.offset);\n\n    if (table.version > 1) {\n      table.sxHeight = this.readInt16(this.offset);\n      table.sCapHeight = this.readInt16(this.offset);\n      table.usDefaultChar = this.readUInt16(this.offset);\n      table.usBreakChar = this.readUInt16(this.offset);\n      table.usMaxContext = this.readUInt16(this.offset);\n    } else {\n      table.sxHeight = 0;\n      table.sCapHeight = 0;\n      table.usDefaultChar = 0;\n      table.usBreakChar = 0;\n      table.usMaxContext = 0;\n    }\n\n    return table;\n  }\n\n  readPostTable() {\n    let tableInfo = this.getTable('post');\n    this.offset = tableInfo.offset;\n    let table = new TtfPostTable();\n    table.formatType = this.readFixed(this.offset);\n    table.italicAngle = this.readFixed(this.offset);\n    table.underlinePosition = this.readInt16(this.offset);\n    table.underlineThickness = this.readInt16(this.offset);\n    table.isFixedPitch = this.readUInt32(this.offset);\n    table.minType42 = this.readUInt32(this.offset);\n    table.maxType42 = this.readUInt32(this.offset);\n    table.minType1 = this.readUInt32(this.offset);\n    table.maxType1 = this.readUInt32(this.offset);\n    return table;\n  }\n  /**\n   * Reads Width of the glyphs.\n   */\n\n\n  readWidthTable(glyphCount, unitsPerEm) {\n    let tableInfo = this.getTable('hmtx');\n    this.offset = tableInfo.offset;\n    let width = [];\n\n    for (let i = 0; i < glyphCount; i++) {\n      let glyph = new TtfLongHorMetric();\n      glyph.advanceWidth = this.readUInt16(this.offset);\n      glyph.lsb = this.readInt16(this.offset);\n      let glyphWidth = glyph.advanceWidth * 1000 / unitsPerEm;\n      width.push(Math.floor(glyphWidth));\n    }\n\n    return width;\n  }\n  /**\n   * Reads the cmap table.\n   */\n\n\n  readCmapTable() {\n    let tableInfo = this.getTable('cmap');\n    this.offset = tableInfo.offset;\n    let table = new TtfCmapTable();\n    table.version = this.readUInt16(this.offset);\n    table.tablesCount = this.readUInt16(this.offset);\n    let position = this.offset;\n    let subTables = [];\n\n    for (let i = 0; i < table.tablesCount; i++) {\n      this.offset = position;\n      let subTable = new TtfCmapSubTable();\n      subTable.platformID = this.readUInt16(this.offset);\n      subTable.encodingID = this.readUInt16(this.offset);\n      subTable.offset = this.readUInt32(this.offset);\n      position = this.offset;\n      this.readCmapSubTable(subTable);\n      subTables[i] = subTable;\n    }\n\n    return subTables;\n  }\n  /**\n   * Reads the cmap sub table.\n   */\n\n\n  readCmapSubTable(subTable) {\n    let tableInfo = this.getTable('cmap');\n    this.offset = tableInfo.offset + subTable.offset;\n    let format = this.readUInt16(this.offset);\n    let encoding = this.getCmapEncoding(subTable.platformID, subTable.encodingID);\n    let platform = encoding === TtfCmapEncoding.Macintosh ? TtfPlatformID.Macintosh : TtfPlatformID.Microsoft;\n\n    if (encoding !== TtfCmapEncoding.Unknown) {\n      switch (format) {\n        case TtfCmapFormat.Apple:\n          this.readAppleCmapTable(subTable, encoding);\n          break;\n\n        case TtfCmapFormat.Microsoft:\n          this.readMicrosoftCmapTable(subTable, encoding);\n          break;\n\n        case TtfCmapFormat.Trimmed:\n          this.readTrimmedCmapTable(subTable, encoding);\n          break;\n      }\n    }\n  }\n  /**\n   * Reads Symbol cmap table.\n   */\n\n\n  readAppleCmapTable(subTable, encoding) {\n    let tableInfo = this.getTable('cmap');\n    this.offset = tableInfo.offset + subTable.offset;\n    let table = new TtfAppleCmapSubTable();\n    table.format = this.readUInt16(this.offset);\n    table.length = this.readUInt16(this.offset);\n    table.version = this.readUInt16(this.offset);\n\n    if (this.maxMacIndex === null || this.maxMacIndex === undefined) {\n      this.maxMacIndex = 0;\n    }\n\n    for (let i = 0; i < 256; ++i) {\n      let glyphInfo = new TtfGlyphInfo();\n      glyphInfo.index = this.readByte(this.offset);\n      glyphInfo.width = this.getWidth(glyphInfo.index);\n      glyphInfo.charCode = i;\n      this.macintosh.setValue(i, glyphInfo);\n      this.addGlyph(glyphInfo, encoding); // NOTE: this code fixes char codes that extends 0x100. However, it might corrupt something.\n\n      this.maxMacIndex = Math.max(i, this.maxMacIndex);\n    }\n  }\n  /**\n   * Reads Symbol cmap table.\n   */\n\n\n  readMicrosoftCmapTable(subTable, encoding) {\n    let tableInfo = this.getTable('cmap');\n    this.offset = tableInfo.offset + subTable.offset;\n    let collection = encoding === TtfCmapEncoding.Unicode ? this.microsoft : this.macintosh;\n    let table = new TtfMicrosoftCmapSubTable();\n    table.format = this.readUInt16(this.offset);\n    table.length = this.readUInt16(this.offset);\n    table.version = this.readUInt16(this.offset);\n    table.segCountX2 = this.readUInt16(this.offset);\n    table.searchRange = this.readUInt16(this.offset);\n    table.entrySelector = this.readUInt16(this.offset);\n    table.rangeShift = this.readUInt16(this.offset);\n    let segCount = table.segCountX2 / 2;\n    table.endCount = this.readUshortArray(segCount);\n    table.reservedPad = this.readUInt16(this.offset);\n    table.startCount = this.readUshortArray(segCount);\n    table.idDelta = this.readUshortArray(segCount);\n    table.idRangeOffset = this.readUshortArray(segCount);\n    let length = table.length / 2 - 8 - segCount * 4;\n    table.glyphID = this.readUshortArray(length); // Process glyphIdArray array.\n\n    let codeOffset = 0;\n    let index = 0;\n\n    for (let j = 0; j < segCount; j++) {\n      for (let k = table.startCount[j]; k <= table.endCount[j] && k !== 65535; k++) {\n        if (table.idRangeOffset[j] === 0) {\n          codeOffset = k + table.idDelta[j] & 65535;\n        } else {\n          index = j + table.idRangeOffset[j] / 2 - segCount + k - table.startCount[j];\n\n          if (index >= table.glyphID.length) {\n            continue;\n          }\n\n          codeOffset = table.glyphID[index] + table.idDelta[j] & 65535;\n        }\n\n        let glyph = new TtfGlyphInfo();\n        glyph.index = codeOffset;\n        glyph.width = this.getWidth(glyph.index);\n        let id = encoding === TtfCmapEncoding.Symbol ? (k & 0xff00) === 0xf000 ? k & 0xff : k : k;\n        glyph.charCode = id;\n        collection.setValue(id, glyph);\n        this.addGlyph(glyph, encoding);\n      }\n    }\n  }\n  /**\n   * Reads Trimed cmap table.\n   */\n\n\n  readTrimmedCmapTable(subTable, encoding) {\n    let tableInfo = this.getTable('cmap');\n    this.offset = tableInfo.offset + subTable.offset;\n    let table = new TtfTrimmedCmapSubTable();\n    table.format = this.readUInt16(this.offset);\n    table.length = this.readUInt16(this.offset);\n    table.version = this.readUInt16(this.offset);\n    table.firstCode = this.readUInt16(this.offset);\n    table.entryCount = this.readUInt16(this.offset);\n\n    for (let i = 0; i < table.entryCount; ++i) {\n      let glyphInfo = new TtfGlyphInfo();\n      glyphInfo.index = this.readUInt16(this.offset);\n      glyphInfo.width = this.getWidth(glyphInfo.index);\n      glyphInfo.charCode = i + table.firstCode;\n      this.macintosh.setValue(i, glyphInfo);\n      this.addGlyph(glyphInfo, encoding); // NOTE: this code fixes char codes that extends 0x100. However, it might corrupt something.\n\n      this.maxMacIndex = Math.max(i, this.maxMacIndex);\n    }\n  }\n\n  initializeFontName(nameTable) {\n    for (let i = 0; i < nameTable.recordsCount; i++) {\n      let record = nameTable.nameRecords[i];\n\n      if (record.nameID === 1) {\n        //font family\n        this.metrics.fontFamily = record.name;\n      } else if (record.nameID === 6) {\n        //post script name\n        this.metrics.postScriptName = record.name;\n      }\n      /* tslint:disable */\n\n\n      if (this.metrics.fontFamily !== null && this.metrics.fontFamily !== undefined && this.metrics.postScriptName !== null && this.metrics.postScriptName !== undefined) {\n        break;\n      }\n      /* tslint:disable */\n\n    }\n  }\n\n  getTable(name) {\n    // if (name === null) {\n    //     throw new Error('Argument Null Exception : name');\n    // }\n    let table = new TtfTableInfo();\n    let obj;\n\n    if (this.tableDirectory.containsKey(name)) {\n      obj = this.tableDirectory.getValue(name);\n    }\n\n    if (obj !== null && obj !== undefined) {\n      table = obj;\n    }\n\n    return table;\n  }\n  /**\n   * Returns width of the glyph.\n   */\n\n\n  getWidth(glyphCode) {\n    glyphCode = glyphCode < this.width.length ? glyphCode : this.width.length - 1;\n    return this.width[glyphCode];\n  }\n  /**\n   * Gets CMAP encoding based on platform ID and encoding ID.\n   */\n\n  /* tslint:disable */\n\n\n  getCmapEncoding(platformID, encodingID) {\n    let format = TtfCmapEncoding.Unknown;\n\n    if (platformID == TtfPlatformID.Microsoft && encodingID == TtfMicrosoftEncodingID.Undefined) {\n      // When building a symbol font for Windows,\n      // the platform ID should be 3 and the encoding ID should be 0.\n      format = TtfCmapEncoding.Symbol;\n    } else if (platformID == TtfPlatformID.Microsoft && encodingID == TtfMicrosoftEncodingID.Unicode) {\n      // When building a Unicode font for Windows,\n      // the platform ID should be 3 and the encoding ID should be 1.\n      format = TtfCmapEncoding.Unicode;\n    } else if (platformID == TtfPlatformID.Macintosh && encodingID == TtfMacintoshEncodingID.Roman) {\n      // When building a font that will be used on the Macintosh,\n      // the platform ID should be 1 and the encoding ID should be 0.\n      format = TtfCmapEncoding.Macintosh;\n    }\n\n    return format;\n  }\n  /* tslint:enable */\n\n  /**\n   * Adds glyph to the collection.\n   */\n\n\n  addGlyph(glyph, encoding) {\n    let collection = null;\n\n    switch (encoding) {\n      case TtfCmapEncoding.Unicode:\n        collection = this.microsoftGlyphs;\n        break;\n\n      case TtfCmapEncoding.Macintosh:\n      case TtfCmapEncoding.Symbol:\n        collection = this.macintoshGlyphs;\n        break;\n    }\n\n    collection.setValue(glyph.index, glyph);\n  }\n  /**\n   * Initializes metrics.\n   */\n\n  /* tslint:disable */\n\n\n  initializeMetrics(nameTable, headTable, horizontalHeadTable, os2Table, postTable, cmapTables) {\n    /* tslint:enable */\n    // if (cmapTables === null) {\n    //     throw new Error('ArgumentNullException : cmapTables');\n    // }\n    this.initializeFontName(nameTable); // Get font encoding.\n\n    let bSymbol = false;\n\n    for (let i = 0; i < cmapTables.length; i++) {\n      let subTable = cmapTables[i];\n      let encoding = this.getCmapEncoding(subTable.platformID, subTable.encodingID);\n\n      if (encoding === TtfCmapEncoding.Symbol) {\n        bSymbol = true;\n        break;\n      }\n    }\n\n    this.metrics.isSymbol = bSymbol;\n    this.metrics.macStyle = headTable.macStyle;\n    this.metrics.isFixedPitch = postTable.isFixedPitch !== 0;\n    this.metrics.italicAngle = postTable.italicAngle;\n    let factor = 1000 / headTable.unitsPerEm;\n    this.metrics.winAscent = os2Table.sTypoAscender * factor;\n    this.metrics.macAscent = horizontalHeadTable.ascender * factor; //m_metrics.MacAscent = os2Table.UsWinAscent * factor;\n    // NOTE: This is stange workaround. The value is good if os2Table.SCapHeight != 0, otherwise it should be properly computed.\n\n    this.metrics.capHeight = os2Table.sCapHeight !== 0 ? os2Table.sCapHeight : 0.7 * headTable.unitsPerEm * factor;\n    this.metrics.winDescent = os2Table.sTypoDescender * factor;\n    this.metrics.macDescent = horizontalHeadTable.descender * factor; //m_metrics.MacDescent = -os2Table.UsWinDescent * factor;\n\n    this.metrics.leading = (os2Table.sTypoAscender - os2Table.sTypoDescender + os2Table.sTypoLineGap) * factor;\n    this.metrics.lineGap = Math.ceil(horizontalHeadTable.lineGap * factor);\n    let left = headTable.xMin * factor;\n    let top = Math.ceil(this.metrics.macAscent + this.metrics.lineGap);\n    let right = headTable.xMax * factor;\n    let bottom = this.metrics.macDescent;\n    this.metrics.fontBox = new Rectangle(left, top, right, bottom); // NOTE: Strange!\n\n    this.metrics.stemV = 80;\n    this.metrics.widthTable = this.updateWidth();\n    this.metrics.contains = this.tableDirectory.containsKey('CFF');\n    this.metrics.subScriptSizeFactor = headTable.unitsPerEm / os2Table.ySubscriptYSize;\n    this.metrics.superscriptSizeFactor = headTable.unitsPerEm / os2Table.ySuperscriptYSize;\n  }\n  /**\n   * Updates chars structure which is used in the case of ansi encoding (256 bytes).\n   */\n\n\n  updateWidth() {\n    let count = 256;\n    let bytes = [];\n\n    if (this.metrics.isSymbol) {\n      for (let i = 0; i < count; i++) {\n        let glyphInfo = this.getGlyph(String.fromCharCode(i));\n        bytes[i] = glyphInfo.empty ? 0 : glyphInfo.width;\n      }\n    } else {\n      let byteToProcess = [];\n      let unknown = '?';\n      let space = String.fromCharCode(32);\n\n      for (let i = 0; i < count; i++) {\n        byteToProcess[0] = i;\n        let text = this.getString(byteToProcess, 0, byteToProcess.length);\n        let ch = text.length > 0 ? text[0] : unknown;\n        let glyphInfo = this.getGlyph(ch);\n\n        if (!glyphInfo.empty) {\n          bytes[i] = glyphInfo.width;\n        } else {\n          glyphInfo = this.getGlyph(space);\n          bytes[i] = glyphInfo.empty ? 0 : glyphInfo.width;\n        }\n      }\n    }\n\n    return bytes;\n  }\n  /**\n   * Returns default glyph.\n   */\n\n\n  getDefaultGlyph() {\n    let glyph = this.getGlyph(StringTokenizer.whiteSpace);\n    return glyph;\n  }\n  /**\n   * Reads unicode string from byte array.\n   */\n\n\n  getString(byteToProcess, start, length) {\n    let result = '';\n\n    for (let index = 0; index < length; index++) {\n      result += String.fromCharCode(byteToProcess[index + start]);\n    }\n\n    return result;\n  }\n  /**\n   * Reads loca table.\n   */\n\n\n  readLocaTable(bShort) {\n    let tableInfo = this.getTable('loca');\n    this.offset = tableInfo.offset;\n    let table = new TtfLocaTable();\n    let buffer = null;\n\n    if (bShort) {\n      let len = tableInfo.length / 2;\n      buffer = [];\n\n      for (let i = 0; i < len; i++) {\n        buffer[i] = this.readUInt16(this.offset) * 2;\n      }\n    } else {\n      let len = tableInfo.length / 4;\n      buffer = [];\n\n      for (let i = 0; i < len; i++) {\n        buffer[i] = this.readUInt32(this.offset);\n      }\n    }\n\n    table.offsets = buffer;\n    return table;\n  }\n  /**\n   * Updates hash table of used glyphs.\n   */\n\n\n  updateGlyphChars(glyphChars, locaTable) {\n    // if (glyphChars === null) {\n    //     throw new Error('Argument Null Exception : glyphChars');\n    // }\n    // Add zero key.\n    if (!glyphChars.containsKey(0)) {\n      glyphChars.setValue(0, 0);\n    }\n\n    let clone = new Dictionary();\n    let glyphCharKeys = glyphChars.keys();\n\n    for (let i = 0; i < glyphCharKeys.length; i++) {\n      clone.setValue(glyphCharKeys[i], glyphChars.getValue(glyphCharKeys[i]));\n    }\n\n    for (let i = 0; i < glyphCharKeys.length; i++) {\n      let nextKey = glyphCharKeys[i];\n      this.processCompositeGlyph(glyphChars, nextKey, locaTable);\n    }\n  }\n  /**\n   * Checks if glyph is composite or not.\n   */\n\n\n  processCompositeGlyph(glyphChars, glyph, locaTable) {\n    // if (glyphChars === null) {\n    //     throw new Error('Argument Null Exception : glyphChars');\n    // }\n    // Is in range.\n    if (glyph < locaTable.offsets.length - 1) {\n      let glyphOffset = locaTable.offsets[glyph];\n\n      if (glyphOffset !== locaTable.offsets[glyph + 1]) {\n        let tableInfo = this.getTable('glyf');\n        this.offset = tableInfo.offset + glyphOffset;\n        let glyphHeader = new TtfGlyphHeader();\n        glyphHeader.numberOfContours = this.readInt16(this.offset);\n        glyphHeader.xMin = this.readInt16(this.offset);\n        glyphHeader.yMin = this.readInt16(this.offset);\n        glyphHeader.xMax = this.readInt16(this.offset);\n        glyphHeader.yMax = this.readInt16(this.offset); // Glyph is composite.\n\n        if (glyphHeader.numberOfContours < 0) {\n          let skipBytes = 0;\n          let entry = true;\n\n          while (entry) {\n            let flags = this.readUInt16(this.offset);\n            let glyphIndex = this.readUInt16(this.offset);\n\n            if (!glyphChars.containsKey(glyphIndex)) {\n              glyphChars.setValue(glyphIndex, 0);\n            }\n\n            if ((flags & TtfCompositeGlyphFlags.MoreComponents) === 0) {\n              break;\n            }\n\n            skipBytes = (flags & TtfCompositeGlyphFlags.Arg1And2AreWords) !== 0 ? 4 : 2;\n\n            if ((flags & TtfCompositeGlyphFlags.WeHaveScale) !== 0) {\n              skipBytes += 2;\n            } else if ((flags & TtfCompositeGlyphFlags.WeHaveAnXyScale) !== 0) {\n              skipBytes += 4;\n            } else if ((flags & TtfCompositeGlyphFlags.WeHaveTwoByTwo) !== 0) {\n              skipBytes += 2 * 4;\n            }\n\n            this.offset += skipBytes;\n          }\n        }\n      }\n    }\n  }\n  /**\n   * Creates new glyph tables based on chars that are used for output.\n   */\n\n  /* tslint:disable */\n\n\n  generateGlyphTable(glyphChars, locaTable, newLocaTable, newGlyphTable) {\n    /* tslint:enable */\n    // if (glyphChars === null) {\n    //     throw new Error('Argument Null Exception : glyphChars');\n    // }\n    newLocaTable = []; // Sorting used glyphs keys.\n\n    let activeGlyphs = glyphChars.keys();\n    activeGlyphs.sort((a, b) => a - b);\n    let glyphSize = 0;\n\n    for (let i = 0; i < activeGlyphs.length; i++) {\n      let glyphIndex = activeGlyphs[i];\n\n      if (locaTable.offsets.length > 0) {\n        glyphSize += locaTable.offsets[glyphIndex + 1] - locaTable.offsets[glyphIndex];\n      }\n    }\n\n    let glyphSizeAligned = this.align(glyphSize);\n    newGlyphTable = [];\n\n    for (let i = 0; i < glyphSizeAligned; i++) {\n      newGlyphTable.push(0);\n    }\n\n    let nextGlyphOffset = 0;\n    let nextGlyphIndex = 0;\n    let table = this.getTable('glyf'); // Creating NewLocaTable - that would hold offsets for filtered glyphs.\n\n    for (let i = 0; i < locaTable.offsets.length; i++) {\n      newLocaTable.push(nextGlyphOffset);\n\n      if (nextGlyphIndex < activeGlyphs.length && activeGlyphs[nextGlyphIndex] === i) {\n        ++nextGlyphIndex;\n        newLocaTable[i] = nextGlyphOffset;\n        let oldGlyphOffset = locaTable.offsets[i];\n        let oldNextGlyphOffset = locaTable.offsets[i + 1] - oldGlyphOffset;\n\n        if (oldNextGlyphOffset > 0) {\n          this.offset = table.offset + oldGlyphOffset;\n          let result = this.read(newGlyphTable, nextGlyphOffset, oldNextGlyphOffset);\n          newGlyphTable = result.buffer;\n          nextGlyphOffset += oldNextGlyphOffset;\n        }\n      }\n    }\n\n    return {\n      glyphTableSize: glyphSize,\n      newLocaTable: newLocaTable,\n      newGlyphTable: newGlyphTable\n    };\n  }\n  /**\n   * Updates new Loca table.\n   */\n\n  /* tslint:disable */\n\n\n  updateLocaTable(newLocaTable, bLocaIsShort, newLocaTableOut) {\n    /* tslint:enable */\n    if (newLocaTable === null) {\n      throw new Error('Argument Null Exception : newLocaTable');\n    }\n\n    let size = bLocaIsShort ? newLocaTable.length * 2 : newLocaTable.length * 4;\n    let count = this.align(size); //BigEndianWiter\n\n    let writer = new BigEndianWriter(count);\n\n    for (let i = 0; i < newLocaTable.length; i++) {\n      let value = newLocaTable[i];\n\n      if (bLocaIsShort) {\n        value /= 2;\n        writer.writeShort(value);\n      } else {\n        writer.writeInt(value);\n      }\n    }\n\n    return {\n      newLocaUpdated: writer.data,\n      newLocaSize: size\n    };\n  }\n  /**\n   * Aligns number to be divisible on 4.\n   */\n\n\n  align(value) {\n    return value + 3 & ~3;\n  }\n  /**\n   * Returns font program data.\n   */\n\n  /* tslint:disable */\n\n\n  getFontProgram(newLocaTableOut, newGlyphTable, glyphTableSize, locaTableSize) {\n    /* tslint:enable */\n    if (newLocaTableOut === null) {\n      throw new Error('Argument Null Exception : newLocaTableOut');\n    }\n\n    if (newGlyphTable === null) {\n      throw new Error('Argument Null Exception : newGlyphTable');\n    }\n\n    let tableNames = this.tableNames;\n    let result = this.getFontProgramLength(newLocaTableOut, newGlyphTable, 0);\n    let fontProgramLength = result.fontProgramLength;\n    let numTables = result.numTables;\n    let writer = new BigEndianWriter(fontProgramLength);\n    writer.writeInt(0x10000);\n    writer.writeShort(numTables);\n    let entrySelector = this.entrySelectors[numTables];\n    writer.writeShort((1 << (entrySelector & 31)) * 16);\n    writer.writeShort(entrySelector);\n    writer.writeShort((numTables - (1 << (entrySelector & 31))) * 16); // Writing to destination buffer - checksums && sizes of used tables.\n\n    this.writeCheckSums(writer, numTables, newLocaTableOut, newGlyphTable, glyphTableSize, locaTableSize); // // Writing to destination buffer - used glyphs.\n\n    this.writeGlyphs(writer, newLocaTableOut, newGlyphTable);\n    return writer.data;\n  }\n  /* tslint:disable */\n\n\n  getFontProgramLength(newLocaTableOut, newGlyphTable, numTables) {\n    /* tslint:enable */\n    if (newLocaTableOut === null) {\n      throw new Error('Argument Null Exception : newLocaTableOut');\n    }\n\n    if (newGlyphTable === null) {\n      throw new Error('Argument Null Exception : newGlyphTable');\n    } // glyf and loca are used by default;\n\n\n    numTables = 2;\n    let tableNames = this.tableNames;\n    let fontProgramLength = 0;\n\n    for (let i = 0; i < tableNames.length; i++) {\n      let tableName = tableNames[i];\n\n      if (tableName !== 'glyf' && tableName !== 'loca') {\n        let table = this.getTable(tableName);\n\n        if (!table.empty) {\n          ++numTables;\n          fontProgramLength += this.align(table.length);\n        }\n      }\n    }\n\n    fontProgramLength += newLocaTableOut.length;\n    fontProgramLength += newGlyphTable.length;\n    let usedTablesSize = numTables * 16 + 3 * 4;\n    fontProgramLength += usedTablesSize;\n    return {\n      fontProgramLength: fontProgramLength,\n      numTables: numTables\n    };\n  }\n  /**\n   * Writing to destination buffer - checksums and sizes of used tables.\n   */\n\n  /* tslint:disable */\n\n\n  writeCheckSums(writer, numTables, newLocaTableOut, newGlyphTable, glyphTableSize, locaTableSize) {\n    /* tslint:enable */\n    if (writer === null) {\n      throw new Error('Argument Null Exception : writer');\n    }\n\n    if (newLocaTableOut === null) {\n      throw new Error('Argument Null Exception : newLocaTableOut');\n    }\n\n    if (newGlyphTable === null) {\n      throw new Error('Argument Null Exception : newGlyphTable');\n    }\n\n    let tableNames = this.tableNames;\n    let usedTablesSize = numTables * 16 + 3 * 4;\n    let nextTableSize = 0;\n\n    for (let i = 0; i < tableNames.length; i++) {\n      let tableName = tableNames[i];\n      let tableInfo = this.getTable(tableName);\n\n      if (tableInfo.empty) {\n        continue;\n      }\n\n      writer.writeString(tableName);\n\n      if (tableName === 'glyf') {\n        let checksum = this.calculateCheckSum(newGlyphTable);\n        writer.writeInt(checksum);\n        nextTableSize = glyphTableSize;\n      } else if (tableName === 'loca') {\n        let checksum = this.calculateCheckSum(newLocaTableOut);\n        writer.writeInt(checksum);\n        nextTableSize = locaTableSize;\n      } else {\n        writer.writeInt(tableInfo.checksum);\n        nextTableSize = tableInfo.length;\n      }\n\n      writer.writeUInt(usedTablesSize);\n      writer.writeUInt(nextTableSize);\n      usedTablesSize += this.align(nextTableSize);\n    }\n  }\n  /**\n   * Gets checksum from source buffer.\n   */\n\n\n  calculateCheckSum(bytes) {\n    if (bytes === null) {\n      throw new Error('Argument Null Exception : bytes');\n    }\n\n    let pos = 0;\n    let byte1 = 0;\n    let byte2 = 0;\n    let byte3 = 0;\n    let byte4 = 0;\n\n    for (let i = 0; i < (bytes.length + 1) / 4; i++) {\n      byte4 += bytes[pos++] & 255;\n      byte3 += bytes[pos++] & 255;\n      byte2 += bytes[pos++] & 255;\n      byte1 += bytes[pos++] & 255;\n    }\n\n    let result = byte1;\n    result += byte2 << 8;\n    result += byte3 << 16;\n    result += byte4 << 24;\n    return result;\n  }\n  /**\n   * Writing to destination buffer - used glyphs.\n   */\n\n\n  writeGlyphs(writer, newLocaTable, newGlyphTable) {\n    if (writer === null) {\n      throw new Error('Argument Null Exception : writer');\n    }\n\n    if (newLocaTable === null) {\n      throw new Error('Argument Null Exception : newLocaTableOut');\n    }\n\n    if (newGlyphTable === null) {\n      throw new Error('Argument Null Exception : newGlyphTable');\n    }\n\n    let tableNames = this.tableNames;\n\n    for (let i = 0; i < tableNames.length; i++) {\n      let tableName = tableNames[i];\n      let tableInfo = this.getTable(tableName);\n\n      if (tableInfo.empty) {\n        continue;\n      }\n\n      if (tableName === 'glyf') {\n        writer.writeBytes(newGlyphTable);\n      } else if (tableName === 'loca') {\n        writer.writeBytes(newLocaTable);\n      } else {\n        let count = this.align(tableInfo.length);\n        let buff = [];\n\n        for (let i = 0; i < count; i++) {\n          buff.push(0);\n        }\n\n        this.offset = tableInfo.offset;\n        let result = this.read(buff, 0, tableInfo.length);\n        writer.writeBytes(result.buffer);\n      }\n    }\n  } //public methods\n\n  /**\n   * Sets position value of font data.\n   */\n\n\n  setOffset(offset) {\n    this.offset = offset;\n  }\n  /**\n   * Creates font Internals\n   * @private\n   */\n\n\n  createInternals() {\n    this.metrics = new TtfMetrics();\n    let nameTable = this.readNameTable();\n    let headTable = this.readHeadTable();\n    this.bIsLocaShort = headTable.indexToLocalFormat === 0;\n    let horizontalHeadTable = this.readHorizontalHeaderTable();\n    let os2Table = this.readOS2Table();\n    let postTable = this.readPostTable();\n    this.width = this.readWidthTable(horizontalHeadTable.numberOfHMetrics, headTable.unitsPerEm);\n    let subTables = this.readCmapTable();\n    this.initializeMetrics(nameTable, headTable, horizontalHeadTable, os2Table, postTable, subTables);\n  }\n\n  getGlyph(charCode) {\n    if (typeof charCode === 'number') {\n      let obj1 = null;\n\n      if (!this.metrics.isSymbol && this.microsoftGlyphs != null) {\n        if (this.microsoftGlyphs.containsKey(charCode)) {\n          obj1 = this.microsoftGlyphs.getValue(charCode);\n        }\n      } else if (this.metrics.isSymbol && this.macintoshGlyphs != null) {\n        if (this.macintoshGlyphs.containsKey(charCode)) {\n          obj1 = this.macintoshGlyphs.getValue(charCode);\n        }\n      }\n\n      let glyph = obj1 != null ? obj1 : this.getDefaultGlyph();\n      return glyph;\n    } else {\n      let obj = null;\n      let code = charCode.charCodeAt(0);\n\n      if (!this.metrics.isSymbol && this.microsoft !== null) {\n        if (this.microsoft.containsKey(code)) {\n          obj = this.microsoft.getValue(code);\n\n          if (code !== StringTokenizer.whiteSpace.charCodeAt(0)) {\n            this.isFontPresent = true;\n          }\n        } else if (code !== StringTokenizer.whiteSpace.charCodeAt(0)) {\n          this.isFontPresent = false;\n        }\n      } else if (this.metrics.isSymbol && this.macintosh !== null || this.isMacTTF) {\n        // NOTE: this code fixes char codes that extends 0x100. However, it might corrupt something.\n        if (this.maxMacIndex !== 0) {\n          code %= this.maxMacIndex + 1;\n        } else {\n          code = (code & 0xff00) === 0xf000 ? code & 0xff : code;\n        }\n\n        if (this.macintosh.containsKey(code)) {\n          obj = this.macintosh.getValue(code);\n          this.isFontPresent = true;\n        }\n      } // Fix for StackOverFlow exception in XPS to PDF converter\n\n\n      if (charCode === StringTokenizer.whiteSpace && obj === null) {\n        obj = new TtfGlyphInfo();\n      }\n\n      let glyph = obj !== null ? obj : this.getDefaultGlyph();\n      return glyph;\n    }\n  }\n  /**\n   * Gets hash table with chars indexed by glyph index.\n   */\n\n\n  getGlyphChars(chars) {\n    if (chars === null || chars === undefined) {\n      throw new Error('Argument Null Exception : chars');\n    }\n\n    let dictionary = new Dictionary();\n    let charKeys = chars.keys();\n\n    for (let i = 0; i < charKeys.length; i++) {\n      let ch = charKeys[i];\n      let glyph = this.getGlyph(ch);\n\n      if (!glyph.empty) {\n        dictionary.setValue(glyph.index, ch.charCodeAt(0));\n      }\n    }\n\n    return dictionary;\n  }\n  /**\n   * Gets all glyphs.\n   */\n\n\n  getAllGlyphs() {\n    let allGlyphInfo = [];\n    let info = new TtfGlyphInfo();\n    let index = 0;\n\n    for (let i = 0; i < this.width.length; i++) {\n      let width = this.width[i];\n      info.index = index;\n      info.width = width;\n      allGlyphInfo.push(info);\n      index++;\n    }\n\n    return allGlyphInfo;\n  }\n  /**\n   * Reads a font's program.\n   * @private\n   */\n\n\n  readFontProgram(chars) {\n    let glyphChars = this.getGlyphChars(chars);\n    let locaTable = this.readLocaTable(this.bIsLocaShort);\n\n    if (glyphChars.size() < chars.size()) {\n      this.missedGlyphs = chars.size() - glyphChars.size();\n    }\n\n    this.updateGlyphChars(glyphChars, locaTable);\n    /* tslint:disable */\n\n    let result1 = this.generateGlyphTable(glyphChars, locaTable, null, null);\n    /* tslint:enable */\n\n    let glyphTableSize = result1.glyphTableSize;\n    let newLocaTable = result1.newLocaTable;\n    let newGlyphTable = result1.newGlyphTable;\n    let result2 = this.updateLocaTable(newLocaTable, this.bIsLocaShort, null);\n    let newLocaSize = result2.newLocaSize;\n    let newLocaUpdated = result2.newLocaUpdated;\n    let fontProgram = this.getFontProgram(newLocaUpdated, newGlyphTable, glyphTableSize, newLocaSize);\n    return fontProgram;\n  }\n  /**\n   * Reconverts string to be in proper format saved into PDF file.\n   */\n\n\n  convertString(text) {\n    if (text === null) {\n      throw new Error('Argument Null Exception : text');\n    }\n\n    let glyph = '';\n\n    for (let k = 0; k < text.length; k++) {\n      let ch = text[k];\n      let glyphInfo = this.getGlyph(ch);\n\n      if (!glyphInfo.empty) {\n        glyph += String.fromCharCode(glyphInfo.index);\n      }\n    }\n\n    return glyph;\n  }\n  /**\n   * Gets char width.\n   */\n\n\n  getCharWidth(code) {\n    let glyphInfo = this.getGlyph(code);\n    glyphInfo = !glyphInfo.empty ? glyphInfo : this.getDefaultGlyph();\n    let codeWidth = !glyphInfo.empty ? glyphInfo.width : 0;\n    return codeWidth;\n  }\n\n  readString(length, isUnicode) {\n    if (isUnicode === undefined) {\n      return this.readString(length, false);\n    } else {\n      //let buffer : number[] = this.readBytes(length);\n      let result = '';\n\n      if (isUnicode) {\n        for (let i = 0; i < length; i++) {\n          if (i % 2 !== 0) {\n            result += String.fromCharCode(this.fontData[this.offset]);\n          }\n\n          this.offset += 1;\n        }\n      } else {\n        for (let i = 0; i < length; i++) {\n          result += String.fromCharCode(this.fontData[this.offset]);\n          this.offset += 1;\n        }\n      }\n\n      return result;\n    }\n  }\n\n  readFixed(offset) {\n    let integer = this.readInt16(offset);\n    let sFraction = this.readInt16(offset + 2);\n    let fraction = sFraction / 16384;\n    return integer + fraction;\n  }\n\n  readInt32(offset) {\n    let i1 = this.fontData[offset + 3];\n    let i2 = this.fontData[offset + 2];\n    let i3 = this.fontData[offset + 1];\n    let i4 = this.fontData[offset];\n    this.offset += 4;\n    return i1 + (i2 << 8) + (i3 << 16) + (i4 << 24);\n  }\n\n  readUInt32(offset) {\n    let i1 = this.fontData[offset + 3];\n    let i2 = this.fontData[offset + 2];\n    let i3 = this.fontData[offset + 1];\n    let i4 = this.fontData[offset];\n    this.offset += 4;\n    return i1 | i2 << 8 | i3 << 16 | i4 << 24;\n  } // private readInt16(offset : number) : number {\n  //     let result : number = (this.fontData[offset] << 8) + this.fontData[offset + 1];\n  //     this.offset += 2;\n  //     return result;\n  // }\n\n\n  readInt16(offset) {\n    let result = (this.fontData[offset] << 8) + this.fontData[offset + 1];\n    result = result & 1 << 15 ? result - 0x10000 : result;\n    this.offset += 2;\n    return result;\n  }\n\n  readInt64(offset) {\n    let low = this.readInt32(offset + 4);\n    let n = this.readInt32(offset) * 4294967296.0 + low;\n\n    if (low < 0) {\n      n += 4294967296;\n    }\n\n    return n;\n  }\n\n  readUInt16(offset) {\n    let result = this.fontData[offset] << 8 | this.fontData[offset + 1];\n    this.offset += 2;\n    return result;\n  }\n  /**\n   * Reads ushort array.\n   */\n\n\n  readUshortArray(length) {\n    let buffer = [];\n\n    for (let i = 0; i < length; i++) {\n      buffer[i] = this.readUInt16(this.offset);\n    }\n\n    return buffer;\n  }\n\n  readBytes(length) {\n    let result = [];\n\n    for (let i = 0; i < length; i++) {\n      result.push(this.fontData[this.offset]);\n      this.offset += 1;\n    }\n\n    return result;\n  }\n\n  readByte(offset) {\n    let result = this.fontData[offset];\n    this.offset += 1;\n    return result;\n  }\n  /**\n   * Reads bytes to array in BigEndian order.\n   * @private\n   */\n\n\n  read(buffer, index, count) {\n    if (buffer === null) {\n      throw new Error('Argument Null Exception : buffer');\n    }\n\n    let written = 0;\n    let read = 0;\n\n    do {\n      for (let i = 0; i < count - written && this.offset + i < this.fontData.length; i++) {\n        buffer[index + i] = this.fontData[this.offset + i];\n      }\n\n      read = count - written;\n      this.offset += read;\n      written += read;\n    } while (written < count);\n\n    return {\n      buffer: buffer,\n      written: written\n    };\n  }\n\n}\n/**\n * `Metrics` of the font.\n * @private\n */\n\n\nclass PdfFontMetrics {\n  constructor() {\n    /**\n     * `Line gap`.\n     * @private\n     */\n    this.lineGap = 0;\n  } //  Public methods\n\n  /**\n   * Returns `ascent` taking into consideration font`s size.\n   * @private\n   */\n\n\n  getAscent(format) {\n    let returnValue = this.ascent * PdfFont.charSizeMultiplier * this.getSize(format);\n    return returnValue;\n  }\n  /**\n   * Returns `descent` taking into consideration font`s size.\n   * @private\n   */\n\n\n  getDescent(format) {\n    let returnValue = this.descent * PdfFont.charSizeMultiplier * this.getSize(format);\n    return returnValue;\n  }\n  /**\n   * Returns `Line gap` taking into consideration font`s size.\n   * @private\n   */\n\n\n  getLineGap(format) {\n    let returnValue = this.lineGap * PdfFont.charSizeMultiplier * this.getSize(format);\n    return returnValue;\n  }\n  /**\n   * Returns `height` taking into consideration font`s size.\n   * @private\n   */\n\n\n  getHeight(format) {\n    let height;\n    let clearTypeFonts = ['cambria', 'candara', 'constantia', 'corbel', 'cariadings'];\n    let clearTypeFontCollection = [];\n\n    for (let index = 0; index < clearTypeFonts.length; index++) {\n      let font = clearTypeFonts[index];\n      clearTypeFontCollection.push(font);\n    }\n\n    if (this.getDescent(format) < 0) {\n      // if ((clearTypeFontCollection.indexOf(this.name.toLowerCase()) !== -1) && !this.isUnicodeFont) {\n      //     height = (this.GetAscent(format) - this.GetDescent(format) - this.GetLineGap(format));\n      // } else {\n      height = this.getAscent(format) - this.getDescent(format) + this.getLineGap(format); // }\n    } else {\n      height = this.getAscent(format) + this.getDescent(format) + this.getLineGap(format);\n    }\n\n    return height;\n  }\n  /**\n   * Calculates `size` of the font depending on the subscript/superscript value.\n   * @private\n   */\n\n\n  getSize(format) {\n    let size = this.size;\n\n    if (format != null) {\n      switch (format.subSuperScript) {\n        case PdfSubSuperScript.SubScript:\n          size /= this.subScriptSizeFactor;\n          break;\n\n        case PdfSubSuperScript.SuperScript:\n          size /= this.superscriptSizeFactor;\n          break;\n      }\n    }\n\n    return size;\n  }\n  /**\n   * `Clones` the metrics.\n   * @private\n   */\n\n\n  clone() {\n    let metrics = this;\n    metrics.widthTable = WidthTable.clone();\n    return metrics;\n  } //  Properies\n\n  /**\n   * Gets or sets the `width table`.\n   * @private\n   */\n\n\n  get widthTable() {\n    return this.internalWidthTable;\n  }\n\n  set widthTable(value) {\n    this.internalWidthTable = value;\n  }\n\n}\n\nclass WidthTable {\n  /**\n   * Static `clones` this instance of the WidthTable class.\n   * @private\n   */\n  static clone() {\n    return null;\n  }\n\n}\n\nclass StandardWidthTable extends WidthTable {\n  //Properties\n\n  /**\n   * Gets the `32 bit number` at the specified index.\n   * @private\n   */\n  items(index) {\n    if (index < 0 || index >= this.widths.length) {\n      throw new Error('ArgumentOutOfRangeException:index, The character is not supported by the font.');\n    }\n\n    let result = this.widths[index];\n    return result;\n  }\n  /**\n   * Gets the `length` of the internal array.\n   * @private\n   */\n\n\n  get length() {\n    return this.widths.length;\n  } // Constructors\n\n  /**\n   * Initializes a new instance of the `StandardWidthTable` class.\n   * @private\n   */\n\n\n  constructor(widths) {\n    super();\n\n    if (widths == null) {\n      throw new Error('ArgumentNullException:widths');\n    }\n\n    this.widths = widths;\n  } //Overrides\n\n  /**\n   * `Clones` this instance of the WidthTable class.\n   * @private\n   */\n\n\n  clone() {\n    let swt = this;\n    swt.widths = this.widths;\n    return swt;\n  }\n  /**\n   * Converts width table to a `PDF array`.\n   * @private\n   */\n\n\n  toArray() {\n    let arr = new PdfArray(this.widths);\n    return arr;\n  }\n\n}\n/**\n * TrueTypeFont.ts class for EJ2-PDF\n */\n\n\nclass UnicodeTrueTypeFont {\n  /* tslint:enable */\n  //Constructors\n\n  /**\n   * Initializes a new instance of the `PdfTrueTypeFont` class.\n   * @private\n   */\n  constructor(base64String, size) {\n    // Fields\n    this.nameString = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';\n    /**\n     * Specifies the Internal variable to store fields of `PdfDictionaryProperties`.\n     * @private\n     */\n\n    this.dictionaryProperties = new DictionaryProperties();\n    /**\n     * Indicates whether the font program is compressed or not.\n     * @private\n     */\n\n    this.isCompress = false;\n    /**\n     * Indicates whether the font is embedded or not.\n     */\n\n    this.isEmbedFont = false;\n    /**\n     * Cmap table's start prefix.\n     */\n\n    /* tslint:disable */\n\n    this.cmapPrefix = '/CIDInit /ProcSet findresource begin\\n12 dict begin\\nbegincmap' + Operators.newLine + '/CIDSystemInfo << /Registry (Adobe)/Ordering (UCS)/Supplement 0>> def\\n/CMapName ' + '/Adobe-Identity-UCS def\\n/CMapType 2 def\\n1 begincodespacerange' + Operators.newLine;\n    /* tslint:enable */\n\n    /**\n     * Cmap table's start suffix.\n     */\n\n    this.cmapEndCodespaceRange = 'endcodespacerange' + Operators.newLine;\n    /**\n     * Cmap's begin range marker.\n     */\n\n    this.cmapBeginRange = 'beginbfrange' + Operators.newLine;\n    /**\n     * Cmap's end range marker.\n     */\n\n    this.cmapEndRange = 'endbfrange' + Operators.newLine;\n    /**\n     * Cmap table's end\n     */\n\n    /* tslint:disable */\n\n    this.cmapSuffix = 'endbfrange\\nendcmap\\nCMapName currentdict ' + '/CMap defineresource pop\\nend end' + Operators.newLine;\n\n    if (base64String === null || base64String === undefined) {\n      throw new Error('ArgumentNullException:base64String');\n    }\n\n    this.fontSize = size;\n    this.fontString = base64String;\n    this.Initialize();\n  } //Implementation\n\n  /**\n   * Returns width of the char symbol.\n   */\n\n\n  getCharWidth(charCode) {\n    let codeWidth = this.ttfReader.getCharWidth(charCode);\n    return codeWidth;\n  }\n  /**\n   * Returns width of the text line.\n   */\n\n\n  getLineWidth(line) {\n    // if (line == null) {\n    //     throw new Error('ArgumentNullException : line');\n    // }\n    let width = 0;\n\n    for (let i = 0, len = line.length; i < len; i++) {\n      let ch = line[i];\n      let charWidth = this.getCharWidth(ch);\n      width += charWidth;\n    }\n\n    return width;\n  }\n  /**\n   * Initializes a new instance of the `PdfTrueTypeFont` class.\n   * @private\n   */\n\n\n  Initialize() {\n    let byteArray = new ByteArray(this.fontString.length);\n    byteArray.writeFromBase64String(this.fontString);\n    this.fontData = byteArray.internalBuffer;\n    this.ttfReader = new TtfReader(this.fontData);\n    this.ttfMetrics = this.ttfReader.metrics;\n  }\n\n  createInternals() {\n    this.fontDictionary = new PdfDictionary();\n    this.fontProgram = new PdfStream();\n    this.cmap = new PdfStream();\n    this.descendantFont = new PdfDictionary();\n    this.metrics = new PdfFontMetrics();\n    this.ttfReader.createInternals();\n    this.ttfMetrics = this.ttfReader.metrics;\n    this.initializeMetrics(); // Create all the dictionaries of the font.\n\n    this.subsetName = this.getFontName();\n    this.createDescendantFont();\n    this.createCmap();\n    this.createFontDictionary();\n    this.createFontProgram();\n  }\n\n  getInternals() {\n    return this.fontDictionary;\n  }\n  /**\n   * Initializes metrics.\n   */\n\n\n  initializeMetrics() {\n    let ttfMetrics = this.ttfReader.metrics;\n    this.metrics.ascent = ttfMetrics.macAscent;\n    this.metrics.descent = ttfMetrics.macDescent;\n    this.metrics.height = ttfMetrics.macAscent - ttfMetrics.macDescent + ttfMetrics.lineGap;\n    this.metrics.name = ttfMetrics.fontFamily;\n    this.metrics.postScriptName = ttfMetrics.postScriptName;\n    this.metrics.size = this.fontSize;\n    this.metrics.widthTable = new StandardWidthTable(ttfMetrics.widthTable);\n    this.metrics.lineGap = ttfMetrics.lineGap;\n    this.metrics.subScriptSizeFactor = ttfMetrics.subScriptSizeFactor;\n    this.metrics.superscriptSizeFactor = ttfMetrics.superscriptSizeFactor;\n    this.metrics.isBold = ttfMetrics.isBold;\n  }\n  /**\n   * Gets random string.\n   */\n\n\n  getFontName() {\n    let builder = '';\n    let name; // if (this.isEmbed === false) {\n\n    for (let i = 0; i < 6; i++) {\n      let index = Math.floor(Math.random() * (25 - 0 + 1)) + 0;\n      builder += this.nameString[index];\n    }\n\n    builder += '+'; // }\n\n    builder += this.ttfReader.metrics.postScriptName;\n    name = builder.toString(); // if (name === '') {\n    //     name = this.ttfReader.metrics.fontFamily;\n    // }\n\n    name = this.formatName(name);\n    return name;\n  }\n  /**\n   * Generates name of the font.\n   */\n\n\n  formatName(fontName) {\n    // if (fontName === null) {\n    //     throw new Error('ArgumentNullException : fontName');\n    // }\n    // if (fontName === '') {\n    //     throw new Error('ArgumentOutOfRangeException : fontName, Parameter can not be empty');\n    // }\n    let ret = fontName.replace('(', '#28');\n    ret = ret.replace(')', '#29');\n    ret = ret.replace('[', '#5B');\n    ret = ret.replace(']', '#5D');\n    ret = ret.replace('<', '#3C');\n    ret = ret.replace('>', '#3E');\n    ret = ret.replace('{', '#7B');\n    ret = ret.replace('}', '#7D');\n    ret = ret.replace('/', '#2F');\n    ret = ret.replace('%', '#25');\n    return ret.replace(' ', '#20');\n  }\n  /**\n   * Creates descendant font.\n   */\n\n\n  createDescendantFont() {\n    // Set property used to clone Font every time\n    this.descendantFont.isFont = true;\n    this.descendantFont.descendantFontBeginSave = new SaveDescendantFontEventHandler(this);\n    this.descendantFont.items.setValue(this.dictionaryProperties.type, new PdfName(this.dictionaryProperties.font));\n    this.descendantFont.items.setValue(this.dictionaryProperties.subtype, new PdfName(this.dictionaryProperties.cIDFontType2));\n    this.descendantFont.items.setValue(this.dictionaryProperties.baseFont, new PdfName(this.subsetName));\n    this.descendantFont.items.setValue(this.dictionaryProperties.cIDToGIDMap, new PdfName(this.dictionaryProperties.identity));\n    this.descendantFont.items.setValue(this.dictionaryProperties.dw, new PdfNumber(1000));\n    this.fontDescriptor = this.createFontDescriptor();\n    this.descendantFont.items.setValue(this.dictionaryProperties.fontDescriptor, new PdfReferenceHolder(this.fontDescriptor));\n    let systemInfo = this.createSystemInfo();\n    this.descendantFont.items.setValue(this.dictionaryProperties.cIDSystemInfo, systemInfo);\n  }\n  /**\n   * Creates font descriptor.\n   */\n\n\n  createFontDescriptor() {\n    let descriptor = new PdfDictionary();\n    let metrics = this.ttfReader.metrics; // Set property used to clone Font every time\n\n    descriptor.isFont = true;\n    descriptor.items.setValue(this.dictionaryProperties.type, new PdfName(this.dictionaryProperties.fontDescriptor));\n    descriptor.items.setValue(this.dictionaryProperties.fontName, new PdfName(this.subsetName));\n    descriptor.items.setValue(this.dictionaryProperties.flags, new PdfNumber(this.getDescriptorFlags()));\n    descriptor.items.setValue(this.dictionaryProperties.fontBBox, PdfArray.fromRectangle(this.getBoundBox()));\n    descriptor.items.setValue(this.dictionaryProperties.missingWidth, new PdfNumber(metrics.widthTable[32]));\n    descriptor.items.setValue(this.dictionaryProperties.stemV, new PdfNumber(metrics.stemV));\n    descriptor.items.setValue(this.dictionaryProperties.italicAngle, new PdfNumber(metrics.italicAngle));\n    descriptor.items.setValue(this.dictionaryProperties.capHeight, new PdfNumber(metrics.capHeight));\n    descriptor.items.setValue(this.dictionaryProperties.ascent, new PdfNumber(metrics.winAscent));\n    descriptor.items.setValue(this.dictionaryProperties.descent, new PdfNumber(metrics.winDescent));\n    descriptor.items.setValue(this.dictionaryProperties.leading, new PdfNumber(metrics.leading));\n    descriptor.items.setValue(this.dictionaryProperties.avgWidth, new PdfNumber(metrics.widthTable[32]));\n    descriptor.items.setValue(this.dictionaryProperties.fontFile2, new PdfReferenceHolder(this.fontProgram));\n    descriptor.items.setValue(this.dictionaryProperties.maxWidth, new PdfNumber(metrics.widthTable[32]));\n    descriptor.items.setValue(this.dictionaryProperties.xHeight, new PdfNumber(0));\n    descriptor.items.setValue(this.dictionaryProperties.stemH, new PdfNumber(0));\n    return descriptor;\n  }\n  /**\n   * Generates cmap.\n   * @private\n   */\n\n\n  createCmap() {\n    this.cmap.cmapBeginSave = new SaveCmapEventHandler(this);\n  }\n  /**\n   * Generates font dictionary.\n   */\n\n\n  createFontDictionary() {\n    // Set property used to clone Font every time\n    this.fontDictionary.isFont = true;\n    this.fontDictionary.fontDictionaryBeginSave = new SaveFontDictionaryEventHandler(this);\n    this.fontDictionary.items.setValue(this.dictionaryProperties.type, new PdfName(this.dictionaryProperties.font));\n    this.fontDictionary.items.setValue(this.dictionaryProperties.baseFont, new PdfName(this.subsetName));\n    this.fontDictionary.items.setValue(this.dictionaryProperties.subtype, new PdfName(this.dictionaryProperties.type0));\n    this.fontDictionary.items.setValue(this.dictionaryProperties.encoding, new PdfName(this.dictionaryProperties.identityH));\n    let descFonts = new PdfArray();\n    let reference = new PdfReferenceHolder(this.descendantFont); // Set property used to clone Font every time\n\n    descFonts.isFont = true;\n    descFonts.add(reference);\n    this.fontDictionary.items.setValue(this.dictionaryProperties.descendantFonts, descFonts);\n  }\n  /**\n   * Creates font program.\n   */\n\n\n  createFontProgram() {\n    this.fontProgram.fontProgramBeginSave = new SaveFontProgramEventHandler(this);\n  }\n  /**\n   * Creates system info dictionary for CID font.\n   * @private\n   */\n\n\n  createSystemInfo() {\n    let systemInfo = new PdfDictionary();\n    systemInfo.items.setValue(this.dictionaryProperties.registry, new PdfString('Adobe'));\n    systemInfo.items.setValue(this.dictionaryProperties.ordering, new PdfString(this.dictionaryProperties.identity));\n    systemInfo.items.setValue(this.dictionaryProperties.supplement, new PdfNumber(0));\n    return systemInfo;\n  }\n  /**\n   * Runs before font Dictionary will be saved.\n   */\n\n\n  descendantFontBeginSave() {\n    if (this.usedChars !== null && this.usedChars !== undefined && this.usedChars.size() > 0) {\n      let width = this.getDescendantWidth();\n\n      if (width !== null) {\n        this.descendantFont.items.setValue(this.dictionaryProperties.w, width);\n      }\n    }\n  }\n  /**\n   * Runs before font Dictionary will be saved.\n   */\n\n\n  cmapBeginSave() {\n    this.generateCmap();\n  }\n  /**\n   * Runs before font Dictionary will be saved.\n   */\n\n  /* tslint:disable */\n\n\n  fontDictionaryBeginSave() {\n    if (this.usedChars !== null && this.usedChars !== undefined && this.usedChars.size() > 0 && !this.fontDictionary.containsKey(this.dictionaryProperties.toUnicode)) {\n      this.fontDictionary.items.setValue(this.dictionaryProperties.toUnicode, new PdfReferenceHolder(this.cmap));\n    }\n  }\n  /* tslint:enable */\n\n  /**\n   * Runs before font program stream save.\n   */\n\n\n  fontProgramBeginSave() {\n    this.isCompress = true;\n    this.generateFontProgram();\n  }\n  /**\n   * Gets width description pad array for c i d font.\n   */\n\n\n  getDescendantWidth() {\n    let array = new PdfArray();\n\n    if (this.usedChars !== null && this.usedChars !== undefined && this.usedChars.size() > 0) {\n      let glyphInfo = []; // if (!this.isEmbedFont) {\n\n      let keys = this.usedChars.keys();\n\n      for (let i = 0; i < keys.length; i++) {\n        let chLen = keys[i];\n        let glyph = this.ttfReader.getGlyph(chLen);\n\n        if (glyph.empty) {\n          continue;\n        }\n\n        glyphInfo.push(glyph);\n      } // } else {\n      //     glyphInfo = this.ttfReader.getAllGlyphs();\n      // }\n\n\n      glyphInfo.sort((a, b) => a.index - b.index);\n      let firstGlyphIndex = 0;\n      let lastGlyphIndex = 0;\n      let firstGlyphIndexWasSet = false;\n      let widthDetails = new PdfArray(); // if (!this.isEmbedFont) {\n\n      for (let i = 0; i < glyphInfo.length; i++) {\n        let glyph = glyphInfo[i];\n\n        if (!firstGlyphIndexWasSet) {\n          firstGlyphIndexWasSet = true;\n          firstGlyphIndex = glyph.index;\n          lastGlyphIndex = glyph.index - 1;\n        }\n\n        if ((lastGlyphIndex + 1 !== glyph.index || i + 1 === glyphInfo.length) && glyphInfo.length > 1) {\n          // Add glyph index / width.\n          array.add(new PdfNumber(firstGlyphIndex));\n\n          if (i !== 0) {\n            array.add(widthDetails);\n          }\n\n          firstGlyphIndex = glyph.index;\n          widthDetails = new PdfArray();\n        }\n\n        widthDetails.add(new PdfNumber(glyph.width));\n\n        if (i + 1 === glyphInfo.length) {\n          array.add(new PdfNumber(firstGlyphIndex));\n          array.add(widthDetails);\n        }\n\n        lastGlyphIndex = glyph.index;\n      } // } else {\n      //     for (let i : number = 0; i < glyphInfo.length; i++) {\n      //         let glyph : TtfGlyphInfo = glyphInfo[i];\n      //         if (!firstGlyphIndexWasSet) {\n      //             firstGlyphIndexWasSet = true;\n      //             lastGlyphIndex = glyph.index - 1;\n      //         }\n      //         firstGlyphIndex = glyph.index;\n      //         if ((lastGlyphIndex + 1 === glyph.index || (i + 1 === glyphInfo.length)) && glyphInfo.length > 1) {\n      //             // Add glyph index / width.\n      //             widthDetails.add(new PdfNumber(glyph.width));\n      //             array.add(new PdfNumber(firstGlyphIndex));\n      //             array.add(widthDetails);\n      //             widthDetails = new PdfArray();\n      //         }\n      //         lastGlyphIndex = glyph.index;\n      //     }\n      // }\n\n    }\n\n    return array;\n  }\n  /**\n   * Creates cmap.\n   */\n\n\n  generateCmap() {\n    if (this.usedChars !== null && this.usedChars !== undefined && this.usedChars.size() > 0) {\n      let glyphChars = this.ttfReader.getGlyphChars(this.usedChars);\n\n      if (glyphChars.size() > 0) {\n        let keys = glyphChars.keys().sort(); // add first and last glyph indexes\n\n        let first = keys[0];\n        let last = keys[keys.length - 1];\n        let middlePart = this.toHexString(first, false) + this.toHexString(last, false) + Operators.newLine;\n        let builder = '';\n        builder += this.cmapPrefix;\n        builder += middlePart;\n        builder += this.cmapEndCodespaceRange;\n        let nextRange = 0;\n\n        for (let i = 0; i < keys.length; i++) {\n          if (nextRange === 0) {\n            if (i !== 0) {\n              builder += this.cmapEndRange;\n            }\n\n            nextRange = Math.min(100, keys.length - i);\n            builder += nextRange;\n            builder += Operators.whiteSpace;\n            builder += this.cmapBeginRange;\n          }\n\n          nextRange -= 1;\n          let key = keys[i];\n          /* tslint:disable */\n\n          builder += this.toHexString(key, true) + this.toHexString(key, true) + this.toHexString(glyphChars.getValue(key), true) + '\\n';\n          /* tslint:enable */\n        }\n\n        builder += this.cmapSuffix;\n        this.cmap.clearStream();\n        this.cmap.isFont = true;\n        this.cmap.write(builder);\n      }\n    }\n  }\n  /**\n   * Generates font program.\n   */\n\n\n  generateFontProgram() {\n    let fontProgram = null;\n    this.usedChars = this.usedChars === null || this.usedChars === undefined ? new Dictionary() : this.usedChars;\n    this.ttfReader.setOffset(0);\n    fontProgram = this.ttfReader.readFontProgram(this.usedChars);\n    this.fontProgram.clearStream();\n    this.fontProgram.isFont = true;\n    this.fontProgram.writeBytes(fontProgram);\n  }\n  /**\n   * Calculates flags for the font descriptor.\n   * @private\n   */\n\n\n  getDescriptorFlags() {\n    let flags = 0;\n    let metrics = this.ttfReader.metrics;\n\n    if (metrics.isFixedPitch) {\n      flags |= FontDescriptorFlags.FixedPitch;\n    }\n\n    if (metrics.isSymbol) {\n      flags |= FontDescriptorFlags.Symbolic;\n    } else {\n      flags |= FontDescriptorFlags.Nonsymbolic;\n    }\n\n    if (metrics.isItalic) {\n      flags |= FontDescriptorFlags.Italic;\n    }\n\n    if (metrics.isBold) {\n      flags |= FontDescriptorFlags.ForceBold;\n    }\n\n    return flags;\n  }\n  /**\n   * Calculates BoundBox of the descriptor.\n   * @private\n   */\n\n\n  getBoundBox() {\n    let rect = this.ttfReader.metrics.fontBox;\n    let width = Math.abs(rect.right - rect.left);\n    let height = Math.abs(rect.top - rect.bottom);\n    let rectangle = new RectangleF(rect.left, rect.bottom, width, height);\n    return rectangle;\n  }\n  /**\n   * Converts integer of decimal system to hex integer.\n   */\n\n\n  toHexString(n, isCaseChange) {\n    let s = n.toString(16);\n\n    if (isCaseChange) {\n      s = s.toUpperCase();\n    }\n\n    return '<0000'.substring(0, 5 - s.length) + s + '>';\n  }\n  /**\n   * Stores used symbols.\n   */\n\n\n  setSymbols(text) {\n    if (text === null) {\n      throw new Error('Argument Null Exception : text');\n    }\n\n    if (this.usedChars === null || this.usedChars === undefined) {\n      this.usedChars = new Dictionary();\n    }\n\n    for (let i = 0; i < text.length; i++) {\n      let ch = text[i];\n      this.usedChars.setValue(ch, String.fromCharCode(0));\n    } // else {\n    //     if (text === null) {\n    //         throw new Error('Argument Null Exception : glyphs');\n    //     }\n    //     if (this.usedChars === null || this.usedChars === undefined) {\n    //             this.usedChars = new Dictionary<string, string>();\n    //     }\n    //     for (let i : number = 0; i < text.length; i++) {\n    //         let glyphIndex : number = text[i];\n    //         let glyph : TtfGlyphInfo =  this.ttfReader.getGlyph(glyphIndex);\n    //         if (!glyph == null) {\n    //             let c : string = glyph.charCode.toLocaleString();\n    //             this.usedChars.setValue(c, String.fromCharCode(0));\n    //         }\n    //     }\n    // }\n\n\n    if (this.isEmbedFont === false) {\n      this.getDescendantWidth();\n    }\n  }\n\n}\n/**\n * ArabicShapeRenderer.ts class for EJ2-PDF\n */\n\n\nclass ArabicShapeRenderer {\n  //#endregion\n  //#region Constructor\n  constructor() {\n    //#region Constants\n    this.arabicCharTable = [['\\u0621', '\\uFE80'], ['\\u0622', '\\uFE81', '\\uFE82'], ['\\u0623', '\\uFE83', '\\uFE84'], ['\\u0624', '\\uFE85', '\\uFE86'], ['\\u0625', '\\uFE87', '\\uFE88'], ['\\u0626', '\\uFE89', '\\uFE8A', '\\uFE8B', '\\uFE8C'], ['\\u0627', '\\uFE8D', '\\uFE8E'], ['\\u0628', '\\uFE8F', '\\uFE90', '\\uFE91', '\\uFE92'], ['\\u0629', '\\uFE93', '\\uFE94'], ['\\u062A', '\\uFE95', '\\uFE96', '\\uFE97', '\\uFE98'], ['\\u062B', '\\uFE99', '\\uFE9A', '\\uFE9B', '\\uFE9C'], ['\\u062C', '\\uFE9D', '\\uFE9E', '\\uFE9F', '\\uFEA0'], ['\\u062D', '\\uFEA1', '\\uFEA2', '\\uFEA3', '\\uFEA4'], ['\\u062E', '\\uFEA5', '\\uFEA6', '\\uFEA7', '\\uFEA8'], ['\\u062F', '\\uFEA9', '\\uFEAA'], ['\\u0630', '\\uFEAB', '\\uFEAC'], ['\\u0631', '\\uFEAD', '\\uFEAE'], ['\\u0632', '\\uFEAF', '\\uFEB0'], ['\\u0633', '\\uFEB1', '\\uFEB2', '\\uFEB3', '\\uFEB4'], ['\\u0634', '\\uFEB5', '\\uFEB6', '\\uFEB7', '\\uFEB8'], ['\\u0635', '\\uFEB9', '\\uFEBA', '\\uFEBB', '\\uFEBC'], ['\\u0636', '\\uFEBD', '\\uFEBE', '\\uFEBF', '\\uFEC0'], ['\\u0637', '\\uFEC1', '\\uFEC2', '\\uFEC3', '\\uFEC4'], ['\\u0638', '\\uFEC5', '\\uFEC6', '\\uFEC7', '\\uFEC8'], ['\\u0639', '\\uFEC9', '\\uFECA', '\\uFECB', '\\uFECC'], ['\\u063A', '\\uFECD', '\\uFECE', '\\uFECF', '\\uFED0'], ['\\u0640', '\\u0640', '\\u0640', '\\u0640', '\\u0640'], ['\\u0641', '\\uFED1', '\\uFED2', '\\uFED3', '\\uFED4'], ['\\u0642', '\\uFED5', '\\uFED6', '\\uFED7', '\\uFED8'], ['\\u0643', '\\uFED9', '\\uFEDA', '\\uFEDB', '\\uFEDC'], ['\\u0644', '\\uFEDD', '\\uFEDE', '\\uFEDF', '\\uFEE0'], ['\\u0645', '\\uFEE1', '\\uFEE2', '\\uFEE3', '\\uFEE4'], ['\\u0646', '\\uFEE5', '\\uFEE6', '\\uFEE7', '\\uFEE8'], ['\\u0647', '\\uFEE9', '\\uFEEA', '\\uFEEB', '\\uFEEC'], ['\\u0648', '\\uFEED', '\\uFEEE'], ['\\u0649', '\\uFEEF', '\\uFEF0', '\\uFBE8', '\\uFBE9'], ['\\u064A', '\\uFEF1', '\\uFEF2', '\\uFEF3', '\\uFEF4'], ['\\u0671', '\\uFB50', '\\uFB51'], ['\\u0679', '\\uFB66', '\\uFB67', '\\uFB68', '\\uFB69'], ['\\u067A', '\\uFB5E', '\\uFB5F', '\\uFB60', '\\uFB61'], ['\\u067B', '\\uFB52', '\\uFB53', '\\uFB54', '\\uFB55'], ['\\u067E', '\\uFB56', '\\uFB57', '\\uFB58', '\\uFB59'], ['\\u067F', '\\uFB62', '\\uFB63', '\\uFB64', '\\uFB65'], ['\\u0680', '\\uFB5A', '\\uFB5B', '\\uFB5C', '\\uFB5D'], ['\\u0683', '\\uFB76', '\\uFB77', '\\uFB78', '\\uFB79'], ['\\u0684', '\\uFB72', '\\uFB73', '\\uFB74', '\\uFB75'], ['\\u0686', '\\uFB7A', '\\uFB7B', '\\uFB7C', '\\uFB7D'], ['\\u0687', '\\uFB7E', '\\uFB7F', '\\uFB80', '\\uFB81'], ['\\u0688', '\\uFB88', '\\uFB89'], ['\\u068C', '\\uFB84', '\\uFB85'], ['\\u068D', '\\uFB82', '\\uFB83'], ['\\u068E', '\\uFB86', '\\uFB87'], ['\\u0691', '\\uFB8C', '\\uFB8D'], ['\\u0698', '\\uFB8A', '\\uFB8B'], ['\\u06A4', '\\uFB6A', '\\uFB6B', '\\uFB6C', '\\uFB6D'], ['\\u06A6', '\\uFB6E', '\\uFB6F', '\\uFB70', '\\uFB71'], ['\\u06A9', '\\uFB8E', '\\uFB8F', '\\uFB90', '\\uFB91'], ['\\u06AD', '\\uFBD3', '\\uFBD4', '\\uFBD5', '\\uFBD6'], ['\\u06AF', '\\uFB92', '\\uFB93', '\\uFB94', '\\uFB95'], ['\\u06B1', '\\uFB9A', '\\uFB9B', '\\uFB9C', '\\uFB9D'], ['\\u06B3', '\\uFB96', '\\uFB97', '\\uFB98', '\\uFB99'], ['\\u06BA', '\\uFB9E', '\\uFB9F'], ['\\u06BB', '\\uFBA0', '\\uFBA1', '\\uFBA2', '\\uFBA3'], ['\\u06BE', '\\uFBAA', '\\uFBAB', '\\uFBAC', '\\uFBAD'], ['\\u06C0', '\\uFBA4', '\\uFBA5'], ['\\u06C1', '\\uFBA6', '\\uFBA7', '\\uFBA8', '\\uFBA9'], ['\\u06C5', '\\uFBE0', '\\uFBE1'], ['\\u06C6', '\\uFBD9', '\\uFBDA'], ['\\u06C7', '\\uFBD7', '\\uFBD8'], ['\\u06C8', '\\uFBDB', '\\uFBDC'], ['\\u06C9', '\\uFBE2', '\\uFBE3'], ['\\u06CB', '\\uFBDE', '\\uFBDF'], ['\\u06CC', '\\uFBFC', '\\uFBFD', '\\uFBFE', '\\uFBFF'], ['\\u06D0', '\\uFBE4', '\\uFBE5', '\\uFBE6', '\\uFBE7'], ['\\u06D2', '\\uFBAE', '\\uFBAF'], ['\\u06D3', '\\uFBB0', '\\uFBB1']];\n    this.alef = '\\u0627';\n    this.alefHamza = '\\u0623';\n    this.alefHamzaBelow = '\\u0625';\n    this.alefMadda = '\\u0622';\n    this.lam = '\\u0644';\n    this.hamza = '\\u0621';\n    this.zeroWidthJoiner = '\\u200D';\n    this.hamzaAbove = '\\u0654';\n    this.hamzaBelow = '\\u0655';\n    this.wawHamza = '\\u0624';\n    this.yehHamza = '\\u0626';\n    this.waw = '\\u0648';\n    this.alefMaksura = '\\u0649';\n    this.yeh = '\\u064A';\n    this.farsiYeh = '\\u06CC';\n    this.shadda = '\\u0651';\n    this.madda = '\\u0653';\n    this.lwa = '\\uFEFB';\n    this.lwawh = '\\uFEF7';\n    this.lwawhb = '\\uFEF9';\n    this.lwawm = '\\uFEF5';\n    this.bwhb = '\\u06D3';\n    this.fathatan = '\\u064B';\n    this.superScriptalef = '\\u0670';\n    this.vowel = 0x1; // #endregion\n    //#region Fields\n\n    this.arabicMapTable = new Dictionary();\n\n    for (let i = 0; i < this.arabicCharTable.length; i++) {\n      this.arabicMapTable.setValue(this.arabicCharTable[i][0], this.arabicCharTable[i]);\n    }\n  } //#endregion\n  //#region implementation\n\n\n  getCharacterShape(input, index) {\n    if (input >= this.hamza && input <= this.bwhb) {\n      let value = [];\n\n      if (this.arabicMapTable.getValue(input)) {\n        value = this.arabicMapTable.getValue(input);\n        return value[index + 1];\n      }\n    } else if (input >= this.lwawm && input <= this.lwa) {\n      return input;\n    }\n\n    return input;\n  }\n\n  shape(text, level) {\n    let builder = '';\n    let str2 = '';\n\n    for (let i = 0; i < text.length; i++) {\n      let c = text[i];\n\n      if (c >= '' && c <= '') {\n        //if(c>= 0x0600.toString() && c<= 0x06FF.toString()) {\n        str2 = str2 + c;\n      } else {\n        if (str2.length > 0) {\n          let st = this.doShape(str2.toString(), 0);\n          builder = builder + st;\n          str2 = '';\n        }\n\n        builder = builder + c;\n      }\n    }\n\n    if (str2.length > 0) {\n      let st = this.doShape(str2.toString(), 0);\n      builder = builder + st;\n    }\n\n    return builder.toString();\n  }\n\n  doShape(input, level) {\n    let str = '';\n    let ligature = 0;\n    let len = 0;\n    let i = 0;\n    let next = '';\n    let previous = new ArabicShape();\n    let present = new ArabicShape();\n\n    while (i < input.length) {\n      next = input[i++];\n      ligature = this.ligature(next, present);\n\n      if (ligature === 0) {\n        let shapeCount = this.getShapeCount(next);\n        len = shapeCount === 1 ? 0 : 2;\n\n        if (previous.Shapes > 2) {\n          len += 1;\n        }\n\n        len = len % present.Shapes;\n        present.Value = this.getCharacterShape(present.Value, len);\n        str = this.append(str, previous, level);\n        previous = present;\n        present = new ArabicShape();\n        present.Value = next;\n        present.Shapes = shapeCount;\n        present.Ligature++;\n      }\n    }\n\n    len = previous.Shapes > 2 ? 1 : 0;\n    len = len % present.Shapes;\n    present.Value = this.getCharacterShape(present.Value, len);\n    str = this.append(str, previous, level);\n    str = this.append(str, present, level);\n    return str.toString();\n  }\n\n  append(builder, shape, level) {\n    if (shape.Value !== '') {\n      builder = builder + shape.Value;\n      shape.Ligature -= 1;\n\n      if (shape.Type !== '') {\n        if ((level & this.vowel) === 0) {\n          builder = builder + shape.Type;\n          shape.Ligature -= 1;\n        } else {\n          shape.Ligature -= 1;\n        }\n      }\n\n      if (shape.vowel !== '') {\n        if ((level & this.vowel) === 0) {\n          builder = builder + shape.vowel;\n          shape.Ligature -= 1;\n        } else {\n          shape.Ligature -= 1;\n        }\n      }\n    }\n\n    return builder;\n  }\n\n  ligature(value, shape) {\n    if (shape.Value !== '') {\n      let result = 0;\n\n      if (value >= this.fathatan && value <= this.hamzaBelow || value === this.superScriptalef) {\n        result = 1;\n\n        if (shape.vowel !== '' && value !== this.shadda) {\n          result = 2;\n        }\n\n        if (value === this.shadda) {\n          if (shape.Type == null) {\n            shape.Type = this.shadda;\n          } else {\n            return 0;\n          }\n        } else if (value === this.hamzaBelow) {\n          if (shape.Value === this.alef) {\n            shape.Value = this.alefHamzaBelow;\n            result = 2;\n          } else if (value === this.lwa) {\n            shape.Value = this.lwawhb;\n            result = 2;\n          } else {\n            shape.Type = this.hamzaBelow;\n          }\n        } else if (value === this.hamzaAbove) {\n          if (shape.Value === this.alef) {\n            shape.Value = this.alefHamza;\n            result = 2;\n          } else if (shape.Value === this.lwa) {\n            shape.Value = this.lwawh;\n            result = 2;\n          } else if (shape.Value === this.waw) {\n            shape.Value = this.wawHamza;\n            result = 2;\n          } else if (shape.Value === this.yeh || shape.Value === this.alefMaksura || shape.Value === this.farsiYeh) {\n            shape.Value = this.yehHamza;\n            result = 2;\n          } else {\n            shape.Type = this.hamzaAbove;\n          }\n        } else if (value === this.madda) {\n          if (shape.Value === this.alef) {\n            shape.Value = this.alefMadda;\n            result = 2;\n          }\n        } else {\n          shape.vowel = value;\n        }\n\n        if (result === 1) {\n          shape.Ligature++;\n        }\n\n        return result;\n      }\n\n      if (shape.vowel !== '') {\n        return 0;\n      }\n\n      if (shape.Value === this.lam) {\n        if (value === this.alef) {\n          shape.Value = this.lwa;\n          shape.Shapes = 2;\n          result = 3;\n        } else if (value === this.alefHamza) {\n          shape.Value = this.lwawh;\n          shape.Shapes = 2;\n          result = 3;\n        } else if (value === this.alefHamzaBelow) {\n          shape.Value = this.lwawhb;\n          shape.Shapes = 2;\n          result = 3;\n        } else if (value === this.alefMadda) {\n          shape.Value = this.lwawm;\n          shape.Shapes = 2;\n          result = 3;\n        }\n      } // else if (shape.Value === '') {\n      //     shape.Value = value;\n      //     shape.Shapes = this.getShapeCount(value);\n      //     result = 1;\n      // }\n\n\n      return result;\n    } else {\n      return 0;\n    }\n  }\n\n  getShapeCount(shape) {\n    if (shape >= this.hamza && shape <= this.bwhb && !(shape >= this.fathatan && shape <= this.hamzaBelow || shape === this.superScriptalef)) {\n      let c = [];\n\n      if (this.arabicMapTable.getValue(shape)) {\n        c = this.arabicMapTable.getValue(shape);\n        return c.length - 1;\n      }\n    } else if (shape === this.zeroWidthJoiner) {\n      return 4;\n    }\n\n    return 1;\n  }\n\n} //#endregion\n//#region Internals\n\n\nclass ArabicShape {\n  constructor() {\n    //#region Fields\n    this.shapeValue = '';\n    this.shapeType = '';\n    this.shapeVowel = '';\n    this.shapeLigature = 0;\n    this.shapeShapes = 1; //#endregion\n  } //#endregion\n  //#region Properties \n\n  /**\n   * Gets or sets the values.\n   * @private\n   */\n\n\n  get Value() {\n    return this.shapeValue;\n  }\n\n  set Value(value) {\n    this.shapeValue = value;\n  }\n  /**\n   * Gets or sets the values.\n   * @private\n   */\n\n\n  get Type() {\n    return this.shapeType;\n  }\n\n  set Type(value) {\n    this.shapeType = value;\n  }\n  /**\n   * Gets or sets the values.\n   * @private\n   */\n\n\n  get vowel() {\n    return this.shapeVowel;\n  }\n\n  set vowel(value) {\n    this.shapeVowel = value;\n  }\n  /**\n   * Gets or sets the values.\n   * @private\n   */\n\n\n  get Ligature() {\n    return this.shapeLigature;\n  }\n\n  set Ligature(value) {\n    this.shapeLigature = value;\n  }\n  /**\n   * Gets or sets the values.\n   * @private\n   */\n\n\n  get Shapes() {\n    return this.shapeShapes;\n  }\n\n  set Shapes(value) {\n    this.shapeShapes = value;\n  }\n\n} //#endregion\n\n/**\n * Bidi.ts class for EJ2-PDF\n */\n\n/**\n * `Metrics` of the font.\n * @private\n */\n\n\nclass Bidi {\n  //#endregion\n  //#region Constructor\n  constructor() {\n    //#region Fields\n    this.indexes = [];\n    this.indexLevels = [];\n    this.mirroringShapeCharacters = new Dictionary();\n    this.update();\n  } //#endregion\n  //#region implementation\n\n\n  doMirrorShaping(text) {\n    let result = [];\n\n    for (let i = 0; i < text.length; i++) {\n      if ((this.indexLevels[i] & 1) === 1 && this.mirroringShapeCharacters.containsKey(text[i].charCodeAt(0))) {\n        result[i] = String.fromCharCode(this.mirroringShapeCharacters.getValue(text[i].charCodeAt(0)));\n      } else {\n        result[i] = text[i].toString();\n      }\n    }\n\n    let res = '';\n\n    for (let j = 0; j < result.length; j++) {\n      res = res + result[j];\n    }\n\n    return res;\n  }\n\n  getLogicalToVisualString(inputText, isRtl) {\n    let rtlCharacters = new RtlCharacters();\n    this.indexLevels = rtlCharacters.getVisualOrder(inputText, isRtl);\n    this.setDefaultIndexLevel();\n    this.doOrder(0, this.indexLevels.length - 1);\n    let text = this.doMirrorShaping(inputText); //let text : string = inputText;\n\n    let resultBuilder = '';\n\n    for (let i = 0; i < this.indexes.length; i++) {\n      let index = this.indexes[i];\n      resultBuilder += text[index];\n    }\n\n    return resultBuilder.toString();\n  }\n\n  setDefaultIndexLevel() {\n    for (let i = 0; i < this.indexLevels.length; i++) {\n      this.indexes[i] = i;\n    }\n  }\n\n  doOrder(sIndex, eIndex) {\n    let max = this.indexLevels[sIndex];\n    let min = max;\n    let odd = max;\n    let even = max;\n\n    for (let i = sIndex + 1; i <= eIndex; ++i) {\n      let data = this.indexLevels[i];\n\n      if (data > max) {\n        max = data;\n      } else if (data < min) {\n        min = data;\n      }\n\n      odd &= data;\n      even |= data;\n    }\n\n    if ((even & 1) === 0) {\n      return;\n    }\n\n    if ((odd & 1) === 1) {\n      this.reArrange(sIndex, eIndex + 1);\n      return;\n    }\n\n    min |= 1;\n\n    while (max >= min) {\n      let pstart = sIndex;\n      /*tslint:disable:no-constant-condition */\n\n      while (true) {\n        while (pstart <= eIndex) {\n          if (this.indexLevels[pstart] >= max) {\n            break;\n          }\n\n          pstart += 1;\n        }\n\n        if (pstart > eIndex) {\n          break;\n        }\n\n        let pend = pstart + 1;\n\n        while (pend <= eIndex) {\n          if (this.indexLevels[pend] < max) {\n            break;\n          }\n\n          pend += 1;\n        }\n\n        this.reArrange(pstart, pend);\n        pstart = pend + 1;\n      }\n\n      max -= 1;\n    }\n  }\n\n  reArrange(i, j) {\n    let length = (i + j) / 2;\n    --j;\n\n    for (; i < length; ++i, --j) {\n      let temp = this.indexes[i];\n      this.indexes[i] = this.indexes[j];\n      this.indexes[j] = temp;\n    }\n  }\n\n  update() {\n    this.mirroringShapeCharacters.setValue(40, 41);\n    this.mirroringShapeCharacters.setValue(41, 40);\n    this.mirroringShapeCharacters.setValue(60, 62);\n    this.mirroringShapeCharacters.setValue(62, 60);\n    this.mirroringShapeCharacters.setValue(91, 93);\n    this.mirroringShapeCharacters.setValue(93, 91);\n    this.mirroringShapeCharacters.setValue(123, 125);\n    this.mirroringShapeCharacters.setValue(125, 123);\n    this.mirroringShapeCharacters.setValue(171, 187);\n    this.mirroringShapeCharacters.setValue(187, 171);\n    this.mirroringShapeCharacters.setValue(8249, 8250);\n    this.mirroringShapeCharacters.setValue(8250, 8249);\n    this.mirroringShapeCharacters.setValue(8261, 8262);\n    this.mirroringShapeCharacters.setValue(8262, 8261);\n    this.mirroringShapeCharacters.setValue(8317, 8318);\n    this.mirroringShapeCharacters.setValue(8318, 8317);\n    this.mirroringShapeCharacters.setValue(8333, 8334);\n    this.mirroringShapeCharacters.setValue(8334, 8333);\n    this.mirroringShapeCharacters.setValue(8712, 8715);\n    this.mirroringShapeCharacters.setValue(8713, 8716);\n    this.mirroringShapeCharacters.setValue(8714, 8717);\n    this.mirroringShapeCharacters.setValue(8715, 8712);\n    this.mirroringShapeCharacters.setValue(8716, 8713);\n    this.mirroringShapeCharacters.setValue(8717, 8714);\n    this.mirroringShapeCharacters.setValue(8725, 10741);\n    this.mirroringShapeCharacters.setValue(8764, 8765);\n    this.mirroringShapeCharacters.setValue(8765, 8764);\n    this.mirroringShapeCharacters.setValue(8771, 8909);\n    this.mirroringShapeCharacters.setValue(8786, 8787);\n    this.mirroringShapeCharacters.setValue(8787, 8786);\n    this.mirroringShapeCharacters.setValue(8788, 8789);\n    this.mirroringShapeCharacters.setValue(8789, 8788);\n    this.mirroringShapeCharacters.setValue(8804, 8805);\n    this.mirroringShapeCharacters.setValue(8805, 8804);\n    this.mirroringShapeCharacters.setValue(8806, 8807);\n    this.mirroringShapeCharacters.setValue(8807, 8806);\n    this.mirroringShapeCharacters.setValue(8808, 8809);\n    this.mirroringShapeCharacters.setValue(8809, 8808);\n    this.mirroringShapeCharacters.setValue(8810, 8811);\n    this.mirroringShapeCharacters.setValue(8811, 8810);\n    this.mirroringShapeCharacters.setValue(8814, 8815);\n    this.mirroringShapeCharacters.setValue(8815, 8814);\n    this.mirroringShapeCharacters.setValue(8816, 8817);\n    this.mirroringShapeCharacters.setValue(8817, 8816);\n    this.mirroringShapeCharacters.setValue(8818, 8819);\n    this.mirroringShapeCharacters.setValue(8819, 8818);\n    this.mirroringShapeCharacters.setValue(8820, 8821);\n    this.mirroringShapeCharacters.setValue(8821, 8820);\n    this.mirroringShapeCharacters.setValue(8822, 8823);\n    this.mirroringShapeCharacters.setValue(8823, 8822);\n    this.mirroringShapeCharacters.setValue(8824, 8825);\n    this.mirroringShapeCharacters.setValue(8825, 8824);\n    this.mirroringShapeCharacters.setValue(8826, 8827);\n    this.mirroringShapeCharacters.setValue(8827, 8826);\n    this.mirroringShapeCharacters.setValue(8828, 8829);\n    this.mirroringShapeCharacters.setValue(8829, 8828);\n    this.mirroringShapeCharacters.setValue(8830, 8831);\n    this.mirroringShapeCharacters.setValue(8831, 8830);\n    this.mirroringShapeCharacters.setValue(8832, 8833);\n    this.mirroringShapeCharacters.setValue(8833, 8832);\n    this.mirroringShapeCharacters.setValue(8834, 8835);\n    this.mirroringShapeCharacters.setValue(8835, 8834);\n    this.mirroringShapeCharacters.setValue(8836, 8837);\n    this.mirroringShapeCharacters.setValue(8837, 8836);\n    this.mirroringShapeCharacters.setValue(8838, 8839);\n    this.mirroringShapeCharacters.setValue(8839, 8838);\n    this.mirroringShapeCharacters.setValue(8840, 8841);\n    this.mirroringShapeCharacters.setValue(8841, 8840);\n    this.mirroringShapeCharacters.setValue(8842, 8843);\n    this.mirroringShapeCharacters.setValue(8843, 8842);\n    this.mirroringShapeCharacters.setValue(8847, 8848);\n    this.mirroringShapeCharacters.setValue(8848, 8847);\n    this.mirroringShapeCharacters.setValue(8849, 8850);\n    this.mirroringShapeCharacters.setValue(8850, 8849);\n    this.mirroringShapeCharacters.setValue(8856, 10680);\n    this.mirroringShapeCharacters.setValue(8866, 8867);\n    this.mirroringShapeCharacters.setValue(8867, 8866);\n    this.mirroringShapeCharacters.setValue(8870, 10974);\n    this.mirroringShapeCharacters.setValue(8872, 10980);\n    this.mirroringShapeCharacters.setValue(8873, 10979);\n    this.mirroringShapeCharacters.setValue(8875, 10981);\n    this.mirroringShapeCharacters.setValue(8880, 8881);\n    this.mirroringShapeCharacters.setValue(8881, 8880);\n    this.mirroringShapeCharacters.setValue(8882, 8883);\n    this.mirroringShapeCharacters.setValue(8883, 8882);\n    this.mirroringShapeCharacters.setValue(8884, 8885);\n    this.mirroringShapeCharacters.setValue(8885, 8884);\n    /*tslint:disable:max-func-body-length */\n\n    this.mirroringShapeCharacters.setValue(8886, 8887);\n    this.mirroringShapeCharacters.setValue(8887, 8886);\n    this.mirroringShapeCharacters.setValue(8905, 8906);\n    this.mirroringShapeCharacters.setValue(8906, 8905);\n    this.mirroringShapeCharacters.setValue(8907, 8908);\n    this.mirroringShapeCharacters.setValue(8908, 8907);\n    this.mirroringShapeCharacters.setValue(8909, 8771);\n    this.mirroringShapeCharacters.setValue(8912, 8913);\n    this.mirroringShapeCharacters.setValue(8913, 8912);\n    this.mirroringShapeCharacters.setValue(8918, 8919);\n    this.mirroringShapeCharacters.setValue(8919, 8918);\n    this.mirroringShapeCharacters.setValue(8920, 8921);\n    this.mirroringShapeCharacters.setValue(8921, 8920);\n    this.mirroringShapeCharacters.setValue(8922, 8923);\n    this.mirroringShapeCharacters.setValue(8923, 8922);\n    this.mirroringShapeCharacters.setValue(8924, 8925);\n    this.mirroringShapeCharacters.setValue(8925, 8924);\n    this.mirroringShapeCharacters.setValue(8926, 8927);\n    this.mirroringShapeCharacters.setValue(8927, 8926);\n    this.mirroringShapeCharacters.setValue(8928, 8929);\n    this.mirroringShapeCharacters.setValue(8929, 8928);\n    this.mirroringShapeCharacters.setValue(8930, 8931);\n    this.mirroringShapeCharacters.setValue(8931, 8930);\n    this.mirroringShapeCharacters.setValue(8932, 8933);\n    this.mirroringShapeCharacters.setValue(8933, 8932);\n    this.mirroringShapeCharacters.setValue(8934, 8935);\n    this.mirroringShapeCharacters.setValue(8935, 8934);\n    this.mirroringShapeCharacters.setValue(8936, 8937);\n    this.mirroringShapeCharacters.setValue(8937, 8936);\n    this.mirroringShapeCharacters.setValue(8938, 8939);\n    this.mirroringShapeCharacters.setValue(8939, 8938);\n    this.mirroringShapeCharacters.setValue(8940, 8941);\n    this.mirroringShapeCharacters.setValue(8941, 8940);\n    this.mirroringShapeCharacters.setValue(8944, 8945);\n    this.mirroringShapeCharacters.setValue(8945, 8944);\n    this.mirroringShapeCharacters.setValue(8946, 8954);\n    this.mirroringShapeCharacters.setValue(8947, 8955);\n    this.mirroringShapeCharacters.setValue(8948, 8956);\n    this.mirroringShapeCharacters.setValue(8950, 8957);\n    this.mirroringShapeCharacters.setValue(8951, 8958);\n    this.mirroringShapeCharacters.setValue(8954, 8946);\n    this.mirroringShapeCharacters.setValue(8955, 8947);\n    this.mirroringShapeCharacters.setValue(8956, 8948);\n    this.mirroringShapeCharacters.setValue(8957, 8950);\n    this.mirroringShapeCharacters.setValue(8958, 8951);\n    this.mirroringShapeCharacters.setValue(8968, 8969);\n    this.mirroringShapeCharacters.setValue(8969, 8968);\n    this.mirroringShapeCharacters.setValue(8970, 8971);\n    this.mirroringShapeCharacters.setValue(8971, 8970);\n    this.mirroringShapeCharacters.setValue(9001, 9002);\n    this.mirroringShapeCharacters.setValue(9002, 9001);\n    this.mirroringShapeCharacters.setValue(10088, 10089);\n    this.mirroringShapeCharacters.setValue(10089, 10088);\n    this.mirroringShapeCharacters.setValue(10090, 10091);\n    this.mirroringShapeCharacters.setValue(10091, 10090);\n    this.mirroringShapeCharacters.setValue(10092, 10093);\n    this.mirroringShapeCharacters.setValue(10093, 10092);\n    this.mirroringShapeCharacters.setValue(10094, 10095);\n    this.mirroringShapeCharacters.setValue(10095, 10094);\n    this.mirroringShapeCharacters.setValue(10096, 10097);\n    this.mirroringShapeCharacters.setValue(10097, 10096);\n    this.mirroringShapeCharacters.setValue(10098, 10099);\n    this.mirroringShapeCharacters.setValue(10099, 10098);\n    this.mirroringShapeCharacters.setValue(10100, 10101);\n    this.mirroringShapeCharacters.setValue(10101, 10100);\n    this.mirroringShapeCharacters.setValue(10197, 10198);\n    this.mirroringShapeCharacters.setValue(10198, 10197);\n    this.mirroringShapeCharacters.setValue(10205, 10206);\n    this.mirroringShapeCharacters.setValue(10206, 10205);\n    this.mirroringShapeCharacters.setValue(10210, 10211);\n    this.mirroringShapeCharacters.setValue(10211, 10210);\n    this.mirroringShapeCharacters.setValue(10212, 10213);\n    this.mirroringShapeCharacters.setValue(10213, 10212);\n    this.mirroringShapeCharacters.setValue(10214, 10215);\n    this.mirroringShapeCharacters.setValue(10215, 10214);\n    this.mirroringShapeCharacters.setValue(10216, 10217);\n    this.mirroringShapeCharacters.setValue(10217, 10216);\n    this.mirroringShapeCharacters.setValue(10218, 10219);\n    this.mirroringShapeCharacters.setValue(10219, 10218);\n    this.mirroringShapeCharacters.setValue(10627, 10628);\n    this.mirroringShapeCharacters.setValue(10628, 10627);\n    this.mirroringShapeCharacters.setValue(10629, 10630);\n    this.mirroringShapeCharacters.setValue(10630, 10629);\n    this.mirroringShapeCharacters.setValue(10631, 10632);\n    this.mirroringShapeCharacters.setValue(10632, 10631);\n    this.mirroringShapeCharacters.setValue(10633, 10634);\n    this.mirroringShapeCharacters.setValue(10634, 10633);\n    this.mirroringShapeCharacters.setValue(10635, 10636);\n    this.mirroringShapeCharacters.setValue(10636, 10635);\n    this.mirroringShapeCharacters.setValue(10637, 10640);\n    this.mirroringShapeCharacters.setValue(10638, 10639);\n    this.mirroringShapeCharacters.setValue(10639, 10638);\n    this.mirroringShapeCharacters.setValue(10640, 10637);\n    this.mirroringShapeCharacters.setValue(10641, 10642);\n    this.mirroringShapeCharacters.setValue(10642, 10641);\n    this.mirroringShapeCharacters.setValue(10643, 10644);\n    this.mirroringShapeCharacters.setValue(10644, 10643);\n    this.mirroringShapeCharacters.setValue(10645, 10646);\n    this.mirroringShapeCharacters.setValue(10646, 10645);\n    this.mirroringShapeCharacters.setValue(10647, 10648);\n    this.mirroringShapeCharacters.setValue(10648, 10647);\n    this.mirroringShapeCharacters.setValue(10680, 8856);\n    this.mirroringShapeCharacters.setValue(10688, 10689);\n    this.mirroringShapeCharacters.setValue(10689, 10688);\n    this.mirroringShapeCharacters.setValue(10692, 10693);\n    this.mirroringShapeCharacters.setValue(10693, 10692);\n    this.mirroringShapeCharacters.setValue(10703, 10704);\n    this.mirroringShapeCharacters.setValue(10704, 10703);\n    this.mirroringShapeCharacters.setValue(10705, 10706);\n    this.mirroringShapeCharacters.setValue(10706, 10705);\n    this.mirroringShapeCharacters.setValue(10708, 10709);\n    this.mirroringShapeCharacters.setValue(10709, 10708);\n    this.mirroringShapeCharacters.setValue(10712, 10713);\n    this.mirroringShapeCharacters.setValue(10713, 10712);\n    this.mirroringShapeCharacters.setValue(10714, 10715);\n    this.mirroringShapeCharacters.setValue(10715, 10714);\n    this.mirroringShapeCharacters.setValue(10741, 8725);\n    this.mirroringShapeCharacters.setValue(10744, 10745);\n    this.mirroringShapeCharacters.setValue(10745, 10744);\n    this.mirroringShapeCharacters.setValue(10748, 10749);\n    this.mirroringShapeCharacters.setValue(10749, 10748);\n    this.mirroringShapeCharacters.setValue(10795, 10796);\n    this.mirroringShapeCharacters.setValue(10796, 10795);\n    this.mirroringShapeCharacters.setValue(10797, 10796);\n    this.mirroringShapeCharacters.setValue(10798, 10797);\n    this.mirroringShapeCharacters.setValue(10804, 10805);\n    this.mirroringShapeCharacters.setValue(10805, 10804);\n    this.mirroringShapeCharacters.setValue(10812, 10813);\n    this.mirroringShapeCharacters.setValue(10813, 10812);\n    this.mirroringShapeCharacters.setValue(10852, 10853);\n    this.mirroringShapeCharacters.setValue(10853, 10852);\n    this.mirroringShapeCharacters.setValue(10873, 10874);\n    this.mirroringShapeCharacters.setValue(10874, 10873);\n    this.mirroringShapeCharacters.setValue(10877, 10878);\n    this.mirroringShapeCharacters.setValue(10878, 10877);\n    this.mirroringShapeCharacters.setValue(10879, 10880);\n    this.mirroringShapeCharacters.setValue(10880, 10879);\n    this.mirroringShapeCharacters.setValue(10881, 10882);\n    this.mirroringShapeCharacters.setValue(10882, 10881);\n    this.mirroringShapeCharacters.setValue(10883, 10884);\n    this.mirroringShapeCharacters.setValue(10884, 10883);\n    this.mirroringShapeCharacters.setValue(10891, 10892);\n    this.mirroringShapeCharacters.setValue(10892, 10891);\n    this.mirroringShapeCharacters.setValue(10897, 10898);\n    this.mirroringShapeCharacters.setValue(10898, 10897);\n    this.mirroringShapeCharacters.setValue(10899, 10900);\n    this.mirroringShapeCharacters.setValue(10900, 10899);\n    this.mirroringShapeCharacters.setValue(10901, 10902);\n    this.mirroringShapeCharacters.setValue(10902, 10901);\n    this.mirroringShapeCharacters.setValue(10903, 10904);\n    this.mirroringShapeCharacters.setValue(10904, 10903);\n    this.mirroringShapeCharacters.setValue(10905, 10906);\n    this.mirroringShapeCharacters.setValue(10906, 10905);\n    this.mirroringShapeCharacters.setValue(10907, 10908);\n    this.mirroringShapeCharacters.setValue(10908, 10907);\n    this.mirroringShapeCharacters.setValue(10913, 10914);\n    this.mirroringShapeCharacters.setValue(10914, 10913);\n    this.mirroringShapeCharacters.setValue(10918, 10919);\n    this.mirroringShapeCharacters.setValue(10919, 10918);\n    this.mirroringShapeCharacters.setValue(10920, 10921);\n    this.mirroringShapeCharacters.setValue(10921, 10920);\n    this.mirroringShapeCharacters.setValue(10922, 10923);\n    this.mirroringShapeCharacters.setValue(10923, 10922);\n    this.mirroringShapeCharacters.setValue(10924, 10925);\n    this.mirroringShapeCharacters.setValue(10925, 10924);\n    this.mirroringShapeCharacters.setValue(10927, 10928);\n    this.mirroringShapeCharacters.setValue(10928, 10927);\n    this.mirroringShapeCharacters.setValue(10931, 10932);\n    this.mirroringShapeCharacters.setValue(10932, 10931);\n    this.mirroringShapeCharacters.setValue(10939, 10940);\n    this.mirroringShapeCharacters.setValue(10940, 10939);\n    this.mirroringShapeCharacters.setValue(10941, 10942);\n    this.mirroringShapeCharacters.setValue(10942, 10941);\n    this.mirroringShapeCharacters.setValue(10943, 10944);\n    this.mirroringShapeCharacters.setValue(10944, 10943);\n    this.mirroringShapeCharacters.setValue(10945, 10946);\n    this.mirroringShapeCharacters.setValue(10946, 10945);\n    this.mirroringShapeCharacters.setValue(10947, 10948);\n    this.mirroringShapeCharacters.setValue(10948, 10947);\n    this.mirroringShapeCharacters.setValue(10949, 10950);\n    this.mirroringShapeCharacters.setValue(10950, 10949);\n    this.mirroringShapeCharacters.setValue(10957, 10958);\n    this.mirroringShapeCharacters.setValue(10958, 10957);\n    this.mirroringShapeCharacters.setValue(10959, 10960);\n    this.mirroringShapeCharacters.setValue(10960, 10959);\n    this.mirroringShapeCharacters.setValue(10961, 10962);\n    this.mirroringShapeCharacters.setValue(10962, 10961);\n    this.mirroringShapeCharacters.setValue(10963, 10964);\n    this.mirroringShapeCharacters.setValue(10964, 10963);\n    this.mirroringShapeCharacters.setValue(10965, 10966);\n    this.mirroringShapeCharacters.setValue(10966, 10965);\n    this.mirroringShapeCharacters.setValue(10974, 8870);\n    this.mirroringShapeCharacters.setValue(10979, 8873);\n    this.mirroringShapeCharacters.setValue(10980, 8872);\n    this.mirroringShapeCharacters.setValue(10981, 8875);\n    this.mirroringShapeCharacters.setValue(10988, 10989);\n    this.mirroringShapeCharacters.setValue(10989, 10988);\n    this.mirroringShapeCharacters.setValue(10999, 11000);\n    this.mirroringShapeCharacters.setValue(11000, 10999);\n    this.mirroringShapeCharacters.setValue(11001, 11002);\n    this.mirroringShapeCharacters.setValue(11002, 11001);\n    this.mirroringShapeCharacters.setValue(12296, 12297);\n    this.mirroringShapeCharacters.setValue(12297, 12296);\n    this.mirroringShapeCharacters.setValue(12298, 12299);\n    this.mirroringShapeCharacters.setValue(12299, 12298);\n    this.mirroringShapeCharacters.setValue(12300, 12301);\n    this.mirroringShapeCharacters.setValue(12301, 12300);\n    this.mirroringShapeCharacters.setValue(12302, 12303);\n    this.mirroringShapeCharacters.setValue(12303, 12302);\n    this.mirroringShapeCharacters.setValue(12304, 12305);\n    this.mirroringShapeCharacters.setValue(12305, 12304);\n    this.mirroringShapeCharacters.setValue(12308, 12309);\n    this.mirroringShapeCharacters.setValue(12309, 12308);\n    this.mirroringShapeCharacters.setValue(12310, 12311);\n    this.mirroringShapeCharacters.setValue(12311, 12310);\n    this.mirroringShapeCharacters.setValue(12312, 12313);\n    this.mirroringShapeCharacters.setValue(12313, 12312);\n    this.mirroringShapeCharacters.setValue(12314, 12315);\n    this.mirroringShapeCharacters.setValue(12315, 12314);\n    this.mirroringShapeCharacters.setValue(65288, 65289);\n    this.mirroringShapeCharacters.setValue(65289, 65288);\n    this.mirroringShapeCharacters.setValue(65308, 65310);\n    this.mirroringShapeCharacters.setValue(65310, 65308);\n    this.mirroringShapeCharacters.setValue(65339, 65341);\n    this.mirroringShapeCharacters.setValue(65341, 65339);\n    this.mirroringShapeCharacters.setValue(65371, 65373);\n    this.mirroringShapeCharacters.setValue(65373, 65371);\n    this.mirroringShapeCharacters.setValue(65375, 65376);\n    this.mirroringShapeCharacters.setValue(65376, 65375);\n    this.mirroringShapeCharacters.setValue(65378, 65379);\n    this.mirroringShapeCharacters.setValue(65379, 65378);\n  }\n\n}\n\nclass RtlCharacters {\n  //#endregion\n  //#region constructors\n  constructor() {\n    //#region fields\n    /// <summary>\n    /// Specifies the character types.\n    /// </summary>\n    this.types = []; /// <summary>\n    /// Specifies the text order (RTL or LTR).\n    /// </summary>\n\n    this.textOrder = -1; /// <summary>\n    /// Specifies the RTL character types.\n    /// </summary>\n\n    /* tslint:disable-next-line:prefer-array-literal */\n\n    this.rtlCharacterTypes = new Array(65536); //#endregion\n    //#region constants\n    /// <summary>\n    /// Left-to-Right (Non-European or non-Arabic digits).\n    /// </summary>\n\n    this.L = 0; /// <summary>\n    /// Left-to-Right Embedding\n    /// </summary>\n\n    this.LRE = 1; /// <summary>\n    /// Left-to-Right Override\n    /// </summary>\n\n    this.LRO = 2; /// <summary>\n    /// Right-to-Left (Hebrew alphabet, and related punctuation).\n    /// </summary>\n\n    this.R = 3; /// <summary>\n    /// Right-to-Left Arabic \n    /// </summary>\n\n    this.AL = 4; /// <summary>\n    /// Right-to-Left Embedding.\n    /// </summary>\n\n    this.RLE = 5; /// <summary>\n    /// Right-to-Left Override\n    /// </summary>\n\n    this.RLO = 6; /// <summary>\n    /// Pop Directional Format\n    /// </summary>\n\n    this.PDF = 7; /// <summary>\n    /// European Number (European digits, Eastern Arabic-Indic digits).\n    /// </summary>\n\n    this.EN = 8; /// <summary>\n    /// European Number Separator (Plus sign, Minus sign).\n    /// </summary>\n\n    this.ES = 9; /// <summary>\n    /// European Number Terminator (Degree sign, currency symbols).\n    /// </summary>\n\n    this.ET = 10; /// <summary>\n    /// Arabic Number (Arabic-Indic digits, Arabic decimal and thousands separators).\n    /// </summary>\n\n    this.AN = 11; /// <summary>\n    /// Common Number Separator (Colon, Comma, Full Stop, No-Break Space.\n    /// </summary>\n\n    this.CS = 12; /// <summary>\n    /// Nonspacing Mark (Characters with the General_Category values).\n    /// </summary>\n\n    this.NSM = 13; /// <summary>\n    /// Boundary Neutral (Default ignorables, non-characters, and control characters, other than those explicitly given other types.)\n    /// </summary>\n\n    this.BN = 14; /// <summary>\n    /// Paragraph Separator (Paragraph separator, appropriate Newline Functions, higher-level protocol paragraph determination).\n    /// </summary>\n\n    this.B = 15; /// <summary>\n    /// \tSegment Separator (tab).\n    /// </summary>\n\n    this.S = 16; /// <summary>\n    /// Whitespace (Space, Figure space, Line separator, Form feed, General Punctuation spaces).\n    /// </summary>\n\n    this.WS = 17; /// <summary>\n    /// Other Neutrals (All other characters, including object replacement character).\n    /// </summary>\n\n    this.ON = 18; /// <summary>\n    /// RTL character types.\n    /// </summary>\n\n    this.charTypes = [this.L, this.EN, this.BN, this.ES, this.ES, this.S, this.ET, this.ET, this.B, this.AN, this.AN, this.S, this.CS, this.CS, this.WS, this.NSM, this.NSM, this.B, this.BN, 27, this.BN, 28, 30, this.B, 31, 31, this.S, 32, 32, this.WS, 33, 34, this.ON, 35, 37, this.ET, 38, 42, this.ON, 43, 43, this.ET, 44, 44, this.CS, 45, 45, this.ET, 46, 46, this.CS, 47, 47, this.CS, 48, 57, this.EN, 58, 58, this.CS, 59, 64, this.ON, 65, 90, this.L, 91, 96, this.ON, 97, 122, this.L, 123, 126, this.ON, 127, 132, this.BN, 133, 133, this.B, 134, 159, this.BN, 160, 160, this.CS, 161, 161, this.ON, 162, 165, this.ET, 166, 169, this.ON, 170, 170, this.L, 171, 175, this.ON, 176, 177, this.ET, 178, 179, this.EN, 180, 180, this.ON, 181, 181, this.L, 182, 184, this.ON, 185, 185, this.EN, 186, 186, this.L, 187, 191, this.ON, 192, 214, this.L, 215, 215, this.ON, 216, 246, this.L, 247, 247, this.ON, 248, 696, this.L, 697, 698, this.ON, 699, 705, this.L, 706, 719, this.ON, 720, 721, this.L, 722, 735, this.ON, 736, 740, this.L, 741, 749, this.ON, 750, 750, this.L, 751, 767, this.ON, 768, 855, this.NSM, 856, 860, this.L, 861, 879, this.NSM, 880, 883, this.L, 884, 885, this.ON, 886, 893, this.L, 894, 894, this.ON, 895, 899, this.L, 900, 901, this.ON, 902, 902, this.L, 903, 903, this.ON, 904, 1013, this.L, 1014, 1014, this.ON, 1015, 1154, this.L, 1155, 1158, this.NSM, 1159, 1159, this.L, 1160, 1161, this.NSM, 1162, 1417, this.L, 1418, 1418, this.ON, 1419, 1424, this.L, 1425, 1441, this.NSM, 1442, 1442, this.L, 1443, 1465, this.NSM, 1466, 1466, this.L, 1467, 1469, this.NSM, 1470, 1470, this.R, 1471, 1471, this.NSM, 1472, 1472, this.R, 1473, 1474, this.NSM, 1475, 1475, this.R, 1476, 1476, this.NSM, 1477, 1487, this.L, 1488, 1514, this.R, 1515, 1519, this.L, 1520, 1524, this.R, 1525, 1535, this.L, 1536, 1539, this.AL, 1540, 1547, this.L, 1548, 1548, this.CS, 1549, 1549, this.AL, 1550, 1551, this.ON, 1552, 1557, this.NSM, 1558, 1562, this.L, 1563, 1563, this.AL, 1564, 1566, this.L, 1567, 1567, this.AL, 1568, 1568, this.L, 1569, 1594, this.AL, 1595, 1599, this.L, 1600, 1610, this.AL, 1611, 1624, this.NSM, 1625, 1631, this.L, 1632, 1641, this.AN, 1642, 1642, this.ET, 1643, 1644, this.AN, 1645, 1647, this.AL, 1648, 1648, this.NSM, 1649, 1749, this.AL, 1750, 1756, this.NSM, 1757, 1757, this.AL, 1758, 1764, this.NSM, 1765, 1766, this.AL, 1767, 1768, this.NSM, 1769, 1769, this.ON, 1770, 1773, this.NSM, 1774, 1775, this.AL, 1776, 1785, this.EN, 1786, 1805, this.AL, 1806, 1806, this.L, 1807, 1807, this.BN, 1808, 1808, this.AL, 1809, 1809, this.NSM, 1810, 1839, this.AL, 1840, 1866, this.NSM, 1867, 1868, this.L, 1869, 1871, this.AL, 1872, 1919, this.L, 1920, 1957, this.AL, 1958, 1968, this.NSM, 1969, 1969, this.AL, 1970, 2304, this.L, 2305, 2306, this.NSM, 2307, 2363, this.L, 2364, 2364, this.NSM, 2365, 2368, this.L, 2369, 2376, this.NSM, 2377, 2380, this.L, 2381, 2381, this.NSM, 2382, 2384, this.L, 2385, 2388, this.NSM, 2389, 2401, this.L, 2402, 2403, this.NSM, 2404, 2432, this.L, 2433, 2433, this.NSM, 2434, 2491, this.L, 2492, 2492, this.NSM, 2493, 2496, this.L, 2497, 2500, this.NSM, 2501, 2508, this.L, 2509, 2509, this.NSM, 2510, 2529, this.L, 2530, 2531, this.NSM, 2532, 2545, this.L, 2546, 2547, this.ET, 2548, 2560, this.L, 2561, 2562, this.NSM, 2563, 2619, this.L, 2620, 2620, this.NSM, 2621, 2624, this.L, 2625, 2626, this.NSM, 2627, 2630, this.L, 2631, 2632, this.NSM, 2633, 2634, this.L, 2635, 2637, this.NSM, 2638, 2671, this.L, 2672, 2673, this.NSM, 2674, 2688, this.L, 2689, 2690, this.NSM, 2691, 2747, this.L, 2748, 2748, this.NSM, 2749, 2752, this.L, 2753, 2757, this.NSM, 2758, 2758, this.L, 2759, 2760, this.NSM, 2761, 2764, this.L, 2765, 2765, this.NSM, 2766, 2785, this.L, 2786, 2787, this.NSM, 2788, 2800, this.L, 2801, 2801, this.ET, 2802, 2816, this.L, 2817, 2817, this.NSM, 2818, 2875, this.L, 2876, 2876, this.NSM, 2877, 2878, this.L, 2879, 2879, this.NSM, 2880, 2880, this.L, 2881, 2883, this.NSM, 2884, 2892, this.L, 2893, 2893, this.NSM, 2894, 2901, this.L, 2902, 2902, this.NSM, 2903, 2945, this.L, 2946, 2946, this.NSM, 2947, 3007, this.L, 3008, 3008, this.NSM, 3009, 3020, this.L, 3021, 3021, this.NSM, 3022, 3058, this.L, 3059, 3064, this.ON, 3065, 3065, this.ET, 3066, 3066, this.ON, 3067, 3133, this.L, 3134, 3136, this.NSM, 3137, 3141, this.L, 3142, 3144, this.NSM, 3145, 3145, this.L, 3146, 3149, this.NSM, 3150, 3156, this.L, 3157, 3158, this.NSM, 3159, 3259, this.L, 3260, 3260, this.NSM, 3261, 3275, this.L, 3276, 3277, this.NSM, 3278, 3392, this.L, 3393, 3395, this.NSM, 3396, 3404, this.L, 3405, 3405, this.NSM, 3406, 3529, this.L, 3530, 3530, this.NSM, 3531, 3537, this.L, 3538, 3540, this.NSM, 3541, 3541, this.L, 3542, 3542, this.NSM, 3543, 3632, this.L, 3633, 3633, this.NSM, 3634, 3635, this.L, 3636, 3642, this.NSM, 3643, 3646, this.L, 3647, 3647, this.ET, 3648, 3654, this.L, 3655, 3662, this.NSM, 3663, 3760, this.L, 3761, 3761, this.NSM, 3762, 3763, this.L, 3764, 3769, this.NSM, 3770, 3770, this.L, 3771, 3772, this.NSM, 3773, 3783, this.L, 3784, 3789, this.NSM, 3790, 3863, this.L, 3864, 3865, this.NSM, 3866, 3892, this.L, 3893, 3893, this.NSM, 3894, 3894, this.L, 3895, 3895, this.NSM, 3896, 3896, this.L, 3897, 3897, this.NSM, 3898, 3901, this.ON, 3902, 3952, this.L, 3953, 3966, this.NSM, 3967, 3967, this.L, 3968, 3972, this.NSM, 3973, 3973, this.L, 3974, 3975, this.NSM, 3976, 3983, this.L, 3984, 3991, this.NSM, 3992, 3992, this.L, 3993, 4028, this.NSM, 4029, 4037, this.L, 4038, 4038, this.NSM, 4039, 4140, this.L, 4141, 4144, this.NSM, 4145, 4145, this.L, 4146, 4146, this.NSM, 4147, 4149, this.L, 4150, 4151, this.NSM, 4152, 4152, this.L, 4153, 4153, this.NSM, 4154, 4183, this.L, 4184, 4185, this.NSM, 4186, 5759, this.L, 5760, 5760, this.WS, 5761, 5786, this.L, 5787, 5788, this.ON, 5789, 5905, this.L, 5906, 5908, this.NSM, 5909, 5937, this.L, 5938, 5940, this.NSM, 5941, 5969, this.L, 5970, 5971, this.NSM, 5972, 6001, this.L, 6002, 6003, this.NSM, 6004, 6070, this.L, 6071, 6077, this.NSM, 6078, 6085, this.L, 6086, 6086, this.NSM, 6087, 6088, this.L, 6089, 6099, this.NSM, 6100, 6106, this.L, 6107, 6107, this.ET, 6108, 6108, this.L, 6109, 6109, this.NSM, 6110, 6127, this.L, 6128, 6137, this.ON, 6138, 6143, this.L, 6144, 6154, this.ON, 6155, 6157, this.NSM, 6158, 6158, this.WS, 6159, 6312, this.L, 6313, 6313, this.NSM, 6314, 6431, this.L, 6432, 6434, this.NSM, 6435, 6438, this.L, 6439, 6443, this.NSM, 6444, 6449, this.L, 6450, 6450, this.NSM, 6451, 6456, this.L, 6457, 6459, this.NSM, 6460, 6463, this.L, 6464, 6464, this.ON, 6465, 6467, this.L, 6468, 6469, this.ON, 6470, 6623, this.L, 6624, 6655, this.ON, 6656, 8124, this.L, 8125, 8125, this.ON, 8126, 8126, this.L, 8127, 8129, this.ON, 8130, 8140, this.L, 8141, 8143, this.ON, 8144, 8156, this.L, 8157, 8159, this.ON, 8160, 8172, this.L, 8173, 8175, this.ON, 8176, 8188, this.L, 8189, 8190, this.ON, 8191, 8191, this.L, 8192, 8202, this.WS, 8203, 8205, this.BN, 8206, 8206, this.L, 8207, 8207, this.R, 8208, 8231, this.ON, 8232, 8232, this.WS, 8233, 8233, this.B, 8234, 8234, this.LRE, 8235, 8235, this.RLE, 8236, 8236, this.PDF, 8237, 8237, this.LRO, 8238, 8238, this.RLO, 8239, 8239, this.WS, 8240, 8244, this.ET, 8245, 8276, this.ON, 8277, 8278, this.L, 8279, 8279, this.ON, 8280, 8286, this.L, 8287, 8287, this.WS, 8288, 8291, this.BN, 8292, 8297, this.L, 8298, 8303, this.BN, 8304, 8304, this.EN, 8305, 8307, this.L, 8308, 8313, this.EN, 8314, 8315, this.ET, 8316, 8318, this.ON, 8319, 8319, this.L, 8320, 8329, this.EN, 8330, 8331, this.ET, 8332, 8334, this.ON, 8335, 8351, this.L, 8352, 8369, this.ET, 8370, 8399, this.L, 8400, 8426, this.NSM, 8427, 8447, this.L, 8448, 8449, this.ON, 8450, 8450, this.L, 8451, 8454, this.ON, 8455, 8455, this.L, 8456, 8457, this.ON, 8458, 8467, this.L, 8468, 8468, this.ON, 8469, 8469, this.L, 8470, 8472, this.ON, 8473, 8477, this.L, 8478, 8483, this.ON, 8484, 8484, this.L, 8485, 8485, this.ON, 8486, 8486, this.L, 8487, 8487, this.ON, 8488, 8488, this.L, 8489, 8489, this.ON, 8490, 8493, this.L, 8494, 8494, this.ET, 8495, 8497, this.L, 8498, 8498, this.ON, 8499, 8505, this.L, 8506, 8507, this.ON, 8508, 8511, this.L, 8512, 8516, this.ON, 8517, 8521, this.L, 8522, 8523, this.ON, 8524, 8530, this.L, 8531, 8543, this.ON, 8544, 8591, this.L, 8592, 8721, this.ON, 8722, 8723, this.ET, 8724, 9013, this.ON, 9014, 9082, this.L, 9083, 9108, this.ON, 9109, 9109, this.L, 9110, 9168, this.ON, 9169, 9215, this.L, 9216, 9254, this.ON, 9255, 9279, this.L, 9280, 9290, this.ON, 9291, 9311, this.L, 9312, 9371, this.EN, 9372, 9449, this.L, 9450, 9450, this.EN, 9451, 9751, this.ON, 9752, 9752, this.L, 9753, 9853, this.ON, 9854, 9855, this.L, 9856, 9873, this.ON, 9874, 9887, this.L, 9888, 9889, this.ON, 9890, 9984, this.L, 9985, 9988, this.ON, 9989, 9989, this.L, 9990, 9993, this.ON, 9994, 9995, this.L, 9996, 10023, this.ON, 10024, 10024, this.L, 10025, 10059, this.ON, 10060, 10060, this.L, 10061, 10061, this.ON, 10062, 10062, this.L, 10063, 10066, this.ON, 10067, 10069, this.L, 10070, 10070, this.ON, 10071, 10071, this.L, 10072, 10078, this.ON, 10079, 10080, this.L, 10081, 10132, this.ON, 10133, 10135, this.L, 10136, 10159, this.ON, 10160, 10160, this.L, 10161, 10174, this.ON, 10175, 10191, this.L, 10192, 10219, this.ON, 10220, 10223, this.L, 10224, 11021, this.ON, 11022, 11903, this.L, 11904, 11929, this.ON, 11930, 11930, this.L, 11931, 12019, this.ON, 12020, 12031, this.L, 12032, 12245, this.ON, 12246, 12271, this.L, 12272, 12283, this.ON, 12284, 12287, this.L, 12288, 12288, this.WS, 12289, 12292, this.ON, 12293, 12295, this.L, 12296, 12320, this.ON, 12321, 12329, this.L, 12330, 12335, this.NSM, 12336, 12336, this.ON, 12337, 12341, this.L, 12342, 12343, this.ON, 12344, 12348, this.L, 12349, 12351, this.ON, 12352, 12440, this.L, 12441, 12442, this.NSM, 12443, 12444, this.ON, 12445, 12447, this.L, 12448, 12448, this.ON, 12449, 12538, this.L, 12539, 12539, this.ON, 12540, 12828, this.L, 12829, 12830, this.ON, 12831, 12879, this.L, 12880, 12895, this.ON, 12896, 12923, this.L, 12924, 12925, this.ON, 12926, 12976, this.L, 12977, 12991, this.ON, 12992, 13003, this.L, 13004, 13007, this.ON, 13008, 13174, this.L, 13175, 13178, this.ON, 13179, 13277, this.L, 13278, 13279, this.ON, 13280, 13310, this.L, 13311, 13311, this.ON, 13312, 19903, this.L, 19904, 19967, this.ON, 19968, 42127, this.L, 42128, 42182, this.ON, 42183, 64284, this.L, 64285, 64285, this.R, 64286, 64286, this.NSM, 64287, 64296, this.R, 64297, 64297, this.ET, 64298, 64310, this.R, 64311, 64311, this.L, 64312, 64316, this.R, 64317, 64317, this.L, 64318, 64318, this.R, 64319, 64319, this.L, 64320, 64321, this.R, 64322, 64322, this.L, 64323, 64324, this.R, 64325, 64325, this.L, 64326, 64335, this.R, 64336, 64433, this.AL, 64434, 64466, this.L, 64467, 64829, this.AL, 64830, 64831, this.ON, 64832, 64847, this.L, 64848, 64911, this.AL, 64912, 64913, this.L, 64914, 64967, this.AL, 64968, 65007, this.L, 65008, 65020, this.AL, 65021, 65021, this.ON, 65022, 65023, this.L, 65024, 65039, this.NSM, 65040, 65055, this.L, 65056, 65059, this.NSM, 65060, 65071, this.L, 65072, 65103, this.ON, 65104, 65104, this.CS, 65105, 65105, this.ON, 65106, 65106, this.CS, 65107, 65107, this.L, 65108, 65108, this.ON, 65109, 65109, this.CS, 65110, 65118, this.ON, 65119, 65119, this.ET, 65120, 65121, this.ON, 65122, 65123, this.ET, 65124, 65126, this.ON, 65127, 65127, this.L, 65128, 65128, this.ON, 65129, 65130, this.ET, 65131, 65131, this.ON, 65132, 65135, this.L, 65136, 65140, this.AL, 65141, 65141, this.L, 65142, 65276, this.AL, 65277, 65278, this.L, 65279, 65279, this.BN, 65280, 65280, this.L, 65281, 65282, this.ON, 65283, 65285, this.ET, 65286, 65290, this.ON, 65291, 65291, this.ET, 65292, 65292, this.CS, 65293, 65293, this.ET, 65294, 65294, this.CS, 65295, 65295, this.ES, 65296, 65305, this.EN, 65306, 65306, this.CS, 65307, 65312, this.ON, 65313, 65338, this.L, 65339, 65344, this.ON, 65345, 65370, this.L, 65371, 65381, this.ON, 65382, 65503, this.L, 65504, 65505, this.ET, 65506, 65508, this.ON, 65509, 65510, this.ET, 65511, 65511, this.L, 65512, 65518, this.ON, 65519, 65528, this.L, 65529, 65531, this.BN, 65532, 65533, this.ON, 65534, 65535, this.L];\n\n    for (let i = 0; i < this.charTypes.length; ++i) {\n      let start = this.charTypes[i];\n      let end = this.charTypes[++i];\n      let b = this.charTypes[++i];\n\n      while (start <= end) {\n        this.rtlCharacterTypes[start++] = b;\n      }\n    }\n  } //#endregion\n  //#region implementation\n\n\n  getVisualOrder(inputText, isRtl) {\n    this.types = this.getCharacterCode(inputText);\n    this.textOrder = isRtl ? this.LRE : this.L;\n    this.doVisualOrder();\n    let result = [];\n\n    for (let i = 0; i < this.levels.length; i++) {\n      result[i] = this.levels[i];\n    }\n\n    return result;\n  }\n\n  getCharacterCode(text) {\n    let characterCodes = [];\n\n    for (let i = 0; i < text.length; i++) {\n      characterCodes[i] = this.rtlCharacterTypes[text[i].charCodeAt(0)];\n    }\n\n    return characterCodes;\n  }\n\n  setDefaultLevels() {\n    for (let i = 0; i < this.length; i++) {\n      this.levels[i] = this.textOrder;\n    }\n  }\n\n  setLevels() {\n    this.setDefaultLevels();\n\n    for (let n = 0; n < this.length; ++n) {\n      let level = this.levels[n];\n\n      if ((level & 0x80) !== 0) {\n        level &= 0x7f;\n        this.result[n] = (level & 0x1) === 0 ? this.L : this.R;\n      }\n\n      this.levels[n] = level;\n    }\n  }\n\n  updateLevels(index, level, length) {\n    if ((level & 1) === 0) {\n      for (let i = index; i < length; ++i) {\n        if (this.result[i] === this.R) {\n          this.levels[i] += 1;\n        } else if (this.result[i] !== this.L) {\n          this.levels[i] += 2;\n        }\n      }\n    } else {\n      for (let i = index; i < length; ++i) {\n        if (this.result[i] !== this.R) {\n          this.levels[i] += 1;\n        }\n      }\n    }\n  }\n\n  doVisualOrder() {\n    this.length = this.types.length;\n    this.result = this.types;\n    this.levels = [];\n    this.setLevels();\n    this.length = this.getEmbeddedCharactersLength();\n    let preview = this.textOrder;\n    let i = 0;\n\n    while (i < this.length) {\n      let level = this.levels[i];\n      let preType = (Math.max(preview, level) & 0x1) === 0 ? this.L : this.R;\n      let length = i + 1;\n\n      while (length < this.length && this.levels[length] === level) {\n        ++length;\n      }\n\n      let success = length < this.length ? this.levels[length] : this.textOrder;\n      let type = (Math.max(success, level) & 0x1) === 0 ? this.L : this.R;\n      this.checkNSM(i, length, level, preType, type);\n      this.updateLevels(i, level, length);\n      preview = level;\n      i = length;\n    }\n\n    this.checkEmbeddedCharacters(this.length);\n  }\n\n  getEmbeddedCharactersLength() {\n    let index = 0;\n\n    for (let i = 0; i < this.length; ++i) {\n      if (!(this.types[i] === this.LRE || this.types[i] === this.RLE || this.types[i] === this.LRO || this.types[i] === this.RLO || this.types[i] === this.PDF || this.types[i] === this.BN)) {\n        this.result[index] = this.result[i];\n        this.levels[index] = this.levels[i];\n        index++;\n      }\n    }\n\n    return index;\n  }\n\n  checkEmbeddedCharacters(length) {\n    for (let i = this.types.length - 1; i >= 0; --i) {\n      if (this.types[i] === this.LRE || this.types[i] === this.RLE || this.types[i] === this.LRO || this.types[i] === this.RLO || this.types[i] === this.PDF || this.types[i] === this.BN) {\n        this.result[i] = this.types[i];\n        this.levels[i] = -1;\n      } else {\n        length -= 1;\n        this.result[i] = this.result[length];\n        this.levels[i] = this.levels[length];\n      }\n    }\n\n    for (let i = 0; i < this.types.length; i++) {\n      if (this.levels[i] === -1) {\n        if (i === 0) {\n          this.levels[i] = this.textOrder;\n        } else {\n          this.levels[i] = this.levels[i - 1];\n        }\n      }\n    }\n  }\n\n  checkNSM(index, length, level, startType, endType) {\n    let charType = startType;\n\n    for (let i = index; i < length; ++i) {\n      if (this.result[i] === this.NSM) {\n        this.result[i] = charType;\n      } else {\n        charType = this.result[i];\n      }\n    }\n\n    this.checkEuropeanDigits(index, length, level, startType, endType);\n  }\n\n  checkEuropeanDigits(index, length, level, startType, endType) {\n    for (let i = index; i < length; ++i) {\n      if (this.result[i] === this.EN) {\n        for (let j = i - 1; j >= index; --j) {\n          if (this.result[j] === this.L || this.result[j] === this.R || this.result[j] === this.AL) {\n            if (this.result[j] === this.AL) {\n              this.result[i] = this.AN;\n            }\n\n            break;\n          }\n        }\n      }\n    }\n\n    this.checkArabicCharacters(index, length, level, startType, endType);\n  }\n\n  checkArabicCharacters(index, length, level, startType, endType) {\n    for (let i = index; i < length; ++i) {\n      if (this.result[i] === this.AL) {\n        this.result[i] = this.R;\n      }\n    }\n\n    this.checkEuropeanNumberSeparator(index, length, level, startType, endType);\n  }\n\n  checkEuropeanNumberSeparator(index, length, level, startType, endType) {\n    for (let i = index + 1; i < length - 1; ++i) {\n      if (this.result[i] === this.ES || this.result[i] === this.CS) {\n        let preview = this.result[i - 1];\n        let success = this.result[i + 1];\n\n        if (preview === this.EN && success === this.EN) {\n          this.result[i] = this.EN;\n        } else if (this.result[i] === this.CS && preview === this.AN && success === this.AN) {\n          this.result[i] = this.AN;\n        }\n      }\n    }\n\n    this.checkEuropeanNumberTerminator(index, length, level, startType, endType);\n  }\n\n  checkEuropeanNumberTerminator(index, length, level, startType, endType) {\n    for (let i = index; i < length; ++i) {\n      if (this.result[i] === this.ET) {\n        let s = i;\n        let b = [];\n        b.push(this.ET);\n        let l = this.getLength(s, length, b);\n        let data = s === index ? startType : this.result[s - 1];\n\n        if (data !== this.EN) {\n          data = l === length ? endType : this.result[l];\n        }\n\n        if (data === this.EN) {\n          for (let j = s; j < l; ++j) {\n            this.result[j] = this.EN;\n          }\n        }\n\n        i = l;\n      }\n    }\n\n    this.checkOtherNeutrals(index, length, level, startType, endType);\n  }\n\n  checkOtherNeutrals(index, length, level, startType, endType) {\n    for (let i = index; i < length; ++i) {\n      if (this.result[i] === this.ES || this.result[i] === this.ET || this.result[i] === this.CS) {\n        this.result[i] = this.ON;\n      }\n    }\n\n    this.checkOtherCharacters(index, length, level, startType, endType);\n  }\n\n  checkOtherCharacters(index, length, level, startType, endType) {\n    for (let i = index; i < length; ++i) {\n      if (this.result[i] === this.EN) {\n        let pst = startType;\n\n        for (let j = i - 1; j >= index; --j) {\n          if (this.result[j] === this.L || this.result[j] === this.R) {\n            pst = this.result[j];\n            break;\n          }\n        }\n\n        if (pst === this.L) {\n          this.result[i] = this.L;\n        }\n      }\n    }\n\n    this.checkCommanCharacters(index, length, level, startType, endType);\n  }\n\n  getLength(index, length, validSet) {\n    --index;\n\n    while (++index < length) {\n      let t = this.result[index];\n\n      for (let i = 0; i < validSet.length; ++i) {\n        if (t === validSet[i]) {\n          index = this.getLength(++index, length, validSet);\n        }\n      }\n\n      return index;\n    }\n\n    return length;\n  }\n\n  checkCommanCharacters(index, length, level, startType, endType) {\n    for (let i = index; i < length; ++i) {\n      if (this.result[i] === this.WS || this.result[i] === this.ON || this.result[i] === this.B || this.result[i] === this.S) {\n        let s = i;\n        let byte = [this.B, this.S, this.WS, this.ON];\n        let l = this.getLength(s, length, byte);\n        let lt = 0;\n        let tt = 0;\n        let rt = 0;\n\n        if (s === index) {\n          lt = startType;\n        } else {\n          lt = this.result[s - 1];\n\n          if (lt === this.AN) {\n            lt = this.R;\n          } else if (lt === this.EN) {\n            lt = this.R;\n          }\n        }\n\n        if (l === length) {\n          tt = endType;\n        } else {\n          tt = this.result[l];\n\n          if (tt === this.AN) {\n            tt = this.R;\n          } else if (tt === this.EN) {\n            tt = this.R;\n          }\n        }\n\n        if (lt === tt) {\n          rt = lt;\n        } else {\n          rt = (level & 0x1) === 0 ? this.L : this.R;\n        }\n\n        for (let j = s; j < l; ++j) {\n          this.result[j] = rt;\n        }\n\n        i = l;\n      }\n    }\n  }\n\n}\n/**\n * `Metrics` of the font.\n * @private\n */\n\n\nclass RtlRenderer {\n  constructor() {\n    //region Constants\n    /// Open bracket symbol.\n    /// </summary>\n    this.openBracket = '('; /// <summary>\n    /// Close bracket symbol.\n    /// </summary>\n\n    this.closeBracket = ')'; //#endregion\n  } //#region Constructors\n  /// <summary>\n  /// Initializes a new instance of the <see cref=\"RtlRenderer\"/> class.\n  /// </summary>\n  // public constructor() {\n  // }\n  //#region Public Methods\n  /// <summary>\n  /// Layouts text. Changes blocks position in the RTL text.\n  /// Ligates the text if needed.\n  /// </summary>\n  /// <param name=\"line\">Line of the text.</param>\n  /// <param name=\"font\">Font to be used for string printing.</param>\n  /// <param name=\"rtl\">Font alignment.</param>\n  /// <param name=\"wordSpace\">Indicates whether Word Spacing used or not.</param>\n  /// <returns>Layout string.</returns>\n\n\n  layout(line, font, rtl, wordSpace, format) {\n    if (line == null) {\n      throw new Error('ArgumentNullException : line');\n    }\n\n    if (font == null) {\n      throw new Error('ArgumentNullException : font');\n    }\n\n    let result = [];\n\n    if (font.Unicode) {\n      result = this.customLayout(line, rtl, format, font, wordSpace);\n    } else {\n      result = [];\n      result[0] = line;\n    }\n\n    return result;\n  } /// <summary>\n  /// Layouts a string and splits it by the words and using correct lay outing.\n  /// </summary>\n  /// <param name=\"line\">Text line.</param>\n  /// <param name=\"font\">Font object.</param>\n  /// <param name=\"rtl\">Indicates whether RTL should be applied.</param>\n  /// <param name=\"wordSpace\">Indicates whether word spacing is used.</param>\n  /// <returns>Array of words if converted, null otherwise.</returns>\n\n\n  splitLayout(line, font, rtl, wordSpace, format) {\n    if (line == null) {\n      throw new Error('ArgumentNullException : line');\n    }\n\n    if (font == null) {\n      throw new Error('ArgumentNullException : font');\n    }\n\n    let words = [];\n    let system = false;\n\n    if (!system || words == null) {\n      words = this.customSplitLayout(line, font, rtl, wordSpace, format);\n    }\n\n    return words;\n  } //#endregion\n  //#region Implementation\n  // private isEnglish( word : string) : boolean\n  // {\n  //     let c : string = (word.length > 0) ? word[0] : '';\n  //     return (c >= '0' && c < '');\n  // }\n  // private keepOrder( words : string, startIndex : number, count: number, result : string[], resultIndex : number) : void\n  // {\n  //     for (let i : number = 0, ri = resultIndex - count + 1; i < count; ++i, ++ri) {\n  //         result[ri] = words[i + startIndex];\n  //     }\n  // }\n  /// <summary>\n  /// Uses system API to layout the text.\n  /// </summary>\n  /// <param name=\"line\">Line of the text to be layouted.</param>\n  /// <param name=\"font\">Font which is used for text printing.</param>\n  /// <param name=\"rtl\">Indicates whether we use RTL or RTL lay outing of the text container.</param>\n  /// <returns>Layout string.</returns>\n\n  /* tslint:disable-next-line:max-line-length */\n\n\n  getGlyphIndex(line, font, rtl,\n  /*out*/\n  glyphs, custom) {\n    let success = true;\n    let fail = false;\n\n    if (line == null) {\n      throw new Error('ArgumentNullException : line');\n    }\n\n    if (font == null) {\n      throw new Error('ArgumentNullException : font');\n    }\n\n    glyphs = null;\n\n    if (line.length === 0) {\n      return {\n        success: fail,\n        glyphs: glyphs\n      };\n    }\n\n    let renderer = new ArabicShapeRenderer();\n    let text = renderer.shape(line, 0);\n    let internalFont = font.fontInternal;\n    let ttfReader = internalFont.ttfReader;\n    glyphs = new Uint16Array(text.length);\n    let i = 0;\n\n    for (let k = 0, len = text.length; k < len; k++) {\n      let ch = text[k];\n      let glyphInfo = ttfReader.getGlyph(ch);\n\n      if (glyphInfo !== null && typeof glyphInfo !== 'undefined') {\n        glyphs[i++] = glyphInfo.index;\n      }\n    }\n\n    return {\n      success: success,\n      glyphs: glyphs\n    };\n  }\n  /* tslint:disable-next-line:max-line-length */\n\n\n  customLayout(line, rtl, format, font, wordSpace) {\n    if (wordSpace === null || typeof wordSpace === 'undefined') {\n      if (line == null) {\n        throw new Error('ArgumentNullException : line');\n      }\n\n      let result = null; //bidirectional order.\n\n      if (format !== null && typeof format !== 'undefined' && format.textDirection !== PdfTextDirection.None) {\n        let bidi = new Bidi();\n        result = bidi.getLogicalToVisualString(line, rtl);\n      }\n\n      return result;\n    } else {\n      if (line == null) {\n        throw new Error('ArgumentNullException : line');\n      }\n\n      if (font == null) {\n        throw new Error('ArgumentNullException : font');\n      }\n\n      let layouted = null;\n\n      if (format !== null && typeof format !== 'undefined' && format.textDirection !== PdfTextDirection.None) {\n        let renderer = new ArabicShapeRenderer();\n        let txt = renderer.shape(line, 0);\n        layouted = this.customLayout(txt, rtl, format);\n      } // else {\n      //     layouted = this.customLayout(line, rtl, format);\n      // }\n      // We have unicode font, but from the file.        \n\n\n      let result = []; // Split the text by words if word spacing is not default.\n\n      if (wordSpace) {\n        let words = layouted.split('');\n        let count = words.length;\n\n        for (let i = 0; i < count; i++) {\n          words[i] = this.addChars(font, words[i]);\n        }\n\n        result = words;\n      } else {\n        result = [];\n        result[0] = this.addChars(font, layouted);\n      }\n\n      return result;\n    }\n  } /// <summary>\n  /// Add information about used glyphs to the font.\n  /// </summary>\n  /// <param name=\"font\">Font used for text rendering.</param>\n  /// <param name=\"glyphs\">Array of used glyphs.</param>\n  /// <returns>String in the form to be written to the file.</returns>\n\n\n  addChars(font, glyphs) {\n    let line = glyphs;\n\n    if (font == null) {\n      throw new Error('ArgumentNullException : font');\n    }\n\n    if (line == null) {\n      throw new Error('ArgumentNullException : line');\n    }\n\n    let text = line;\n    let internalFont = font.fontInternal;\n    let ttfReader = internalFont.ttfReader;\n    font.setSymbols(text); // Reconvert string according to unicode standard.\n\n    text = ttfReader.convertString(text);\n    let bytes = PdfString.toUnicodeArray(text, false);\n    text = PdfString.byteToString(bytes);\n    return text; // else {\n    //     if (font == null) {\n    //         throw new Error('ArgumentNullException : font');\n    //     }\n    //     if (glyphs == null) {\n    //         throw new Error('ArgumentNullException : glyphs');\n    //     }\n    //     // Mark the chars as used.\n    //     let text : string = '';\n    //     font.setSymbols(glyphs);\n    //     // Create string from the glyphs.\n    //     \n    //     let chars : string[] = [];\n    //     for (let i : number = 0; i < glyphs.length; i++) {\n    //         chars[i] = glyphs[i].toString();\n    //     }\n    //     for (let j : number = 0 ; j < chars.length; j++) {\n    //         text = text + chars[j];\n    //     }\n    //     let bytes : number[] = PdfString.toUnicodeArray(text, false);\n    //     text = PdfString.byteToString(bytes);\n    //     return text;\n    // }\n  } /// <summary>\n  /// Layouts a string and splits it by the words by using custom lay outing.\n  /// </summary>\n  /// <param name=\"line\">Text line.</param>\n  /// <param name=\"font\">Font object.</param>\n  /// <param name=\"rtl\">Indicates whether RTL should be applied.</param>\n  /// <param name=\"wordSpace\">Indicates whether word spacing is used.</param>\n  /// <returns>Array of words if converted, null otherwise.</returns>\n\n  /* tslint:disable-next-line:max-line-length */\n\n\n  customSplitLayout(line, font, rtl, wordSpace, format) {\n    if (line == null) {\n      throw new Error('ArgumentNullException : line');\n    }\n\n    if (font == null) {\n      throw new Error('ArgumentNullException : font');\n    }\n\n    let reversedLine = this.customLayout(line, rtl, format);\n    let words = reversedLine.split('');\n    return words;\n  }\n\n}\n/**\n * public Enum for `PdfLayoutType`.\n * @private\n */\n\n\nvar PdfLayoutType = /*#__PURE__*/(() => {\n  (function (PdfLayoutType) {\n    /**\n     * Specifies the type of `Paginate`.\n     * @private\n     */\n    PdfLayoutType[PdfLayoutType[\"Paginate\"] = 0] = \"Paginate\";\n    /**\n     * Specifies the type of `OnePage`.\n     * @private\n     */\n\n    PdfLayoutType[PdfLayoutType[\"OnePage\"] = 1] = \"OnePage\";\n  })(PdfLayoutType || (PdfLayoutType = {}));\n\n  return PdfLayoutType;\n})();\n\n/**\n * public Enum for `PdfLayoutBreakType`.\n * @private\n */\nvar PdfLayoutBreakType = /*#__PURE__*/(() => {\n  (function (PdfLayoutBreakType) {\n    /**\n     * Specifies the type of `FitPage`.\n     * @private\n     */\n    PdfLayoutBreakType[PdfLayoutBreakType[\"FitPage\"] = 0] = \"FitPage\";\n    /**\n     * Specifies the type of `FitElement`.\n     * @private\n     */\n\n    PdfLayoutBreakType[PdfLayoutBreakType[\"FitElement\"] = 1] = \"FitElement\";\n    /**\n     * Specifies the type of `FitColumnsToPage`.\n     * @private\n     */\n\n    PdfLayoutBreakType[PdfLayoutBreakType[\"FitColumnsToPage\"] = 2] = \"FitColumnsToPage\";\n  })(PdfLayoutBreakType || (PdfLayoutBreakType = {}));\n\n  return PdfLayoutBreakType;\n})();\nvar PathPointType = /*#__PURE__*/(() => {\n  (function (PathPointType) {\n    /**\n     * Specifies the path point type of `Start`.\n     * @private\n     */\n    PathPointType[PathPointType[\"Start\"] = 0] = \"Start\";\n    /**\n     * Specifies the path point type of `Line`.\n     * @private\n     */\n\n    PathPointType[PathPointType[\"Line\"] = 1] = \"Line\";\n    /**\n     * Specifies the path point type of `Bezier3`.\n     * @private\n     */\n\n    PathPointType[PathPointType[\"Bezier3\"] = 3] = \"Bezier3\";\n    /**\n     * Specifies the path point type of `Bezier`.\n     * @private\n     */\n\n    PathPointType[PathPointType[\"Bezier\"] = 3] = \"Bezier\";\n    /**\n     * Specifies the path point type of `PathTypeMask`.\n     * @private\n     */\n\n    PathPointType[PathPointType[\"PathTypeMask\"] = 7] = \"PathTypeMask\";\n    /**\n     * Specifies the path point type of `DashMode`.\n     * @private\n     */\n\n    PathPointType[PathPointType[\"DashMode\"] = 16] = \"DashMode\";\n    /**\n     * Specifies the path point type of `PathMarker`.\n     * @private\n     */\n\n    PathPointType[PathPointType[\"PathMarker\"] = 32] = \"PathMarker\";\n    /**\n     * Specifies the path point type of `CloseSubpath`.\n     * @private\n     */\n\n    PathPointType[PathPointType[\"CloseSubpath\"] = 128] = \"CloseSubpath\";\n  })(PathPointType || (PathPointType = {}));\n\n  return PathPointType;\n})();\n\n/**\n * `PdfGradientBrush` class provides objects used to fill the interiors of graphical shapes such as rectangles,\n * ellipses, pies, polygons, and paths.\n * @private\n */\nclass PdfGradientBrush extends PdfBrush {\n  //Constructor\n\n  /**\n   * Initializes a new instance of the `PdfGradientBrush` class.\n   * @public\n   */\n\n  /* tslint:disable-next-line:max-line-length */\n  constructor(shading) {\n    super(); // Fields\n\n    /**\n     * Local variable to store the background color.\n     * @private\n     */\n\n    this.mbackground = new PdfColor(255, 255, 255);\n    /**\n     * Local variable to store the stroking color.\n     * @private\n     */\n\n    this.mbStroking = false;\n    /**\n     * Local variable to store the function.\n     * @private\n     */\n\n    this.mfunction = null;\n    /**\n     * Local variable to store the DictionaryProperties.\n     * @private\n     */\n\n    this.dictionaryProperties = new DictionaryProperties();\n    this.mpatternDictionary = new PdfDictionary();\n    this.mpatternDictionary.items.setValue(this.dictionaryProperties.type, new PdfName(this.dictionaryProperties.pattern));\n    this.mpatternDictionary.items.setValue(this.dictionaryProperties.patternType, new PdfNumber(2));\n    this.shading = shading;\n    this.colorSpace = PdfColorSpace.Rgb;\n  } //Properties\n\n  /**\n   * Gets or sets the background color of the brush.\n   * @public\n   */\n\n\n  get background() {\n    return this.mbackground;\n  }\n\n  set background(value) {\n    this.mbackground = value;\n    let sh = this.shading;\n\n    if (value.isEmpty) {\n      sh.remove(this.dictionaryProperties.background);\n    } else {\n      sh.items.setValue(this.dictionaryProperties.background, value.toArray(this.colorSpace));\n    }\n  }\n  /**\n   * Gets or sets a value indicating whether use anti aliasing algorithm.\n   * @public\n   */\n\n\n  get antiAlias() {\n    let sh = this.shading;\n    let aa = sh.items.getValue(this.dictionaryProperties.antiAlias);\n    return aa.value;\n  }\n\n  set antiAlias(value) {\n    let sh = this.shading;\n    let aa = sh.items.getValue(this.dictionaryProperties.antiAlias);\n\n    if (aa == null && typeof aa === 'undefined') {\n      aa = new PdfBoolean(value);\n      sh.items.setValue(this.dictionaryProperties.antiAlias, aa);\n    } else {\n      aa.value = value;\n    }\n  }\n  /**\n   * Gets or sets the function of the brush.\n   * @protected\n   */\n\n\n  get function() {\n    return this.mfunction;\n  }\n\n  set function(value) {\n    this.mfunction = value;\n\n    if (value != null && typeof value !== 'undefined') {\n      this.shading.items.setValue(this.dictionaryProperties.function, new PdfReferenceHolder(this.mfunction));\n    } else {\n      this.shading.remove(this.dictionaryProperties.function);\n    }\n  }\n  /**\n   * Gets or sets the boundary box of the brush.\n   * @protected\n   */\n\n\n  get bBox() {\n    let sh = this.shading;\n    let box = sh.items.getValue(this.dictionaryProperties.bBox);\n    return box;\n  }\n\n  set bBox(value) {\n    let sh = this.shading;\n\n    if (value == null && typeof value === 'undefined') {\n      sh.remove(this.dictionaryProperties.bBox);\n    } else {\n      sh.items.setValue(this.dictionaryProperties.bBox, value);\n    }\n  }\n  /**\n   * Gets or sets the color space of the brush.\n   * @public\n   */\n\n\n  get colorSpace() {\n    return this.mcolorSpace;\n  }\n\n  set colorSpace(value) {\n    let colorSpace = this.shading.items.getValue(this.dictionaryProperties.colorSpace);\n\n    if (value !== this.mcolorSpace || colorSpace == null) {\n      this.mcolorSpace = value;\n      let csValue = this.colorSpaceToDeviceName(value);\n      this.shading.items.setValue(this.dictionaryProperties.colorSpace, new PdfName(csValue));\n    }\n  }\n  /**\n   * Gets or sets a value indicating whether this PdfGradientBrush is stroking.\n   * @public\n   */\n\n\n  get stroking() {\n    return this.mbStroking;\n  }\n\n  set stroking(value) {\n    this.mbStroking = value;\n  }\n  /**\n   * Gets the pattern dictionary.\n   * @protected\n   */\n\n\n  get patternDictionary() {\n    if (this.mpatternDictionary == null) {\n      this.mpatternDictionary = new PdfDictionary();\n    }\n\n    return this.mpatternDictionary;\n  }\n  /**\n   * Gets or sets the shading dictionary.\n   * @protected\n   */\n\n\n  get shading() {\n    return this.mshading;\n  }\n\n  set shading(value) {\n    if (value == null) {\n      throw new Error('ArgumentNullException : Shading');\n    }\n\n    if (value !== this.mshading) {\n      this.mshading = value;\n      this.patternDictionary.items.setValue(this.dictionaryProperties.shading, new PdfReferenceHolder(this.mshading));\n    }\n  }\n  /**\n   * Gets or sets the transformation matrix.\n   * @public\n   */\n\n\n  get matrix() {\n    return this.mmatrix;\n  }\n\n  set matrix(value) {\n    if (value == null) {\n      throw new Error('ArgumentNullException : Matrix');\n    }\n\n    if (value !== this.mmatrix) {\n      this.mmatrix = value.clone();\n      let m = new PdfArray(this.mmatrix.matrix.elements);\n      this.mpatternDictionary.items.setValue(this.dictionaryProperties.matrix, m);\n    }\n  } //Overrides\n\n  /**\n   * Monitors the changes of the brush and modify PDF state respectfully.\n   * @param brush The brush.\n   * @param streamWriter The stream writer.\n   * @param getResources The get resources delegate.\n   * @param saveChanges if set to true the changes should be saved anyway.\n   * @param currentColorSpace The current color space.\n   */\n\n  /* tslint:disable-next-line:max-line-length */\n\n\n  monitorChanges(brush, streamWriter, getResources, saveChanges, currentColorSpace) {\n    let diff = false;\n\n    if (brush instanceof PdfGradientBrush) {\n      if (this.colorSpace !== currentColorSpace) {\n        this.colorSpace = currentColorSpace;\n        this.resetFunction();\n      } //  Set the /Pattern colour space.\n\n\n      streamWriter.setColorSpace('Pattern', this.mbStroking); //  Set the pattern for non-stroking operations.\n\n      let resources = getResources.getResources();\n      let name = resources.getName(this);\n      streamWriter.setColourWithPattern(null, name, this.mbStroking);\n      diff = true;\n    }\n\n    return diff;\n  }\n  /**\n   * Resets the changes, which were made by the brush.\n   * In other words resets the state to the initial one.\n   * @param streamWriter The stream writer.\n   */\n\n\n  resetChanges(streamWriter) {//  Unable reset.\n  } //Implementation\n\n  /**\n   * Converts colorspace enum to a PDF name.\n   * @param colorSpace The color space enum value.\n   */\n\n\n  colorSpaceToDeviceName(colorSpace) {\n    let result;\n\n    switch (colorSpace) {\n      case PdfColorSpace.Rgb:\n        result = 'DeviceRGB';\n        break;\n    }\n\n    return result;\n  }\n  /**\n   * Resets the pattern dictionary.\n   * @param dictionary A new pattern dictionary.\n   */\n\n\n  resetPatternDictionary(dictionary) {\n    this.mpatternDictionary = dictionary;\n  }\n  /**\n   * Clones the anti aliasing value.\n   * @param brush The brush.\n   */\n\n\n  cloneAntiAliasingValue(brush) {\n    if (brush == null) {\n      throw new Error('ArgumentNullException : brush');\n    }\n\n    let sh = this.shading;\n    let aa = sh.items.getValue(this.dictionaryProperties.antiAlias);\n\n    if (aa != null) {\n      brush.shading.items.setValue(this.dictionaryProperties.antiAlias, new PdfBoolean(aa.value));\n    }\n  }\n  /**\n   * Clones the background value.\n   * @param brush The brush.\n   */\n\n\n  cloneBackgroundValue(brush) {\n    let background = this.background;\n\n    if (!background.isEmpty) {\n      brush.background = background;\n    }\n  }\n  /* tslint:enable */\n  // IPdfWrapper Members\n\n  /**\n   * Gets the `element`.\n   * @private\n   */\n\n\n  get element() {\n    return this.patternDictionary;\n  }\n\n}\n/**\n * PdfTemplate.ts class for EJ2-PDF\n */\n\n/**\n * Represents `Pdf Template` object.\n * @private\n */\n\n\nclass PdfTemplate {\n  constructor(arg1, arg2) {\n    /**\n     * Initialize an instance for `DictionaryProperties` class.\n     * @private\n     * @hidden\n     */\n    this.dictionaryProperties = new DictionaryProperties();\n    /**\n     * Checks whether the transformation 'is performed'.\n     * @default true\n     * @private\n     */\n\n    this.writeTransformation = true;\n\n    if (typeof arg1 === 'undefined') {//\n    } else if (arg1 instanceof SizeF && typeof arg2 === 'undefined') {\n      this.content = new PdfStream();\n      let tempSize = new SizeF(arg1.width, arg1.height);\n      this.setSize(tempSize);\n      this.initialize();\n    } else {\n      this.content = new PdfStream();\n      this.setSize(new SizeF(arg1, arg2));\n      this.initialize();\n    }\n  } //Properties\n\n  /**\n   * Gets the size of the 'PdfTemplate'.\n   */\n\n\n  get size() {\n    return this.templateSize;\n  }\n  /**\n   * Gets the width of the 'PdfTemplate'.\n   */\n\n\n  get width() {\n    return this.size.width;\n  }\n  /**\n   * Gets the height of the 'PdfTemplate'.\n   */\n\n\n  get height() {\n    return this.size.height;\n  }\n  /**\n   * Gets the `graphics` of the 'PdfTemplate'.\n   */\n\n\n  get graphics() {\n    if (this.pdfGraphics == null || typeof this.pdfGraphics === 'undefined') {\n      let gr = new GetResourceEventHandler(this);\n      let g = new PdfGraphics(this.size, gr, this.content);\n      this.pdfGraphics = g; // if(this.writeTransformation) {\n      // Transform co-ordinates to Top/Left.\n\n      this.pdfGraphics.initializeCoordinates(); // }\n    }\n\n    return this.pdfGraphics;\n  }\n  /**\n   * Gets the resources and modifies the template dictionary.\n   * @private\n   */\n\n\n  getResources() {\n    if (this.resources == null) {\n      this.resources = new PdfResources();\n      this.content.items.setValue(this.dictionaryProperties.resources, this.resources);\n    }\n\n    return this.resources;\n  } // Public methods\n\n  /**\n   * `Initialize` the type and subtype of the template.\n   * @private\n   */\n\n\n  initialize() {\n    this.addType();\n    this.addSubType();\n  }\n  /**\n   * `Adds type key`.\n   * @private\n   */\n\n\n  addType() {\n    let value = new PdfName(this.dictionaryProperties.xObject);\n    this.content.items.setValue(this.dictionaryProperties.type, value);\n  }\n  /**\n   * `Adds SubType key`.\n   * @private\n   */\n\n\n  addSubType() {\n    let value = new PdfName(this.dictionaryProperties.form);\n    this.content.items.setValue(this.dictionaryProperties.subtype, value);\n  }\n\n  reset(size) {\n    if (typeof size === 'undefined') {\n      if (this.resources != null) {\n        this.resources = null;\n        this.content.remove(this.dictionaryProperties.resources);\n      }\n\n      if (this.graphics != null) {\n        this.graphics.reset(this.size);\n      }\n    } else {\n      this.setSize(size);\n      this.reset();\n    }\n  }\n  /**\n   * `Set the size` of the 'PdfTemplate'.\n   * @private\n   */\n\n\n  setSize(size) {\n    let rect = new RectangleF(new PointF(0, 0), size);\n    let val = PdfArray.fromRectangle(rect);\n    this.content.items.setValue(this.dictionaryProperties.bBox, val);\n    this.templateSize = size;\n  } // /**\n  //  * Returns the value of current graphics.\n  //  * @private\n  //  */\n  // public GetGraphics(g : PdfGraphics) : PdfGraphics {\n  //     if (this.graphics == null || typeof this.graphics === 'undefined') {\n  //         this.graphics = g;\n  //         this.graphics.Size = this.Size;\n  //         this.graphics.StreamWriter = new PdfStreamWriter(this.content)\n  //         this.graphics.Initialize();\n  //         if(this.writeTransformation) {\n  //             this.graphics.InitializeCoordinates();\n  //         }\n  //     }\n  //     return this.graphics;\n  // }\n  // IPdfWrapper Members\n\n  /**\n   * Gets the `content stream` of 'PdfTemplate' class.\n   * @private\n   */\n\n\n  get element() {\n    return this.content;\n  }\n\n}\n/**\n * PdfResources.ts class for EJ2-PDF\n */\n\n/**\n * `PdfResources` class used to set resource contents like font, image.\n * @private\n */\n\n\nclass PdfResources extends PdfDictionary {\n  constructor(baseDictionary) {\n    super(baseDictionary);\n    /**\n     * Dictionary for the `properties names`.\n     * @private\n     */\n\n    this.properties = new PdfDictionary();\n  } //Properties\n\n  /**\n   * Gets the `font names`.\n   * @private\n   */\n\n\n  get names() {\n    return this.getNames();\n  }\n  /**\n   * Get or set the `page document`.\n   * @private\n   */\n\n\n  get document() {\n    return this.pdfDocument;\n  }\n\n  set document(value) {\n    this.pdfDocument = value;\n  } //Public Methods\n\n  /**\n   * `Generates name` for the object and adds to the resource if the object is new.\n   * @private\n   */\n\n\n  getName(obj) {\n    let primitive = obj.element;\n    let name = null;\n\n    if (this.names.containsKey(primitive)) {\n      name = this.names.getValue(primitive);\n    } // Object is new.\n\n\n    if (name == null) {\n      let sName = this.generateName();\n      name = new PdfName(sName);\n      this.names.setValue(primitive, name);\n\n      if (obj instanceof PdfFont) {\n        this.add(obj, name);\n      } else if (obj instanceof PdfTemplate) {\n        this.add(obj, name);\n      } else if (obj instanceof PdfGradientBrush || obj instanceof PdfTilingBrush) {\n        this.add(obj, name);\n      } else if (obj instanceof PdfTransparency) {\n        this.add(obj, name);\n      } else if (obj instanceof PdfImage || obj instanceof PdfBitmap) {\n        this.add(obj, name);\n      }\n    }\n\n    return name;\n  }\n  /**\n   * Gets `resource names` to font dictionaries.\n   * @private\n   */\n\n\n  getNames() {\n    if (this.pdfNames == null) {\n      this.pdfNames = new TemporaryDictionary();\n    }\n\n    let fonts = this.items.getValue(this.dictionaryProperties.font);\n\n    if (fonts != null) {\n      let dictionary = fonts;\n      dictionary = PdfCrossTable.dereference(fonts);\n    }\n\n    return this.pdfNames;\n  }\n  /**\n   * Add `RequireProcedureSet` into procset array.\n   * @private\n   */\n\n\n  requireProcedureSet(procedureSetName) {\n    if (procedureSetName == null) {\n      throw new Error('ArgumentNullException:procedureSetName');\n    }\n\n    let procSets = this.items.getValue(this.dictionaryProperties.procset);\n\n    if (procSets == null) {\n      procSets = new PdfArray();\n      this.items.setValue(this.dictionaryProperties.procset, procSets);\n    }\n\n    let name = new PdfName(procedureSetName);\n\n    if (!procSets.contains(name)) {\n      procSets.add(name);\n    }\n  } //Helper Methods\n\n  /**\n   * `Remove font` from array.\n   * @private\n   */\n\n\n  removeFont(name) {\n    let key = null;\n    let keys = this.pdfNames.keys();\n\n    for (let index = 0; index < this.pdfNames.size(); index++) {\n      if (this.pdfNames.getValue(keys[index]) === new PdfName(name)) {\n        key = keys[index];\n        break;\n      }\n    }\n\n    if (key != null) {\n      this.pdfNames.remove(key);\n    }\n  }\n  /**\n   * Generates `Unique string name`.\n   * @private\n   */\n\n\n  generateName() {\n    let name = Guid.getNewGuidString();\n    return name;\n  }\n\n  add(arg1, arg2) {\n    if (arg1 instanceof PdfFont) {\n      let dictionary = null;\n      let fonts = this.items.getValue(this.dictionaryProperties.font);\n\n      if (fonts != null) {\n        dictionary = fonts;\n        dictionary = fonts;\n      } else {\n        dictionary = new PdfDictionary();\n        this.items.setValue(this.dictionaryProperties.font, dictionary);\n      }\n\n      dictionary.items.setValue(arg2.value, new PdfReferenceHolder(arg1.element));\n    } else if (arg1 instanceof PdfTemplate) {\n      let xobjects;\n      xobjects = this.items.getValue(this.dictionaryProperties.xObject); // Create fonts dictionary.\n\n      if (xobjects == null) {\n        xobjects = new PdfDictionary();\n        this.items.setValue(this.dictionaryProperties.xObject, xobjects);\n      }\n\n      xobjects.items.setValue(arg2.value, new PdfReferenceHolder(arg1.element));\n    } else if (arg1 instanceof PdfBrush) {\n      if (arg1 instanceof PdfGradientBrush || arg1 instanceof PdfTilingBrush) {\n        let savable = arg1.element;\n\n        if (savable != null) {\n          let pattern = this.items.getValue(this.dictionaryProperties.pattern); // Create a new pattern dictionary.\n\n          if (pattern == null) {\n            pattern = new PdfDictionary();\n            this.items.setValue(this.dictionaryProperties.pattern, pattern);\n          }\n\n          pattern.items.setValue(arg2.value, new PdfReferenceHolder(savable));\n        }\n      }\n    } else if (arg1 instanceof PdfTransparency) {\n      let savable = arg1.element;\n      let transDic = null;\n      transDic = this.items.getValue(this.dictionaryProperties.extGState); // Create a new pattern dictionary.\n\n      if (transDic == null) {\n        transDic = new PdfDictionary();\n        this.items.setValue(this.dictionaryProperties.extGState, transDic);\n      }\n\n      transDic.items.setValue(arg2.value, new PdfReferenceHolder(savable));\n    } else {\n      /* tslint:disable */\n      let xobjects = this.Dictionary.items.getValue(this.dictionaryProperties.xObject);\n      let parentXObjects;\n\n      if (typeof this.pdfDocument !== 'undefined') {\n        parentXObjects = this.pdfDocument.sections.element.items.getValue(this.dictionaryProperties.resources).items.getValue(this.dictionaryProperties.xObject);\n      }\n\n      let values = this.Dictionary.items.values();\n      let hasSameImageStream = false;\n      let oldReference;\n\n      if (typeof this.pdfDocument !== 'undefined' && (typeof parentXObjects === undefined || parentXObjects == null)) {\n        parentXObjects = new PdfDictionary();\n        this.pdfDocument.sections.element.items.getValue(this.dictionaryProperties.resources).items.setValue(this.dictionaryProperties.xObject, parentXObjects);\n      } else if (typeof this.pdfDocument !== 'undefined') {\n        let values = parentXObjects.items.values();\n\n        for (let i = 0; i < values.length; i++) {\n          if (typeof values[i] !== 'undefined' && typeof values[i].element !== 'undefined') {\n            if (values[i].element.data[0] === arg1.element.data[0]) {\n              oldReference = values[i];\n              hasSameImageStream = true;\n            }\n          }\n        }\n      }\n\n      if (xobjects == null) {\n        xobjects = new PdfDictionary();\n        this.Dictionary.items.setValue(this.dictionaryProperties.xObject, xobjects);\n      }\n\n      if (hasSameImageStream && typeof oldReference !== 'undefined') {\n        xobjects.items.setValue(arg2.value, oldReference);\n      } else {\n        let reference = new PdfReferenceHolder(arg1.element);\n        xobjects.items.setValue(arg2.value, reference);\n\n        if (typeof this.pdfDocument !== 'undefined') {\n          parentXObjects.items.setValue(arg2.value, reference);\n        }\n      }\n      /* tslint:enable */\n\n    }\n  }\n\n}\n/* tslint:disable */\n\n/**\n * Used to create new guid for resources.\n * @private\n */\n\n\nclass Guid {\n  /**\n   * Generate `new GUID`.\n   * @private\n   */\n  static getNewGuidString() {\n    return 'aaaaaaaa-aaaa-4aaa-baaa-aaaaaaaaaaaa'.replace(/[ab]/g, c => {\n      let random = Math.random() * 16 | 0;\n      let result = c === 'a' ? random : random & 0x3 | 0x8;\n      return result.toString(16);\n    });\n  }\n\n}\n/* tslint:enable */\n\n/**\n * `PdfTilingBrush` Implements a colored tiling brush.\n */\n\n\nclass PdfTilingBrush extends PdfBrush {\n  /**\n   * Initializes a new instance of the `PdfTilingBrush` class.\n   * @public\n   */\n  constructor(arg1, arg2) {\n    super();\n    /**\n     * Local variable to store Stroking.\n     * @private\n     */\n\n    this.mStroking = false;\n    /**\n     * Local variable to store the tile start location.\n     * @private\n     */\n\n    this.mLocation = new PointF(0, 0);\n    /**\n     * Local variable to store the dictionary properties.\n     * @private\n     */\n\n    this.mDictionaryProperties = new DictionaryProperties();\n    let rect = null;\n\n    if (arg1 instanceof Rectangle) {\n      rect = arg1;\n    } else if (arg1 instanceof SizeF) {\n      rect = new Rectangle(0, 0, arg1.width, arg1.height);\n    }\n\n    if (arg2 !== null && arg2 instanceof PdfPage) {\n      this.mPage = arg2;\n    }\n\n    this.brushStream = new PdfStream();\n    this.mResources = new PdfResources();\n    this.brushStream.items.setValue(this.mDictionaryProperties.resources, this.mResources);\n    this.setBox(rect);\n    this.setObligatoryFields();\n\n    if (arg2 !== null && arg2 instanceof PdfPage) {\n      this.mPage = arg2;\n      this.graphics.colorSpace = arg2.document.colorSpace;\n    }\n  }\n  /**\n   * Initializes a new instance of the `PdfTilingBrush` class.\n   * @private\n   * @param rectangle The size of the smallest brush cell.\n   * @param page The Current Page Object.\n   * @param location The Tile start location.\n   * @param matrix The matrix.\n   */\n\n\n  initialize(rectangle, page, location, matrix) {\n    this.mPage = page;\n    this.mLocation = location;\n    this.mTransformationMatrix = matrix;\n    this.tempBrushStream = this.brushStream;\n    this.brushStream = new PdfStream();\n    let tempResource = new PdfResources();\n    this.brushStream.items.setValue(this.mDictionaryProperties.resources, tempResource);\n    this.setBox(rectangle);\n    this.setObligatoryFields();\n    return this;\n  } //Properties\n\n  /**\n   * Location representing the start position of the tiles.\n   * @public\n   */\n\n\n  get location() {\n    return this.mLocation;\n  }\n\n  set location(value) {\n    this.mLocation = value;\n  }\n  /**\n   * Sets the obligatory fields.\n   * @private\n   */\n\n\n  setObligatoryFields() {\n    this.brushStream.items.setValue(this.mDictionaryProperties.patternType, new PdfNumber(1)); //  Tiling brush.\n\n    this.brushStream.items.setValue(this.mDictionaryProperties.paintType, new PdfNumber(1)); //  Coloured.\n\n    this.brushStream.items.setValue(this.mDictionaryProperties.tilingType, new PdfNumber(1)); //  Constant spacing.\n\n    this.brushStream.items.setValue(this.mDictionaryProperties.xStep, new PdfNumber(this.mBox.right - this.mBox.left));\n    this.brushStream.items.setValue(this.mDictionaryProperties.yStep, new PdfNumber(this.mBox.bottom - this.mBox.top));\n\n    if (this.mPage != null && this.mLocation != null) {\n      if (this.mTransformationMatrix == null && typeof this.mTransformationMatrix === 'undefined') {\n        // Transform the tile origin to fit the location\n        let tileTransform = this.mPage.size.height % this.rectangle.size.height - this.mLocation.y;\n        /* tslint:disable-next-line:max-line-length */\n\n        this.brushStream.items.setValue(this.mDictionaryProperties.matrix, new PdfArray([1, 0, 0, 1, this.mLocation.x, tileTransform]));\n      } else {\n        let tileTransform = 0; // Transform the tile origin to fit the location\n\n        let elements = this.mTransformationMatrix.matrix.elements;\n\n        if (this.mPage.size.height > this.rectangle.size.height) {\n          tileTransform = this.mTransformationMatrix.matrix.offsetY - this.mPage.size.height % this.rectangle.size.height;\n        } else {\n          tileTransform = this.mPage.size.height % this.rectangle.size.height + this.mTransformationMatrix.matrix.offsetY;\n        }\n\n        this.brushStream.items.setValue(this.mDictionaryProperties.matrix, new PdfArray([elements[0], elements[1], elements[2], elements[3], elements[4], tileTransform]));\n      }\n    }\n  }\n  /**\n   * Sets the BBox coordinates.\n   * @private\n   */\n\n\n  setBox(box) {\n    this.mBox = box;\n    let rect = new RectangleF(this.mBox.left, this.mBox.top, this.mBox.right, this.mBox.bottom);\n    this.brushStream.items.setValue(this.mDictionaryProperties.bBox, PdfArray.fromRectangle(rect));\n  } //Properties\n\n  /**\n   * Gets the boundary box of the smallest brush cell.\n   * @public\n   */\n\n\n  get rectangle() {\n    return this.mBox;\n  }\n  /**\n   * Gets the size of the smallest brush cell.\n   * @public\n   */\n\n\n  get size() {\n    return this.mBox.size;\n  }\n  /**\n   * Gets Graphics context of the brush.\n   */\n\n\n  get graphics() {\n    if (this.mGraphics == null && typeof this.mGraphics === 'undefined') {\n      let gr = new GetResourceEventHandler(this);\n      let g = new PdfGraphics(this.size, gr, this.brushStream);\n      this.mGraphics = g;\n      this.mResources = this.getResources();\n      this.mGraphics.initializeCoordinates();\n    }\n\n    return this.mGraphics;\n  }\n  /**\n   * Gets the resources and modifies the template dictionary.\n   * @public\n   */\n\n\n  getResources() {\n    return this.mResources;\n  }\n  /**\n   * Gets or sets a value indicating whether this PdfTilingBrush\n   * is used for stroking operations.\n   */\n\n\n  get stroking() {\n    return this.mStroking;\n  }\n\n  set stroking(value) {\n    this.mStroking = value;\n  } //PdfBrush methods\n\n  /**\n   * Creates a new copy of a brush.\n   * @public\n   */\n\n\n  clone() {\n    let brush = this.initialize(this.rectangle, this.mPage, this.location, this.mTransformationMatrix);\n\n    if (this.mTransformationMatrix != null && this.mTransformationMatrix.matrix != null) {\n      /* tslint:disable-next-line:max-line-length */\n      brush.brushStream.items.setValue(this.mDictionaryProperties.matrix, new PdfArray(this.mTransformationMatrix.matrix.elements));\n    }\n\n    brush.brushStream.data = this.tempBrushStream.data;\n    brush.mResources = new PdfResources(this.mResources);\n    brush.brushStream.items.setValue(this.mDictionaryProperties.resources, brush.mResources);\n    return brush;\n  }\n  /**\n   * Monitors the changes of the brush and modify PDF state respectfully.\n   * @param brush The brush\n   * @param streamWriter The stream writer\n   * @param getResources The get resources delegate.\n   * @param saveChanges if set to true the changes should be saved anyway.\n   * @param currentColorSpace The current color space.\n   */\n\n  /* tslint:disable-next-line:max-line-length */\n\n\n  monitorChanges(brush, streamWriter, getResources, saveChanges, currentColorSpace) {\n    let diff = false;\n\n    if (brush !== this) {\n      //  Set the Pattern colour space.\n      streamWriter.setColorSpace('Pattern', this.mStroking); //  Set the pattern for non-stroking operations.\n\n      let resources1 = getResources.getResources();\n      let name1 = resources1.getName(this);\n      streamWriter.setColourWithPattern(null, name1, this.mStroking);\n      diff = true;\n    } else if (brush instanceof PdfTilingBrush) {\n      //  Set the /Pattern colour space.\n      streamWriter.setColorSpace('Pattern', this.mStroking); //  Set the pattern for non-stroking operations.\n\n      let resources = getResources.getResources();\n      let name = resources.getName(this);\n      streamWriter.setColourWithPattern(null, name, this.mStroking);\n      diff = true;\n    }\n\n    return diff;\n  }\n  /**\n   * Resets the changes, which were made by the brush.\n   * In other words resets the state to the initial one.\n   * @param streamWriter The stream writer.\n   */\n\n\n  resetChanges(streamWriter) {//  We shouldn't do anything to reset changes.\n    //  All changes will be reset automatically by setting a new colour space.\n  }\n  /* tslint:enable */\n  // IPdfWrapper Members\n\n  /**\n   * Gets the `element`.\n   * @public\n   */\n\n\n  get element() {\n    return this.brushStream;\n  }\n\n}\n/**\n * PdfGraphics.ts class for EJ2-PDF\n */\n\n/**\n * `PdfGraphics` class represents a graphics context of the objects.\n * It's used for performing all the graphics operations.\n * ```typescript\n * // create a new PDF document\n * let document : PdfDocument = new PdfDocument();\n * // add a new page to the document\n * let page1 : PdfPage = document.pages.add();\n * // set the font\n * let font : PdfStandardFont = new PdfStandardFont(PdfFontFamily.Helvetica, 20);\n * // create black brush\n * let blackBrush : PdfSolidBrush = new PdfSolidBrush(new PdfColor(0, 0, 0));\n * //\n * //graphics of the page\n * let page1Graphics : PdfGraphics = page1.graphics;\n * // draw the text on the page1 graphics\n * page1Graphics.drawString('Hello World', font, blackBrush, new PointF(0, 0));\n * //\n * // save the document\n * document.save('output.pdf');\n * // destroy the document\n * document.destroy();\n * ```\n */\n\n\nlet PdfGraphics = /*#__PURE__*/(() => {\n  class PdfGraphics {\n    constructor(arg1, arg2, arg3) {\n      /**\n       * Represents the `Current color space`.\n       * @private\n       */\n      this.currentColorSpace = PdfColorSpace.Rgb;\n      /**\n       * Stores `previous rendering mode`.\n       * @private\n       */\n\n      this.previousTextRenderingMode = TextRenderingMode.Fill;\n      /**\n       * Previous `character spacing` value or 0.\n       * @private\n       */\n\n      this.previousCharacterSpacing = 0.0;\n      /**\n       * Previous `word spacing` value or 0.\n       * @private\n       */\n\n      this.previousWordSpacing = 0.0;\n      /**\n       * The `previously used text scaling` value.\n       * @private\n       */\n\n      this.previousTextScaling = 100.0;\n      /**\n       * Instance of `ProcedureSets` class.\n       * @private\n       */\n\n      this.procedureSets = new ProcedureSets();\n      /**\n       * To check wihether it is a `direct text rendering`.\n       * @default true\n       * @private\n       */\n\n      this.isNormalRender = true;\n      /**\n       * check whether to `use font size` to calculate the shift.\n       * @default false\n       * @private\n       */\n\n      this.isUseFontSize = false;\n      /**\n       * check whether the font is in `italic type`.\n       * @default false\n       * @private\n       */\n\n      this.isItalic = false;\n      /**\n       * Check whether it is an `emf Text Matrix`.\n       * @default false\n       * @private\n       */\n\n      this.isEmfTextScaled = false;\n      /**\n       * Check whether it is an `emf` call.\n       * @default false\n       * @private\n       */\n\n      this.isEmf = false;\n      /**\n       * Check whether it is an `emf plus` call.\n       * @default false\n       * @private\n       */\n\n      this.isEmfPlus = false;\n      /**\n       * Check whether it is in `base line format`.\n       * @default true\n       * @private\n       */\n\n      this.isBaselineFormat = true;\n      /**\n       * Emf Text `Scaling Factor`.\n       * @private\n       */\n\n      this.emfScalingFactor = new SizeF(0, 0);\n      /**\n       * To check whether the `last color space` of document and garphics is saved.\n       * @private\n       */\n\n      this.colorSpaceChanged = false;\n      /**\n       * Stores an instance of `DictionaryProperties`.\n       * @private\n       */\n\n      this.dictionaryProperties = new DictionaryProperties();\n      /**\n       * Checks whether the x co-ordinate is need to set as client size or not.\n       * @hidden\n       * @private\n       */\n\n      this.isOverloadWithPosition = false;\n      /**\n       * Checks whether the x co-ordinate is need to set as client size or not.\n       * @hidden\n       * @private\n       */\n\n      this.isPointOverload = false;\n      /**\n       * Current colorspaces.\n       * @hidden\n       * @private\n       */\n\n      this.currentColorSpaces = ['RGB', 'CMYK', 'GrayScale', 'Indexed'];\n      /**\n       * Checks the current image `is optimized` or not.\n       * @default false.\n       * @private\n       */\n\n      this.isImageOptimized = false;\n      /**\n       * Stores the `graphics states`.\n       * @private\n       */\n\n      this.graphicsState = [];\n      /**\n       * Indicates whether the object `had trasparency`.\n       * @default false\n       * @private\n       */\n\n      this.istransparencySet = false;\n      /**\n       * Stores the instance of `PdfAutomaticFieldInfoCollection` class .\n       * @default null\n       * @private\n       */\n\n      this.internalAutomaticFields = null;\n      /**\n       * Stores the index of the start line that should draw with in the next page.\n       * @private\n       */\n\n      this.startCutIndex = -1;\n      this.getResources = arg2;\n      this.canvasSize = arg1;\n\n      if (arg3 instanceof PdfStreamWriter) {\n        this.pdfStreamWriter = arg3;\n      } else {\n        this.pdfStreamWriter = new PdfStreamWriter(arg3);\n      }\n\n      this.initialize();\n    } //  Properties\n\n    /**\n     * Returns the `result` after drawing string.\n     * @private\n     */\n\n\n    get stringLayoutResult() {\n      return this.pdfStringLayoutResult;\n    }\n    /**\n     * Gets the `size` of the canvas.\n     * @private\n     */\n\n\n    get size() {\n      return this.canvasSize;\n    }\n    /**\n     * Gets and Sets the value of `MediaBox upper right bound`.\n     * @private\n     */\n\n\n    get mediaBoxUpperRightBound() {\n      if (typeof this.internalMediaBoxUpperRightBound === 'undefined') {\n        this.internalMediaBoxUpperRightBound = 0;\n      }\n\n      return this.internalMediaBoxUpperRightBound;\n    }\n\n    set mediaBoxUpperRightBound(value) {\n      this.internalMediaBoxUpperRightBound = value;\n    }\n    /**\n     * Gets the `size` of the canvas reduced by margins and page templates.\n     * @private\n     */\n\n\n    get clientSize() {\n      return new SizeF(this.clipBounds.width, this.clipBounds.height);\n    }\n    /**\n     * Gets or sets the current `color space` of the document\n     * @private\n     */\n\n\n    get colorSpace() {\n      return this.currentColorSpace;\n    }\n\n    set colorSpace(value) {\n      this.currentColorSpace = value;\n    }\n    /**\n     * Gets the `stream writer`.\n     * @private\n     */\n\n\n    get streamWriter() {\n      return this.pdfStreamWriter;\n    }\n    /**\n     * Gets the `transformation matrix` reflecting current transformation.\n     * @private\n     */\n\n\n    get matrix() {\n      if (this.transformationMatrix == null) {\n        this.transformationMatrix = new PdfTransformationMatrix();\n      }\n\n      return this.transformationMatrix;\n    }\n    /**\n     * Gets the `layer` for the graphics, if exists.\n     * @private\n     */\n\n\n    get layer() {\n      return this.pageLayer;\n    }\n    /**\n     * Gets the `page` for this graphics, if exists.\n     * @private\n     */\n\n\n    get page() {\n      return this.pageLayer.page;\n    }\n\n    get automaticFields() {\n      if (this.internalAutomaticFields == null || typeof this.internalAutomaticFields === 'undefined') {\n        this.internalAutomaticFields = new PdfAutomaticFieldInfoCollection();\n      }\n\n      return this.internalAutomaticFields;\n    } //Implementation\n\n    /**\n     * `Initializes` this instance.\n     * @private\n     */\n\n\n    initialize() {\n      this.bStateSaved = false;\n      this.currentPen = null;\n      this.currentBrush = null;\n      this.currentFont = null;\n      this.currentColorSpace = PdfColorSpace.Rgb;\n      this.bCSInitialized = false;\n      this.transformationMatrix = null;\n      this.previousTextRenderingMode = -1; //.Fill;\n\n      this.previousCharacterSpacing = -1.0;\n      this.previousWordSpacing = -1.0;\n      this.previousTextScaling = -100.0; // this.m_trasparencies = null;\n\n      this.currentStringFormat = null;\n      this.clipBounds = new RectangleF(new PointF(0, 0), this.size);\n      this.getResources.getResources().requireProcedureSet(this.procedureSets.pdf);\n    }\n\n    drawPdfTemplate(template, location, size) {\n      if (typeof size === 'undefined') {\n        if (template == null) {\n          throw Error('ArgumentNullException-template');\n        }\n\n        this.drawPdfTemplate(template, location, template.size);\n      } else {\n        // let crossTable : PdfCrossTable = null;\n        // if (this.pageLayer != null) {\n        //     crossTable = (this.page as PdfPage).section.parentDocument.crossTable;\n        // }\n        if (template == null) {\n          throw Error('ArgumentNullException-template');\n        }\n\n        let scaleX = template.width > 0 ? size.width / template.width : 1;\n        let scaleY = template.height > 0 ? size.height / template.height : 1;\n        let bNeedScale = !(scaleX === 1 && scaleY === 1); // Save state.\n\n        let state = this.save(); // Take into consideration that rect location is bottom/left.\n\n        let matrix = new PdfTransformationMatrix();\n\n        if (this.pageLayer != null) {\n          this.getTranslateTransform(location.x, location.y + size.height, matrix);\n        }\n\n        if (bNeedScale) {\n          this.getScaleTransform(scaleX, scaleY, matrix);\n        }\n\n        this.pdfStreamWriter.modifyCtm(matrix); // Output template.\n\n        let resources = this.getResources.getResources();\n        let name = resources.getName(template);\n        this.pdfStreamWriter.executeObject(name); // Restore state.\n\n        this.restore(state); //Transfer automatic fields from template.\n\n        let g = template.graphics;\n\n        if (g != null) {\n          for (let index = 0; index < g.automaticFields.automaticFields.length; index++) {\n            let fieldInfo = g.automaticFields.automaticFields[index];\n            let newLocation = new PointF(fieldInfo.location.x + location.x, fieldInfo.location.y + location.y);\n            let scalingX = template.size.width == 0 ? 0 : size.width / template.size.width;\n            let scalingY = template.size.height == 0 ? 0 : size.height / template.size.height;\n            this.automaticFields.add(new PdfAutomaticFieldInfo(fieldInfo.field, newLocation, scalingX, scalingY));\n            this.page.dictionary.modify();\n          }\n        }\n\n        this.getResources.getResources().requireProcedureSet(this.procedureSets.imageB);\n        this.getResources.getResources().requireProcedureSet(this.procedureSets.imageC);\n        this.getResources.getResources().requireProcedureSet(this.procedureSets.imageI);\n        this.getResources.getResources().requireProcedureSet(this.procedureSets.text);\n      }\n    }\n    /* tslint:disable */\n\n    /**\n     * @public\n     */\n\n\n    drawString(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9) {\n      if (typeof arg1 === 'string' && arg2 instanceof PdfFont && (arg3 instanceof PdfPen || arg3 === null) && (arg4 instanceof PdfBrush || arg4 === null) && typeof arg5 === 'number' && typeof arg6 === 'number' && (arg7 instanceof PdfStringFormat || arg7 === null) && typeof arg8 === 'undefined') {\n        this.isOverloadWithPosition = true;\n        this.drawString(arg1, arg2, arg3, arg4, arg5, arg6, this.clientSize.width - arg5, 0, arg7);\n      } else {\n        let temparg3 = arg3;\n        let temparg4 = arg4;\n        let temparg5 = arg5;\n        let temparg6 = arg6;\n        let temparg7 = arg7;\n        let temparg8 = arg8;\n        let temparg9 = arg9;\n        let layouter = new PdfStringLayouter();\n        let result = layouter.layout(arg1, arg2, temparg9, new SizeF(temparg7, temparg8), this.isOverloadWithPosition, this.clientSize);\n\n        if (!result.empty) {\n          let rect = this.checkCorrectLayoutRectangle(result.actualSize, temparg5, temparg6, temparg9);\n\n          if (temparg7 <= 0) {\n            temparg5 = rect.x;\n            temparg7 = rect.width;\n          }\n\n          if (temparg8 <= 0) {\n            temparg6 = rect.y;\n            temparg8 = rect.height;\n          }\n\n          this.drawStringLayoutResult(result, arg2, temparg3, temparg4, new RectangleF(temparg5, temparg6, temparg7, temparg8), temparg9);\n          this.isEmfTextScaled = false;\n          this.emfScalingFactor = new SizeF(0, 0);\n        }\n\n        this.getResources.getResources().requireProcedureSet(this.procedureSets.text);\n        this.isNormalRender = true;\n        this.pdfStringLayoutResult = result;\n        this.isUseFontSize = false;\n      }\n    }\n    /* tslint:enable */\n\n\n    drawLine(arg1, arg2, arg3, arg4, arg5) {\n      if (arg2 instanceof PointF) {\n        let temparg2 = arg2;\n        let temparg3 = arg3;\n        this.drawLine(arg1, temparg2.x, temparg2.y, temparg3.x, temparg3.y);\n      } else {\n        let temparg2 = arg2;\n        let temparg3 = arg3;\n        let temparg4 = arg4;\n        let temparg5 = arg5;\n        this.stateControl(arg1, null, null);\n        let sw = this.streamWriter;\n        sw.beginPath(temparg2, temparg3);\n        sw.appendLineSegment(temparg4, temparg5);\n        sw.strokePath();\n        this.getResources.getResources().requireProcedureSet(this.procedureSets.pdf);\n      }\n    }\n    /* tslint:disable */\n\n\n    drawRectangle(arg1, arg2, arg3, arg4, arg5, arg6) {\n      if (arg1 instanceof PdfPen && typeof arg2 === 'number') {\n        let temparg3 = arg3;\n        this.drawRectangle(arg1, null, arg2, temparg3, arg4, arg5);\n      } else if (arg1 instanceof PdfBrush && typeof arg2 === 'number') {\n        let temparg3 = arg3;\n        this.drawRectangle(null, arg1, arg2, temparg3, arg4, arg5);\n      } else {\n        let temparg3 = arg3;\n        let temparg4 = arg4;\n        let temparg5 = arg5;\n        let temparg6 = arg6;\n\n        if (arg2 instanceof PdfTilingBrush) {\n          this.bCSInitialized = false;\n          let xOffset = this.matrix.matrix.offsetX + temparg3;\n          let yOffset;\n\n          if (this.layer != null && this.layer.page != null) {\n            yOffset = this.layer.page.size.height - this.matrix.matrix.offsetY + temparg4;\n          } else {\n            yOffset = this.clientSize.height - this.matrix.matrix.offsetY + temparg4;\n          }\n\n          arg2.location = new PointF(xOffset, yOffset);\n          arg2.graphics.colorSpace = this.colorSpace;\n        } else if (arg2 instanceof PdfGradientBrush) {\n          arg2.colorSpace = this.colorSpace;\n        }\n\n        if (arg2 instanceof PdfSolidBrush && arg2.color.isEmpty) {\n          arg2 = null;\n        }\n\n        let temparg1 = arg1;\n        let temparg2 = arg2;\n        this.stateControl(temparg1, temparg2, null);\n        this.streamWriter.appendRectangle(temparg3, temparg4, temparg5, temparg6);\n        this.drawPathHelper(temparg1, temparg2, false);\n      }\n    }\n\n    drawPathHelper(arg1, arg2, arg3, arg4) {\n      if (typeof arg3 === 'boolean') {\n        let temparg3 = arg3;\n        this.drawPathHelper(arg1, arg2, PdfFillMode.Winding, temparg3);\n      } else {\n        let temparg3 = arg3;\n        let isPen = arg1 != null;\n        let isBrush = arg2 != null;\n        let isEvenOdd = temparg3 === PdfFillMode.Alternate;\n\n        if (isPen && isBrush) {\n          this.streamWriter.fillStrokePath(isEvenOdd);\n        } else if (!isPen && !isBrush) {\n          this.streamWriter.endPath();\n        } else if (isPen) {\n          this.streamWriter.strokePath();\n        } else {\n          this.streamWriter.fillPath(isEvenOdd);\n        }\n      }\n    }\n    /* tslint:disable */\n\n\n    drawImage(arg1, arg2, arg3, arg4, arg5) {\n      if (typeof arg2 === 'number' && typeof arg3 === 'number' && typeof arg4 === 'undefined') {\n        let size = arg1.physicalDimension;\n        this.drawImage(arg1, arg2, arg3, size.width, size.height);\n      } else {\n        let temparg2 = arg2;\n        let temparg3 = arg3;\n        let temparg5 = arg5;\n        arg1.save();\n        let matrix = new PdfTransformationMatrix();\n        this.getTranslateTransform(temparg2, temparg3 + temparg5, matrix);\n        this.getScaleTransform(arg4, arg5, matrix);\n        this.pdfStreamWriter.write('q');\n        this.pdfStreamWriter.modifyCtm(matrix); // Output template.\n\n        let resources = this.getResources.getResources();\n\n        if (typeof this.pageLayer !== 'undefined' && this.page != null) {\n          resources.document = this.page.document;\n        }\n\n        let name = resources.getName(arg1);\n\n        if (typeof this.pageLayer !== 'undefined') {\n          this.page.setResources(resources);\n        }\n\n        this.pdfStreamWriter.executeObject(name);\n        this.pdfStreamWriter.write(Operators.restoreState);\n        this.pdfStreamWriter.write(Operators.newLine);\n        let resource = this.getResources.getResources();\n        resource.requireProcedureSet(this.procedureSets.imageB);\n        resource.requireProcedureSet(this.procedureSets.imageC);\n        resource.requireProcedureSet(this.procedureSets.imageI);\n        resource.requireProcedureSet(this.procedureSets.text);\n      }\n    } //Implementation\n\n    /* tslint:disable */\n\n    /**\n     * Returns `bounds` of the line info.\n     * @private\n     */\n\n\n    getLineBounds(lineIndex, result, font, layoutRectangle, format) {\n      let bounds;\n\n      if (!result.empty && lineIndex < result.lineCount && lineIndex >= 0) {\n        let line = result.lines[lineIndex];\n        let vShift = this.getTextVerticalAlignShift(result.actualSize.height, layoutRectangle.height, format);\n        let y = vShift + layoutRectangle.y + result.lineHeight * lineIndex;\n        let lineWidth = line.width;\n        let hShift = this.getHorizontalAlignShift(lineWidth, layoutRectangle.width, format);\n        let lineIndent = this.getLineIndent(line, format, layoutRectangle, lineIndex === 0);\n        hShift += !this.rightToLeft(format) ? lineIndent : 0;\n        let x = layoutRectangle.x + hShift;\n        /* tslint:disable */\n\n        let width = !this.shouldJustify(line, layoutRectangle.width, format) ? lineWidth - lineIndent : layoutRectangle.width - lineIndent;\n        /* tslint:enable */\n\n        let height = result.lineHeight;\n        bounds = new RectangleF(x, y, width, height);\n      } else {\n        bounds = new RectangleF(0, 0, 0, 0);\n      }\n\n      return bounds;\n    }\n    /**\n     * Creates `lay outed rectangle` depending on the text settings.\n     * @private\n     */\n\n\n    checkCorrectLayoutRectangle(textSize, x, y, format) {\n      let layoutedRectangle = new RectangleF(x, y, textSize.width, textSize.width);\n\n      if (format != null) {\n        switch (format.alignment) {\n          case PdfTextAlignment.Center:\n            layoutedRectangle.x -= layoutedRectangle.width / 2;\n            break;\n\n          case PdfTextAlignment.Right:\n            layoutedRectangle.x -= layoutedRectangle.width;\n            break;\n        }\n\n        switch (format.lineAlignment) {\n          case PdfVerticalAlignment.Middle:\n            layoutedRectangle.y -= layoutedRectangle.height / 2;\n            break;\n\n          case PdfVerticalAlignment.Bottom:\n            layoutedRectangle.y -= layoutedRectangle.height;\n            break;\n        }\n      }\n\n      return layoutedRectangle;\n    }\n    /**\n     * Sets the `layer` for the graphics.\n     * @private\n     */\n\n\n    setLayer(layer) {\n      this.pageLayer = layer;\n      let page = layer.page;\n\n      if (page != null && typeof page !== 'undefined') {\n        page.beginSave = this.pageSave;\n      }\n    }\n    /**\n     * Adding page number field before page saving.\n     * @private\n     */\n\n    /* tslint:disable */\n\n\n    pageSave(page) {\n      if (page.graphics.automaticFields != null) {\n        for (let i = 0; i < page.graphics.automaticFields.automaticFields.length; i++) {\n          let fieldInfo = page.graphics.automaticFields.automaticFields[i];\n          fieldInfo.field.performDraw(page.graphics, fieldInfo.location, fieldInfo.scalingX, fieldInfo.scalingY);\n        }\n      }\n    }\n    /**\n     * `Draws a layout result`.\n     * @private\n     */\n\n\n    drawStringLayoutResult(result, font, pen, brush, layoutRectangle, format) {\n      if (!result.empty) {\n        this.applyStringSettings(font, pen, brush, format, layoutRectangle); // Set text scaling\n\n        let textScaling = format != null ? format.horizontalScalingFactor : 100.0;\n\n        if (textScaling !== this.previousTextScaling && !this.isEmfTextScaled) {\n          this.pdfStreamWriter.setTextScaling(textScaling);\n          this.previousTextScaling = textScaling;\n        }\n\n        let height = format == null || format.lineSpacing === 0 ? font.height : format.lineSpacing + font.height;\n        let subScript = format != null && format.subSuperScript === PdfSubSuperScript.SubScript;\n        let shift = 0;\n        shift = subScript ? height - (font.height + font.metrics.getDescent(format)) : height - font.metrics.getAscent(format);\n        this.shift = shift;\n        this.pdfStreamWriter.startNextLine(layoutRectangle.x, layoutRectangle.y - shift);\n        this.pdfStreamWriter.setLeading(+height);\n        let resultHeight = 0;\n        let remainingString = '';\n\n        for (let i = 0; i < result.lines.length; i++) {\n          resultHeight += result.lineHeight;\n\n          if (layoutRectangle.y + resultHeight > this.clientSize.height) {\n            this.startCutIndex = i;\n            break;\n          }\n        }\n\n        for (let j = this.startCutIndex; j < result.lines.length && j >= 0; j++) {\n          remainingString += result.lines[j].text;\n        }\n\n        let bounds = new RectangleF(layoutRectangle.x, layoutRectangle.y, layoutRectangle.width, layoutRectangle.height);\n        this.drawLayoutResult(result, font, format, layoutRectangle);\n        this.underlineStrikeoutText(pen, brush, result, font, bounds, format);\n        this.isEmfPlus = false;\n        this.isUseFontSize = false;\n\n        if (this.startCutIndex !== -1) {\n          let page = this.getNextPage();\n          page.graphics.drawString(remainingString, font, pen, brush, layoutRectangle.x, 0, layoutRectangle.width, 0, format);\n        }\n      } else {\n        throw new Error('ArgumentNullException:result');\n      }\n    }\n    /**\n     * Gets the `next page`.\n     * @private\n     */\n\n\n    getNextPage() {\n      let section = this.currentPage.section;\n      let nextPage = null;\n      let index = section.indexOf(this.currentPage);\n\n      if (index === section.count - 1) {\n        nextPage = section.add();\n      } else {\n        nextPage = section.getPages()[index + 1];\n      }\n\n      return nextPage;\n    }\n\n    setClip(rectangle, mode) {\n      if (typeof mode === 'undefined') {\n        this.setClip(rectangle, PdfFillMode.Winding);\n      } else {\n        this.pdfStreamWriter.appendRectangle(rectangle);\n        this.pdfStreamWriter.clipPath(mode === PdfFillMode.Alternate);\n      }\n    }\n    /**\n     * Applies all the `text settings`.\n     * @private\n     */\n\n\n    applyStringSettings(font, pen, brush, format, bounds) {\n      if (brush instanceof PdfTilingBrush) {\n        this.bCSInitialized = false;\n        brush.graphics.colorSpace = this.colorSpace;\n      } else if (brush instanceof PdfGradientBrush) {\n        this.bCSInitialized = false;\n        brush.colorSpace = this.colorSpace;\n      }\n\n      let tm = this.getTextRenderingMode(pen, brush, format);\n      this.stateControl(pen, brush, font, format);\n      this.pdfStreamWriter.beginText();\n\n      if (tm !== this.previousTextRenderingMode) {\n        this.pdfStreamWriter.setTextRenderingMode(tm);\n        this.previousTextRenderingMode = tm;\n      } // Set character spacing.\n\n\n      let cs = format != null ? format.characterSpacing : 0;\n\n      if (cs !== this.previousCharacterSpacing && !this.isEmfTextScaled) {\n        this.pdfStreamWriter.setCharacterSpacing(cs);\n        this.previousCharacterSpacing = cs;\n      } // Set word spacing.\n      // NOTE: it works only if the space code is equal to 32 (0x20).\n\n\n      let ws = format != null ? format.wordSpacing : 0;\n\n      if (ws !== this.previousWordSpacing) {\n        this.pdfStreamWriter.setWordSpacing(ws);\n        this.previousWordSpacing = ws;\n      }\n    }\n    /**\n     * Calculates `shift value` if the text is vertically aligned.\n     * @private\n     */\n\n\n    getTextVerticalAlignShift(textHeight, boundsHeight, format) {\n      let shift = 0;\n\n      if (boundsHeight >= 0 && format != null && format.lineAlignment !== PdfVerticalAlignment.Top) {\n        switch (format.lineAlignment) {\n          case PdfVerticalAlignment.Middle:\n            shift = (boundsHeight - textHeight) / 2;\n            break;\n\n          case PdfVerticalAlignment.Bottom:\n            shift = boundsHeight - textHeight;\n            break;\n        }\n      }\n\n      return shift;\n    }\n    /* tslint:disable */\n\n    /**\n     * `Draws layout result`.\n     * @private\n     */\n\n\n    drawLayoutResult(result, font, format, layoutRectangle) {\n      let vAlignShift = this.getTextVerticalAlignShift(result.actualSize.height, layoutRectangle.height, format);\n\n      if (vAlignShift !== 0) {\n        this.pdfStreamWriter.startNextLine(0, vAlignShift);\n      }\n\n      let ttfFont = font;\n      let unicode = ttfFont != null && ttfFont.isUnicode;\n      let embed = ttfFont != null && ttfFont.isEmbedFont;\n      let lines = result.lines;\n\n      for (let i = 0, len = lines.length; i < len && i !== this.startCutIndex; i++) {\n        let lineInfo = lines[i];\n        let line = lineInfo.text;\n        let lineWidth = lineInfo.width;\n        let hAlignShift = this.getHorizontalAlignShift(lineWidth, layoutRectangle.width, format);\n        let lineIndent = this.getLineIndent(lineInfo, format, layoutRectangle, i === 0);\n        hAlignShift += !this.rightToLeft(format) ? lineIndent : 0;\n\n        if (hAlignShift !== 0 && !this.isEmfTextScaled) {\n          this.pdfStreamWriter.startNextLine(hAlignShift, 0);\n        }\n\n        if (unicode) {\n          this.drawUnicodeLine(lineInfo, layoutRectangle, font, format);\n        } else {\n          this.drawAsciiLine(lineInfo, layoutRectangle, font, format);\n        }\n\n        if (hAlignShift !== 0 && !this.isEmfTextScaled) {\n          this.pdfStreamWriter.startNextLine(-hAlignShift, 0);\n        }\n\n        if (this.isOverloadWithPosition && lines.length > 1) {\n          this.pdfStreamWriter.startNextLine(-layoutRectangle.x, 0);\n          layoutRectangle.x = 0;\n          layoutRectangle.width = this.clientSize.width;\n          this.isOverloadWithPosition = false;\n          this.isPointOverload = true;\n        }\n      }\n\n      this.getResources.getResources().requireProcedureSet(this.procedureSets.text);\n\n      if (vAlignShift !== 0) {\n        this.pdfStreamWriter.startNextLine(0, -(vAlignShift - result.lineHeight));\n      }\n\n      this.pdfStreamWriter.endText();\n    }\n    /**\n     * `Draws Ascii line`.\n     * @private\n     */\n\n\n    drawAsciiLine(lineInfo, layoutRectangle, font, format) {\n      this.justifyLine(lineInfo, layoutRectangle.width, format);\n      let value = '';\n\n      if (lineInfo.text.indexOf('(') !== -1 || lineInfo.text.indexOf(')') !== -1) {\n        for (let i = 0; i < lineInfo.text.length; i++) {\n          if (lineInfo.text[i] === '(') {\n            value += '\\\\\\(';\n          } else if (lineInfo.text[i] === ')') {\n            value += '\\\\\\)';\n          } else {\n            value += lineInfo.text[i];\n          }\n        }\n      }\n\n      if (value === '') {\n        value = lineInfo.text;\n      }\n\n      let line = '(' + value + ')';\n      this.pdfStreamWriter.showNextLineText(new PdfString(line));\n    }\n    /**\n     * Draws unicode line.\n     * @private\n     */\n\n\n    drawUnicodeLine(lineInfo, layoutRectangle, font, format) {\n      let line = lineInfo.text;\n      let lineWidth = lineInfo.width;\n      let rtl = format !== null && typeof format !== 'undefined' && format.rightToLeft;\n      let useWordSpace = format !== null && typeof format !== 'undefined' && (format.wordSpacing !== 0 || format.alignment === PdfTextAlignment.Justify);\n      let ttfFont = font;\n      let wordSpacing = this.justifyLine(lineInfo, layoutRectangle.width, format);\n      let rtlRender = new RtlRenderer();\n\n      if (rtl || format !== null && typeof format !== 'undefined' && format.textDirection !== PdfTextDirection.None) {\n        let blocks = null;\n        let rightAlign = format !== null && typeof format !== 'undefined' && format.alignment === PdfTextAlignment.Right;\n\n        if (format !== null && typeof format !== 'undefined' && format.textDirection !== PdfTextDirection.None) {\n          /* tslint:disable-next-line:max-line-length */\n          blocks = rtlRender.layout(line, ttfFont, format.textDirection === PdfTextDirection.RightToLeft ? true : false, useWordSpace, format);\n        } else {\n          blocks = rtlRender.layout(line, ttfFont, rightAlign, useWordSpace, format);\n        }\n\n        let words = null;\n\n        if (blocks.length > 1) {\n          if (format !== null && typeof format !== 'undefined' && format.textDirection !== PdfTextDirection.None) {\n            /* tslint:disable-next-line:max-line-length */\n            words = rtlRender.splitLayout(line, ttfFont, format.textDirection === PdfTextDirection.RightToLeft ? true : false, useWordSpace, format);\n          } else {\n            words = rtlRender.splitLayout(line, ttfFont, rightAlign, useWordSpace, format);\n          }\n        } else {\n          words = [line];\n        }\n\n        this.drawUnicodeBlocks(blocks, words, ttfFont, format, wordSpacing);\n      } else {\n        if (useWordSpace) {\n          let result = this.breakUnicodeLine(line, ttfFont, null);\n          let blocks = result.tokens;\n          let words = result.words;\n          this.drawUnicodeBlocks(blocks, words, ttfFont, format, wordSpacing);\n        } else {\n          let token = this.convertToUnicode(line, ttfFont);\n          let value = this.getUnicodeString(token);\n          this.streamWriter.showNextLineText(value);\n        }\n      }\n    }\n    /**\n     * Draws array of unicode tokens.\n     */\n\n    /* tslint:disable */\n\n\n    drawUnicodeBlocks(blocks, words, font, format, wordSpacing) {\n      /* tslint:enable */\n      if (blocks == null) {\n        throw new Error('Argument Null Exception : blocks');\n      }\n\n      if (words == null) {\n        throw new Error('Argument Null Exception : words');\n      }\n\n      if (font == null) {\n        throw new Error('Argument Null Exception : font');\n      }\n\n      this.streamWriter.startNextLine();\n      let x = 0;\n      let xShift = 0;\n      let firstLineIndent = 0;\n      let paragraphIndent = 0;\n\n      try {\n        if (format !== null && typeof format !== 'undefined') {\n          firstLineIndent = format.firstLineIndent;\n          paragraphIndent = format.paragraphIndent;\n          format.firstLineIndent = 0;\n          format.paragraphIndent = 0;\n        }\n\n        let spaceWidth = font.getCharWidth(StringTokenizer.whiteSpace, format) + wordSpacing;\n        let characterSpacing = format != null ? format.characterSpacing : 0;\n        let wordSpace = format !== null && typeof format !== 'undefined' && wordSpacing === 0 ? format.wordSpacing : 0;\n        spaceWidth += characterSpacing + wordSpace;\n\n        for (let i = 0; i < blocks.length; i++) {\n          let token = blocks[i];\n          let word = words[i];\n          let tokenWidth = 0;\n\n          if (x !== 0) {\n            this.streamWriter.startNextLine(x, 0);\n          }\n\n          if (word.length > 0) {\n            tokenWidth +=\n            /*Utils.Round(*/\n            font.measureString(word, format).width\n            /*)*/\n            ;\n            tokenWidth += characterSpacing;\n            let val = this.getUnicodeString(token);\n            this.streamWriter.showText(val);\n          }\n\n          if (i !== blocks.length - 1) {\n            x = tokenWidth + spaceWidth;\n            xShift += x;\n          }\n        } // Rolback current line position.\n\n\n        if (xShift > 0) {\n          this.streamWriter.startNextLine(-xShift, 0);\n        }\n      } finally {\n        if (format !== null && typeof format !== 'undefined') {\n          format.firstLineIndent = firstLineIndent;\n          format.paragraphIndent = paragraphIndent;\n        }\n      }\n    }\n    /**\n     * Breakes the unicode line to the words and converts symbols to glyphs.\n     */\n\n\n    breakUnicodeLine(line, ttfFont, words) {\n      if (line === null) {\n        throw new Error('Argument Null Exception : line');\n      }\n\n      words = line.split(null);\n      let tokens = [];\n\n      for (let i = 0; i < words.length; i++) {\n        // Reconvert string according to unicode standard.\n        let word = words[i];\n        let token = this.convertToUnicode(word, ttfFont);\n        tokens[i] = token;\n      }\n\n      return {\n        tokens: tokens,\n        words: words\n      };\n    }\n    /**\n     * Creates PdfString from the unicode text.\n     */\n\n\n    getUnicodeString(token) {\n      if (token === null) {\n        throw new Error('Argument Null Exception : token');\n      }\n\n      let val = new PdfString(token);\n      val.converted = true;\n      val.encode = InternalEnum.ForceEncoding.Ascii;\n      return val;\n    }\n    /**\n     * Converts to unicode format.\n     */\n\n\n    convertToUnicode(text, ttfFont) {\n      let token = null;\n\n      if (text == null) {\n        throw new Error('Argument Null Exception : text');\n      }\n\n      if (ttfFont == null) {\n        throw new Error('Argument Null Exception : ttfFont');\n      }\n\n      if (ttfFont.fontInternal instanceof UnicodeTrueTypeFont) {\n        let ttfReader = ttfFont.fontInternal.ttfReader;\n        ttfFont.setSymbols(text);\n        token = ttfReader.convertString(text);\n        let bytes = PdfString.toUnicodeArray(token, false);\n        token = PdfString.byteToString(bytes);\n      }\n\n      return token;\n    }\n    /**\n     * `Justifies` the line if needed.\n     * @private\n     */\n\n\n    justifyLine(lineInfo, boundsWidth, format) {\n      let line = lineInfo.text;\n      let lineWidth = lineInfo.width;\n      let shouldJustify = this.shouldJustify(lineInfo, boundsWidth, format);\n      let hasWordSpacing = format != null && format.wordSpacing !== 0;\n      let symbols = StringTokenizer.spaces;\n      let whitespacesCount = StringTokenizer.getCharsCount(line, symbols);\n      let wordSpace = 0;\n\n      if (shouldJustify) {\n        // Correct line width.\n        if (hasWordSpacing) {\n          lineWidth -= whitespacesCount * format.wordSpacing;\n        }\n\n        let difference = boundsWidth - lineWidth;\n        wordSpace = difference / whitespacesCount;\n        this.pdfStreamWriter.setWordSpacing(wordSpace);\n      } else {\n        // If there is justifying, but the line shouldn't be justified, restore default word spacing.\n        if (hasWordSpacing) {\n          this.pdfStreamWriter.setWordSpacing(format.wordSpacing);\n        } else {\n          this.pdfStreamWriter.setWordSpacing(0);\n        }\n      }\n\n      return wordSpace;\n    }\n    /**\n     * `Reset` or reinitialize the current graphic value.\n     * @private\n     */\n\n\n    reset(size) {\n      this.canvasSize = size;\n      this.streamWriter.clear();\n      this.initialize();\n      this.initializeCoordinates();\n    }\n    /**\n     * Checks whether the line should be `justified`.\n     * @private\n     */\n\n\n    shouldJustify(lineInfo, boundsWidth, format) {\n      let line = lineInfo.text;\n      let lineWidth = lineInfo.width;\n      let justifyStyle = format != null && format.alignment === PdfTextAlignment.Justify;\n      let goodWidth = boundsWidth >= 0 && lineWidth < boundsWidth;\n      let symbols = StringTokenizer.spaces;\n      let whitespacesCount = StringTokenizer.getCharsCount(line, symbols);\n      let hasSpaces = whitespacesCount > 0 && line[0] !== StringTokenizer.whiteSpace;\n      let goodLineBreakStyle = (lineInfo.lineType & LineType.LayoutBreak) > 0;\n      /* tslint:disable */\n\n      let shouldJustify = justifyStyle && goodWidth && hasSpaces && (goodLineBreakStyle || format.alignment === PdfTextAlignment.Justify);\n      /* tslint:enable */\n\n      return shouldJustify;\n    }\n    /* tslint:disable */\n\n    /**\n     * Emulates `Underline, Strikeout` of the text if needed.\n     * @private\n     */\n\n\n    underlineStrikeoutText(pen, brush, result, font, layoutRectangle, format) {\n      if (font.underline || font.strikeout) {\n        // Calculate line width.\n        let linePen = this.createUnderlineStikeoutPen(pen, brush, font, format);\n\n        if (linePen != null) {\n          // Approximate line positions.\n          let vShift = this.getTextVerticalAlignShift(result.actualSize.height, layoutRectangle.height, format);\n          let underlineYOffset = 0;\n          underlineYOffset = layoutRectangle.y + vShift + font.metrics.getAscent(format) + 1.5 * linePen.width;\n          let strikeoutYOffset = layoutRectangle.y + vShift + font.metrics.getHeight(format) / 2 + 1.5 * linePen.width;\n          let lines = result.lines; // Run through the text and draw lines.\n\n          for (let i = 0, len = result.lineCount; i < len; i++) {\n            let lineInfo = lines[i];\n            let line = lineInfo.text;\n            let lineWidth = lineInfo.width;\n            let hShift = this.getHorizontalAlignShift(lineWidth, layoutRectangle.width, format);\n            let lineIndent = this.getLineIndent(lineInfo, format, layoutRectangle, i === 0);\n            hShift += !this.rightToLeft(format) ? lineIndent : 0;\n            let x1 = layoutRectangle.x + hShift;\n            /* tslint:disable */\n\n            let x2 = !this.shouldJustify(lineInfo, layoutRectangle.width, format) ? x1 + lineWidth - lineIndent : x1 + layoutRectangle.width - lineIndent;\n            /* tslint:enable */\n\n            if (font.underline) {\n              let y = underlineYOffset;\n              this.drawLine(linePen, x1, y, x2, y);\n              underlineYOffset += result.lineHeight;\n            }\n\n            if (font.strikeout) {\n              let y = strikeoutYOffset;\n              this.drawLine(linePen, x1, y, x2, y);\n              strikeoutYOffset += result.lineHeight;\n            }\n\n            if (this.isPointOverload && lines.length > 1) {\n              layoutRectangle.x = 0;\n              layoutRectangle.width = this.clientSize.width;\n            }\n          }\n\n          this.isPointOverload = false;\n        }\n      }\n    }\n    /**\n     * `Creates a pen` for drawing lines in the text.\n     * @private\n     */\n\n\n    createUnderlineStikeoutPen(pen, brush, font, format) {\n      // Calculate line width.\n      let lineWidth = font.metrics.getSize(format) / 20;\n      let linePen = null; // Create a pen fo the lines.\n\n      if (pen != null) {\n        linePen = new PdfPen(pen.color, lineWidth);\n      } else if (brush != null) {\n        linePen = new PdfPen(brush, lineWidth);\n      }\n\n      return linePen;\n    }\n    /**\n     * Return `text rendering mode`.\n     * @private\n     */\n\n\n    getTextRenderingMode(pen, brush, format) {\n      let tm = TextRenderingMode.None;\n\n      if (pen != null && brush != null) {\n        tm = TextRenderingMode.FillStroke;\n      } else if (pen != null) {\n        tm = TextRenderingMode.Stroke;\n      } else {\n        tm = TextRenderingMode.Fill;\n      }\n\n      if (format != null && format.clipPath) {\n        tm |= TextRenderingMode.ClipFlag;\n      }\n\n      return tm;\n    }\n    /**\n     * Returns `line indent` for the line.\n     * @private\n     */\n\n\n    getLineIndent(lineInfo, format, layoutBounds, firstLine) {\n      let lineIndent = 0;\n      let firstParagraphLine = (lineInfo.lineType & LineType.FirstParagraphLine) > 0;\n\n      if (format != null && firstParagraphLine) {\n        lineIndent = firstLine ? format.firstLineIndent : format.paragraphIndent;\n        lineIndent = layoutBounds.width > 0 ? Math.min(layoutBounds.width, lineIndent) : lineIndent;\n      }\n\n      return lineIndent;\n    }\n    /**\n     * Calculates shift value if the line is `horizontaly aligned`.\n     * @private\n     */\n\n\n    getHorizontalAlignShift(lineWidth, boundsWidth, format) {\n      let shift = 0;\n\n      if (boundsWidth >= 0 && format != null && format.alignment !== PdfTextAlignment.Left) {\n        switch (format.alignment) {\n          case PdfTextAlignment.Center:\n            shift = (boundsWidth - lineWidth) / 2;\n            break;\n\n          case PdfTextAlignment.Right:\n            shift = boundsWidth - lineWidth;\n            break;\n        }\n      }\n\n      return shift;\n    }\n    /**\n     * Gets or sets the value that indicates `text direction` mode.\n     * @private\n     */\n\n\n    rightToLeft(format) {\n      let rtl = format !== null && typeof format !== 'undefined' && format.rightToLeft;\n\n      if (format !== null && typeof format !== 'undefined') {\n        if (format.textDirection !== PdfTextDirection.None && typeof format.textDirection !== 'undefined') {\n          rtl = true;\n        }\n      }\n\n      return rtl;\n    }\n\n    stateControl(pen, brush, font, format) {\n      if (typeof format === 'undefined') {\n        this.stateControl(pen, brush, font, null);\n      } else {\n        if (brush instanceof PdfGradientBrush) {\n          this.bCSInitialized = false;\n          brush.colorSpace = this.colorSpace;\n        }\n\n        if (brush instanceof PdfTilingBrush) {\n          this.bCSInitialized = false;\n          brush.graphics.colorSpace = this.colorSpace;\n        }\n\n        let saveState = false;\n\n        if (brush !== null) {\n          if (typeof this.pageLayer !== 'undefined' && this.pageLayer != null) {\n            if (this.colorSpaceChanged === false) {\n              this.lastDocumentCS = this.pageLayer.page.document.colorSpace;\n              this.lastGraphicsCS = this.pageLayer.page.graphics.colorSpace;\n              this.colorSpace = this.pageLayer.page.document.colorSpace;\n              this.currentColorSpace = this.pageLayer.page.document.colorSpace;\n              this.colorSpaceChanged = true;\n            }\n          }\n\n          this.initCurrentColorSpace(this.currentColorSpace);\n        } else if (pen != null) {\n          if (typeof this.pageLayer !== 'undefined' && this.pageLayer != null) {\n            /* tslint:disable */\n            this.colorSpace = this.pageLayer.page.document.colorSpace;\n            this.currentColorSpace = this.pageLayer.page.document.colorSpace;\n          }\n\n          this.initCurrentColorSpace(this.currentColorSpace);\n        }\n\n        this.penControl(pen, saveState);\n        this.brushControl(brush, saveState);\n        this.fontControl(font, format, saveState);\n      }\n    }\n    /**\n     * Initializes the `current color space`.\n     * @private\n     */\n\n\n    initCurrentColorSpace(colorspace) {\n      let re = this.getResources.getResources();\n\n      if (!this.bCSInitialized) {\n        if (this.currentColorSpace != PdfColorSpace.GrayScale) {\n          this.pdfStreamWriter.setColorSpace('Device' + this.currentColorSpaces[this.currentColorSpace], true);\n          this.pdfStreamWriter.setColorSpace('Device' + this.currentColorSpaces[this.currentColorSpace], false);\n          this.bCSInitialized = true;\n        } else {\n          this.pdfStreamWriter.setColorSpace('DeviceGray', true);\n          this.pdfStreamWriter.setColorSpace('DeviceGray', false);\n          this.bCSInitialized = true;\n        }\n      }\n    }\n    /**\n     * Controls the `pen state`.\n     * @private\n     */\n\n\n    penControl(pen, saveState) {\n      if (pen != null) {\n        this.currentPen = pen;\n        /* tslint:disable */\n\n        pen.monitorChanges(this.currentPen, this.pdfStreamWriter, this.getResources, saveState, this.colorSpace, this.matrix.clone());\n        /* tslint:enable */\n\n        this.currentPen = pen.clone();\n      }\n    }\n    /**\n     * Controls the `brush state`.\n     * @private\n     */\n\n\n    brushControl(brush, saveState) {\n      if (brush != null && typeof brush !== 'undefined') {\n        let b = brush.clone();\n        let lgb = b;\n\n        if (lgb !== null && typeof lgb !== 'undefined' && !(brush instanceof PdfSolidBrush) && !(brush instanceof PdfTilingBrush)) {\n          let m = lgb.matrix;\n          let matrix = this.matrix.clone();\n\n          if (m != null) {\n            m.multiply(matrix);\n            matrix = m;\n          }\n\n          lgb.matrix = matrix;\n        }\n\n        this.currentBrush = lgb;\n        b.monitorChanges(this.currentBrush, this.pdfStreamWriter, this.getResources, saveState, this.colorSpace);\n        /* tslint:enable */\n\n        this.currentBrush = brush;\n        brush = null;\n      }\n    }\n    /**\n     * Saves the font and other `font settings`.\n     * @private\n     */\n\n\n    fontControl(font, format, saveState) {\n      if (font != null) {\n        let curSubSuper = format != null ? format.subSuperScript : PdfSubSuperScript.None;\n        /* tslint:disable */\n\n        let prevSubSuper = this.currentStringFormat != null ? this.currentStringFormat.subSuperScript : PdfSubSuperScript.None;\n        /* tslint:enable */\n\n        if (saveState || font !== this.currentFont || curSubSuper !== prevSubSuper) {\n          let resources = this.getResources.getResources();\n          this.currentFont = font;\n          this.currentStringFormat = format;\n          let size = font.metrics.getSize(format);\n          /* tslint:disable */\n\n          this.isEmfTextScaled = false;\n          let fontName = resources.getName(font);\n          this.pdfStreamWriter.setFont(font, fontName, size);\n        }\n      }\n    }\n\n    setTransparency(arg1, arg2, arg3) {\n      if (typeof arg2 === 'undefined') {\n        this.istransparencySet = true;\n        this.setTransparency(arg1, arg1, PdfBlendMode.Normal);\n      } else if (typeof arg2 === 'number' && typeof arg3 === 'undefined') {\n        this.setTransparency(arg1, arg2, PdfBlendMode.Normal);\n      } else {\n        if (this.trasparencies == null) {\n          this.trasparencies = new TemporaryDictionary();\n        }\n\n        let transp = null;\n        let td = new TransparencyData(arg1, arg2, arg3);\n\n        if (this.trasparencies.containsKey(td)) {\n          transp = this.trasparencies.getValue(td);\n        }\n\n        if (transp == null) {\n          transp = new PdfTransparency(arg1, arg2, arg3);\n          this.trasparencies.setValue(td, transp);\n        }\n\n        let resources = this.getResources.getResources();\n        let name = resources.getName(transp);\n        let sw = this.streamWriter;\n        sw.setGraphicsState(name);\n      }\n    }\n\n    clipTranslateMargins(x, y, left, top, right, bottom) {\n      if (x instanceof RectangleF && typeof y === 'undefined') {\n        this.clipBounds = x;\n        this.pdfStreamWriter.writeComment('Clip margins.');\n        this.pdfStreamWriter.appendRectangle(x);\n        this.pdfStreamWriter.closePath();\n        this.pdfStreamWriter.clipPath(false);\n        this.pdfStreamWriter.writeComment('Translate co-ordinate system.');\n        this.translateTransform(x.x, x.y);\n      } else if (typeof x === 'number') {\n        let clipArea = new RectangleF(left, top, this.size.width - left - right, this.size.height - top - bottom);\n        this.clipBounds = clipArea;\n        this.pdfStreamWriter.writeComment(\"Clip margins.\");\n        this.pdfStreamWriter.appendRectangle(clipArea);\n        this.pdfStreamWriter.closePath();\n        this.pdfStreamWriter.clipPath(false);\n        this.pdfStreamWriter.writeComment(\"Translate co-ordinate system.\");\n        this.translateTransform(x, y);\n      }\n    }\n    /**\n     * `Updates y` co-ordinate.\n     * @private\n     */\n\n\n    updateY(y) {\n      return -y;\n    }\n    /**\n     * Used to `translate the transformation`.\n     * ```typescript\n     * // create a new PDF document\n     * let document : PdfDocument = new PdfDocument();\n     * // create a new page\n     * let page1 : PdfPage = document.pages.add();\n     * // set pen\n     * let pen : PdfPen = new PdfPen(new PdfColor(0, 0, 0));\n     * //\n     * // set translate transform\n     * page1.graphics.translateTransform(100, 100);\n     * //\n     * // draw the rectangle after applying translate transform\n     * page1.graphics.drawRectangle(pen, new RectangleF({x : 0, y : 0}, {width : 100, height : 50}));\n     * // save the document.\n     * document.save('output.pdf');\n     * // destroy the document\n     * document.destroy();\n     * ```\n     * @param offsetX The x-coordinate of the translation.\n     * @param offsetY The y-coordinate of the translation.\n     */\n\n\n    translateTransform(offsetX, offsetY) {\n      let matrix = new PdfTransformationMatrix();\n      this.getTranslateTransform(offsetX, offsetY, matrix);\n      this.pdfStreamWriter.modifyCtm(matrix);\n      this.matrix.multiply(matrix);\n    }\n    /**\n     * `Translates` coordinates of the input matrix.\n     * @private\n     */\n\n\n    getTranslateTransform(x, y, input) {\n      input.translate(x, this.updateY(y));\n      return input;\n    }\n    /* tslint:disable */\n\n    /**\n     * Applies the specified `scaling operation` to the transformation matrix of this Graphics by prepending it to the object's transformation matrix.\n     * ```typescript\n     * // create a new PDF document\n     * let document : PdfDocument = new PdfDocument();\n     * // create a new page\n     * let page1 : PdfPage = document.pages.add();\n     * // create pen\n     * let pen : PdfPen = new PdfPen(new PdfColor(0, 0, 0));\n     * //\n     * // apply scaling trasformation\n     * page1.graphics.scaleTransform(1.5, 2);\n     * //\n     * // draw the rectangle after applying scaling transform\n     * page1.graphics.drawRectangle(pen, new RectangleF({x : 100, y : 100}, {width : 100, height : 50}));\n     * // save the document.\n     * document.save('output.pdf');\n     * // destroy the document\n     * document.destroy();\n     * ```\n     * @param scaleX Scale factor in the x direction.\n     * @param scaleY Scale factor in the y direction.\n     */\n\n    /* tslint:enable */\n\n\n    scaleTransform(scaleX, scaleY) {\n      let matrix = new PdfTransformationMatrix();\n      this.getScaleTransform(scaleX, scaleY, matrix);\n      this.pdfStreamWriter.modifyCtm(matrix);\n      this.matrix.multiply(matrix);\n    }\n    /**\n     * `Scales` coordinates of the input matrix.\n     * @private\n     */\n\n\n    getScaleTransform(x, y, input) {\n      if (input == null) {\n        input = new PdfTransformationMatrix();\n      }\n\n      input.scale(x, y);\n      return input;\n    }\n    /**\n     * Applies the specified `rotation` to the transformation matrix of this Graphics.\n     * ```typescript\n     * // create a new PDF document\n     * let document : PdfDocument = new PdfDocument();\n     * // create a new page\n     * let page1 : PdfPage = document.pages.add();\n     * // create pen\n     * let pen : PdfPen = new PdfPen(new PdfColor(0, 0, 0));\n     * //\n     * // set RotateTransform with 25 degree of angle\n     * page1.graphics.rotateTransform(25);\n     * //\n     * // draw the rectangle after RotateTransformation\n     * page1.graphics.drawRectangle(pen, new RectangleF({x : 100, y : 100}, {width : 100, height : 50}));\n     * // save the document.\n     * document.save('output.pdf');\n     * // destroy the document\n     * document.destroy();\n     * ```\n     * @param angle Angle of rotation in degrees.\n     */\n\n\n    rotateTransform(angle) {\n      let matrix = new PdfTransformationMatrix();\n      this.getRotateTransform(angle, matrix);\n      this.pdfStreamWriter.modifyCtm(matrix);\n      this.matrix.multiply(matrix);\n    }\n    /**\n     * `Initializes coordinate system`.\n     * @private\n     */\n\n\n    initializeCoordinates() {\n      // Matrix equation: TM(T-1)=M', where T=[1 0 0 -1 0 h]\n      this.pdfStreamWriter.writeComment('Change co-ordinate system to left/top.'); // Translate co-ordinates only, don't flip.\n\n      if (this.mediaBoxUpperRightBound !== -this.size.height) {\n        if (this.cropBox == null) {\n          if (this.mediaBoxUpperRightBound === this.size.height || this.mediaBoxUpperRightBound === 0) {\n            this.translateTransform(0, this.updateY(this.size.height));\n          } else {\n            this.translateTransform(0, this.updateY(this.mediaBoxUpperRightBound));\n          }\n        }\n      }\n    }\n    /**\n     * `Rotates` coordinates of the input matrix.\n     * @private\n     */\n\n\n    getRotateTransform(angle, input) {\n      if (input == null || typeof input === 'undefined') {\n        input = new PdfTransformationMatrix();\n      }\n\n      input.rotate(this.updateY(angle));\n      return input;\n    }\n    /**\n     * `Saves` the current state of this Graphics and identifies the saved state with a GraphicsState.\n     * ```typescript\n     * // create a new PDF document\n     * let document : PdfDocument = new PdfDocument();\n     * // create a new page\n     * let page1 : PdfPage = document.pages.add();\n     * // create pen\n     * let pen : PdfPen = new PdfPen(new PdfColor(0, 0, 0));\n     * //\n     * // save the graphics state\n     * let state1 : PdfGraphicsState = page1.graphics.save();\n     * //\n     * page1.graphics.scaleTransform(1.5, 2);\n     * // draw the rectangle\n     * page1.graphics.drawRectangle(pen, new RectangleF({x : 100, y : 100}, {width : 100, height : 50}));\n     * // restore the graphics state\n     * page1.graphics.restore(state1);\n     * // save the document.\n     * document.save('output.pdf');\n     * // destroy the document\n     * document.destroy();\n     * ```\n     */\n\n\n    save() {\n      let state = new PdfGraphicsState(this, this.matrix.clone());\n      state.brush = this.currentBrush;\n      state.pen = this.currentPen;\n      state.font = this.currentFont;\n      state.colorSpace = this.currentColorSpace;\n      state.characterSpacing = this.previousCharacterSpacing;\n      state.wordSpacing = this.previousWordSpacing;\n      state.textScaling = this.previousTextScaling;\n      state.textRenderingMode = this.previousTextRenderingMode;\n      this.graphicsState.push(state);\n      this.pdfStreamWriter.saveGraphicsState();\n      return state;\n    }\n\n    restore(state) {\n      if (typeof state === 'undefined') {\n        if (this.graphicsState.length > 0) {\n          this.doRestoreState();\n        }\n      } else {\n        if (this.graphicsState.indexOf(state) !== -1) {\n          for (;;) {\n            if (this.graphicsState.length === 0) {\n              break;\n            }\n\n            let popState = this.doRestoreState();\n\n            if (popState === state) {\n              break;\n            }\n          }\n        }\n      }\n    }\n    /**\n     * `Restores graphics state`.\n     * @private\n     */\n\n\n    doRestoreState() {\n      let state = this.graphicsState.pop();\n      this.transformationMatrix = state.matrix;\n      this.currentBrush = state.brush;\n      this.currentPen = state.pen;\n      this.currentFont = state.font;\n      this.currentColorSpace = state.colorSpace;\n      this.previousCharacterSpacing = state.characterSpacing;\n      this.previousWordSpacing = state.wordSpacing;\n      this.previousTextScaling = state.textScaling;\n      this.previousTextRenderingMode = state.textRenderingMode;\n      this.pdfStreamWriter.restoreGraphicsState();\n      return state;\n    }\n    /* tslint:enable */\n\n    /**\n     * `Draws the specified path`, using its original physical size, at the location specified by a coordinate pair.\n     * ```typescript\n     * // create a new PDF document.\n     * let document : PdfDocument = new PdfDocument();\n     * // add a page to the document.\n     * let page1 : PdfPage = document.pages.add();\n     * //Create new PDF path.\n     * let path : PdfPath = new PdfPath();\n     * //Add line path points.\n     * path.addLine(new PointF(10, 100), new PointF(10, 200));\n     * path.addLine(new PointF(100, 100), new PointF(100, 200));\n     * path.addLine(new PointF(100, 200), new PointF(55, 150));\n     * // set pen\n     * let pen : PdfPen = new PdfPen(new PdfColor(255, 0, 0));\n     * // set brush\n     * let brush : PdfSolidBrush = new PdfSolidBrush(new PdfColor(0, 0, 0));\n     * // draw the path\n     * page1.graphics.drawPath(pen, brush, path);\n     * //\n     * // save the document.\n     * document.save('output.pdf');\n     * // destroy the document\n     * document.destroy();\n     * ```\n     * @param pen Color of the text.\n     * @param brush Color of the text.\n     * @param path Draw path.\n     */\n\n\n    drawPath(pen, brush, path) {\n      if (brush instanceof PdfTilingBrush) {\n        this.bCSInitialized = false;\n        brush.graphics.colorSpace = this.colorSpace;\n      } else if (brush instanceof PdfGradientBrush) {\n        this.bCSInitialized = false;\n        brush.colorSpace = this.colorSpace;\n      }\n\n      this.stateControl(pen, brush, null);\n      this.buildUpPath(path.pathPoints, path.pathTypes);\n      this.drawPathHelper(pen, brush, path.fillMode, false);\n    }\n    /* tslint:disable-next-line:max-line-length */\n\n\n    drawArc(arg1, arg2, arg3, arg4, arg5, arg6, arg7) {\n      if (arg2 instanceof RectangleF) {\n        this.drawArc(arg1, arg2.x, arg2.y, arg2.width, arg2.height, arg3, arg4);\n      } else {\n        if (arg7 !== 0) {\n          this.stateControl(arg1, null, null);\n          this.constructArcPath(arg2, arg3, arg2 + arg4, arg3 + arg5, arg6, arg7);\n          this.drawPathHelper(arg1, null, false);\n        }\n      }\n    }\n    /**\n     * Builds up the path.\n     * @private\n     */\n\n\n    buildUpPath(arg1, arg2) {\n      let cnt = arg1.length;\n\n      for (let i = 0; i < cnt; ++i) {\n        let typeValue = 0;\n        let point = arg1[i];\n\n        switch (arg2[i] & PdfGraphics.pathTypesValuesMask) {\n          case PathPointType.Start:\n            this.pdfStreamWriter.beginPath(point.x, point.y);\n            break;\n\n          case PathPointType.Bezier3:\n            let p2 = new PointF(0, 0);\n            let p3 = new PointF(0, 0);\n            let result1 = this.getBezierPoints(arg1, arg2, i, p2, p3);\n            this.pdfStreamWriter.appendBezierSegment(point, result1.p2, result1.p3);\n            i = result1.i;\n            break;\n\n          case PathPointType.Line:\n            this.pdfStreamWriter.appendLineSegment(point);\n            break;\n\n          default:\n            throw new Error('ArithmeticException - Incorrect path formation.');\n        }\n\n        typeValue = arg2[i];\n        this.checkFlags(typeValue);\n      }\n    }\n    /**\n     * Gets the bezier points from respective arrays.\n     * @private\n     */\n\n    /* tslint:disable-next-line:max-line-length */\n\n\n    getBezierPoints(points, types, i, p2, p3) {\n      ++i;\n\n      if ((types[i] & PdfGraphics.pathTypesValuesMask) === PathPointType.Bezier3) {\n        p2 = points[i];\n        ++i;\n\n        if ((types[i] & PdfGraphics.pathTypesValuesMask) === PathPointType.Bezier3) {\n          p3 = points[i];\n        } else {\n          throw new Error('ArgumentException : errorMsg');\n        }\n      } else {\n        throw new Error('ArgumentException : errorMsg');\n      }\n\n      return {\n        i: i,\n        p2: p2,\n        p3: p3\n      };\n    }\n    /**\n     * Checks path point type flags.\n     * @private\n     */\n\n\n    checkFlags(type) {\n      if ((type & PathPointType.CloseSubpath) === PathPointType.CloseSubpath) {\n        this.pdfStreamWriter.closePath();\n      }\n    }\n    /**\n     * Constructs the arc path using Bezier curves.\n     * @private\n     */\n\n\n    constructArcPath(x1, y1, x2, y2, startAng, sweepAngle) {\n      let points = this.getBezierArc(x1, y1, x2, y2, startAng, sweepAngle);\n\n      if (points.length === 0) {\n        return;\n      }\n\n      let pt = [points[0], points[1], points[2], points[3], points[4], points[5], points[6], points[7]];\n      this.pdfStreamWriter.beginPath(pt[0], pt[1]);\n      let i = 0;\n\n      for (i = 0; i < points.length; i = i + 8) {\n        pt = [points[i], points[i + 1], points[i + 2], points[i + 3], points[i + 4], points[i + 5], points[i + 6], points[i + 7]];\n        this.pdfStreamWriter.appendBezierSegment(pt[2], pt[3], pt[4], pt[5], pt[6], pt[7]);\n      }\n    }\n    /**\n     * Gets the bezier points for arc constructing.\n     * @private\n     */\n\n\n    getBezierArc(numX1, numY1, numX2, numY2, s1, e1) {\n      if (numX1 > numX2) {\n        let tmp;\n        tmp = numX1;\n        numX1 = numX2;\n        numX2 = tmp;\n      }\n\n      if (numY2 > numY1) {\n        let tmp;\n        tmp = numY1;\n        numY1 = numY2;\n        numY2 = tmp;\n      }\n\n      let fragAngle1;\n      let numFragments;\n\n      if (Math.abs(e1) <= 90) {\n        fragAngle1 = e1;\n        numFragments = 1;\n      } else {\n        numFragments = Math.ceil(Math.abs(e1) / 90);\n        fragAngle1 = e1 / numFragments;\n      }\n\n      let xcen = (numX1 + numX2) / 2;\n      let ycen = (numY1 + numY2) / 2;\n      let rx = (numX2 - numX1) / 2;\n      let ry = (numY2 - numY1) / 2;\n      let halfAng = fragAngle1 * (Math.PI / 360);\n      let kappa = Math.abs(4.0 / 3.0 * (1.0 - Math.cos(halfAng)) / Math.sin(halfAng));\n      let pointsList = [];\n\n      for (let i = 0; i < numFragments; i++) {\n        let thetaValue0 = (s1 + i * fragAngle1) * (Math.PI / 180);\n        let thetaValue1 = (s1 + (i + 1) * fragAngle1) * (Math.PI / 180);\n        let cos0 = Math.cos(thetaValue0);\n        let cos1 = Math.cos(thetaValue1);\n        let sin0 = Math.sin(thetaValue0);\n        let sin1 = Math.sin(thetaValue1);\n\n        if (fragAngle1 > 0) {\n          /* tslint:disable-next-line:max-line-length */\n          pointsList.push(xcen + rx * cos0, ycen - ry * sin0, xcen + rx * (cos0 - kappa * sin0), ycen - ry * (sin0 + kappa * cos0), xcen + rx * (cos1 + kappa * sin1), ycen - ry * (sin1 - kappa * cos1), xcen + rx * cos1, ycen - ry * sin1);\n        } else {\n          /* tslint:disable-next-line:max-line-length */\n          pointsList.push(xcen + rx * cos0, ycen - ry * sin0, xcen + rx * (cos0 + kappa * sin0), ycen - ry * (sin0 - kappa * cos0), xcen + rx * (cos1 - kappa * sin1), ycen - ry * (sin1 + kappa * cos1), xcen + rx * cos1, ycen - ry * sin1);\n        }\n      }\n\n      return pointsList;\n    }\n\n  }\n\n  // Constants\n\n  /**\n   * Specifies the mask of `path type values`.\n   * @private\n   */\n  PdfGraphics.pathTypesValuesMask = 0xf;\n  /**\n   * Checks whether the object is `transparencyObject`.\n   * @hidden\n   * @private\n   */\n\n  PdfGraphics.transparencyObject = false;\n  /**\n   * `GetResourceEventHandler` class is alternate for event handlers and delegates.\n   * @private\n   * @hidden\n   */\n\n  return PdfGraphics;\n})();\n\nclass GetResourceEventHandler {\n  /**\n   * Return the instance of `PdfResources` class.\n   * @private\n   */\n  getResources() {\n    return this.sender.getResources();\n  }\n  /**\n   * Initialize instance of `GetResourceEventHandler` class.\n   * Alternate for event handlers and delegates.\n   * @private\n   */\n\n\n  constructor(sender) {\n    this.sender = sender;\n  }\n\n}\n\nclass PdfGraphicsState {\n  constructor(graphics, matrix) {\n    /**\n     * Stores `previous rendering mode`.\n     * @default TextRenderingMode.Fill\n     * @private\n     */\n    this.internalTextRenderingMode = TextRenderingMode.Fill;\n    /**\n     * `Previous character spacing` value or 0.\n     * @default 0.0\n     * @private\n     */\n\n    this.internalCharacterSpacing = 0.0;\n    /**\n     * `Previous word spacing` value or 0.\n     * @default 0.0\n     * @private\n     */\n\n    this.internalWordSpacing = 0.0;\n    /**\n     * The previously used `text scaling value`.\n     * @default 100.0\n     * @private\n     */\n\n    this.internalTextScaling = 100.0;\n    /**\n     * `Current color space`.\n     * @default PdfColorSpace.Rgb\n     * @private\n     */\n\n    this.pdfColorSpace = PdfColorSpace.Rgb;\n\n    if (typeof graphics !== 'undefined') {\n      this.pdfGraphics = graphics;\n      this.transformationMatrix = matrix;\n    }\n  } // Properties\n\n  /**\n   * Gets the parent `graphics object`.\n   * @private\n   */\n\n\n  get graphics() {\n    return this.pdfGraphics;\n  }\n  /**\n   * Gets the `current matrix`.\n   * @private\n   */\n\n\n  get matrix() {\n    return this.transformationMatrix;\n  }\n  /**\n   * Gets or sets the `current character spacing`.\n   * @private\n   */\n\n\n  get characterSpacing() {\n    return this.internalCharacterSpacing;\n  }\n\n  set characterSpacing(value) {\n    this.internalCharacterSpacing = value;\n  }\n  /**\n   * Gets or sets the `word spacing` value.\n   * @private\n   */\n\n\n  get wordSpacing() {\n    return this.internalWordSpacing;\n  }\n\n  set wordSpacing(value) {\n    this.internalWordSpacing = value;\n  }\n  /**\n   * Gets or sets the `text scaling` value.\n   * @private\n   */\n\n\n  get textScaling() {\n    return this.internalTextScaling;\n  }\n\n  set textScaling(value) {\n    this.internalTextScaling = value;\n  }\n  /**\n   * Gets or sets the `current pen` object.\n   * @private\n   */\n\n\n  get pen() {\n    return this.pdfPen;\n  }\n\n  set pen(value) {\n    this.pdfPen = value;\n  }\n  /**\n   * Gets or sets the `brush`.\n   * @private\n   */\n\n\n  get brush() {\n    return this.pdfBrush;\n  }\n\n  set brush(value) {\n    this.pdfBrush = value;\n  }\n  /**\n   * Gets or sets the `current font` object.\n   * @private\n   */\n\n\n  get font() {\n    return this.pdfFont;\n  }\n\n  set font(value) {\n    this.pdfFont = value;\n  }\n  /**\n   * Gets or sets the `current color space` value.\n   * @private\n   */\n\n\n  get colorSpace() {\n    return this.pdfColorSpace;\n  }\n\n  set colorSpace(value) {\n    this.pdfColorSpace = value;\n  }\n  /**\n   * Gets or sets the `text rendering mode`.\n   * @private\n   */\n\n\n  get textRenderingMode() {\n    return this.internalTextRenderingMode;\n  }\n\n  set textRenderingMode(value) {\n    this.internalTextRenderingMode = value;\n  }\n\n}\n\nclass TransparencyData {\n  // Constructors\n\n  /**\n   * Initializes a new instance of the `TransparencyData` class.\n   * @private\n   */\n  constructor(alphaPen, alphaBrush, blendMode) {\n    this.alphaPen = alphaPen;\n    this.alphaBrush = alphaBrush;\n    this.blendMode = blendMode;\n  }\n\n}\n/**\n * The `PdfPageLayer` used to create layers in PDF document.\n * @private\n */\n\n\nclass PdfPageLayer {\n  constructor(page, streamClipPageTemplates) {\n    // private bSaved : boolean;\n\n    /**\n     * Local Variable to store the `color space` of the document.\n     * @private\n     */\n    this.pdfColorSpace = PdfColorSpace.Rgb;\n    /**\n     * Local Variable to set `visibility`.\n     * @default true\n     * @private\n     */\n\n    this.isVisible = true;\n    /**\n     * Indicates if `Sublayer` is present.\n     * @default false\n     * @private\n     */\n\n    this.sublayer = false;\n    /**\n     * Local variable to store `length` of the graphics.\n     * @default 0\n     * @private\n     */\n\n    this.contentLength = 0;\n    /**\n     * Instance for `PdfDictionaryProperties` Class.\n     * @private\n     */\n\n    this.dictionaryProperties = new DictionaryProperties();\n\n    if (page === null) {\n      throw new Error('ArgumentNullException:page');\n    }\n\n    this.pdfPage = page;\n    this.clipPageTemplates = true;\n\n    if (typeof streamClipPageTemplates === 'undefined') {\n      this.content = new PdfStream();\n    } else if (streamClipPageTemplates instanceof PdfStream || streamClipPageTemplates === null) {\n      if (streamClipPageTemplates === null) {\n        throw new Error('ArgumentNullException:stream');\n      }\n\n      this.content = streamClipPageTemplates;\n    } else {\n      this.content = new PdfStream();\n      this.clipPageTemplates = streamClipPageTemplates;\n    }\n  } // Properties\n\n  /**\n   * Get or set the `color space`.\n   * @private\n   */\n\n\n  get colorSpace() {\n    return this.pdfColorSpace;\n  }\n\n  set colorSpace(value) {\n    this.pdfColorSpace = value;\n  }\n  /**\n   * Gets parent `page` of the layer.\n   * @private\n   */\n\n\n  get page() {\n    return this.pdfPage;\n  }\n  /**\n   * Gets and Sets the `id of the layer`.\n   * @private\n   */\n\n\n  get layerId() {\n    return this.layerid;\n  }\n\n  set layerId(value) {\n    this.layerid = value;\n  }\n  /**\n   * Gets or sets the `name` of the layer.\n   * @private\n   */\n\n\n  get name() {\n    return this.layerName;\n  }\n\n  set name(value) {\n    this.layerName = value;\n  }\n  /**\n   * Gets or sets the `visibility` of the layer.\n   * @private\n   */\n\n\n  get visible() {\n    return this.isVisible;\n  }\n\n  set visible(value) {\n    this.isVisible = value;\n  }\n  /**\n   * Gets `Graphics` context of the layer, used to draw various graphical content on layer.\n   * @private\n   */\n\n\n  get graphics() {\n    if (this.pdfGraphics == null) {\n      this.initializeGraphics(this.page);\n    }\n\n    return this.pdfGraphics;\n  }\n  /**\n   * Gets the collection of `PdfPageLayer`, this collection handle by the class 'PdfPageLayerCollection'.\n   * @private\n   */\n\n\n  get layers() {\n    if (this.layer == null) {\n      this.layer = new PdfPageLayerCollection(this.page);\n      this.layer.sublayer = true;\n      return this.layer;\n    } else {\n      return this.layer;\n    }\n  } // Implementation\n\n  /**\n   * `Adds` a new PDF Page layer.\n   * @private\n   */\n\n\n  add() {\n    let layer = new PdfPageLayer(this.pdfPage);\n    layer.name = '';\n    return layer;\n  }\n  /**\n   * Returns a value indicating the `sign` of a single-precision floating-point number.\n   * @private\n   */\n\n\n  sign(number) {\n    if (number === 0) {\n      return 0;\n    } else if (number > 0) {\n      return 1;\n    } else {\n      return -1;\n    }\n  }\n  /**\n   * `Initializes Graphics context` of the layer.\n   * @private\n   */\n\n\n  initializeGraphics(page) {\n    let oPage = page;\n    let gr = new GetResourceEventHandler(this.page);\n    this.pdfGraphics = new PdfGraphics(page.size, gr, this.content);\n    this.pdfGraphics.mediaBoxUpperRightBound = 0;\n\n    if (oPage != null) {\n      let sc = oPage.section.parent;\n\n      if (sc != null) {\n        this.pdfGraphics.colorSpace = sc.document.colorSpace;\n        this.colorSpace = sc.document.colorSpace;\n      }\n    } // Transform coordinates to the left/top and activate margins.\n\n\n    let isSame = this.sign(page.origin.y) === this.sign(page.origin.x); // if (page != null) {\n\n    if (page.origin.x >= 0 && page.origin.y >= 0 || !isSame) {\n      this.pdfGraphics.initializeCoordinates();\n    } else {// this.m_graphics.InitializeCoordinates(page);\n    }\n\n    let clipRect = oPage.section.getActualBounds(oPage, true);\n    let margins = oPage.section.pageSettings.margins;\n\n    if (this.clipPageTemplates) {\n      if (page.origin.x >= 0 && page.origin.y >= 0) {\n        this.pdfGraphics.clipTranslateMargins(clipRect);\n      }\n    } else {\n      this.graphics.clipTranslateMargins(clipRect.x, clipRect.y, margins.left, margins.top, margins.right, margins.bottom);\n    }\n\n    this.pdfGraphics.setLayer(this); // this.bSaved = false;\n  } // IPdfWrapper Members\n\n  /**\n   * Gets the wrapped `element`.\n   * @private\n   */\n\n\n  get element() {\n    return this.content;\n  }\n\n}\n/**\n * PdfCollection.ts class for EJ2-PDF\n * The class used to handle the collection of PdF objects.\n */\n\n\nclass PdfCollection {\n  // Constructors\n\n  /**\n   * Initializes a new instance of the `Collection` class.\n   * @private\n   */\n  constructor() {//\n  } // Properties\n\n  /**\n   * Gets the `Count` of stored objects.\n   * @private\n   */\n\n\n  get count() {\n    if (typeof this.collection === 'undefined') {\n      this.collection = [];\n    }\n\n    return this.collection.length;\n  }\n  /**\n   * Gets the `list` of stored objects.\n   * @private\n   */\n\n\n  get list() {\n    if (typeof this.collection === 'undefined') {\n      this.collection = [];\n    }\n\n    return this.collection;\n  }\n\n}\n/**\n * PdfPageLayerCollection.ts class for EJ2-PDF\n */\n\n/**\n * The class provides methods and properties to handle the collections of `PdfPageLayer`.\n */\n\n\nclass PdfPageLayerCollection extends PdfCollection {\n  constructor(page) {\n    super();\n    /**\n     * Stores the `number of first level layers` in the document.\n     * @default 0\n     * @private\n     */\n\n    this.parentLayerCount = 0;\n    /**\n     * Indicates if `Sublayer` is present.\n     * @default false\n     * @private\n     */\n\n    this.sublayer = false;\n    /**\n     * Stores the `optional content dictionary`.\n     * @private\n     */\n\n    this.optionalContent = new PdfDictionary();\n\n    if (page instanceof PdfPageBase) {\n      // if (page == null) {\n      //     throw new Error('ArgumentNullException:page');\n      // }\n      this.page = page;\n      let lPage = page; // if (lPage != null) {\n\n      this.parseLayers(lPage); // }\n    }\n  }\n\n  items(index, value) {\n    if (typeof index === 'number' && typeof value === 'undefined') {\n      let obj = this.list[index];\n      return obj;\n    } else {\n      if (value == null) {\n        throw new Error('ArgumentNullException: layer');\n      }\n\n      if (value.page !== this.page) {\n        throw new Error('ArgumentException: The layer belongs to another page');\n      } // // Add/remove the layer.\n      // let layer : PdfPageLayer = this.items(index);\n      // if (layer != null) {\n      //     this.RemoveLayer(layer);\n      // }\n      // this.List[index] = value;\n      // this.InsertLayer(index, value);\n\n    }\n  }\n\n  add(firstArgument, secondArgument) {\n    if (typeof firstArgument === 'undefined') {\n      let layer = new PdfPageLayer(this.page);\n      layer.name = '';\n      this.add(layer);\n      return layer;\n    } else if (firstArgument instanceof PdfPageLayer) {\n      // if (layer == null)\n      //     throw new ArgumentNullException(\"layer\");\n      // if (layer.Page != m_page)\n      //     throw new ArgumentException(\"The layer belongs to another page\");\n      let index = this.list.push(firstArgument); // Register layer.\n\n      this.addLayer(index, firstArgument);\n      return index;\n    } else {\n      return 0;\n    }\n  }\n  /**\n   * Registers `layer` at the page.\n   * @private\n   */\n\n\n  addLayer(index, layer) {\n    let reference = new PdfReferenceHolder(layer);\n    this.page.contents.add(reference);\n  } // private RemoveLayer(layer : PdfPageLayer) : void {\n  //     if (layer == null) {\n  //         throw new Error('ArgumentNullException:layer');\n  //     }\n  //     let reference : PdfReferenceHolder = new PdfReferenceHolder(layer);\n  //     if (this.page != null) {\n  //         this.page.Contents.Remove(reference);\n  //     }\n  // }\n\n  /**\n   * Inserts `PdfPageLayer` into the collection at specified index.\n   * @private\n   */\n\n\n  insert(index, layer) {\n    // if (index < 0)\n    //     throw new ArgumentOutOfRangeException(\"index\", \"Value can not be less 0\");\n    // if (layer == null)\n    //     throw new ArgumentNullException(\"layer\");\n    // if (layer.Page != m_page)\n    //     throw new ArgumentException(\"The layer belongs to another page\");\n    let list = [];\n    let length = this.list.length;\n\n    for (let i = index; i < length; i++) {\n      list.push(this.list.pop());\n    }\n\n    this.list.push(layer);\n\n    for (let i = 0; i < list.length; i++) {\n      this.list.push(list[i]);\n    } // Register layer.\n\n\n    this.insertLayer(index, layer);\n  }\n  /**\n   * Registers layer at the page.\n   * @private\n   */\n\n\n  insertLayer(index, layer) {\n    if (layer == null) {\n      throw new Error('ArgumentNullException:layer');\n    }\n\n    let reference = new PdfReferenceHolder(layer);\n    this.page.contents.insert(index, reference);\n  } // tslint:disable\n\n  /**\n   * `Parses the layers`.\n   * @private\n   */\n\n\n  parseLayers(loadedPage) {\n    // if (loadedPage == null) {\n    //     throw new Error('ArgumentNullException:loadedPage');\n    // }\n    let contents = this.page.contents;\n    let resource = this.page.getResources();\n    let crossTable = null;\n    crossTable = loadedPage.crossTable; // } else {\n    //     crossTable = (loadedPage as PdfLoadedPage).CrossTable;\n    //     Propertie = PdfCrossTable.Dereference(Resource[DictionaryProperties.Properties]) as PdfDictionary;\n    //     ocproperties = PdfCrossTable.Dereference((loadedPage as PdfLoadedPage).\n    //     Document.Catalog[DictionaryProperties.OCProperties]) as PdfDictionary;\n    // }\n\n    let saveStream = new PdfStream();\n    let restoreStream = new PdfStream();\n    let saveState = 'q';\n    let restoreState = 'Q'; // for (let index : number = 0; index < contents.Items.length; index++) {\n    //     let obj : IPdfPrimitive = contents[index];\n    //     let stream : PdfStream = crossTable.GetObject(obj) as PdfStream;\n    //     if (stream == null)\n    //         throw new PdfDocumentException(\"Invalid contents array.\");\n    //     // if (stream.Compress)\n    //     {\n    //         if (!loadedPage.Imported)\n    //             stream.Decompress();\n    //     }\n    //     byte[] contentId = stream.Data;\n    //     string str = PdfString.ByteToString(contentId);\n    //     if (!loadedPage.Imported && (contents.Count == 1) && ((stream.Data[stream.Data.Length - 2] ==\n    //     RestoreState) || (stream.Data[stream.Data.Length - 1] == RestoreState)))\n    //     {\n    //         byte[] content = stream.Data;\n    //         byte[] data = new byte[content.Length + 4];\n    //         data[0] = SaveState;\n    //         data[1] = NewLine;\n    //         content.CopyTo(data, 2);\n    //         data[data.Length - 2] = NewLine;\n    //         data[data.Length - 1] = RestoreState;\n    //         stream.Data = data;\n    //     }\n    //     if (ocproperties != null)\n    //     {\n    //         if (Propertie != null)\n    //         {\n    //             foreach (KeyValuePair<PdfName, IPdfPrimitive> prop in Propertie.Items)\n    //             {\n    //                 String Key = prop.Key.ToString();\n    //                 PdfReferenceHolder refh = prop.Value as PdfReferenceHolder;\n    //                 PdfDictionary Dict = null;\n    //                 if (refh != null)\n    //                 {\n    //                     Dict = refh.Object as PdfDictionary;\n    //                 }\n    //                 else\n    //                 {\n    //                     Dict = prop.Value as PdfDictionary;\n    //                 }\n    //                 PdfDictionary m_usage = PdfCrossTable.Dereference(Dict[DictionaryProperties.Usage]) as PdfDictionary;\n    //                 if (m_usage != null)\n    //                 {\n    //                     if (str.Contains(Key))\n    //                     {\n    //                         PdfPageLayer layer = new PdfPageLayer(loadedPage, stream);\n    //                         PdfDictionary printoption = PdfCrossTable.Dereference(m_usage[DictionaryProperties.Print])\n    //                         as PdfDictionary;\n    //                         if (printoption != null)\n    //                         {\n    //                             layer.m_printOption = printoption;\n    //                             foreach (KeyValuePair<PdfName, IPdfPrimitive> value in printoption.Items)\n    //                             {\n    //                                 if (value.Key.Value.Equals(DictionaryProperties.PrintState))\n    //                                 {\n    //                                     string printState = (value.Value as PdfName).Value;\n    //                                     if (printState.Equals(DictionaryProperties.OCGON))\n    //                                     {\n    //                                         layer.PrintState = PdfPrintState.AlwaysPrint;\n    //                                         break;\n    //                                     }\n    //                                     else\n    //                                     {\n    //                                         layer.PrintState = PdfPrintState.NeverPrint;\n    //                                         break;\n    //                                     }\n    //                                 }\n    //                             }\n    //                         }\n    //                         PdfString layerName = PdfCrossTable.Dereference(Dict[DictionaryProperties.Name]) as PdfString;\n    //                         layer.Name = layerName.Value;\n    //                         List.add(layer);\n    //                         isLayerAdded = true;\n    //                         if(!str.Contains(\"EMC\"))\n    //                         break;\n    //                     }\n    //                 }\n    //                 else\n    //                 {\n    //                     if (str.Contains(Key))\n    //                     {\n    //                         PdfPageLayer layer = new PdfPageLayer(loadedPage, stream);\n    //                         List.add(layer);\n    //                         if(Dict.ContainsKey(DictionaryProperties.Name))\n    //                         {\n    //                         PdfString layerName = PdfCrossTable.Dereference(Dict[DictionaryProperties.Name]) as PdfString;\n    //                         layer.Name = layerName.Value;\n    //                         }\n    //                         isLayerAdded = true;\n    //                         break;\n    //                     }\n    //                 }\n    //             }\n    //         }\n    //     }\n    //     if (!isLayerAdded)\n    //     {\n    //         PdfPageLayer layer = new PdfPageLayer(loadedPage, stream);\n    //         List.add(layer);\n    //     }\n    //     else\n    //         isLayerAdded = false;\n    // }\n\n    let saveData = [];\n    saveData.push(saveState);\n    saveStream.data = saveData;\n    contents.insert(0, new PdfReferenceHolder(saveStream));\n    saveData = [];\n    saveData.push(restoreState);\n    restoreStream.data = saveData;\n    contents.insert(contents.count, new PdfReferenceHolder(restoreStream));\n  }\n  /**\n   * Returns `index of` the `PdfPageLayer` in the collection if exists, -1 otherwise.\n   * @private\n   */\n\n\n  indexOf(layer) {\n    if (layer == null) {\n      throw new Error('ArgumentNullException: layer');\n    }\n\n    let index = this.list.indexOf(layer);\n    return index;\n  }\n\n}\n/**\n * The abstract base class for all pages,\n * `PdfPageBase` class provides methods and properties to create PDF pages and its elements.\n * @private\n */\n\n\nclass PdfPageBase {\n  //constructors\n\n  /**\n   * Initializes a new instance of the `PdfPageBase` class.\n   * @private\n   */\n  constructor(dictionary) {\n    /**\n     * `Index` of the default layer.\n     * @default -1.\n     * @private\n     */\n    this.defLayerIndex = -1;\n    /**\n     * Local variable to store if page `updated`.\n     * @default false.\n     * @private\n     */\n\n    this.modified = false;\n    /**\n     * Instance of `DictionaryProperties` class.\n     * @hidden\n     * @private\n     */\n\n    this.dictionaryProperties = new DictionaryProperties();\n    this.pageDictionary = dictionary;\n  } //Properties\n\n  /**\n   * Gets the `section` of a page.\n   * @private\n   */\n\n\n  get section() {\n    // if (this.pdfSection === null) {\n    //     throw new Error('PdfException : Page must be added to some section before using.');\n    // }\n    return this.pdfSection;\n  }\n\n  set section(value) {\n    this.pdfSection = value;\n  }\n  /**\n   * Gets the page `dictionary`.\n   * @private\n   */\n\n\n  get dictionary() {\n    return this.pageDictionary;\n  }\n  /**\n   * Gets the wrapped `element`.\n   * @private\n   */\n\n\n  get element() {\n    return this.pageDictionary;\n  }\n  /**\n   * Gets the `default layer` of the page (Read only).\n   * @private\n   */\n\n\n  get defaultLayer() {\n    let layer = this.layers;\n    let index = this.defaultLayerIndex;\n    let returnlayer = layer.items(index);\n    return returnlayer;\n  }\n  /**\n   * Gets or sets `index of the default layer`.\n   * @private\n   */\n\n\n  get defaultLayerIndex() {\n    if (this.layerCollection.count === 0 || this.defLayerIndex === -1) {\n      let layer = this.layerCollection.add();\n      this.defLayerIndex = this.layerCollection.indexOf(layer);\n    }\n\n    return this.defLayerIndex;\n  }\n  /**\n   * Gets the collection of the page's `layers` (Read only).\n   * @private\n   */\n\n\n  get layers() {\n    if (this.layerCollection == null || typeof this.layerCollection === 'undefined') {\n      this.layerCollection = new PdfPageLayerCollection(this);\n    }\n\n    return this.layerCollection;\n  }\n  /**\n   * Return an instance of `PdfResources` class.\n   * @private\n   */\n\n\n  getResources() {\n    if (this.resources == null) {\n      this.resources = new PdfResources();\n      this.dictionary.items.setValue(this.dictionaryProperties.resources, this.resources);\n    }\n\n    return this.resources;\n  }\n  /**\n   * Gets `array of page's content`.\n   * @private\n   */\n\n\n  get contents() {\n    let obj = this.pageDictionary.items.getValue(this.dictionaryProperties.contents);\n    let contents = obj;\n\n    if (contents == null) {\n      contents = new PdfArray();\n      this.pageDictionary.items.setValue(this.dictionaryProperties.contents, contents);\n    }\n\n    return contents;\n  }\n  /**\n   * Gets or sets` index of the default layer`.\n   * @private\n   */\n\n\n  set defaultLayerIndex(value) {\n    if (value < 0 || value > this.layers.count - 1) {\n      throw new Error('ArgumentOutOfRangeException : value, Index can not be less 0 and greater Layers.Count - 1');\n    } else {\n      this.defLayerIndex = value;\n      this.modified = true;\n    }\n  }\n  /**\n   * Sets the `resources`.\n   * @private\n   */\n\n\n  setResources(res) {\n    this.resources = res;\n    this.dictionary.items.setValue(this.dictionaryProperties.resources, this.resources);\n    this.modified = true;\n  }\n\n}\n/**\n * `PdfAnnotationCollection` class represents the collection of 'PdfAnnotation' objects.\n * @private\n */\n\n\nclass PdfAnnotationCollection {\n  constructor(page) {\n    // Constants\n\n    /**\n     * `Error` constant message.\n     * @private\n     */\n    this.alreadyExistsAnnotationError = 'This annotatation had been already added to page';\n    /**\n     * `Error` constant message.\n     * @private\n     */\n\n    this.missingAnnotationException = 'Annotation is not contained in collection.';\n    /**\n     * Specifies the Internal variable to store fields of `PdfDictionaryProperties`.\n     * @private\n     */\n\n    this.dictionaryProperties = new DictionaryProperties();\n    /**\n     * Array of the `annotations`.\n     * @private\n     */\n\n    this.internalAnnotations = new PdfArray();\n    /**\n     * privte `list` for the annotations.\n     * @private\n     */\n\n    this.lists = [];\n\n    if (typeof page !== 'undefined') {\n      this.page = page;\n    }\n  }\n  /**\n   * Gets the `PdfAnnotation` object at the specified index. Read-Only.\n   * @private\n   */\n\n\n  get annotations() {\n    return this.internalAnnotations;\n  }\n\n  set annotations(value) {\n    this.internalAnnotations = value;\n  } // Public methods\n\n  /**\n   * `Adds` a new annotation to the collection.\n   * @private\n   */\n\n\n  add(annotation) {\n    // this.SetPrint(annotation);\n    this.doAdd(annotation);\n  }\n  /**\n   * `Adds` a Annotation to collection.\n   * @private\n   */\n\n  /* tslint:disable */\n\n\n  doAdd(annotation) {\n    if (typeof annotation.destination !== 'undefined') {\n      let layout = new PdfStringLayouter();\n      let layoutResult = layout.layout(annotation.text, annotation.font, annotation.stringFormat, new SizeF(annotation.bounds.width, 0), false, new SizeF(0, 0));\n      let lastPosition = annotation.bounds.y;\n\n      if (layoutResult.lines.length === 1) {\n        let size = annotation.font.measureString(layoutResult.lines[0].text);\n        annotation.bounds = new RectangleF(new PointF(annotation.bounds.x, lastPosition), size);\n        annotation.text = layoutResult.lines[0].text; //Draw Annotation Text.\n\n        this.page.graphics.drawString(annotation.text, annotation.font, null, annotation.brush, annotation.bounds.x, annotation.bounds.y, annotation.bounds.width, annotation.bounds.height, null); //Add annotation to dictionary.\n\n        annotation.setPage(this.page);\n        this.setColor(annotation);\n        this.internalAnnotations.add(new PdfReferenceHolder(annotation));\n        this.lists.push(annotation);\n      } else {\n        for (let i = 0; i < layoutResult.lines.length; i++) {\n          let size = annotation.font.measureString(layoutResult.lines[i].text);\n\n          if (i === 0) {\n            annotation.bounds = new RectangleF(annotation.bounds.x, lastPosition, size.width, size.height);\n            annotation.text = layoutResult.lines[i].text; //Draw Annotation Text.\n\n            this.page.graphics.drawString(annotation.text, annotation.font, null, annotation.brush, annotation.bounds.x, lastPosition, size.width, size.height, null); //Add annotation to dictionary.\n\n            annotation.setPage(this.page);\n            this.setColor(annotation);\n            this.internalAnnotations.add(new PdfReferenceHolder(annotation));\n            this.lists.push(annotation); //Update y for drawing next line of the text.\n\n            lastPosition += annotation.bounds.height;\n          } else {\n            let annot = annotation.clone();\n            annot.bounds = new RectangleF(new PointF(annotation.bounds.x, lastPosition), size);\n            annot.text = layoutResult.lines[i].text; //Draw Annotation Text.\n\n            this.page.graphics.drawString(annot.text, annot.font, null, annot.brush, annot.bounds.x, annot.bounds.y, annot.bounds.width, annot.bounds.height, null); //Add annotation to dictionary.\n\n            annot.setPage(this.page);\n            this.setColor(annot);\n            this.internalAnnotations.add(new PdfReferenceHolder(annot));\n            this.lists.push(annot); //Update y for drawing next line of the text.\n\n            lastPosition += annot.bounds.height;\n          }\n        }\n      }\n    } else {\n      annotation.setPage(this.page);\n      this.internalAnnotations.add(new PdfReferenceHolder(annotation));\n      return this.lists.push(annotation);\n    }\n  }\n  /* tslint:enable */\n\n  /**\n   * `Set a color of an annotation`.\n   * @private\n   */\n\n\n  setColor(annotation) {\n    let cs = PdfColorSpace.Rgb;\n    let colours = annotation.color.toArray(cs);\n    annotation.dictionary.items.setValue(this.dictionaryProperties.c, colours);\n  } // IPdfWrapper Members\n\n  /**\n   * Gets the `Element` representing this object.\n   * @private\n   */\n\n\n  get element() {\n    return this.internalAnnotations;\n  }\n\n}\n/**\n * Provides methods and properties to create pages and its elements.\n * `PdfPage` class inherited from the `PdfPageBase` class.\n * ```typescript\n * // create a new PDF document\n * let document : PdfDocument = new PdfDocument();\n * //\n * // add a new page to the document\n * let page1 : PdfPage = document.pages.add();\n * //\n * // set the font\n * let font : PdfStandardFont = new PdfStandardFont(PdfFontFamily.Helvetica, 20);\n * // create black brush\n * let blackBrush : PdfSolidBrush = new PdfSolidBrush(new PdfColor(0, 0, 0));\n * // draw the text\n * page1.graphics.drawString('Hello World', font, blackBrush, new PointF(0, 0));\n * // save the document\n * document.save('output.pdf');\n * // destroy the document\n * document.destroy();\n * ```\n */\n\n\nclass PdfPage extends PdfPageBase {\n  //constructors\n\n  /**\n   * Initialize the new instance for `PdfPage` class.\n   * @private\n   */\n  constructor() {\n    super(new PdfDictionary());\n    /**\n     * Stores the instance of `PdfAnnotationCollection` class.\n     * @hidden\n     * @default null\n     * @private\n     */\n\n    this.annotationCollection = null;\n    /**\n     * Stores the instance of `PageBeginSave` event for Page Number Field.\n     * @default null\n     * @private\n     */\n\n    this.beginSave = null;\n    this.initialize();\n  } //Properties\n\n  /**\n   * Gets current `document`.\n   * @private\n   */\n\n\n  get document() {\n    if (this.section !== null && this.section.parent !== null) {\n      return this.section.parent.document;\n    } else {\n      return null;\n    }\n  }\n  /**\n   * Get the current `graphics`.\n   * ```typescript\n   * // create a new PDF document\n   * let document : PdfDocument = new PdfDocument();\n   * // add a new page to the document\n   * let page1 : PdfPage = document.pages.add();\n   * //\n   * // get graphics\n   * let graphics : PdfGraphics = page1.graphics;\n   * //\n   * // set the font\n   * let font : PdfStandardFont = new PdfStandardFont(PdfFontFamily.Helvetica, 20);\n   * // create black brush\n   * let blackBrush : PdfSolidBrush = new PdfSolidBrush(new PdfColor(0, 0, 0));\n   * // draw the text\n   * graphics.drawString('Hello World', font, blackBrush, new PointF(0, 0));\n   * // save the document\n   * document.save('output.pdf');\n   * // destroy the document\n   * document.destroy();\n   * ```\n   */\n\n\n  get graphics() {\n    let result = this.defaultLayer.graphics;\n    result.currentPage = this;\n    return result;\n  }\n  /**\n   * Gets the `cross table`.\n   * @private\n   */\n\n\n  get crossTable() {\n    if (this.section === null) {\n      throw new Error('PdfDocumentException : Page is not created');\n    }\n\n    return this.section.parent === null ? this.section.parentDocument.crossTable : this.section.parent.document.crossTable;\n  }\n  /**\n   * Gets the size of the PDF page- Read only.\n   * @public\n   */\n\n\n  get size() {\n    return this.section.pageSettings.size;\n  }\n  /**\n   * Gets the `origin` of the page.\n   * @private\n   */\n\n\n  get origin() {\n    return this.section.pageSettings.origin;\n  }\n  /**\n   * Gets a collection of the `annotations` of the page- Read only.\n   * @private\n   */\n\n\n  get annotations() {\n    if (this.annotationCollection == null) {\n      this.annotationCollection = new PdfAnnotationCollection(this); // if (!this.Dictionary.ContainsKey(this.dictionaryProperties.annots)) {\n\n      this.dictionary.items.setValue(this.dictionaryProperties.annots, this.annotationCollection.element); // }\n\n      this.annotationCollection.annotations = this.dictionary.items.getValue(this.dictionaryProperties.annots);\n    }\n\n    return this.annotationCollection;\n  } //Implementation\n\n  /**\n   * `Initializes` a page.\n   * @private\n   */\n\n\n  initialize() {\n    this.dictionary.items.setValue(this.dictionaryProperties.type, new PdfName('Page'));\n    this.dictionary.pageBeginDrawTemplate = new SaveTemplateEventHandler(this);\n  }\n  /**\n   * Sets parent `section` to the page.\n   * @private\n   */\n\n\n  setSection(section) {\n    this.section = section;\n    this.dictionary.items.setValue(this.dictionaryProperties.parent, new PdfReferenceHolder(section));\n  }\n  /**\n   * `Resets the progress`.\n   * @private\n   */\n\n\n  resetProgress() {\n    this.isProgressOn = false;\n  }\n  /**\n   * Get the page size reduced by page margins and page template dimensions.\n   * ```typescript\n   * //createanewPDFdocument\n   * letdocument:PdfDocument=newPdfDocument();\n   * //addapagestothedocument\n   * letpage1:PdfPage=document.pages.add();\n   * //create new standard font\n   * letfont:PdfStandardFont=newPdfStandardFont(PdfFontFamily.Helvetica,20);\n   * //setbrush\n   * letblackBrush:PdfSolidBrush=newPdfSolidBrush(newPdfColor(0,0,0));\n   * //\n   * //setthespecifiedpoint using `getClientSize` method\n   * letpoint:PointF=newPointF(page1.getClientSize().width-200,page1.getClientSize().height-200);\n   * //drawthetext\n   * page1.graphics.drawString('HelloWorld',font,blackBrush,point);\n   * //\n   * //savethedocument\n   * document.save('output.pdf');\n   * // destroy the document\n   * document.destroy();\n   * ```\n   */\n\n\n  getClientSize() {\n    let returnValue = this.section.getActualBounds(this, true);\n    return new SizeF(returnValue.width, returnValue.height);\n  }\n  /**\n   * Helper method to retrive the instance of `PageBeginSave` event for header and footer elements.\n   * @private\n   */\n\n\n  pageBeginSave() {\n    let doc = this.document;\n\n    if (typeof doc !== undefined && doc != null) {\n      this.drawPageTemplates(doc);\n    }\n\n    if (this.beginSave != null && typeof this.beginSave !== 'undefined') {\n      this.beginSave(this);\n    }\n  }\n  /**\n   * Helper method to draw template elements.\n   * @private\n   */\n\n\n  drawPageTemplates(document) {\n    // Draw Background templates.\n    let hasBackTemplates = this.section.containsTemplates(document, this, false);\n\n    if (hasBackTemplates) {\n      let backLayer = new PdfPageLayer(this, false);\n      this.layers.insert(0, backLayer);\n      this.section.drawTemplates(this, backLayer, document, false);\n\n      if (backLayer.graphics !== null && typeof backLayer.graphics !== 'undefined') {\n        for (let i = 0; i < backLayer.graphics.automaticFields.automaticFields.length; i++) {\n          let fieldInfo = backLayer.graphics.automaticFields.automaticFields[i];\n          fieldInfo.field.performDraw(backLayer.graphics, fieldInfo.location, fieldInfo.scalingX, fieldInfo.scalingY);\n        }\n      }\n    } // Draw Foreground templates.\n\n\n    let hasFrontTemplates = this.section.containsTemplates(document, this, true);\n\n    if (hasFrontTemplates) {\n      let frontLayer = new PdfPageLayer(this, false);\n      this.layers.add(frontLayer);\n      this.section.drawTemplates(this, frontLayer, document, true);\n    }\n  }\n\n}\n/**\n * Provides data for `PageAddedEventHandler` event.\n * This event raises when adding the new PDF page to the PDF document.\n */\n\n\nclass PageAddedEventArgs {\n  /**\n   * Gets the `newly added page`.\n   * @private\n   */\n  get page() {\n    return this.pdfPage;\n  }\n\n  constructor(page) {\n    if (typeof page !== 'undefined') {\n      this.pdfPage = page;\n    } else {\n      this.pdfPage = null;\n    }\n  }\n\n}\n/**\n * Represents the `collection of pages in a section`.\n * @private\n */\n\n\nclass PdfSectionPageCollection {\n  // Constructors\n\n  /**\n   * Initializes a new instance of the `PdfSectionPageCollection` class.\n   * @private\n   */\n  constructor(section) {\n    //  Fields\n\n    /**\n     * @hidden\n     * @private\n     */\n    this.pdfSection = null;\n\n    if (section == null) {\n      throw Error('ArgumentNullException(\"section\")');\n    }\n\n    this.section = section;\n  } // Properties\n\n  /**\n   * Gets the `PdfPage` at the specified index.\n   * @private\n   */\n\n\n  get section() {\n    return this.pdfSection;\n  }\n\n  set section(value) {\n    this.pdfSection = value;\n  } // Public Methods\n\n  /**\n   * `Determines` whether the specified page is within the collection.\n   * @private\n   */\n\n\n  contains(page) {\n    return this.section.contains(page);\n  }\n  /**\n   * `Removes` the specified page from collection.\n   * @private\n   */\n\n\n  remove(page) {\n    this.section.remove(page);\n  }\n  /**\n   * `Adds` a new page from collection.\n   * @private\n   */\n\n\n  add() {\n    return this.section.add();\n  }\n\n} // import { PdfStampCollection } from `./../Pages/PdfStampCollection`;\n\n/**\n * `PdfDocumentTemplate` class encapsulates a page template for all the pages in the document.\n * @private\n */\n\n\nclass PdfDocumentTemplate {\n  // private m_stamps : PdfStampCollection;\n  // Properties\n\n  /**\n   * `Left` page template object.\n   * @public\n   */\n  get left() {\n    return this.leftTemplate;\n  }\n\n  set left(value) {\n    this.leftTemplate = this.checkElement(value, TemplateType.Left);\n  }\n  /**\n   * `Top` page template object.\n   * @public\n   */\n\n\n  get top() {\n    return this.topTemplate;\n  }\n\n  set top(value) {\n    this.topTemplate = this.checkElement(value, TemplateType.Top);\n  }\n  /**\n   * `Right` page template object.\n   * @public\n   */\n\n\n  get right() {\n    return this.rightTemplate;\n  }\n\n  set right(value) {\n    this.rightTemplate = this.checkElement(value, TemplateType.Right);\n  }\n  /**\n   * `Bottom` page template object.\n   * @public\n   */\n\n\n  get bottom() {\n    return this.bottomTemplate;\n  }\n\n  set bottom(value) {\n    this.bottomTemplate = this.checkElement(value, TemplateType.Bottom);\n  }\n  /**\n   * `EvenLeft` page template object.\n   * @public\n   */\n\n\n  get EvenLeft() {\n    return this.evenLeft;\n  }\n\n  set EvenLeft(value) {\n    this.evenLeft = this.checkElement(value, TemplateType.Left);\n  }\n  /**\n   * `EvenTop` page template object.\n   * @public\n   */\n\n\n  get EvenTop() {\n    return this.evenTop;\n  }\n\n  set EvenTop(value) {\n    this.evenTop = this.checkElement(value, TemplateType.Top);\n  }\n  /**\n   * `EvenRight` page template object.\n   * @public\n   */\n\n\n  get EvenRight() {\n    return this.evenRight;\n  }\n\n  set EvenRight(value) {\n    this.evenRight = this.checkElement(value, TemplateType.Right);\n  }\n  /**\n   * `EvenBottom` page template object.\n   * @public\n   */\n\n\n  get EvenBottom() {\n    return this.evenBottom;\n  }\n\n  set EvenBottom(value) {\n    this.evenBottom = this.checkElement(value, TemplateType.Bottom);\n  }\n  /**\n   * `OddLeft` page template object.\n   * @public\n   */\n\n\n  get OddLeft() {\n    return this.oddLeft;\n  }\n\n  set OddLeft(value) {\n    this.oddLeft = this.checkElement(value, TemplateType.Left);\n  }\n  /**\n   * `OddTop` page template object.\n   * @public\n   */\n\n\n  get OddTop() {\n    return this.oddTop;\n  }\n\n  set OddTop(value) {\n    this.oddTop = this.checkElement(value, TemplateType.Top);\n  }\n  /**\n   * `OddRight` page template object.\n   * @public\n   */\n\n\n  get OddRight() {\n    return this.oddRight;\n  }\n\n  set OddRight(value) {\n    this.oddRight = this.checkElement(value, TemplateType.Right);\n  }\n  /**\n   * `OddBottom` page template object.\n   * @public\n   */\n\n\n  get OddBottom() {\n    return this.oddBottom;\n  }\n\n  set OddBottom(value) {\n    this.oddBottom = this.checkElement(value, TemplateType.Bottom);\n  } // Constructors\n\n  /**\n   * Initializes a new instance of the `PdfDocumentTemplate` class.\n   * @public\n   */\n\n\n  constructor() {//\n  } // Implementation\n\n  /**\n   * Returns `left` template.\n   * @public\n   */\n\n\n  getLeft(page) {\n    if (page == null) {\n      throw new Error('ArgumentNullException:page');\n    }\n\n    let template = null; // if (page.Document.Pages != null) {\n\n    let even = this.isEven(page);\n\n    if (even) {\n      template = this.EvenLeft != null ? this.EvenLeft : this.left;\n    } else {\n      template = this.OddLeft != null ? this.OddLeft : this.left;\n    } // }\n\n\n    return template;\n  }\n  /**\n   * Returns `top` template.\n   * @public\n   */\n\n\n  getTop(page) {\n    if (page == null) {\n      throw new Error('ArgumentNullException:page');\n    }\n\n    let template = null; // if (page.Document.Pages != null) {\n\n    let even = this.isEven(page);\n\n    if (even) {\n      template = this.EvenTop != null ? this.EvenTop : this.top;\n    } else {\n      template = this.OddTop != null ? this.OddTop : this.top;\n    } // }\n\n\n    return template;\n  }\n  /**\n   * Returns `right` template.\n   * @public\n   */\n\n\n  getRight(page) {\n    if (page == null) {\n      throw new Error('ArgumentNullException:page');\n    }\n\n    let template = null; // if (page.Document.Pages != null) {\n\n    let even = this.isEven(page);\n\n    if (even) {\n      template = this.EvenRight != null ? this.EvenRight : this.right;\n    } else {\n      template = this.OddRight != null ? this.OddRight : this.right;\n    } // }\n\n\n    return template;\n  }\n  /**\n   * Returns `bottom` template.\n   * @public\n   */\n\n\n  getBottom(page) {\n    if (page == null) {\n      throw new Error('ArgumentNullException:page');\n    }\n\n    let template = null; // if (page.Document.Pages != null) {\n\n    let even = this.isEven(page);\n\n    if (even) {\n      template = this.EvenBottom != null ? this.EvenBottom : this.bottom;\n    } else {\n      template = this.OddBottom != null ? this.OddBottom : this.bottom;\n    } // }\n\n\n    return template;\n  }\n  /**\n   * Checks whether the page `is even`.\n   * @private\n   */\n\n\n  isEven(page) {\n    let pages = page.section.document.pages;\n    let index = 0;\n\n    if (pages.pageCollectionIndex.containsKey(page)) {\n      index = pages.pageCollectionIndex.getValue(page) + 1;\n    } else {\n      index = pages.indexOf(page) + 1;\n    }\n\n    let even = index % 2 === 0;\n    return even;\n  }\n  /**\n   * Checks a `template element`.\n   * @private\n   */\n\n\n  checkElement(templateElement, type) {\n    if (templateElement != null) {\n      if (typeof templateElement.type !== 'undefined' && templateElement.type !== TemplateType.None) {\n        throw new Error('NotSupportedException:Can not reassign the template element. Please, create new one.');\n      }\n\n      templateElement.type = type;\n    }\n\n    return templateElement;\n  }\n\n}\n/**\n * PdfSectionTemplate.ts class for EJ2-PDF\n */\n\n/**\n * Represents a `page template` for all the pages in the section.\n */\n\n\nclass PdfSectionTemplate extends PdfDocumentTemplate {\n  // Properties\n\n  /**\n   * Gets or sets value indicating whether parent `Left page template should be used or not`.\n   * @private\n   */\n  get applyDocumentLeftTemplate() {\n    return this.leftValue;\n  }\n\n  set applyDocumentLeftTemplate(value) {\n    this.leftValue = value;\n  }\n  /**\n   * Gets or sets value indicating whether parent `Top page template should be used or not`.\n   * @private\n   */\n\n\n  get applyDocumentTopTemplate() {\n    return this.topValue;\n  }\n\n  set applyDocumentTopTemplate(value) {\n    this.topValue = value;\n  }\n  /**\n   * Gets or sets value indicating whether parent `Right page template should be used or not`.\n   * @private\n   */\n\n\n  get applyDocumentRightTemplate() {\n    return this.rightValue;\n  }\n\n  set applyDocumentRightTemplate(value) {\n    this.rightValue = value;\n  }\n  /**\n   * Gets or sets value indicating whether parent `Bottom page template should be used or not`.\n   * @private\n   */\n\n\n  get applyDocumentBottomTemplate() {\n    return this.bottomValue;\n  }\n\n  set applyDocumentBottomTemplate(value) {\n    this.bottomValue = value;\n  }\n  /**\n   * Gets or sets value indicating whether the `stamp value` is true or not.\n   * @private\n   */\n\n\n  get applyDocumentStamps() {\n    return this.stampValue;\n  }\n\n  set applyDocumentStamps(value) {\n    this.stampValue = value;\n  } // Constructors\n\n  /**\n   * `Creates a new object`.\n   * @private\n   */\n\n\n  constructor() {\n    super();\n    this.leftValue = this.topValue = this.rightValue = this.bottomValue = this.stampValue = true;\n  }\n\n}\n/**\n * Represents a `section` entity. A section it's a set of the pages with similar page settings.\n */\n\n\nclass PdfSection {\n  constructor(document, pageSettings) {\n    //Fields\n    //public PageAdded() : PageAddedEventArgs.PageAddedEventHandler = new PageAddedEventArgs.PageAddedEventHandler(Object,args)\n\n    /**\n     * @hidden\n     * @private\n     */\n    this.pageAdded = new PageAddedEventArgs();\n    /**\n     * @hidden\n     * @private\n     */\n\n    this.pdfPages = [];\n    /**\n     * @hidden\n     * @private\n     */\n\n    this.dictionaryProperties = new DictionaryProperties();\n    this.pdfDocument = document;\n\n    if (typeof pageSettings === 'undefined') {\n      this.settings = document.pageSettings.clone();\n      this.initialSettings = this.settings.clone();\n    } else {\n      this.settings = pageSettings.clone();\n      this.initialSettings = this.settings.clone();\n    }\n\n    this.initialize();\n  } //Property\n\n  /**\n   * Gets or sets the `parent`.\n   * @private\n   */\n\n\n  get parent() {\n    return this.sectionCollection;\n  }\n\n  set parent(value) {\n    this.sectionCollection = value;\n    this.section.items.setValue(this.dictionaryProperties.parent, new PdfReferenceHolder(value));\n  }\n  /**\n   * Gets the `parent document`.\n   * @private\n   */\n\n\n  get parentDocument() {\n    return this.pdfDocument;\n  }\n  /**\n   * Gets or sets the `page settings` of the section.\n   * @private\n   */\n\n\n  get pageSettings() {\n    return this.settings;\n  }\n\n  set pageSettings(value) {\n    if (value != null) {\n      this.settings = value;\n    } else {\n      throw Error('Value can not be null.');\n    }\n  }\n  /**\n   * Gets the wrapped `element`.\n   * @private\n   */\n\n\n  get element() {\n    return this.section;\n  }\n  /**\n   * Gets the `count` of the pages in the section.\n   * @private\n   */\n\n\n  get count() {\n    return this.pagesReferences.count;\n  }\n  /**\n   * Gets or sets a `template` for the pages in the section.\n   * @private\n   */\n\n\n  get template() {\n    if (this.pageTemplate == null) {\n      this.pageTemplate = new PdfSectionTemplate();\n    }\n\n    return this.pageTemplate;\n  }\n\n  set template(value) {\n    this.pageTemplate = value;\n  }\n  /**\n   * Gets the `document`.\n   * @private\n   */\n\n\n  get document() {\n    return this.sectionCollection.document;\n  }\n  /**\n   * Gets the collection of `pages` in a section (Read only)\n   * @private\n   */\n\n\n  get pages() {\n    if (this.pagesCollection == null || typeof this.pagesCollection === 'undefined') {\n      this.pagesCollection = new PdfSectionPageCollection(this);\n    }\n\n    return this.pagesCollection;\n  } //methods\n\n  /**\n   * `Return the page collection` of current section.\n   * @private\n   */\n\n\n  getPages() {\n    return this.pdfPages;\n  }\n  /**\n   * `Translates` point into native coordinates of the page.\n   * @private\n   */\n\n\n  pointToNativePdf(page, point) {\n    let bounds = this.getActualBounds(page, true);\n    point.x += bounds.x;\n    point.y = this.pageSettings.height - point.y;\n    return point;\n  }\n  /**\n   * Sets the page setting of the current section.\n   * @public\n   * @param settings Instance of `PdfPageSettings`\n   */\n\n\n  setPageSettings(settings) {\n    this.settings = settings;\n    this.state.orientation = settings.orientation;\n    this.state.rotate = settings.rotate;\n    this.state.size = settings.size;\n    this.state.origin = settings.origin;\n  }\n  /**\n   * `Initializes` the object.\n   * @private\n   */\n\n\n  initialize() {\n    this.pagesReferences = new PdfArray();\n    this.section = new PdfDictionary();\n    this.state = new PageSettingsState(this.pdfDocument);\n    this.section.sectionBeginSave = new SaveSectionEventHandler(this, this.state);\n    this.pageCount = new PdfNumber(0);\n    this.section.items.setValue(this.dictionaryProperties.count, this.pageCount);\n    this.section.items.setValue(this.dictionaryProperties.type, new PdfName(this.dictionaryProperties.pages));\n    this.section.items.setValue(this.dictionaryProperties.kids, this.pagesReferences);\n  }\n  /**\n   * Checks whether any template should be printed on this layer.\n   * @private\n   * @param document The parent document.\n   * @param page The parent page.\n   * @param foreground Layer z-order.\n   * @returns True - if some content should be printed on the layer, False otherwise.\n   */\n\n\n  containsTemplates(document, page, foreground) {\n    let documentHeaders = this.getDocumentTemplates(document, page, foreground);\n    let sectionTemplates = this.getSectionTemplates(page, foreground);\n    return documentHeaders.length > 0 || sectionTemplates.length > 0;\n  }\n  /**\n   * Returns array of the document templates.\n   * @private\n   * @param document The parent document.\n   * @param page The parent page.\n   * @param headers If true - return headers/footers, if false - return simple templates.\n   * @param foreground If true - return foreground templates, if false - return background templates.\n   * @returns Returns array of the document templates.\n   */\n\n  /* tslint:disable */\n\n\n  getDocumentTemplates(document, page, foreground) {\n    let templates = [];\n\n    if (this.template.applyDocumentTopTemplate && document.template.getTop(page) != null) {\n      if (!(document.template.getTop(page).foreground || foreground) || document.template.getTop(page).foreground && foreground) {\n        templates.push(document.template.getTop(page));\n      }\n    }\n\n    if (this.template.applyDocumentBottomTemplate && document.template.getBottom(page) != null) {\n      if (!(document.template.getBottom(page).foreground || foreground) || document.template.getBottom(page).foreground && foreground) {\n        templates.push(document.template.getBottom(page));\n      }\n    }\n\n    if (this.template.applyDocumentLeftTemplate && document.template.getLeft(page) != null) {\n      if (!(document.template.getLeft(page).foreground || foreground) || document.template.getLeft(page).foreground && foreground) {\n        templates.push(document.template.getLeft(page));\n      }\n    }\n\n    if (this.template.applyDocumentRightTemplate && document.template.getRight(page) != null) {\n      if (!(document.template.getRight(page).foreground || foreground) || document.template.getRight(page).foreground && foreground) {\n        templates.push(document.template.getRight(page));\n      }\n    }\n\n    return templates;\n  }\n  /**\n   * Returns array of the section templates.\n   * @private\n   * @param page The parent page.\n   * @param foreground If true - return foreground templates, if false - return background templates.\n   * @returns Returns array of the section templates.\n   */\n\n  /* tslint:disable */\n\n\n  getSectionTemplates(page, foreground) {\n    let templates = [];\n\n    if (this.template.getTop(page) != null) {\n      let pageTemplate = this.template.getTop(page);\n\n      if (!(pageTemplate.foreground || foreground) || pageTemplate.foreground && foreground) {\n        templates.push(pageTemplate);\n      }\n    }\n\n    if (this.template.getBottom(page) != null) {\n      let pageTemplate = this.template.getBottom(page);\n\n      if (!(pageTemplate.foreground || foreground) || pageTemplate.foreground && foreground) {\n        templates.push(pageTemplate);\n      }\n    }\n\n    if (this.template.getLeft(page) != null) {\n      let pageTemplate = this.template.getLeft(page);\n\n      if (!(pageTemplate.foreground || foreground) || pageTemplate.foreground && foreground) {\n        templates.push(pageTemplate);\n      }\n    }\n\n    if (this.template.getRight(page) != null) {\n      let pageTemplate = this.template.getRight(page);\n\n      if (!(pageTemplate.foreground || foreground) || pageTemplate.foreground && foreground) {\n        templates.push(pageTemplate);\n      }\n    }\n\n    return templates;\n  }\n  /* tslint:enable */\n\n  /**\n   * `Adds` the specified page.\n   * @private\n   */\n\n\n  add(page) {\n    if (typeof page === 'undefined') {\n      let page = new PdfPage();\n      this.add(page);\n      return page;\n    } else {\n      let r = this.checkPresence(page);\n      this.pdfPages.push(page);\n      this.pagesReferences.add(r);\n      page.setSection(this);\n      page.resetProgress();\n      this.pageAddedMethod(page);\n    }\n  }\n  /**\n   * `Checks the presence`.\n   * @private\n   */\n\n\n  checkPresence(page) {\n    let rh = new PdfReferenceHolder(page);\n    let contains = false;\n    let sc = this.parent;\n\n    for (let index = 0; index < sc.section.length; index++) {\n      let section = sc.section[index];\n      contains = contains || section.contains(page);\n    }\n\n    return rh;\n  }\n  /**\n   * `Determines` whether the page in within the section.\n   * @private\n   */\n\n\n  contains(page) {\n    let index = this.indexOf(page);\n    return 0 <= index;\n  }\n  /**\n   * Get the `index of` the page.\n   * @private\n   */\n\n\n  indexOf(page) {\n    for (let index = 0; index < this.pdfPages.length; index++) {\n      if (this.pdfPages[index] === page) {\n        return this.pdfPages.indexOf(page);\n      }\n    }\n\n    let r = new PdfReferenceHolder(page);\n    return this.pagesReferences.indexOf(r);\n  }\n  /**\n   * Call two event's methods.\n   * @hidden\n   * @private\n   */\n\n\n  pageAddedMethod(page) {\n    //Create event's arguments\n    let args = new PageAddedEventArgs(page);\n    this.onPageAdded(args);\n    let parent = this.parent;\n    parent.document.pages.onPageAdded(args);\n    this.pageCount.intValue = this.count;\n  }\n  /**\n   * Called when the page has been added.\n   * @hidden\n   * @private\n   */\n\n\n  onPageAdded(args) {//\n  }\n\n  getActualBounds(arg1, arg2, arg3) {\n    if (arg1 instanceof PdfPage && typeof arg2 === 'boolean') {\n      let result;\n      let document = this.parent.document;\n      result = this.getActualBounds(document, arg1, arg2);\n      return result;\n    } else {\n      arg1 = arg1;\n      arg2 = arg2;\n      arg3 = arg3;\n      let bounds = new RectangleF(0, 0, 0, 0);\n      bounds.height = arg3 ? this.pageSettings.size.height : this.pageSettings.getActualSize().height;\n      bounds.width = arg3 ? this.pageSettings.size.width : this.pageSettings.getActualSize().width;\n      let left = this.getLeftIndentWidth(arg1, arg2, arg3);\n      let top = this.getTopIndentHeight(arg1, arg2, arg3);\n      let right = this.getRightIndentWidth(arg1, arg2, arg3);\n      let bottom = this.getBottomIndentHeight(arg1, arg2, arg3);\n      bounds.x += left;\n      bounds.y += top;\n      bounds.width -= left + right;\n      bounds.height -= top + bottom;\n      return bounds;\n    }\n  }\n  /**\n   * Calculates width of the `left indent`.\n   * @private\n   */\n\n\n  getLeftIndentWidth(document, page, includeMargins) {\n    if (document == null) {\n      throw new Error('ArgumentNullException:document');\n    }\n\n    if (page == null) {\n      throw new Error('ArgumentNullException:page');\n    }\n\n    let value = includeMargins ? this.pageSettings.margins.left : 0;\n    let templateWidth = this.template.getLeft(page) != null ? this.template.getLeft(page).width : 0;\n    let docTemplateWidth = document.template.getLeft(page) != null ? document.template.getLeft(page).width : 0;\n    value += this.template.applyDocumentLeftTemplate ? Math.max(templateWidth, docTemplateWidth) : templateWidth;\n    return value;\n  }\n  /**\n   * Calculates `Height` of the top indent.\n   * @private\n   */\n\n\n  getTopIndentHeight(document, page, includeMargins) {\n    if (document == null) {\n      throw new Error('ArgumentNullException:document');\n    }\n\n    if (page == null) {\n      throw new Error('ArgumentNullException:page');\n    }\n\n    let value = includeMargins ? this.pageSettings.margins.top : 0;\n    let templateHeight = this.template.getTop(page) != null ? this.template.getTop(page).height : 0;\n    let docTemplateHeight = document.template.getTop(page) != null ? document.template.getTop(page).height : 0;\n    value += this.template.applyDocumentTopTemplate ? Math.max(templateHeight, docTemplateHeight) : templateHeight;\n    return value;\n  }\n  /**\n   * Calculates `width` of the right indent.\n   * @private\n   */\n\n\n  getRightIndentWidth(document, page, includeMargins) {\n    if (document == null) {\n      throw new Error('ArgumentNullException:document');\n    }\n\n    if (page == null) {\n      throw new Error('ArgumentNullException:page');\n    }\n\n    let value = includeMargins ? this.pageSettings.margins.right : 0;\n    let templateWidth = this.template.getRight(page) != null ? this.template.getRight(page).width : 0;\n    let docTemplateWidth = document.template.getRight(page) != null ? document.template.getRight(page).width : 0;\n    value += this.template.applyDocumentRightTemplate ? Math.max(templateWidth, docTemplateWidth) : templateWidth;\n    return value;\n  }\n  /**\n   * Calculates `Height` of the bottom indent.\n   * @private\n   */\n\n\n  getBottomIndentHeight(document, page, includeMargins) {\n    if (document == null) {\n      throw new Error('ArgumentNullException:document');\n    }\n\n    if (page == null) {\n      throw new Error('ArgumentNullException:page');\n    }\n\n    let value = includeMargins ? this.pageSettings.margins.bottom : 0;\n    let templateHeight = this.template.getBottom(page) != null ? this.template.getBottom(page).height : 0;\n    let docTemplateHeight = document.template.getBottom(page) != null ? document.template.getBottom(page).height : 0;\n    value += this.template.applyDocumentBottomTemplate ? Math.max(templateHeight, docTemplateHeight) : templateHeight;\n    return value;\n  }\n  /**\n   * `Removes` the page from the section.\n   * @private\n   */\n\n\n  remove(page) {\n    if (page == null) {\n      throw Error('ArgumentNullException(\"page\")');\n    }\n\n    let index = this.pdfPages.indexOf(page);\n    this.pagesReferences.removeAt(index);\n    let temproaryPages = [];\n\n    for (let j = 0; j < index; j++) {\n      temproaryPages.push(this.pdfPages[j]);\n    }\n\n    for (let j = index + 1; j < this.pdfPages.length; j++) {\n      temproaryPages.push(this.pdfPages[j]);\n    }\n\n    this.pdfPages = temproaryPages;\n  }\n  /**\n   * In fills dictionary by the data from `Page settings`.\n   * @private\n   */\n\n\n  applyPageSettings(container, parentSettings, state) {\n    let bounds = new RectangleF(state.origin, state.size);\n    container.items.setValue(this.dictionaryProperties.mediaBox, PdfArray.fromRectangle(bounds));\n    let rotate = 0;\n    rotate = PdfSectionCollection.rotateFactor * state.rotate;\n    let angle = new PdfNumber(rotate);\n    container.items.setValue(this.dictionaryProperties.rotate, angle);\n  }\n  /**\n   * Catches the Save event of the dictionary.\n   * @hidden\n   * @private\n   */\n\n\n  beginSave(state, writer) {\n    let doc = writer.document;\n    this.applyPageSettings(this.section, doc.pageSettings, state);\n  }\n  /**\n   * Draws page templates on the page.\n   * @private\n   */\n\n\n  drawTemplates(page, layer, document, foreground) {\n    let documentHeaders = this.getDocumentTemplates(document, page, foreground);\n    let sectionHeaders = this.getSectionTemplates(page, foreground);\n    this.drawTemplatesHelper(layer, document, documentHeaders);\n    this.drawTemplatesHelper(layer, document, sectionHeaders);\n  }\n  /**\n   * Draws page templates on the page.\n   * @private\n   */\n\n\n  drawTemplatesHelper(layer, document, templates) {\n    if (templates != null && templates.length > 0) {\n      let len = templates.length;\n\n      for (let i = 0; i < len; i++) {\n        let template = templates[i];\n        template.draw(layer, document);\n      }\n    }\n  }\n\n}\n\nclass PageSettingsState {\n  //public Properties\n\n  /**\n   * @hidden\n   * @private\n   */\n  get orientation() {\n    return this.pageOrientation;\n  }\n\n  set orientation(value) {\n    this.pageOrientation = value;\n  }\n  /**\n   * @hidden\n   * @private\n   */\n\n\n  get rotate() {\n    return this.pageRotate;\n  }\n\n  set rotate(value) {\n    this.pageRotate = value;\n  }\n  /**\n   * @hidden\n   * @private\n   */\n\n\n  get size() {\n    return this.pageSize;\n  }\n\n  set size(value) {\n    this.pageSize = value;\n  }\n  /**\n   * @hidden\n   * @private\n   */\n\n\n  get origin() {\n    return this.pageOrigin;\n  }\n\n  set origin(value) {\n    this.pageOrigin = value;\n  } //Public Constructor\n\n  /**\n   * New instance to store the `PageSettings`.\n   * @private\n   */\n\n\n  constructor(document) {\n    this.pageOrientation = document.pageSettings.orientation;\n    this.pageRotate = document.pageSettings.rotate;\n    this.pageSize = document.pageSettings.size;\n    this.pageOrigin = document.pageSettings.origin;\n  }\n\n}\n/**\n * Represents the `collection of the sections`.\n * @private\n */\n\n\nlet PdfSectionCollection = /*#__PURE__*/(() => {\n  class PdfSectionCollection {\n    //constructor\n\n    /**\n     * Initializes a new instance of the `PdfSectionCollection` class.\n     * @private\n     */\n    constructor(document) {\n      /**\n       * @hidden\n       * @private\n       */\n      this.sections = [];\n      /**\n       * @hidden\n       * @private\n       */\n\n      this.dictionaryProperties = new DictionaryProperties(); // if (document === null) {\n      //     throw new Error('ArgumentNullException : document');\n      // }\n\n      this.pdfDocument = document.clone();\n      this.initialize();\n    } //Properties\n\n    /**\n     * Gets the `Section` collection.\n     */\n\n\n    get section() {\n      return this.sections;\n    }\n    /**\n     * Gets a parent `document`.\n     * @private\n     */\n\n\n    get document() {\n      return this.pdfDocument;\n    }\n    /**\n     * Gets the `number of sections` in a document.\n     * @private\n     */\n\n\n    get count() {\n      return this.sections.length;\n    }\n    /**\n     * Gets the wrapped `element`.\n     * @private\n     */\n\n\n    get element() {\n      return this.pages;\n    } //Methods\n\n    /**\n     * `Initializes the object`.\n     * @private\n     */\n\n\n    initialize() {\n      this.sectionCount = new PdfNumber(0);\n      this.sectionCollection = new PdfArray();\n      this.pages = new PdfDictionary();\n      this.pages.beginSave = new SaveSectionCollectionEventHandler(this);\n      this.pages.items.setValue(this.dictionaryProperties.type, new PdfName('Pages'));\n      this.pages.items.setValue(this.dictionaryProperties.kids, this.sectionCollection);\n      this.pages.items.setValue(this.dictionaryProperties.count, this.sectionCount);\n      this.pages.items.setValue(this.dictionaryProperties.resources, new PdfDictionary());\n      this.setPageSettings(this.pages, this.pdfDocument.pageSettings);\n    }\n    /**\n     * Initializes a new instance of the `PdfSectionCollection` class.\n     * @private\n     */\n\n\n    pdfSectionCollection(index) {\n      if (index < 0 || index >= this.count) {\n        throw new Error('IndexOutOfRangeException()');\n      }\n\n      return this.sections[index];\n    }\n    /**\n     * In fills dictionary by the data from `Page settings`.\n     * @private\n     */\n\n\n    setPageSettings(container, pageSettings) {\n      // if (container === null) {\n      //     throw new Error('ArgumentNullException : container');\n      // }\n      // if (pageSettings === null) {\n      //     throw new Error('ArgumentNullException : pageSettings');\n      // }\n      let bounds = new RectangleF(new PointF(), pageSettings.size);\n      container.items.setValue(this.dictionaryProperties.mediaBox, PdfArray.fromRectangle(bounds));\n    }\n    /**\n     * `Adds` the specified section.\n     * @private\n     */\n\n\n    add(section) {\n      if (typeof section === 'undefined') {\n        let section = new PdfSection(this.pdfDocument);\n        this.add(section);\n        return section;\n      } else {\n        // if (section === null) {\n        //     throw new Error('ArgumentNullException : section');\n        // }\n        let r = this.checkSection(section);\n        this.sections.push(section);\n        section.parent = this;\n        this.sectionCollection.add(r);\n        return this.sections.indexOf(section);\n      }\n    }\n    /**\n     * `Checks` if the section is within the collection.\n     * @private\n     */\n\n\n    checkSection(section) {\n      let r = new PdfReferenceHolder(section);\n      let contains = this.sectionCollection.contains(r); // if (contains) {\n      //     throw new Error('ArgumentException : The object can not be added twice to the collection,section');\n      // }\n\n      return r;\n    }\n    /**\n     * Catches the Save event of the dictionary to `count the pages`.\n     * @private\n     */\n\n\n    countPages() {\n      let count = 0;\n      this.sections.forEach(n => count += n.count);\n      return count;\n    }\n    /**\n     * Catches the Save event of the dictionary to `count the pages`.\n     * @hidden\n     * @private\n     */\n\n\n    beginSave() {\n      this.sectionCount.intValue = this.countPages();\n    }\n\n  }\n\n  //Fields\n\n  /**\n   * Rotate factor for page `rotation`.\n   * @default 90\n   * @private\n   */\n  PdfSectionCollection.rotateFactor = 90;\n  /**\n   * Represents a virtual collection of all the pages in the document.\n   * @private\n   */\n\n  return PdfSectionCollection;\n})();\n\nclass PdfDocumentPageCollection {\n  //constructor\n\n  /**\n   * Initializes a new instance of the `PdfPageCollection` class.\n   * @private\n   */\n  constructor(document) {\n    /**\n     * It holds the page collection with the `index`.\n     * @private\n     */\n    this.pdfPageCollectionIndex = new Dictionary();\n    this.document = document;\n  } //Property\n\n  /**\n   * Gets the total `number of the pages`.\n   * @private\n   */\n\n\n  get count() {\n    return this.countPages();\n  }\n  /**\n   * Gets a `page index` from the document.\n   * @private\n   */\n\n\n  get pageCollectionIndex() {\n    return this.pdfPageCollectionIndex;\n  }\n\n  add(page) {\n    if (typeof page === 'undefined') {\n      let page = new PdfPage();\n      this.add(page);\n      return page;\n    } else {\n      let section = this.getLastSection();\n      section.add(page);\n    }\n  }\n  /**\n   * Returns `last section` in the document.\n   * @private\n   */\n\n\n  getLastSection() {\n    let sc = this.document.sections;\n\n    if (sc.section.length === 0) {\n      sc.add();\n    }\n\n    let section = sc.section[sc.section.length - 1];\n    return section;\n  }\n  /**\n   * Called when `new page has been added`.\n   * @private\n   */\n\n\n  onPageAdded(args) {// if (PageAdded !== null)\n    // {\n    //     PageAdded(this, args);\n    // }\n  }\n  /**\n   * Gets the `total number of pages`.\n   * @private\n   */\n\n\n  countPages() {\n    let sc = this.document.sections;\n    let count = 0;\n\n    for (let index = 0; index < sc.section.length; index++) {\n      count += sc.section[index].count;\n    }\n\n    return count;\n  }\n  /**\n   * Gets the `page object` from page index.\n   * @private\n   */\n\n\n  getPageByIndex(index) {\n    return this.getPage(index);\n  }\n  /**\n   * Gets a page by its `index` in the document.\n   * @private\n   */\n\n\n  getPage(index) {\n    if (index < 0 || index >= this.count) {\n      throw Error('ArgumentOutOfRangeException(\"index\", \"Value can not be less 0\")');\n    }\n\n    let page = null;\n    let sectionStartIndex = 0;\n    let sectionCount = 0;\n    let pageIndex = 0;\n    let length = this.document.sections.count;\n\n    for (let i = 0; i < length; i++) {\n      let section = this.document.sections.section[i];\n      sectionCount = section.count;\n      pageIndex = index - sectionStartIndex; // We found a section containing the page.\n\n      if (index >= sectionStartIndex && pageIndex < sectionCount) {\n        page = section.getPages()[pageIndex];\n        break;\n      }\n\n      sectionStartIndex += sectionCount;\n    }\n\n    return page;\n  }\n  /**\n   * Gets the `index of` the page in the document.\n   * @private\n   */\n\n\n  indexOf(page) {\n    let index = -1;\n\n    if (page == null) {\n      throw new Error('ArgumentNullException: page');\n    } else {\n      let numPages = 0;\n\n      for (let i = 0, len = this.document.sections.count; i < len; i++) {\n        let section = this.document.sections.pdfSectionCollection(i);\n        index = section.indexOf(page);\n\n        if (index >= 0) {\n          index += numPages;\n          break;\n        } else {\n          index = -1;\n        }\n\n        numPages += section.count;\n      }\n    }\n\n    return index;\n  }\n  /**\n   * `Removes` the specified page.\n   * @private\n   */\n\n\n  remove(page) {\n    if (page == null) {\n      throw Error('ArgumentNullException(\"page\")');\n    }\n\n    let section = null;\n\n    for (let i = 0, len = this.document.sections.count; i < len; i++) {\n      section = this.document.sections.pdfSectionCollection(i);\n\n      if (section.pages.contains(page)) {\n        section.pages.remove(page);\n        break;\n      }\n    }\n\n    return section;\n  }\n\n}\n/**\n * PdfCacheCollection.ts class for EJ2-PDF\n */\n\n/**\n * `Collection of the cached objects`.\n * @private\n */\n\n\nclass PdfCacheCollection {\n  // Constructors\n\n  /**\n   * Initializes a new instance of the `PdfCacheCollection` class.\n   * @private\n   */\n  constructor() {\n    this.referenceObjects = [];\n    this.pdfFontCollection = new Dictionary();\n  } // Public methods\n\n  /**\n   * `Searches` for the similar cached object. If is not found - adds the object to the cache.\n   * @private\n   */\n\n\n  search(obj) {\n    let result = null;\n    let group = this.getGroup(obj);\n\n    if (group == null) {\n      group = this.createNewGroup();\n    } else if (group.length > 0) {\n      result = group[0];\n    }\n\n    group.push(obj);\n    return result;\n  } // Implementation\n\n  /**\n   * `Creates` a new group.\n   * @private\n   */\n\n\n  createNewGroup() {\n    let group = [];\n    this.referenceObjects.push(group);\n    return group;\n  }\n  /**\n   * `Find and Return` a group.\n   * @private\n   */\n\n\n  getGroup(result) {\n    let group = null;\n\n    if (result !== null) {\n      let len = this.referenceObjects.length;\n\n      for (let i = 0; i < len; i++) {\n        if (this.referenceObjects.length > 0) {\n          let tGroup = this.referenceObjects[i];\n\n          if (tGroup.length > 0) {\n            let representative = tGroup[0];\n\n            if (result.equalsTo(representative)) {\n              group = tGroup;\n              break;\n            }\n          } else {\n            this.removeGroup(tGroup);\n          }\n        }\n\n        len = this.referenceObjects.length;\n      }\n    }\n\n    return group;\n  }\n  /**\n   * Remove a group from the storage.\n   */\n\n\n  removeGroup(group) {\n    if (group !== null) {\n      let index = this.referenceObjects.indexOf(group);\n      this.referenceObjects.slice(index, index + 1);\n    }\n  }\n\n  destroy() {\n    this.pdfFontCollection = undefined;\n    this.referenceObjects = undefined;\n  }\n\n}\n/**\n * Represents a PDF document and can be used to create a new PDF document from the scratch.\n * ```typescript\n * // create a new PDF document\n * let document : PdfDocument = new PdfDocument();\n * // add a new page to the document\n * let page1 : PdfPage = document.pages.add();\n * // set the font\n * let font : PdfStandardFont = new PdfStandardFont(PdfFontFamily.Helvetica, 20);\n * // create black brush\n * let blackBrush : PdfSolidBrush = new PdfSolidBrush(new PdfColor(0, 0, 0));\n * // draw the text\n * page1.graphics.drawString('Hello World', font, blackBrush, new PointF(0, 0));\n * // save the document\n * document.save('output.pdf');\n * // destroy the document\n * document.destroy();\n * ```\n */\n\n\nlet PdfDocument = /*#__PURE__*/(() => {\n  class PdfDocument extends PdfDocumentBase {\n    constructor(isMerging) {\n      super();\n      /**\n       * Default `margin` value.\n       * @default 40.0\n       * @private\n       */\n\n      this.defaultMargin = 40.0;\n      /**\n       * Internal variable to store instance of `StreamWriter` classes..\n       * @default null\n       * @private\n       */\n\n      this.streamWriter = null;\n      this.document = this;\n      let isMerge = false;\n\n      if (typeof isMerging === 'undefined') {\n        PdfDocument.cacheCollection = new PdfCacheCollection();\n        isMerge = false;\n      } else {\n        isMerge = isMerging;\n      }\n\n      let objects = new PdfMainObjectCollection();\n      this.setMainObjectCollection(objects);\n      let crossTable = new PdfCrossTable();\n      crossTable.isMerging = isMerge;\n      crossTable.document = this;\n      this.setCrossTable(crossTable);\n      let catalog = new PdfCatalog();\n      this.setCatalog(catalog);\n      objects.add(catalog);\n      catalog.position = -1;\n      this.sectionCollection = new PdfSectionCollection(this);\n      this.documentPageCollection = new PdfDocumentPageCollection(this);\n      catalog.pages = this.sectionCollection;\n    } //Properties\n\n    /**\n     * Gets the `default font`. It is used for complex objects when font is not explicitly defined.\n     * @private\n     */\n\n\n    static get defaultFont() {\n      if (this.defaultStandardFont == null) {\n        this.defaultStandardFont = new PdfStandardFont(PdfFontFamily.Helvetica, 8);\n      }\n\n      return this.defaultStandardFont;\n    }\n    /**\n     * Gets the collection of the `sections` in the document.\n     * @private\n     */\n\n\n    get sections() {\n      return this.sectionCollection;\n    }\n    /**\n     * Gets the document's page setting.\n     * @public\n     */\n\n\n    get pageSettings() {\n      if (this.settings == null) {\n        this.settings = new PdfPageSettings(this.defaultMargin);\n      }\n\n      return this.settings;\n    }\n    /**\n     * Sets the document's page setting.\n     * ```typescript\n     * //createanewPDFdocument\n     * letdocument:PdfDocument=newPdfDocument();\n     *\n     * //setstheright margin of the page\n     * document.pageSettings.margins.right=0;\n     * //setthepagesize.\n     * document.pageSettings.size=newSizeF(500,500);\n     * //changethepageorientationtolandscape\n     * document.pageSettings.orientation=PdfPageOrientation.Landscape;\n     * //apply90degreerotationonthepage\n     * document.pageSettings.rotate=PdfPageRotateAngle.RotateAngle90;\n     *\n     * //addapagestothedocument\n     * letpage1:PdfPage=document.pages.add();\n     * //setfont\n     * letfont:PdfStandardFont=newPdfStandardFont(PdfFontFamily.Helvetica,20);\n     * //setbrush\n     * letblackBrush:PdfSolidBrush=newPdfSolidBrush(newPdfColor(0,0,0));\n     * //setthespecifiedPoint\n     * letpoint:PointF=newPointF(page1.getClientSize().width-200,page1.getClientSize().height-200);\n     * //drawthetext\n     * page1.graphics.drawString('HelloWorld',font,blackBrush,point);\n     * //savethedocument\n     * document.save('output.pdf');\n     * // destroy the document\n     * document.destroy();\n     * ```\n     */\n\n\n    set pageSettings(value) {\n      this.settings = value;\n    }\n    /**\n     * Represents the collection of pages in the PDF document.\n     * ```typescript\n     * // create a new PDF document\n     * let document : PdfDocument = new PdfDocument();\n     * //\n     * // get the collection of pages in the document\n     * let pageCollection : PdfDocumentPageCollection  = document.pages;\n     * //\n     * // add pages\n     * let page1 : PdfPage = pageCollection.add();\n     * // save the document\n     * document.save('output.pdf');\n     * // destroy the document\n     * document.destroy();\n     * ```\n     */\n\n\n    get pages() {\n      return this.documentPageCollection;\n    }\n    /**\n     * Gets collection of the `cached objects`.\n     * @private\n     */\n\n\n    static get cache() {\n      if (typeof PdfDocument.cacheCollection === 'undefined' || PdfDocument.cacheCollection == null) {\n        return new PdfCacheCollection();\n      }\n\n      return PdfDocument.cacheCollection;\n    }\n    /**\n     * Sets collection of the `cached objects`.\n     * @private\n     */\n\n\n    static set cache(value) {\n      this.cacheCollection = value;\n    }\n    /**\n     * Gets the value of enable cache.\n     * @private\n     */\n\n\n    static get enableCache() {\n      return this.isCacheEnabled;\n    }\n    /**\n     * Sets thie value of enable cache.\n     * @private\n     */\n\n\n    static set enableCache(value) {\n      this.isCacheEnabled = value;\n    }\n    /* tslint:disable */\n\n    /**\n     * Gets or sets the `color space` of the document. This property can be used to create PDF document in RGB, Gray scale or CMYK color spaces.\n     * @private\n     */\n\n\n    get colorSpace() {\n      if (this.pdfColorSpace === PdfColorSpace.Rgb || this.pdfColorSpace === PdfColorSpace.Cmyk || this.pdfColorSpace === PdfColorSpace.GrayScale) {\n        return this.pdfColorSpace;\n      } else {\n        return PdfColorSpace.Rgb;\n      }\n    }\n\n    set colorSpace(value) {\n      if (value === PdfColorSpace.Rgb || value === PdfColorSpace.Cmyk || value === PdfColorSpace.GrayScale) {\n        this.pdfColorSpace = value;\n      } else {\n        this.pdfColorSpace = PdfColorSpace.Rgb;\n      }\n    }\n    /* tslint:enable */\n\n    /**\n     * Gets or sets a `template` to all pages in the document.\n     * @private\n     */\n\n\n    get template() {\n      if (this.pageTemplate == null) {\n        this.pageTemplate = new PdfDocumentTemplate();\n      }\n\n      return this.pageTemplate;\n    }\n\n    set template(value) {\n      this.pageTemplate = value;\n    }\n\n    docSave(stream, arg2, arg3) {\n      this.checkPagesPresence();\n\n      if (stream === null) {\n        throw new Error('ArgumentNullException : stream');\n      }\n\n      this.streamWriter = stream;\n      let writer = new PdfWriter(stream);\n      writer.document = this;\n\n      if (typeof arg2 === 'boolean' && typeof arg3 === 'undefined') {\n        return this.crossTable.save(writer);\n      } else {\n        this.crossTable.save(writer, arg2);\n      }\n    }\n    /**\n     * Checks the pages `presence`.\n     * @private\n     */\n\n\n    checkPagesPresence() {\n      if (this.pages.count === 0) {\n        this.pages.add();\n      }\n    }\n    /**\n     * disposes the current instance of `PdfDocument` class.\n     * ```typescript\n     * // create a new PDF document\n     * let document : PdfDocument = new PdfDocument();\n     * // add a new page to the document\n     * let page1 : PdfPage = document.pages.add();\n     * // set the font\n     * let font : PdfStandardFont = new PdfStandardFont(PdfFontFamily.Helvetica, 20);\n     * // create black brush\n     * let blackBrush : PdfSolidBrush = new PdfSolidBrush(new PdfColor(0, 0, 0));\n     * // draw the text\n     * page1.graphics.drawString('Hello World', font, blackBrush, new PointF(0, 0));\n     * // save the document\n     * document.save('output.pdf');\n     * // destroy the document\n     * document.destroy();\n     * ```\n     */\n\n\n    destroy() {\n      this.catalog = undefined;\n      this.colorSpace = undefined;\n      this.currentSavingObj = undefined;\n      this.documentPageCollection = undefined;\n      this.isStreamCopied = undefined;\n      this.pageSettings = undefined;\n      this.pageTemplate = undefined;\n      this.pdfColorSpace = undefined;\n      this.sectionCollection = undefined;\n      PdfDocument.cache.destroy();\n      this.crossTable.pdfObjects.destroy();\n      PdfDocument.cache = undefined;\n      this.streamWriter.destroy();\n    }\n\n  }\n\n  /**\n   * `Font` used in complex objects to draw strings and text when it is not defined explicitly.\n   * @default null\n   * @private\n   */\n  PdfDocument.defaultStandardFont = null;\n  /**\n   * Indicates whether enable cache or not\n   * @default true\n   * @private\n   */\n\n  PdfDocument.isCacheEnabled = true;\n  /**\n   * PdfStandardFontMetricsFactory.ts class for EJ2-PDF\n   */\n\n  /**\n   * @private\n   * `Factory of the standard fonts metrics`.\n   */\n\n  return PdfDocument;\n})();\nlet PdfStandardFontMetricsFactory = /*#__PURE__*/(() => {\n  class PdfStandardFontMetricsFactory {\n    /**\n     * Returns `metrics` of the font.\n     * @private\n     */\n    static getMetrics(fontFamily, fontStyle, size) {\n      let metrics = null;\n\n      switch (fontFamily) {\n        case PdfFontFamily.Helvetica:\n          metrics = this.getHelveticaMetrics(fontFamily, fontStyle, size);\n          break;\n\n        case PdfFontFamily.Courier:\n          metrics = this.getCourierMetrics(fontFamily, fontStyle, size);\n          break;\n\n        case PdfFontFamily.TimesRoman:\n          metrics = this.getTimesMetrics(fontFamily, fontStyle, size);\n          break;\n\n        case PdfFontFamily.Symbol:\n          metrics = this.getSymbolMetrics(fontFamily, fontStyle, size);\n          break;\n\n        case PdfFontFamily.ZapfDingbats:\n          metrics = this.getZapfDingbatsMetrics(fontFamily, fontStyle, size);\n          break;\n\n        default:\n          metrics = this.getHelveticaMetrics(PdfFontFamily.Helvetica, fontStyle, size);\n          break;\n      }\n\n      metrics.name = fontFamily.toString();\n      metrics.subScriptSizeFactor = this.subSuperScriptFactor;\n      metrics.superscriptSizeFactor = this.subSuperScriptFactor;\n      return metrics;\n    } // Implementation\n\n    /**\n     * Creates `Helvetica font metrics`.\n     * @private\n     */\n\n\n    static getHelveticaMetrics(fontFamily, fontStyle, size) {\n      let metrics = new PdfFontMetrics();\n\n      if ((fontStyle & PdfFontStyle.Bold) > 0 && (fontStyle & PdfFontStyle.Italic) > 0) {\n        metrics.ascent = this.helveticaBoldItalicAscent;\n        metrics.descent = this.helveticaBoldItalicDescent;\n        metrics.postScriptName = this.helveticaBoldItalicName;\n        metrics.size = size;\n        metrics.widthTable = new StandardWidthTable(this.arialBoldWidth);\n        metrics.height = metrics.ascent - metrics.descent;\n      } else if ((fontStyle & PdfFontStyle.Bold) > 0) {\n        metrics.ascent = this.helveticaBoldAscent;\n        metrics.descent = this.helveticaBoldDescent;\n        metrics.postScriptName = this.helveticaBoldName;\n        metrics.size = size;\n        metrics.widthTable = new StandardWidthTable(this.arialBoldWidth);\n        metrics.height = metrics.ascent - metrics.descent;\n      } else if ((fontStyle & PdfFontStyle.Italic) > 0) {\n        metrics.ascent = this.helveticaItalicAscent;\n        metrics.descent = this.helveticaItalicDescent;\n        metrics.postScriptName = this.helveticaItalicName;\n        metrics.size = size;\n        metrics.widthTable = new StandardWidthTable(this.arialWidth);\n        metrics.height = metrics.ascent - metrics.descent;\n      } else {\n        metrics.ascent = this.helveticaAscent;\n        metrics.descent = this.helveticaDescent;\n        metrics.postScriptName = this.helveticaName;\n        metrics.size = size;\n        metrics.widthTable = new StandardWidthTable(this.arialWidth);\n        metrics.height = metrics.ascent - metrics.descent;\n      }\n\n      return metrics;\n    }\n    /**\n     * Creates `Courier font metrics`.\n     * @private\n     */\n\n\n    static getCourierMetrics(fontFamily, fontStyle, size) {\n      let metrics = new PdfFontMetrics();\n\n      if ((fontStyle & PdfFontStyle.Bold) > 0 && (fontStyle & PdfFontStyle.Italic) > 0) {\n        metrics.ascent = this.courierBoldItalicAscent;\n        metrics.descent = this.courierBoldItalicDescent;\n        metrics.postScriptName = this.courierBoldItalicName;\n        metrics.size = size;\n        metrics.widthTable = new StandardWidthTable(this.fixedWidth);\n        metrics.height = metrics.ascent - metrics.descent;\n      } else if ((fontStyle & PdfFontStyle.Bold) > 0) {\n        metrics.ascent = this.courierBoldAscent;\n        metrics.descent = this.courierBoldDescent;\n        metrics.postScriptName = this.courierBoldName;\n        metrics.size = size;\n        metrics.widthTable = new StandardWidthTable(this.fixedWidth);\n        metrics.height = metrics.ascent - metrics.descent;\n      } else if ((fontStyle & PdfFontStyle.Italic) > 0) {\n        metrics.ascent = this.courierItalicAscent;\n        metrics.descent = this.courierItalicDescent;\n        metrics.postScriptName = this.courierItalicName;\n        metrics.size = size;\n        metrics.widthTable = new StandardWidthTable(this.fixedWidth);\n        metrics.height = metrics.ascent - metrics.descent;\n      } else {\n        metrics.ascent = this.courierAscent;\n        metrics.descent = this.courierDescent;\n        metrics.postScriptName = this.courierName;\n        metrics.size = size;\n        metrics.widthTable = new StandardWidthTable(this.fixedWidth);\n        metrics.height = metrics.ascent - metrics.descent;\n      }\n\n      return metrics;\n    }\n    /**\n     * Creates `Times font metrics`.\n     * @private\n     */\n\n\n    static getTimesMetrics(fontFamily, fontStyle, size) {\n      let metrics = new PdfFontMetrics();\n\n      if ((fontStyle & PdfFontStyle.Bold) > 0 && (fontStyle & PdfFontStyle.Italic) > 0) {\n        metrics.ascent = this.timesBoldItalicAscent;\n        metrics.descent = this.timesBoldItalicDescent;\n        metrics.postScriptName = this.timesBoldItalicName;\n        metrics.size = size;\n        metrics.widthTable = new StandardWidthTable(this.timesRomanBoldItalicWidths);\n        metrics.height = metrics.ascent - metrics.descent;\n      } else if ((fontStyle & PdfFontStyle.Bold) > 0) {\n        metrics.ascent = this.timesBoldAscent;\n        metrics.descent = this.timesBoldDescent;\n        metrics.postScriptName = this.timesBoldName;\n        metrics.size = size;\n        metrics.widthTable = new StandardWidthTable(this.timesRomanBoldWidth);\n        metrics.height = metrics.ascent - metrics.descent;\n      } else if ((fontStyle & PdfFontStyle.Italic) > 0) {\n        metrics.ascent = this.timesItalicAscent;\n        metrics.descent = this.timesItalicDescent;\n        metrics.postScriptName = this.timesItalicName;\n        metrics.size = size;\n        metrics.widthTable = new StandardWidthTable(this.timesRomanItalicWidth);\n        metrics.height = metrics.ascent - metrics.descent;\n      } else {\n        metrics.ascent = this.timesAscent;\n        metrics.descent = this.timesDescent;\n        metrics.postScriptName = this.timesName;\n        metrics.size = size;\n        metrics.widthTable = new StandardWidthTable(this.timesRomanWidth);\n        metrics.height = metrics.ascent - metrics.descent;\n      }\n\n      return metrics;\n    }\n    /**\n     * Creates `Symbol font metrics`.\n     * @private\n     */\n\n\n    static getSymbolMetrics(fontFamily, fontStyle, size) {\n      let metrics = new PdfFontMetrics();\n      metrics.ascent = this.symbolAscent;\n      metrics.descent = this.symbolDescent;\n      metrics.postScriptName = this.symbolName;\n      metrics.size = size;\n      metrics.widthTable = new StandardWidthTable(this.symbolWidth);\n      metrics.height = metrics.ascent - metrics.descent;\n      return metrics;\n    }\n    /**\n     * Creates `ZapfDingbats font metrics`.\n     * @private\n     */\n\n\n    static getZapfDingbatsMetrics(fontFamily, fontStyle, size) {\n      let metrics = new PdfFontMetrics();\n      metrics.ascent = this.zapfDingbatsAscent;\n      metrics.descent = this.zapfDingbatsDescent;\n      metrics.postScriptName = this.zapfDingbatsName;\n      metrics.size = size;\n      metrics.widthTable = new StandardWidthTable(this.zapfDingbatsWidth);\n      metrics.height = metrics.ascent - metrics.descent;\n      return metrics;\n    }\n\n  }\n\n  /**\n   * `Multiplier` os subscript superscript.\n   * @private\n   */\n  PdfStandardFontMetricsFactory.subSuperScriptFactor = 1.52;\n  /**\n   * `Ascender` value for the font.\n   * @private\n   */\n\n  PdfStandardFontMetricsFactory.helveticaAscent = 931;\n  /**\n   * `Ascender` value for the font.\n   * @private\n   */\n\n  PdfStandardFontMetricsFactory.helveticaDescent = -225;\n  /**\n   * `Font type`.\n   * @private\n   */\n\n  PdfStandardFontMetricsFactory.helveticaName = 'Helvetica';\n  /**\n   * `Ascender` value for the font.\n   * @private\n   */\n\n  PdfStandardFontMetricsFactory.helveticaBoldAscent = 962;\n  /**\n   * `Ascender` value for the font.\n   * @private\n   */\n\n  PdfStandardFontMetricsFactory.helveticaBoldDescent = -228;\n  /**\n   * `Font type`.\n   * @private\n   */\n\n  PdfStandardFontMetricsFactory.helveticaBoldName = 'Helvetica-Bold';\n  /**\n   * `Ascender` value for the font.\n   * @private\n   */\n\n  PdfStandardFontMetricsFactory.helveticaItalicAscent = 931;\n  /**\n   * `Ascender` value for the font.\n   * @private\n   */\n\n  PdfStandardFontMetricsFactory.helveticaItalicDescent = -225;\n  /**\n   * `Font type`.\n   * @private\n   */\n\n  PdfStandardFontMetricsFactory.helveticaItalicName = 'Helvetica-Oblique';\n  /**\n   * `Ascender` value for the font.\n   * @private\n   */\n\n  PdfStandardFontMetricsFactory.helveticaBoldItalicAscent = 962;\n  /**\n   * `Ascender` value for the font.\n   * @private\n   */\n\n  PdfStandardFontMetricsFactory.helveticaBoldItalicDescent = -228;\n  /**\n   * `Font type`.\n   * @private\n   */\n\n  PdfStandardFontMetricsFactory.helveticaBoldItalicName = 'Helvetica-BoldOblique';\n  /**\n   * `Ascender` value for the font.\n   * @private\n   */\n\n  PdfStandardFontMetricsFactory.courierAscent = 805;\n  /**\n   * `Ascender` value for the font.\n   * @private\n   */\n\n  PdfStandardFontMetricsFactory.courierDescent = -250;\n  /**\n   * `Font type`.\n   * @private\n   */\n\n  PdfStandardFontMetricsFactory.courierName = 'Courier';\n  /**\n   * `Ascender` value for the font.\n   * @private\n   */\n\n  PdfStandardFontMetricsFactory.courierBoldAscent = 801;\n  /**\n   * `Ascender` value for the font.\n   * @private\n   */\n\n  PdfStandardFontMetricsFactory.courierBoldDescent = -250;\n  /**\n   * `Font type`.\n   * @private\n   */\n\n  PdfStandardFontMetricsFactory.courierBoldName = 'Courier-Bold';\n  /**\n   * `Ascender` value for the font.\n   * @private\n   */\n\n  PdfStandardFontMetricsFactory.courierItalicAscent = 805;\n  /**\n   * `Ascender` value for the font.\n   * @private\n   */\n\n  PdfStandardFontMetricsFactory.courierItalicDescent = -250;\n  /**\n   * `Font type`.\n   * @private\n   */\n\n  PdfStandardFontMetricsFactory.courierItalicName = 'Courier-Oblique';\n  /**\n   * `Ascender` value for the font.\n   * @private\n   */\n\n  PdfStandardFontMetricsFactory.courierBoldItalicAscent = 801;\n  /**\n   * `Ascender` value for the font.\n   * @private\n   */\n\n  PdfStandardFontMetricsFactory.courierBoldItalicDescent = -250;\n  /**\n   * `Font type`.\n   * @private\n   */\n\n  PdfStandardFontMetricsFactory.courierBoldItalicName = 'Courier-BoldOblique';\n  /**\n   * `Ascender` value for the font.\n   * @private\n   */\n\n  PdfStandardFontMetricsFactory.timesAscent = 898;\n  /**\n   * `Ascender` value for the font.\n   * @private\n   */\n\n  PdfStandardFontMetricsFactory.timesDescent = -218;\n  /**\n   * `Font type`.\n   * @private\n   */\n\n  PdfStandardFontMetricsFactory.timesName = 'Times-Roman';\n  /**\n   * `Ascender` value for the font.\n   * @private\n   */\n\n  PdfStandardFontMetricsFactory.timesBoldAscent = 935;\n  /**\n   * `Ascender` value for the font.\n   * @private\n   */\n\n  PdfStandardFontMetricsFactory.timesBoldDescent = -218;\n  /**\n   * `Font type`.\n   * @private\n   */\n\n  PdfStandardFontMetricsFactory.timesBoldName = 'Times-Bold';\n  /**\n   * `Ascender` value for the font.\n   * @private\n   */\n\n  PdfStandardFontMetricsFactory.timesItalicAscent = 883;\n  /**\n   * `Ascender` value for the font.\n   * @private\n   */\n\n  PdfStandardFontMetricsFactory.timesItalicDescent = -217;\n  /**\n   * `Font type`.\n   * @private\n   */\n\n  PdfStandardFontMetricsFactory.timesItalicName = 'Times-Italic';\n  /**\n   * `Ascender` value for the font.\n   * @private\n   */\n\n  PdfStandardFontMetricsFactory.timesBoldItalicAscent = 921;\n  /**\n   * `Ascender` value for the font.\n   * @private\n   */\n\n  PdfStandardFontMetricsFactory.timesBoldItalicDescent = -218;\n  /**\n   * `Font type`.\n   * @private\n   */\n\n  PdfStandardFontMetricsFactory.timesBoldItalicName = 'Times-BoldItalic';\n  /**\n   * `Ascender` value for the font.\n   * @private\n   */\n\n  PdfStandardFontMetricsFactory.symbolAscent = 1010;\n  /**\n   * `Ascender` value for the font.\n   * @private\n   */\n\n  PdfStandardFontMetricsFactory.symbolDescent = -293;\n  /**\n   * `Font type`.\n   * @private\n   */\n\n  PdfStandardFontMetricsFactory.symbolName = 'Symbol';\n  /**\n   * `Ascender` value for the font.\n   * @private\n   */\n\n  PdfStandardFontMetricsFactory.zapfDingbatsAscent = 820;\n  /**\n   * `Ascender` value for the font.\n   * @private\n   */\n\n  PdfStandardFontMetricsFactory.zapfDingbatsDescent = -143;\n  /**\n   * `Font type`.\n   * @private\n   */\n\n  PdfStandardFontMetricsFactory.zapfDingbatsName = 'ZapfDingbats';\n  /**\n   * `Arial` widths table.\n   * @private\n   */\n\n  PdfStandardFontMetricsFactory.arialWidth = [278, 278, 355, 556, 556, 889, 667, 191, 333, 333, 389, 584, 278, 333, 278, 278, 556, 556, 556, 556, 556, 556, 556, 556, 556, 556, 278, 278, 584, 584, 584, 556, 1015, 667, 667, 722, 722, 667, 611, 778, 722, 278, 500, 667, 556, 833, 722, 778, 667, 778, 722, 667, 611, 722, 667, 944, 667, 667, 611, 278, 278, 278, 469, 556, 333, 556, 556, 500, 556, 556, 278, 556, 556, 222, 222, 500, 222, 833, 556, 556, 556, 556, 333, 500, 278, 556, 500, 722, 500, 500, 500, 334, 260, 334, 584, 0, 556, 0, 222, 556, 333, 1000, 556, 556, 333, 1000, 667, 333, 1000, 0, 611, 0, 0, 222, 222, 333, 333, 350, 556, 1000, 333, 1000, 500, 333, 944, 0, 500, 667, 0, 333, 556, 556, 556, 556, 260, 556, 333, 737, 370, 556, 584, 0, 737, 333, 400, 584, 333, 333, 333, 556, 537, 278, 333, 333, 365, 556, 834, 834, 834, 611, 667, 667, 667, 667, 667, 667, 1000, 722, 667, 667, 667, 667, 278, 278, 278, 278, 722, 722, 778, 778, 778, 778, 778, 584, 778, 722, 722, 722, 722, 667, 667, 611, 556, 556, 556, 556, 556, 556, 889, 500, 556, 556, 556, 556, 278, 278, 278, 278, 556, 556, 556, 556, 556, 556, 556, 584, 611, 556, 556, 556, 556, 500, 556, 500];\n  /**\n   * `Arial bold` widths table.\n   * @private\n   */\n\n  PdfStandardFontMetricsFactory.arialBoldWidth = [278, 333, 474, 556, 556, 889, 722, 238, 333, 333, 389, 584, 278, 333, 278, 278, 556, 556, 556, 556, 556, 556, 556, 556, 556, 556, 333, 333, 584, 584, 584, 611, 975, 722, 722, 722, 722, 667, 611, 778, 722, 278, 556, 722, 611, 833, 722, 778, 667, 778, 722, 667, 611, 722, 667, 944, 667, 667, 611, 333, 278, 333, 584, 556, 333, 556, 611, 556, 611, 556, 333, 611, 611, 278, 278, 556, 278, 889, 611, 611, 611, 611, 389, 556, 333, 611, 556, 778, 556, 556, 500, 389, 280, 389, 584, 0, 556, 0, 278, 556, 500, 1000, 556, 556, 333, 1000, 667, 333, 1000, 0, 611, 0, 0, 278, 278, 500, 500, 350, 556, 1000, 333, 1000, 556, 333, 944, 0, 500, 667, 0, 333, 556, 556, 556, 556, 280, 556, 333, 737, 370, 556, 584, 0, 737, 333, 400, 584, 333, 333, 333, 611, 556, 278, 333, 333, 365, 556, 834, 834, 834, 611, 722, 722, 722, 722, 722, 722, 1000, 722, 667, 667, 667, 667, 278, 278, 278, 278, 722, 722, 778, 778, 778, 778, 778, 584, 778, 722, 722, 722, 722, 667, 667, 611, 556, 556, 556, 556, 556, 556, 889, 556, 556, 556, 556, 556, 278, 278, 278, 278, 611, 611, 611, 611, 611, 611, 611, 584, 611, 611, 611, 611, 611, 556, 611, 556];\n  /**\n   * `Fixed` widths table.\n   * @private\n   */\n\n  PdfStandardFontMetricsFactory.fixedWidth = [600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600];\n  /**\n   * `Times` widths table.\n   * @private\n   */\n\n  PdfStandardFontMetricsFactory.timesRomanWidth = [250, 333, 408, 500, 500, 833, 778, 180, 333, 333, 500, 564, 250, 333, 250, 278, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 278, 278, 564, 564, 564, 444, 921, 722, 667, 667, 722, 611, 556, 722, 722, 333, 389, 722, 611, 889, 722, 722, 556, 722, 667, 556, 611, 722, 722, 944, 722, 722, 611, 333, 278, 333, 469, 500, 333, 444, 500, 444, 500, 444, 333, 500, 500, 278, 278, 500, 278, 778, 500, 500, 500, 500, 333, 389, 278, 500, 500, 722, 500, 500, 444, 480, 200, 480, 541, 0, 500, 0, 333, 500, 444, 1000, 500, 500, 333, 1000, 556, 333, 889, 0, 611, 0, 0, 333, 333, 444, 444, 350, 500, 1000, 333, 980, 389, 333, 722, 0, 444, 722, 0, 333, 500, 500, 500, 500, 200, 500, 333, 760, 276, 500, 564, 0, 760, 333, 400, 564, 300, 300, 333, 500, 453, 250, 333, 300, 310, 500, 750, 750, 750, 444, 722, 722, 722, 722, 722, 722, 889, 667, 611, 611, 611, 611, 333, 333, 333, 333, 722, 722, 722, 722, 722, 722, 722, 564, 722, 722, 722, 722, 722, 722, 556, 500, 444, 444, 444, 444, 444, 444, 667, 444, 444, 444, 444, 444, 278, 278, 278, 278, 500, 500, 500, 500, 500, 500, 500, 564, 500, 500, 500, 500, 500, 500, 500, 500];\n  /**\n   * `Times bold` widths table.\n   * @private\n   */\n\n  PdfStandardFontMetricsFactory.timesRomanBoldWidth = [250, 333, 555, 500, 500, 1000, 833, 278, 333, 333, 500, 570, 250, 333, 250, 278, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 333, 333, 570, 570, 570, 500, 930, 722, 667, 722, 722, 667, 611, 778, 778, 389, 500, 778, 667, 944, 722, 778, 611, 778, 722, 556, 667, 722, 722, 1000, 722, 722, 667, 333, 278, 333, 581, 500, 333, 500, 556, 444, 556, 444, 333, 500, 556, 278, 333, 556, 278, 833, 556, 500, 556, 556, 444, 389, 333, 556, 500, 722, 500, 500, 444, 394, 220, 394, 520, 0, 500, 0, 333, 500, 500, 1000, 500, 500, 333, 1000, 556, 333, 1000, 0, 667, 0, 0, 333, 333, 500, 500, 350, 500, 1000, 333, 1000, 389, 333, 722, 0, 444, 722, 0, 333, 500, 500, 500, 500, 220, 500, 333, 747, 300, 500, 570, 0, 747, 333, 400, 570, 300, 300, 333, 556, 540, 250, 333, 300, 330, 500, 750, 750, 750, 500, 722, 722, 722, 722, 722, 722, 1000, 722, 667, 667, 667, 667, 389, 389, 389, 389, 722, 722, 778, 778, 778, 778, 778, 570, 778, 722, 722, 722, 722, 722, 611, 556, 500, 500, 500, 500, 500, 500, 722, 444, 444, 444, 444, 444, 278, 278, 278, 278, 500, 556, 500, 500, 500, 500, 500, 570, 500, 556, 556, 556, 556, 500, 556, 500];\n  /**\n   * `Times italic` widths table.\n   * @private\n   */\n\n  PdfStandardFontMetricsFactory.timesRomanItalicWidth = [250, 333, 420, 500, 500, 833, 778, 214, 333, 333, 500, 675, 250, 333, 250, 278, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 333, 333, 675, 675, 675, 500, 920, 611, 611, 667, 722, 611, 611, 722, 722, 333, 444, 667, 556, 833, 667, 722, 611, 722, 611, 500, 556, 722, 611, 833, 611, 556, 556, 389, 278, 389, 422, 500, 333, 500, 500, 444, 500, 444, 278, 500, 500, 278, 278, 444, 278, 722, 500, 500, 500, 500, 389, 389, 278, 500, 444, 667, 444, 444, 389, 400, 275, 400, 541, 0, 500, 0, 333, 500, 556, 889, 500, 500, 333, 1000, 500, 333, 944, 0, 556, 0, 0, 333, 333, 556, 556, 350, 500, 889, 333, 980, 389, 333, 667, 0, 389, 556, 0, 389, 500, 500, 500, 500, 275, 500, 333, 760, 276, 500, 675, 0, 760, 333, 400, 675, 300, 300, 333, 500, 523, 250, 333, 300, 310, 500, 750, 750, 750, 500, 611, 611, 611, 611, 611, 611, 889, 667, 611, 611, 611, 611, 333, 333, 333, 333, 722, 667, 722, 722, 722, 722, 722, 675, 722, 722, 722, 722, 722, 556, 611, 500, 500, 500, 500, 500, 500, 500, 667, 444, 444, 444, 444, 444, 278, 278, 278, 278, 500, 500, 500, 500, 500, 500, 500, 675, 500, 500, 500, 500, 500, 444, 500, 444];\n  /**\n   * `Times bold italic` widths table.\n   * @private\n   */\n\n  PdfStandardFontMetricsFactory.timesRomanBoldItalicWidths = [250, 389, 555, 500, 500, 833, 778, 278, 333, 333, 500, 570, 250, 333, 250, 278, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 333, 333, 570, 570, 570, 500, 832, 667, 667, 667, 722, 667, 667, 722, 778, 389, 500, 667, 611, 889, 722, 722, 611, 722, 667, 556, 611, 722, 667, 889, 667, 611, 611, 333, 278, 333, 570, 500, 333, 500, 500, 444, 500, 444, 333, 500, 556, 278, 278, 500, 278, 778, 556, 500, 500, 500, 389, 389, 278, 556, 444, 667, 500, 444, 389, 348, 220, 348, 570, 0, 500, 0, 333, 500, 500, 1000, 500, 500, 333, 1000, 556, 333, 944, 0, 611, 0, 0, 333, 333, 500, 500, 350, 500, 1000, 333, 1000, 389, 333, 722, 0, 389, 611, 0, 389, 500, 500, 500, 500, 220, 500, 333, 747, 266, 500, 606, 0, 747, 333, 400, 570, 300, 300, 333, 576, 500, 250, 333, 300, 300, 500, 750, 750, 750, 500, 667, 667, 667, 667, 667, 667, 944, 667, 667, 667, 667, 667, 389, 389, 389, 389, 722, 722, 722, 722, 722, 722, 722, 570, 722, 722, 722, 722, 722, 611, 611, 500, 500, 500, 500, 500, 500, 500, 722, 444, 444, 444, 444, 444, 278, 278, 278, 278, 500, 556, 500, 500, 500, 500, 500, 570, 500, 556, 556, 556, 556, 444, 500, 444];\n  /**\n   * `Symbol` widths table.\n   * @private\n   */\n\n  PdfStandardFontMetricsFactory.symbolWidth = [250, 333, 713, 500, 549, 833, 778, 439, 333, 333, 500, 549, 250, 549, 250, 278, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 278, 278, 549, 549, 549, 444, 549, 722, 667, 722, 612, 611, 763, 603, 722, 333, 631, 722, 686, 889, 722, 722, 768, 741, 556, 592, 611, 690, 439, 768, 645, 795, 611, 333, 863, 333, 658, 500, 500, 631, 549, 549, 494, 439, 521, 411, 603, 329, 603, 549, 549, 576, 521, 549, 549, 521, 549, 603, 439, 576, 713, 686, 493, 686, 494, 480, 200, 480, 549, 750, 620, 247, 549, 167, 713, 500, 753, 753, 753, 753, 1042, 987, 603, 987, 603, 400, 549, 411, 549, 549, 713, 494, 460, 549, 549, 549, 549, 1000, 603, 1000, 658, 823, 686, 795, 987, 768, 768, 823, 768, 768, 713, 713, 713, 713, 713, 713, 713, 768, 713, 790, 790, 890, 823, 549, 250, 713, 603, 603, 1042, 987, 603, 987, 603, 494, 329, 790, 790, 786, 713, 384, 384, 384, 384, 384, 384, 494, 494, 494, 494, 329, 274, 686, 686, 686, 384, 384, 384, 384, 384, 384, 494, 494, 494, -1];\n  /**\n   * `Zip dingbats` widths table.\n   * @private\n   */\n\n  PdfStandardFontMetricsFactory.zapfDingbatsWidth = [278, 974, 961, 974, 980, 719, 789, 790, 791, 690, 960, 939, 549, 855, 911, 933, 911, 945, 974, 755, 846, 762, 761, 571, 677, 763, 760, 759, 754, 494, 552, 537, 577, 692, 786, 788, 788, 790, 793, 794, 816, 823, 789, 841, 823, 833, 816, 831, 923, 744, 723, 749, 790, 792, 695, 776, 768, 792, 759, 707, 708, 682, 701, 826, 815, 789, 789, 707, 687, 696, 689, 786, 787, 713, 791, 785, 791, 873, 761, 762, 762, 759, 759, 892, 892, 788, 784, 438, 138, 277, 415, 392, 392, 668, 668, 390, 390, 317, 317, 276, 276, 509, 509, 410, 410, 234, 234, 334, 334, 732, 544, 544, 910, 667, 760, 760, 776, 595, 694, 626, 788, 788, 788, 788, 788, 788, 788, 788, 788, 788, 788, 788, 788, 788, 788, 788, 788, 788, 788, 788, 788, 788, 788, 788, 788, 788, 788, 788, 788, 788, 788, 788, 788, 788, 788, 788, 788, 788, 788, 788, 894, 838, 1016, 458, 748, 924, 748, 918, 927, 928, 928, 834, 873, 828, 924, 924, 917, 930, 931, 463, 883, 836, 836, 867, 867, 696, 696, 874, 874, 760, 946, 771, 865, 771, 888, 967, 888, 831, 873, 927, 970, 918];\n  /**\n   * Represents one of the 14 standard fonts.\n   * It's used to create a standard PDF font to draw the text in to the PDF.\n   * ```typescript\n   * // create a new PDF document\n   * let document : PdfDocument = new PdfDocument();\n   * // add a new page to the document\n   * let page1 : PdfPage = document.pages.add();\n   * //\n   * // create new standard font\n   * let font : PdfStandardFont = new PdfStandardFont(PdfFontFamily.Helvetica, 20);\n   * //\n   * // create black brush\n   * let blackBrush : PdfSolidBrush = new PdfSolidBrush(new PdfColor(0, 0, 0));\n   * // draw the text\n   * page1.graphics.drawString('Hello World', font, blackBrush, new PointF(0, 0));\n   * // save the document\n   * document.save('output.pdf');\n   * // destroy the document\n   * document.destroy();\n   * ```\n   */\n\n  return PdfStandardFontMetricsFactory;\n})();\nlet PdfStandardFont = /*#__PURE__*/(() => {\n  class PdfStandardFont extends PdfFont {\n    constructor(fontFamilyPrototype, size, style) {\n      super(size, typeof style === 'undefined' ? fontFamilyPrototype instanceof PdfStandardFont ? fontFamilyPrototype.style : PdfFontStyle.Regular : style);\n      /**\n       * Gets `ascent` of the font.\n       * @private\n       */\n\n      this.dictionaryProperties = new DictionaryProperties();\n      /**\n       * Gets `encodings` for internal class use.\n       * @hidden\n       * @private\n       */\n\n      this.encodings = ['Unknown', 'StandardEncoding', 'MacRomanEncoding', 'MacExpertEncoding', 'WinAnsiEncoding', 'PDFDocEncoding', 'IdentityH'];\n\n      if (typeof fontFamilyPrototype === 'undefined') {\n        this.pdfFontFamily = PdfFontFamily.Helvetica;\n      } else if (fontFamilyPrototype instanceof PdfStandardFont) {\n        this.pdfFontFamily = fontFamilyPrototype.fontFamily;\n      } else {\n        this.pdfFontFamily = fontFamilyPrototype;\n      }\n\n      this.checkStyle();\n      this.initializeInternals();\n    }\n    /* tslint:enable */\n    //Properties\n\n    /**\n     * Gets the `FontFamily`.\n     * @private\n     */\n\n\n    get fontFamily() {\n      return this.pdfFontFamily;\n    } //methods\n\n    /**\n     * Checks font `style` of the font.\n     * @private\n     */\n\n\n    checkStyle() {\n      if (this.fontFamily === PdfFontFamily.Symbol || this.fontFamily === PdfFontFamily.ZapfDingbats) {\n        let style = this.style;\n        style &= ~(PdfFontStyle.Bold | PdfFontStyle.Italic);\n        this.setStyle(style);\n      }\n    }\n    /**\n     * Returns `width` of the line.\n     * @public\n     */\n\n\n    getLineWidth(line, format) {\n      if (line == null) {\n        throw new Error('ArgumentNullException:line');\n      }\n\n      let width = 0;\n      let name = this.name;\n      line = PdfStandardFont.convert(line);\n\n      for (let i = 0, len = line.length; i < len; i++) {\n        let ch = line[i];\n        let charWidth = this.getCharWidthInternal(ch, format);\n        width += charWidth;\n      }\n\n      let size = this.metrics.getSize(format);\n      width *= PdfFont.charSizeMultiplier * size;\n      width = this.applyFormatSettings(line, format, width);\n      return width;\n    }\n    /**\n     * Checks whether fonts are `equals`.\n     * @private\n     */\n\n\n    equalsToFont(font) {\n      let equal = false;\n      let stFont = font;\n\n      if (stFont != null) {\n        let fontFamilyEqual = this.fontFamily === stFont.fontFamily;\n        let lineReducer = ~(PdfFontStyle.Underline | PdfFontStyle.Strikeout);\n        let styleEqual = (this.style & lineReducer) === (stFont.style & lineReducer);\n        equal = fontFamilyEqual && styleEqual;\n      }\n\n      return equal;\n    }\n    /**\n     * `Initializes` font internals..\n     * @private\n     */\n\n\n    initializeInternals() {\n      let equalFont = null; // if (PdfDocument.EnableCache) {\n\n      equalFont = PdfDocument.cache.search(this); // }\n\n      let internals = null; // if (equalFont == null) {\n      // Create font metrics.\n\n      let metrics = PdfStandardFontMetricsFactory.getMetrics(this.pdfFontFamily, this.style, this.size);\n      this.metrics = metrics;\n      internals = this.createInternals();\n      this.setInternals(internals);\n    }\n    /**\n     * `Creates` font`s dictionary.\n     * @private\n     */\n\n\n    createInternals() {\n      let dictionary = new PdfDictionary();\n      dictionary.items.setValue(this.dictionaryProperties.type, new PdfName(this.dictionaryProperties.font));\n      dictionary.items.setValue(this.dictionaryProperties.subtype, new PdfName(this.dictionaryProperties.type1));\n      dictionary.items.setValue(this.dictionaryProperties.baseFont, new PdfName(this.metrics.postScriptName));\n\n      if (this.fontFamily !== PdfFontFamily.Symbol && this.fontFamily !== PdfFontFamily.ZapfDingbats) {\n        let encoding = this.encodings[FontEncoding.WinAnsiEncoding];\n        dictionary.items.setValue(this.dictionaryProperties.encoding, new PdfName(encoding));\n      }\n\n      return dictionary;\n    }\n    /**\n     * Returns `width` of the char. This methods doesn`t takes into consideration font`s size.\n     * @private\n     */\n\n\n    getCharWidthInternal(charCode, format) {\n      let width = 0;\n      let code = 0;\n      code = charCode.charCodeAt(0);\n\n      if (this.name === '0' || this.name === '1' || this.name === '2' || this.name === '3' || this.name === '4') {\n        code = code - PdfStandardFont.charOffset;\n      }\n\n      code = code >= 0 && code !== 128 ? code : 0;\n      let metrics = this.metrics;\n      let widthTable = metrics.widthTable;\n      width = widthTable.items(code);\n      return width;\n    }\n    /**\n     * `Converts` the specified text.\n     * @private\n     */\n\n\n    static convert(text) {\n      return text;\n    }\n\n  }\n\n  //Constants\n\n  /**\n   * First character `position`.\n   * @private\n   */\n  PdfStandardFont.charOffset = 32;\n  /**\n   * `PdfAnnotation` class represents the base class for annotation objects.\n   * @private\n   */\n\n  return PdfStandardFont;\n})();\n\nclass PdfAnnotation {\n  constructor(arg1) {\n    // Fields\n\n    /**\n     * Specifies the Internal variable to store fields of `PdfDictionaryProperties`.\n     * @private\n     */\n    this.dictionaryProperties = new DictionaryProperties();\n    /**\n     * `Color` of the annotation\n     * @private\n     */\n\n    this.pdfColor = new PdfColor(255, 255, 255);\n    /**\n     * `Bounds` of the annotation.\n     * @private\n     */\n\n    this.rectangle = new RectangleF(0, 0, 0, 0);\n    /**\n     * Parent `page` of the annotation.\n     * @private\n     */\n\n    this.pdfPage = null;\n    /**\n     * `Brush of the text` of the annotation.\n     * @default new PdfSolidBrush(new PdfColor(0, 0, 0))\n     * @private\n     */\n\n    this.textBrush = new PdfSolidBrush(new PdfColor(0, 0, 0));\n    /**\n     * `Font of the text` of the annotation.\n     * @default new PdfStandardFont(PdfFontFamily.TimesRoman, 10)\n     * @private\n     */\n\n    this.textFont = new PdfStandardFont(PdfFontFamily.TimesRoman, 10);\n    /**\n     * `StringFormat of the text` of the annotation.\n     * @default new PdfStringFormat(PdfTextAlignment.Left)\n     * @private\n     */\n\n    this.format = new PdfStringFormat(PdfTextAlignment.Left);\n    /**\n     * `Text` of the annotation.\n     * @private\n     */\n\n    this.content = '';\n    /**\n     * Internal variable to store `dictionary`.\n     * @private\n     */\n\n    this.pdfDictionary = new PdfDictionary();\n    /**\n     * To specifying the `Inner color` with which to fill the annotation\n     * @private\n     */\n\n    this.internalColor = new PdfColor();\n    /**\n     * `opacity or darkness` of the annotation.\n     * @private\n     * @default 1.0\n     */\n\n    this.darkness = 1.0;\n\n    if (typeof arg1 === 'undefined') {\n      this.initialize();\n    } else {\n      this.initialize();\n      this.bounds = arg1;\n    }\n  } // Properties\n\n  /**\n   * `Color` of the annotation\n   * @private\n   */\n\n\n  get color() {\n    return this.pdfColor;\n  }\n\n  set color(value) {\n    this.pdfColor = value;\n  }\n  /**\n   * To specifying the `Inner color` with which to fill the annotation\n   * @private\n   */\n\n\n  get innerColor() {\n    return this.internalColor;\n  }\n\n  set innerColor(value) {\n    this.internalColor = value;\n  }\n  /**\n   * `bounds` of the annotation.\n   * @private\n   */\n\n\n  get bounds() {\n    return this.rectangle;\n  }\n\n  set bounds(value) {\n    this.rectangle = value;\n  }\n  /**\n   * Parent `page` of the annotation.\n   * @private\n   */\n\n\n  get page() {\n    return this.pdfPage;\n  }\n  /**\n   * To specifying the `Font of the text` in the annotation.\n   * @private\n   */\n\n\n  get font() {\n    return this.textFont;\n  }\n\n  set font(value) {\n    this.textFont = value;\n  }\n  /**\n   * To specifying the `StringFormat of the text` in the annotation.\n   * @private\n   */\n\n\n  get stringFormat() {\n    return this.format;\n  }\n\n  set stringFormat(value) {\n    this.format = value;\n  }\n  /**\n   * To specifying the `Brush of the text` in the annotation.\n   * @private\n   */\n\n\n  get brush() {\n    return this.textBrush;\n  }\n\n  set brush(value) {\n    this.textBrush = value;\n  }\n  /**\n   * `Text` of the annotation.\n   * @private\n   */\n\n\n  get text() {\n    return this.content;\n  }\n\n  set text(value) {\n    this.content = value;\n    this.dictionary.items.setValue(this.dictionaryProperties.contents, new PdfString(this.content));\n  }\n  /**\n   * Internal variable to store `dictionary`.\n   * @hidden\n   */\n\n\n  get dictionary() {\n    return this.pdfDictionary;\n  }\n\n  set dictionary(value) {\n    this.pdfDictionary = value;\n  } // Implementation\n\n  /**\n   * `Initialize` the annotation event handler and specifies the type of the annotation.\n   * @private\n   */\n\n\n  initialize() {\n    this.pdfDictionary.annotationBeginSave = new SaveAnnotationEventHandler(this);\n    this.pdfDictionary.items.setValue(this.dictionaryProperties.type, new PdfName(this.dictionaryProperties.annot));\n  }\n  /**\n   * Sets related `page` of the annotation.\n   * @private\n   */\n\n\n  setPage(page) {\n    this.pdfPage = page;\n    this.pdfDictionary.items.setValue(this.dictionaryProperties.p, new PdfReferenceHolder(this.pdfPage));\n  }\n  /**\n   * Handles the `BeginSave` event of the Dictionary.\n   * @private\n   */\n\n\n  beginSave() {\n    this.save();\n  }\n  /**\n   * `Saves` an annotation.\n   * @private\n   */\n\n  /* tslint:disable */\n\n\n  save() {\n    let nativeRectangle = new RectangleF(this.rectangle.x, this.rectangle.y, this.rectangle.width, this.rectangle.height);\n    let section = this.pdfPage.section;\n    let initialHeight = nativeRectangle.height;\n    let tempLoacation = section.pointToNativePdf(this.page, new PointF(nativeRectangle.x, nativeRectangle.y));\n    nativeRectangle.x = tempLoacation.x;\n    nativeRectangle.width = tempLoacation.x + nativeRectangle.width;\n    nativeRectangle.y = tempLoacation.y - this.page.document.pageSettings.margins.top;\n    nativeRectangle.height = nativeRectangle.y - initialHeight;\n    this.pdfDictionary.items.setValue(this.dictionaryProperties.rect, PdfArray.fromRectangle(nativeRectangle));\n    this.dictionary.items.setValue(this.dictionaryProperties.ca, new PdfNumber(this.darkness));\n  }\n  /* tslint:enable */\n  // IPdfWrapper Members\n\n  /**\n   * Gets the `element`.\n   * @private\n   */\n\n\n  get element() {\n    return this.pdfDictionary;\n  }\n\n}\n/**\n * `PdfLinkAnnotation` class represents the ink annotation class.\n * @private\n */\n\n\nclass PdfLinkAnnotation extends PdfAnnotation {\n  constructor(rectangle) {\n    super(rectangle);\n  } // Implementation\n\n  /**\n   * `Initializes` annotation object.\n   * @private\n   */\n\n\n  initialize() {\n    super.initialize();\n    this.dictionary.items.setValue(this.dictionaryProperties.subtype, new PdfName(this.dictionaryProperties.link));\n  }\n\n}\n/**\n * Represents base class for `link annotations` with associated action.\n * @private\n */\n\n\nclass PdfActionLinkAnnotation extends PdfLinkAnnotation {\n  // Constructors\n\n  /**\n   * Specifies the constructor for `ActionLinkAnnotation`.\n   * @private\n   */\n  constructor(rectangle) {\n    super(rectangle); // Fields\n\n    /**\n     * Internal variable to store annotation's `action`.\n     * @default null\n     * @private\n     */\n\n    this.pdfAction = null;\n  } //Public method\n\n  /**\n   * get and set the `action`.\n   * @hidden\n   */\n\n\n  getSetAction(value) {\n    if (typeof value === 'undefined') {\n      return this.pdfAction;\n    } else {\n      this.pdfAction = value;\n    }\n  }\n\n}\n/**\n * `PdfDocumentLinkAnnotation` class represents an annotation object with holds link on another location within a document.\n * ```typescript\n * // create a new PDF document\n * let document : PdfDocument = new PdfDocument();\n * // create new pages\n * let page1 : PdfPage = document.pages.add();\n * let page2 : PdfPage = document.pages.add();\n * // create a new rectangle\n * let bounds : RectangleF = new RectangleF({x : 10, y : 200}, {width : 300, height : 25});\n * //\n * // create a new document link annotation\n * let documentLinkAnnotation : PdfDocumentLinkAnnotation = new PdfDocumentLinkAnnotation(bounds);\n * // set the annotation text\n * documentLinkAnnotation.text = 'Document link annotation';\n * // set the destination\n * documentLinkAnnotation.destination = new PdfDestination(page2);\n * // set the documentlink annotation location\n * documentLinkAnnotation.destination.location = new PointF(10, 0);\n * // add this annotation to a new page\n * page1.annotations.add(documentLinkAnnotation);\n * //\n * // save the document to disk\n * document.save('output.pdf');\n * // destroy the document\n * document.destroy();\n * ```\n */\n\n\nclass PdfDocumentLinkAnnotation extends PdfLinkAnnotation {\n  constructor(rectangle, destination) {\n    super(rectangle); // Fields\n\n    /**\n     * `Destination` of the annotation.\n     * @default null\n     * @private\n     */\n\n    this.pdfDestination = null;\n\n    if (typeof destination !== 'undefined') {\n      this.destination = destination;\n    }\n  } // Properties\n\n  /**\n   * Gets or sets the `destination` of the annotation.\n   * ```typescript\n   * // create a new PDF document\n   * let document : PdfDocument = new PdfDocument();\n   * // create new pages\n   * let page1 : PdfPage = document.pages.add();\n   * let page2 : PdfPage = document.pages.add();\n   * // create a new rectangle\n   * let bounds : RectangleF = new RectangleF({x : 10, y : 200}, {width : 300, height : 25});\n   * //\n   * // create a new document link annotation\n   * let documentLinkAnnotation : PdfDocumentLinkAnnotation = new PdfDocumentLinkAnnotation(bounds);\n   * // set the annotation text\n   * documentLinkAnnotation.text = 'Document link annotation';\n   * // set the destination\n   * documentLinkAnnotation.destination = new PdfDestination(page2);\n   * // set the documentlink annotation location\n   * documentLinkAnnotation.destination.location = new PointF(10, 0);\n   * // add this annotation to a new page\n   * page1.annotations.add(documentLinkAnnotation);\n   * //\n   * // save the document to disk\n   * document.save('output.pdf');\n   * // destroy the document\n   * document.destroy();\n   * ```\n   * @default null\n   */\n\n\n  get destination() {\n    return this.pdfDestination;\n  }\n\n  set destination(value) {\n    // if (this.pdfDestination !== value) {\n    this.pdfDestination = value; // }\n  } // Implementation\n\n  /**\n   * `Saves` annotation object.\n   * @private\n   */\n\n\n  save() {\n    super.save();\n\n    if (this.pdfDestination != null) {\n      this.dictionary.items.setValue(this.dictionaryProperties.dest, this.pdfDestination.element);\n    }\n  }\n  /**\n   * `Clone` the document link annotation.\n   * @private\n   */\n\n\n  clone() {\n    let annot = new PdfDocumentLinkAnnotation(this.bounds, this.destination);\n    annot.color = this.color;\n    annot.brush = this.brush;\n    annot.destination = this.destination;\n    annot.font = this.font;\n    return annot;\n  }\n\n}\n/**\n * ElementLayouter.ts class for EJ2-PDF\n */\n\n/**\n * Base class for `elements lay outing`.\n * @private\n */\n\n\nclass ElementLayouter {\n  // Constructor\n\n  /**\n   * Initializes a new instance of the `ElementLayouter` class.\n   * @private\n   */\n  constructor(element) {\n    this.layoutElement = element;\n  } // Properties\n\n  /**\n   * Gets the `element`.\n   * @private\n   */\n\n\n  get elements() {\n    return this.layoutElement;\n  }\n  /**\n   * Gets the `element`.\n   * @private\n   */\n\n\n  getElement() {\n    return this.layoutElement;\n  } // Implementation\n\n  /**\n   * `Layouts` the element.\n   * @private\n   */\n\n\n  layout(param) {\n    return this.layoutInternal(param);\n  }\n\n  Layouter(param) {\n    return this.layoutInternal(param);\n  }\n  /**\n   * Returns the `next page`.\n   * @private\n   */\n\n\n  getNextPage(currentPage) {\n    let section = currentPage.section;\n    let nextPage = section.add();\n    return nextPage;\n  }\n\n  getPaginateBounds(param) {\n    if (param == null) {\n      throw new Error('ArgumentNullException : param');\n    }\n\n    let result = param.format.usePaginateBounds ? param.format.paginateBounds : new RectangleF(param.bounds.x, 0, param.bounds.width, param.bounds.height);\n    return result;\n  }\n\n}\n\nclass PdfLayoutFormat {\n  // Properties\n\n  /**\n   * Gets or sets `layout` type of the element.\n   * @private\n   */\n  get layout() {\n    // if (typeof this.layoutType === 'undefined' || this.layoutType == null) {\n    //      this.layoutType = PdfLayoutType.Paginate;\n    // }\n    return this.layoutType;\n  }\n\n  set layout(value) {\n    this.layoutType = value;\n  }\n  /**\n   * Gets or sets `break` type of the element.\n   * @private\n   */\n\n\n  get break() {\n    // if (typeof this.breakType === 'undefined' || this.boundsSet == null) {\n    //      this.breakType = PdfLayoutBreakType.FitPage;\n    // }\n    return this.breakType;\n  }\n\n  set break(value) {\n    this.breakType = value;\n  }\n  /**\n   * Gets or sets the `bounds` on the next page.\n   * @private\n   */\n\n\n  get paginateBounds() {\n    if (typeof this.layoutPaginateBounds === 'undefined' && this.layoutPaginateBounds == null) {\n      this.layoutPaginateBounds = new RectangleF(0, 0, 0, 0);\n    }\n\n    return this.layoutPaginateBounds;\n  }\n\n  set paginateBounds(value) {\n    this.layoutPaginateBounds = value;\n    this.boundsSet = true;\n  }\n  /**\n   * Gets a value indicating whether [`use paginate bounds`].\n   * @private\n   */\n\n\n  get usePaginateBounds() {\n    // if (typeof this.boundsSet === 'undefined' || this.boundsSet == null) {\n    //      this.boundsSet = false;\n    // }\n    return this.boundsSet;\n  }\n\n  constructor(baseFormat) {\n    if (typeof baseFormat === 'undefined') {//\n    } else {\n      this.break = baseFormat.break;\n      this.layout = baseFormat.layout;\n      this.paginateBounds = baseFormat.paginateBounds;\n      this.boundsSet = baseFormat.usePaginateBounds;\n    }\n  }\n\n}\n\nclass PdfLayoutParams {\n  // Properties\n\n  /**\n   * Gets or sets the layout `page` for the element.\n   * @private\n   */\n  get page() {\n    return this.pdfPage;\n  }\n\n  set page(value) {\n    this.pdfPage = value;\n  }\n  /**\n   * Gets or sets layout `bounds` for the element.\n   * @private\n   */\n\n\n  get bounds() {\n    return new RectangleF(this.layoutBounds.x, this.layoutBounds.y, this.layoutBounds.width, this.layoutBounds.height);\n  }\n\n  set bounds(value) {\n    this.layoutBounds = value;\n  }\n  /**\n   * Gets or sets `layout settings` for the element.\n   * @private\n   */\n\n\n  get format() {\n    return this.layoutFormat;\n  }\n\n  set format(value) {\n    this.layoutFormat = value;\n  }\n\n}\n\nclass PdfLayoutResult {\n  // Properties\n\n  /**\n   * Gets the last `page` where the element was drawn.\n   * @private\n   */\n  get page() {\n    return this.pdfPage;\n  }\n  /**\n   * Gets the `bounds` of the element on the last page where it was drawn.\n   * @private\n   */\n\n\n  get bounds() {\n    return this.layoutBounds;\n  } // Constructors\n\n  /**\n   * Initializes the new instance of `PdfLayoutResult` class.\n   * @private\n   */\n\n\n  constructor(page, bounds) {\n    this.pdfPage = page;\n    this.layoutBounds = bounds;\n  }\n\n}\n/**\n * PdfBorders.ts class for EJ2-PDF\n */\n\n/**\n * `PdfBorders` class used represents the cell border of the PDF grid.\n */\n\n\nclass PdfBorders {\n  // Properties\n\n  /**\n   * Gets or sets the `Left`.\n   * @private\n   */\n  get left() {\n    return this.leftPen;\n  }\n\n  set left(value) {\n    this.leftPen = value;\n  }\n  /**\n   * Gets or sets the `Right`.\n   * @private\n   */\n\n\n  get right() {\n    return this.rightPen;\n  }\n\n  set right(value) {\n    this.rightPen = value;\n  }\n  /**\n   * Gets or sets the `Top`.\n   * @private\n   */\n\n\n  get top() {\n    return this.topPen;\n  }\n\n  set top(value) {\n    this.topPen = value;\n  }\n  /**\n   * Gets or sets the `Bottom`.\n   * @private\n   */\n\n\n  get bottom() {\n    return this.bottomPen;\n  }\n\n  set bottom(value) {\n    this.bottomPen = value;\n  }\n  /**\n   * sets the `All`.\n   * @private\n   */\n\n\n  set all(value) {\n    this.leftPen = this.rightPen = this.topPen = this.bottomPen = value;\n  }\n  /**\n   * Gets a value indicating whether this instance `is all`.\n   * @private\n   */\n\n\n  get isAll() {\n    return this.leftPen === this.rightPen && this.leftPen === this.topPen && this.leftPen === this.bottomPen;\n  }\n  /**\n   * Gets the `default`.\n   * @private\n   */\n\n\n  static get default() {\n    return new PdfBorders();\n  } // Constructor\n\n  /**\n   * Create a new instance for `PdfBorders` class.\n   * @private\n   */\n\n\n  constructor() {\n    let defaultBorderPenLeft = new PdfPen(new PdfColor(0, 0, 0));\n    defaultBorderPenLeft.dashStyle = PdfDashStyle.Solid;\n    let defaultBorderPenRight = new PdfPen(new PdfColor(0, 0, 0));\n    defaultBorderPenRight.dashStyle = PdfDashStyle.Solid;\n    let defaultBorderPenTop = new PdfPen(new PdfColor(0, 0, 0));\n    defaultBorderPenTop.dashStyle = PdfDashStyle.Solid;\n    let defaultBorderPenBottom = new PdfPen(new PdfColor(0, 0, 0));\n    defaultBorderPenBottom.dashStyle = PdfDashStyle.Solid;\n    this.leftPen = defaultBorderPenLeft;\n    this.rightPen = defaultBorderPenRight;\n    this.topPen = defaultBorderPenTop;\n    this.bottomPen = defaultBorderPenBottom;\n  }\n\n}\n\nclass PdfPaddings {\n  constructor(left, right, top, bottom) {\n    /**\n     * The 'left' border padding set.\n     * @private\n     */\n    this.hasLeftPad = false;\n    /**\n     * The 'right' border padding set.\n     * @private\n     */\n\n    this.hasRightPad = false;\n    /**\n     * The 'top' border padding set.\n     * @private\n     */\n\n    this.hasTopPad = false;\n    /**\n     * The 'bottom' border padding set.\n     * @private\n     */\n\n    this.hasBottomPad = false;\n\n    if (typeof left === 'undefined') {\n      //5.76 and 0 are taken from ms-word default table margins.\n      this.leftPad = this.rightPad = 5.76; //0.5 is set for top and bottom by default.\n\n      this.bottomPad = this.topPad = 0.5;\n    } else {\n      this.leftPad = left;\n      this.rightPad = right;\n      this.topPad = top;\n      this.bottomPad = bottom;\n      this.hasLeftPad = true;\n      this.hasRightPad = true;\n      this.hasTopPad = true;\n      this.hasBottomPad = true;\n    }\n  } // Properties\n\n  /**\n   * Gets or sets the `left` value of the edge\n   * @private\n   */\n\n\n  get left() {\n    return this.leftPad;\n  }\n\n  set left(value) {\n    this.leftPad = value;\n    this.hasLeftPad = true;\n  }\n  /**\n   * Gets or sets the `right` value of the edge.\n   * @private\n   */\n\n\n  get right() {\n    return this.rightPad;\n  }\n\n  set right(value) {\n    this.rightPad = value;\n    this.hasRightPad = true;\n  }\n  /**\n   * Gets or sets the `top` value of the edge\n   * @private\n   */\n\n\n  get top() {\n    return this.topPad;\n  }\n\n  set top(value) {\n    this.topPad = value;\n    this.hasTopPad = true;\n  }\n  /**\n   * Gets or sets the `bottom` value of the edge.\n   * @private\n   */\n\n\n  get bottom() {\n    return this.bottomPad;\n  }\n\n  set bottom(value) {\n    this.bottomPad = value;\n    this.hasBottomPad = true;\n  }\n  /**\n   * Sets value to all sides `left,right,top and bottom`.s\n   * @private\n   */\n\n\n  set all(value) {\n    this.leftPad = this.rightPad = this.topPad = this.bottomPad = value;\n    this.hasLeftPad = true;\n    this.hasRightPad = true;\n    this.hasTopPad = true;\n    this.hasBottomPad = true;\n  }\n\n}\n/**\n * `PdfLayoutElement` class represents the base class for all elements that can be layout on the pages.\n * @private\n */\n\n\nclass PdfLayoutElement {\n  // Property\n\n  /**\n   * Gets a value indicating whether the `start page layout event` should be raised.\n   * @private\n   */\n  get raiseBeginPageLayout() {\n    return typeof this.beginPageLayout !== 'undefined';\n  }\n  /**\n   * Gets a value indicating whether the `ending page layout event` should be raised.\n   * @private\n   */\n\n\n  get raiseEndPageLayout() {\n    return typeof this.endPageLayout !== 'undefined';\n  } //Event Handlers\n\n\n  onBeginPageLayout(args) {\n    if (this.beginPageLayout) {\n      this.beginPageLayout(this, args);\n    }\n  }\n\n  onEndPageLayout(args) {\n    if (this.endPageLayout) {\n      this.endPageLayout(this, args);\n    }\n  }\n\n  drawHelper(arg2, arg3, arg4, arg5) {\n    if (arg3 instanceof PointF && typeof arg3.width === 'undefined' && typeof arg4 === 'undefined') {\n      return this.drawHelper(arg2, arg3.x, arg3.y);\n    } else if (typeof arg3 === 'number' && typeof arg4 === 'number' && typeof arg5 === 'undefined') {\n      return this.drawHelper(arg2, arg3, arg4, null);\n    } else if (arg3 instanceof RectangleF && typeof arg3.width !== 'undefined' && typeof arg4 === 'undefined') {\n      return this.drawHelper(arg2, arg3, null);\n    } else if (arg3 instanceof PointF && typeof arg3.width === 'undefined' && arg4 instanceof PdfLayoutFormat) {\n      return this.drawHelper(arg2, arg3.x, arg3.y, arg4);\n    } else if (typeof arg3 === 'number' && typeof arg4 === 'number' && (arg5 instanceof PdfLayoutFormat || arg5 == null)) {\n      let width = arg2.graphics.clientSize.width - arg3;\n      let layoutRectangle = new RectangleF(arg3, arg4, width, 0);\n      return this.drawHelper(arg2, layoutRectangle, arg5);\n    } else if (arg3 instanceof RectangleF && typeof arg3.width !== 'undefined' && typeof arg4 === 'boolean') {\n      this.bEmbedFonts = arg4;\n      return this.drawHelper(arg2, arg3, null);\n    } else {\n      let param = new PdfLayoutParams();\n      let temparg3 = arg3;\n      let temparg4 = arg4;\n      param.page = arg2;\n      param.bounds = temparg3;\n\n      if (param != null) {\n        let x = param.bounds.x;\n        let y = param.bounds.y;\n\n        if (param.bounds.x === 0) {\n          x = PdfBorders.default.right.width / 2;\n        }\n\n        if (param.bounds.y === 0) {\n          y = PdfBorders.default.top.width / 2;\n        }\n\n        let newBound = new RectangleF(x, y, param.bounds.width, param.bounds.height);\n        param.bounds = newBound;\n      }\n\n      param.format = temparg4 != null ? temparg4 : new PdfLayoutFormat();\n      let result = this.layout(param);\n      return result;\n    }\n  }\n\n}\n/**\n * TextLayouter.ts class for EJ2-PDF\n */\n\n/**\n * Class that `layouts the text`.\n * @private\n */\n\n\nclass TextLayouter extends ElementLayouter {\n  /**\n   * Gets the layout `element`.\n   * @private\n   */\n  get element() {\n    return super.getElement();\n  } // Constructors\n\n  /**\n   * Initializes a new instance of the `TextLayouter` class.\n   * @private\n   */\n\n\n  constructor(element) {\n    super(element);\n  } // Implementation\n\n  /**\n   * `Layouts` the element.\n   * @private\n   */\n\n\n  layoutInternal(param) {\n    /* tslint:disable */\n    this.format = this.element.stringFormat !== null && typeof this.element.stringFormat !== 'undefined' ? this.element.stringFormat : null;\n    let currentPage = param.page;\n    let currentBounds = param.bounds;\n    let text = this.element.value;\n    let result = null;\n    let pageResult = new TextPageLayoutResult();\n    pageResult.page = currentPage;\n    pageResult.remainder = text;\n\n    for (;;) {\n      pageResult = this.layoutOnPage(text, currentPage, currentBounds, param);\n      result = this.getLayoutResult(pageResult);\n      break;\n    }\n    /* tslint:enable */\n\n\n    return result;\n  }\n  /**\n   * Raises `PageLayout` event if needed.\n   * @private\n   */\n\n\n  getLayoutResult(pageResult) {\n    let result = new PdfTextLayoutResult(pageResult.page, pageResult.bounds, pageResult.remainder, pageResult.lastLineBounds);\n    return result;\n  }\n  /* tslint:disable */\n\n  /**\n   * `Layouts` the text on the page.\n   * @private\n   */\n\n\n  layoutOnPage(text, currentPage, currentBounds, param) {\n    let result = new TextPageLayoutResult();\n    result.remainder = text;\n    result.page = currentPage;\n    currentBounds = this.checkCorrectBounds(currentPage, currentBounds);\n    let layouter = new PdfStringLayouter();\n    let stringResult = layouter.layout(text, this.element.font, this.format, currentBounds, currentPage.getClientSize().height, false, new SizeF(0, 0));\n    let textFinished = stringResult.remainder == null;\n    let doesntFit = param.format.break === PdfLayoutBreakType.FitElement;\n    let canDraw = !(doesntFit || stringResult.empty); // Draw the text.\n\n    let graphics = currentPage.graphics;\n    let brush = this.element.getBrush();\n\n    if (this.element instanceof PdfTextWebLink) {\n      brush.color = new PdfColor(0, 0, 255);\n    }\n\n    graphics.drawStringLayoutResult(stringResult, this.element.font, this.element.pen, brush, currentBounds, this.format);\n    let lineInfo = stringResult.lines[stringResult.lineCount - 1];\n    result.lastLineBounds = graphics.getLineBounds(stringResult.lineCount - 1, stringResult, this.element.font, currentBounds, this.format);\n    result.bounds = this.getTextPageBounds(currentPage, currentBounds, stringResult);\n    result.remainder = stringResult.remainder;\n    result.end = textFinished;\n    return result;\n  }\n  /* tslint:enable */\n\n  /**\n   * `Corrects current bounds` on the page.\n   * @private\n   */\n\n\n  checkCorrectBounds(currentPage, currentBounds) {\n    let pageSize = currentPage.graphics.clientSize;\n    currentBounds.height = currentBounds.height > 0 ? currentBounds.height : pageSize.height - currentBounds.y;\n    return currentBounds;\n  }\n  /**\n   * Returns a `rectangle` where the text was printed on the page.\n   * @private\n   */\n\n  /* tslint:disable */\n\n\n  getTextPageBounds(currentPage, currentBounds, stringResult) {\n    let textSize = stringResult.actualSize;\n    let x = currentBounds.x;\n    let y = currentBounds.y;\n    let width = currentBounds.width > 0 ? currentBounds.width : textSize.width;\n    let height = textSize.height;\n    let shiftedRect = currentPage.graphics.checkCorrectLayoutRectangle(textSize, currentBounds.x, currentBounds.y, this.format); // if (currentBounds.width <= 0) {\n\n    x = shiftedRect.x; // }\n\n    let verticalShift = currentPage.graphics.getTextVerticalAlignShift(textSize.height, currentBounds.height, this.format);\n    y += verticalShift;\n    let bounds = new RectangleF(x, y, width, height);\n    return bounds;\n  }\n\n}\n\nclass TextPageLayoutResult {}\n\nclass PdfTextLayoutResult extends PdfLayoutResult {\n  // Properties\n\n  /**\n   * Gets a value that contains the `text` that was not printed.\n   * @private\n   */\n  get remainder() {\n    return this.remainderText;\n  }\n  /**\n   * Gets a value that indicates the `bounds` of the last line that was printed on the page.\n   * @private\n   */\n\n\n  get lastLineBounds() {\n    return this.lastLineTextBounds;\n  } // Constructors\n\n  /**\n   * Initializes the new instance of `PdfTextLayoutResult` class.\n   * @private\n   */\n\n\n  constructor(page, bounds, remainder, lastLineBounds) {\n    super(page, bounds);\n    this.remainderText = remainder;\n    this.lastLineTextBounds = lastLineBounds;\n  }\n\n}\n/**\n * PdfTextElement.ts class for EJ2-PDF\n */\n\n/**\n * `PdfTextElement` class represents the text area with the ability to span several pages\n * and inherited from the 'PdfLayoutElement' class.\n * @private\n */\n\n\nclass PdfTextElement extends PdfLayoutElement {\n  constructor(arg1, arg2, arg3, arg4, arg5) {\n    super(); // Fields\n\n    /**\n     * `Text` data.\n     * @private\n     */\n\n    this.content = '';\n    /**\n     * `Value` of text data.\n     * @private\n     */\n\n    this.elementValue = '';\n    /**\n     * indicate whether the drawText with PointF overload is called or not.\n     * @default false\n     * @private\n     */\n\n    this.hasPointOverload = false;\n    /**\n     * indicate whether the PdfGridCell value is `PdfTextElement`\n     * @default false\n     * @private\n     */\n\n    this.isPdfTextElement = false;\n\n    if (typeof arg1 === 'undefined') {//\n    } else if (typeof arg1 === 'string' && typeof arg2 === 'undefined') {\n      this.content = arg1;\n      this.elementValue = arg1;\n    } else if (typeof arg1 === 'string' && arg2 instanceof PdfFont && typeof arg3 === 'undefined') {\n      this.content = arg1;\n      this.elementValue = arg1;\n      this.pdfFont = arg2;\n    } else if (typeof arg1 === 'string' && arg2 instanceof PdfFont && arg3 instanceof PdfPen && typeof arg4 === 'undefined') {\n      this.content = arg1;\n      this.elementValue = arg1;\n      this.pdfFont = arg2;\n      this.pdfPen = arg3;\n    } else if (typeof arg1 === 'string' && arg2 instanceof PdfFont && arg3 instanceof PdfBrush && typeof arg4 === 'undefined') {\n      this.content = arg1;\n      this.elementValue = arg1;\n      this.pdfFont = arg2;\n      this.pdfBrush = arg3;\n    } else {\n      this.content = arg1;\n      this.elementValue = arg1;\n      this.pdfFont = arg2;\n      this.pdfPen = arg3;\n      this.pdfBrush = arg4;\n      this.format = arg5;\n    }\n  } // Properties\n\n  /**\n   * Gets or sets a value indicating the `text` that should be printed.\n   * ```typescript\n   * // create a new PDF document.\n   * let document : PdfDocument = new PdfDocument();\n   * // add a page to the document.\n   * let page1 : PdfPage = document.pages.add();\n   * // create the font\n   * let font : PdfFont = new PdfStandardFont(PdfFontFamily.Helvetica, 12);\n   * // create the Text Web Link\n   * let textLink : PdfTextWebLink = new PdfTextWebLink();\n   * // set the hyperlink\n   * textLink.url = 'http://www.google.com';\n   * //\n   * // set the link text\n   * textLink.text = 'Google';\n   * //\n   * // set the font\n   * textLink.font = font;\n   * // draw the hyperlink in PDF page\n   * textLink.draw(page1, new PointF(10, 40));\n   * // save the document.\n   * document.save('output.pdf');\n   * // destroy the document\n   * document.destroy();\n   * ```\n   */\n\n\n  get text() {\n    return this.content;\n  }\n\n  set text(value) {\n    this.elementValue = value;\n    this.content = value;\n  } //get value\n\n  /**\n   * Gets or sets a `value` indicating the text that should be printed.\n   * @private\n   */\n\n\n  get value() {\n    return this.elementValue;\n  } //get pen\n\n  /**\n   * Gets or sets a `PdfPen` that determines the color, width, and style of the text\n   * @private\n   */\n\n\n  get pen() {\n    return this.pdfPen;\n  } //Set pen value\n\n\n  set pen(value) {\n    this.pdfPen = value;\n  } //get brush\n\n  /**\n   * Gets or sets the `PdfBrush` that will be used to draw the text with color and texture.\n   * @private\n   */\n\n\n  get brush() {\n    return this.pdfBrush;\n  } //Set brush value\n\n\n  set brush(value) {\n    this.pdfBrush = value;\n  } //get font\n\n  /**\n   * Gets or sets a `PdfFont` that defines the text format.\n   * ```typescript\n   * // create a new PDF document.\n   * let document : PdfDocument = new PdfDocument();\n   * // add a page to the document.\n   * let page1 : PdfPage = document.pages.add();\n   * // create the font\n   * let font : PdfFont = new PdfStandardFont(PdfFontFamily.Helvetica, 12);\n   * // create the Text Web Link\n   * let textLink : PdfTextWebLink = new PdfTextWebLink();\n   * // set the hyperlink\n   * textLink.url = 'http://www.google.com';\n   * // set the link text\n   * textLink.text = 'Google';\n   * //\n   * // set the font\n   * textLink.font = font;\n   * //\n   * // draw the hyperlink in PDF page\n   * textLink.draw(page1, new PointF(10, 40));\n   * // save the document.\n   * document.save('output.pdf');\n   * // destroy the document\n   * document.destroy();\n   * ```\n   */\n\n\n  get font() {\n    return this.pdfFont;\n  }\n\n  set font(value) {\n    this.pdfFont = value;\n\n    if (this.pdfFont instanceof PdfStandardFont && this.content != null) {\n      this.elementValue = PdfStandardFont.convert(this.content);\n    } else {\n      this.elementValue = this.content;\n    }\n  }\n  /**\n   * Gets or sets the `PdfStringFormat` that will be used to set the string format\n   * @private\n   */\n\n\n  get stringFormat() {\n    return this.format;\n  }\n\n  set stringFormat(value) {\n    this.format = value;\n  } // Implementation\n\n  /**\n   * Gets a `brush` for drawing.\n   * @private\n   */\n\n\n  getBrush() {\n    return this.pdfBrush == null || typeof this.pdfBrush === 'undefined' ? new PdfSolidBrush(new PdfColor(0, 0, 0)) : this.pdfBrush;\n  } // /**\n  //  * `Draws` an element on the Graphics.\n  //  * @private\n  //  */\n  // public drawInternal(graphics : PdfGraphics) : void {\n  //     graphics.drawString(this.elementValue, this.pdfFont, this.pdfPen, this.getBrush(), 0, 0, this.stringFormat);\n  // }\n\n  /**\n   * `Layouts` the element.\n   * @private\n   */\n\n\n  layout(param) {\n    let layouter = new TextLayouter(this);\n    let result = layouter.layout(param);\n    return result;\n  }\n\n  drawText(arg2, arg3, arg4, arg5) {\n    if (arg3 instanceof PointF && typeof arg3.width === 'undefined' && typeof arg4 === 'undefined') {\n      this.hasPointOverload = true;\n      return this.drawText(arg2, arg3.x, arg3.y);\n    } else if (typeof arg3 === 'number' && typeof arg4 === 'number' && typeof arg5 === 'undefined') {\n      this.hasPointOverload = true;\n      return this.drawText(arg2, arg3, arg4, null);\n    } else if (arg3 instanceof RectangleF && typeof arg3.width !== 'undefined' && typeof arg4 === 'undefined') {\n      return this.drawText(arg2, arg3, null);\n    } else if (arg3 instanceof PointF && typeof arg3.width === 'undefined' && arg4 instanceof PdfLayoutFormat) {\n      this.hasPointOverload = true;\n      return this.drawText(arg2, arg3.x, arg3.y, arg4);\n    } else if (typeof arg3 === 'number' && typeof arg4 === 'number' && (arg5 instanceof PdfLayoutFormat || arg5 == null)) {\n      this.hasPointOverload = true;\n      let width = arg2.graphics.clientSize.width - arg3;\n      let layoutRectangle = new RectangleF(arg3, arg4, width, 0);\n      return this.drawText(arg2, layoutRectangle, arg5);\n    } else if (arg3 instanceof RectangleF && typeof arg3.width !== 'undefined' && typeof arg4 === 'boolean') {\n      return this.drawText(arg2, arg3, null);\n    } else {\n      let layout = new PdfStringLayouter();\n\n      if (this.hasPointOverload) {\n        let stringLayoutResult = layout.layout(this.value, this.font, this.stringFormat, new SizeF(arg2.graphics.clientSize.width - arg3.x, 0), true, arg2.graphics.clientSize);\n        let layoutResult;\n        let param = new PdfLayoutParams();\n        let temparg3 = arg3;\n        let temparg4 = arg4;\n        param.page = arg2;\n        param.bounds = temparg3;\n        param.format = temparg4 != null ? temparg4 : new PdfLayoutFormat();\n\n        if (stringLayoutResult.lines.length > 1) {\n          this.text = stringLayoutResult.layoutLines[0].text;\n\n          if (param.bounds.y <= param.page.graphics.clientSize.height) {\n            let previousPosition = new PointF(param.bounds.x, param.bounds.y);\n            layoutResult = this.layout(param);\n            let bounds = new RectangleF(0, layoutResult.bounds.y + stringLayoutResult.lineHeight, arg2.graphics.clientSize.width, stringLayoutResult.lineHeight);\n\n            for (let i = 1; i < stringLayoutResult.lines.length; i++) {\n              param.page = layoutResult.page;\n              param.bounds = new RectangleF(new PointF(bounds.x, bounds.y), new SizeF(bounds.width, bounds.height));\n              this.text = stringLayoutResult.layoutLines[i].text;\n\n              if (bounds.y + stringLayoutResult.lineHeight > layoutResult.page.graphics.clientSize.height) {\n                param.page = param.page.graphics.getNextPage();\n\n                if (previousPosition.y > layoutResult.page.graphics.clientSize.height - layoutResult.bounds.height) {\n                  bounds = new RectangleF(0, layoutResult.bounds.height, layoutResult.page.graphics.clientSize.width, stringLayoutResult.lineHeight);\n                } else {\n                  bounds = new RectangleF(0, 0, layoutResult.page.graphics.clientSize.width, stringLayoutResult.lineHeight);\n                }\n\n                param.bounds = bounds;\n              }\n\n              layoutResult = this.layout(param);\n\n              if (i !== stringLayoutResult.lines.length - 1) {\n                bounds = new RectangleF(0, layoutResult.bounds.y + stringLayoutResult.lineHeight, layoutResult.page.graphics.clientSize.width, stringLayoutResult.lineHeight);\n              } else {\n                let lineWidth = this.font.measureString(this.text, this.format).width;\n                layoutResult = this.calculateResultBounds(layoutResult, lineWidth, layoutResult.page.graphics.clientSize.width, 0);\n              }\n            }\n          }\n\n          return layoutResult;\n        } else {\n          let lineSize = this.font.measureString(this.text, this.format);\n\n          if (param.bounds.y <= param.page.graphics.clientSize.height) {\n            layoutResult = this.layout(param);\n            layoutResult = this.calculateResultBounds(layoutResult, lineSize.width, layoutResult.page.graphics.clientSize.width, 0);\n          }\n\n          return layoutResult;\n        }\n      } else {\n        let layoutResult = layout.layout(this.value, this.font, this.stringFormat, new SizeF(arg3.width, 0), false, arg2.graphics.clientSize);\n        let result;\n        let param = new PdfLayoutParams();\n        let temparg3 = arg3;\n        let temparg4 = arg4;\n        param.page = arg2;\n        param.bounds = temparg3;\n        param.format = temparg4 != null ? temparg4 : new PdfLayoutFormat();\n\n        if (layoutResult.lines.length > 1) {\n          this.text = layoutResult.layoutLines[0].text;\n\n          if (param.bounds.y <= param.page.graphics.clientSize.height) {\n            let previousPosition = new PointF(param.bounds.x, param.bounds.y);\n            result = this.layout(param);\n            let bounds = new RectangleF(temparg3.x, result.bounds.y + layoutResult.lineHeight, temparg3.width, layoutResult.lineHeight);\n\n            for (let i = 1; i < layoutResult.lines.length; i++) {\n              param.page = result.page;\n              param.bounds = new RectangleF(bounds.x, bounds.y, bounds.width, bounds.height);\n              this.text = layoutResult.layoutLines[i].text;\n\n              if (bounds.y + layoutResult.lineHeight > result.page.graphics.clientSize.height) {\n                param.page = param.page.graphics.getNextPage();\n\n                if (previousPosition.y > result.page.graphics.clientSize.height - result.bounds.height) {\n                  bounds = new RectangleF(temparg3.x, layoutResult.lineHeight, temparg3.width, layoutResult.lineHeight);\n                } else {\n                  bounds = new RectangleF(temparg3.x, 0, temparg3.width, layoutResult.lineHeight);\n                }\n\n                param.bounds = bounds;\n              }\n\n              result = this.layout(param);\n\n              if (i !== layoutResult.lines.length - 1) {\n                bounds = new RectangleF(temparg3.x, result.bounds.y + layoutResult.lineHeight, temparg3.width, layoutResult.lineHeight);\n              } else {\n                let lineWidth = this.font.measureString(this.text, this.format).width;\n                result = this.calculateResultBounds(result, lineWidth, temparg3.width, temparg3.x);\n              }\n            }\n          }\n\n          return result;\n        } else {\n          let lineSize = this.font.measureString(this.text, this.format);\n\n          if (param.bounds.y <= param.page.graphics.clientSize.height) {\n            result = this.layout(param);\n            result = this.calculateResultBounds(result, lineSize.width, temparg3.width, temparg3.x);\n          }\n\n          return result;\n        }\n      }\n    }\n  }\n\n  calculateResultBounds(result, lineWidth, maximumWidth, startPosition) {\n    if (this.stringFormat != null && typeof this.stringFormat !== 'undefined' && this.stringFormat.alignment === PdfTextAlignment.Center) {\n      result.bounds.x = startPosition + (maximumWidth - lineWidth) / 2;\n      result.bounds.width = lineWidth;\n    } else if (this.stringFormat != null && typeof this.stringFormat !== 'undefined' && this.stringFormat.alignment === PdfTextAlignment.Right) {\n      result.bounds.x = startPosition + (maximumWidth - lineWidth);\n      result.bounds.width = lineWidth;\n    } else if (this.stringFormat != null && typeof this.stringFormat !== 'undefined' && this.stringFormat.alignment === PdfTextAlignment.Justify) {\n      result.bounds.x = startPosition;\n      result.bounds.width = maximumWidth;\n    } else {\n      result.bounds.width = startPosition;\n      result.bounds.width = lineWidth;\n    }\n\n    return result;\n  }\n\n}\n/**\n * `PdfUriAnnotation` class represents the Uri annotation.\n * @private\n */\n\n\nclass PdfUriAnnotation extends PdfActionLinkAnnotation {\n  /**\n   * Get `action` of the annotation.\n   * @private\n   */\n  get uriAction() {\n    if (typeof this.pdfUriAction === 'undefined') {\n      this.pdfUriAction = new PdfUriAction();\n    }\n\n    return this.pdfUriAction;\n  } // Properties\n\n  /**\n   * Gets or sets the `Uri` address.\n   * @private\n   */\n\n\n  get uri() {\n    return this.uriAction.uri;\n  }\n\n  set uri(value) {\n    if (this.uriAction.uri !== value) {\n      this.uriAction.uri = value;\n    }\n  }\n  /**\n   * Gets or sets the `action`.\n   * @private\n   */\n\n\n  get action() {\n    return this.getSetAction();\n  }\n\n  set action(value) {\n    this.getSetAction(value);\n    this.uriAction.next = value;\n  }\n\n  constructor(rectangle, uri) {\n    super(rectangle);\n\n    if (typeof uri !== 'undefined') {\n      this.uri = uri;\n    }\n  } // Implementation\n\n  /**\n   * `Initializes` annotation object.\n   * @private\n   */\n\n\n  initialize() {\n    super.initialize();\n    this.dictionary.items.setValue(this.dictionaryProperties.subtype, new PdfName(this.dictionaryProperties.link));\n    let tempPrimitive = this.uriAction.element;\n    this.dictionary.items.setValue(this.dictionaryProperties.a, this.uriAction.element);\n  }\n\n}\n/**\n * `PdfTextWebLink` class represents the class for text web link annotation.\n * ```typescript\n * // create a new PDF document.\n * let document : PdfDocument = new PdfDocument();\n * // add a page to the document.\n * let page1 : PdfPage = document.pages.add();\n * // create the font\n * let font : PdfFont = new PdfStandardFont(PdfFontFamily.Helvetica, 12);\n * //\n * // create the Text Web Link\n * let textLink : PdfTextWebLink = new PdfTextWebLink();\n * // set the hyperlink\n * textLink.url = 'http://www.google.com';\n * // set the link text\n * textLink.text = 'Google';\n * // set the font\n * textLink.font = font;\n * // draw the hyperlink in PDF page\n * textLink.draw(page1, new PointF(10, 40));\n * //\n * // save the document.\n * document.save('output.pdf');\n * // destroy the document\n * document.destroy();\n * ```\n */\n\n\nclass PdfTextWebLink extends PdfTextElement {\n  // Constructors\n\n  /**\n   * Initializes a new instance of the `PdfTextWebLink` class.\n   * @private\n   */\n  constructor() {\n    super(); // Fields\n\n    /**\n     * Internal variable to store `Url`.\n     * @default ''\n     * @private\n     */\n\n    this.uniformResourceLocator = '';\n    /**\n     * Internal variable to store `Uri Annotation` object.\n     * @default null\n     * @private\n     */\n\n    this.uriAnnotation = null;\n    /**\n     * Checks whether the drawTextWebLink method with `PointF` overload is called or not.\n     * If it set as true, then the start position of each lines excluding firest line is changed as (0, Y).\n     * @private\n     * @hidden\n     */\n\n    this.recalculateBounds = false;\n    this.defaultBorder = new PdfArray();\n\n    for (let i = 0; i < 3; i++) {\n      this.defaultBorder.add(new PdfNumber(0));\n    }\n  } // Properties\n\n  /**\n   * Gets or sets the `Uri address`.\n   * ```typescript\n   * // create a new PDF document.\n   * let document : PdfDocument = new PdfDocument();\n   * // add a page to the document.\n   * let page1 : PdfPage = document.pages.add();\n   * // create the font\n   * let font : PdfFont = new PdfStandardFont(PdfFontFamily.Helvetica, 12);\n   * // create the Text Web Link\n   * let textLink : PdfTextWebLink = new PdfTextWebLink();\n   * //\n   * // set the hyperlink\n   * textLink.url = 'http://www.google.com';\n   * //\n   * // set the link text\n   * textLink.text = 'Google';\n   * // set the font\n   * textLink.font = font;\n   * // draw the hyperlink in PDF page\n   * textLink.draw(page1, new PointF(10, 40));\n   * // save the document.\n   * document.save('output.pdf');\n   * // destroy the document\n   * document.destroy();\n   * ```\n   */\n\n\n  get url() {\n    return this.uniformResourceLocator;\n  }\n\n  set url(value) {\n    if (value.length === 0) {\n      throw new Error('ArgumentException : Url - string can not be empty');\n    }\n\n    this.uniformResourceLocator = value;\n  }\n\n  draw(arg1, arg2) {\n    if (arg1 instanceof PdfPage) {\n      let layout = new PdfStringLayouter();\n      let previousFontStyle = this.font.style;\n\n      if (arg2 instanceof PointF) {\n        this.recalculateBounds = true;\n        this.font.style = PdfFontStyle.Underline;\n        let layoutResult = layout.layout(this.value, this.font, this.stringFormat, new SizeF(arg1.graphics.clientSize.width - arg2.x, 0), true, arg1.graphics.clientSize);\n\n        if (layoutResult.lines.length === 1) {\n          let textSize = this.font.measureString(this.value);\n          let rect = new RectangleF(arg2, textSize);\n          rect = this.calculateBounds(rect, textSize.width, arg1.graphics.clientSize.width, arg2.x);\n          this.uriAnnotation = new PdfUriAnnotation(rect, this.url);\n          this.uriAnnotation.dictionary.items.setValue('Border', this.defaultBorder);\n          arg1.annotations.add(this.uriAnnotation);\n          let result = this.drawText(arg1, arg2);\n          this.font.style = previousFontStyle;\n          return result;\n        } else {\n          let result = this.drawMultipleLineWithPoint(layoutResult, arg1, arg2);\n          this.font.style = previousFontStyle;\n          return result;\n        }\n      } else {\n        let layoutResult = layout.layout(this.value, this.font, this.stringFormat, new SizeF(arg2.width, 0), false, new SizeF(0, 0));\n        this.font.style = PdfFontStyle.Underline;\n\n        if (layoutResult.lines.length === 1) {\n          let textSize = this.font.measureString(this.value);\n          let rect = new RectangleF(new PointF(arg2.x, arg2.y), textSize);\n          rect = this.calculateBounds(rect, textSize.width, arg2.width, arg2.x);\n          this.uriAnnotation = new PdfUriAnnotation(rect, this.url);\n          this.uriAnnotation.dictionary.items.setValue('Border', this.defaultBorder);\n          arg1.annotations.add(this.uriAnnotation);\n          let returnValue = this.drawText(arg1, arg2);\n          this.font.style = previousFontStyle;\n          return returnValue;\n        } else {\n          let returnValue = this.drawMultipleLineWithBounds(layoutResult, arg1, arg2);\n          this.font.style = previousFontStyle;\n          return returnValue;\n        }\n      }\n    } else {\n      let page = new PdfPage();\n      page = arg1.page;\n      return this.draw(page, arg2);\n    }\n  }\n  /* tslint:enable */\n  //Private methods\n\n  /**\n   * Helper method `Draw` a Multiple Line Text Web Link on the Graphics with the specified location.\n   * @private\n   */\n\n\n  drawMultipleLineWithPoint(result, page, location) {\n    let layoutResult;\n\n    for (let i = 0; i < result.layoutLines.length; i++) {\n      let size = this.font.measureString(result.lines[i].text);\n      let bounds = new RectangleF(location, size);\n\n      if (i !== 0) {\n        bounds.x = 0;\n      }\n\n      this.text = result.lines[i].text;\n\n      if (bounds.y + size.height > page.graphics.clientSize.height) {\n        if (i !== 0) {\n          page = page.graphics.getNextPage();\n          bounds = new RectangleF(0, 0, page.graphics.clientSize.width, size.height);\n          location.y = 0;\n        } else {\n          break;\n        }\n      }\n\n      bounds = this.calculateBounds(bounds, size.width, page.graphics.clientSize.width, bounds.x);\n      this.uriAnnotation = new PdfUriAnnotation(bounds, this.url);\n      this.uriAnnotation.dictionary.items.setValue('Border', this.defaultBorder);\n      page.annotations.add(this.uriAnnotation);\n\n      if (i !== 0) {\n        layoutResult = this.drawText(page, new PointF(0, bounds.y));\n      } else {\n        layoutResult = this.drawText(page, bounds.x, bounds.y);\n      }\n\n      location.y += size.height;\n    }\n\n    return layoutResult;\n  }\n  /**\n   * Helper method `Draw` a Multiple Line Text Web Link on the Graphics with the specified bounds.\n   * @private\n   */\n\n\n  drawMultipleLineWithBounds(result, page, bounds) {\n    let layoutResult;\n\n    for (let i = 0; i < result.layoutLines.length; i++) {\n      let size = this.font.measureString(result.lines[i].text);\n      let internalBounds = new RectangleF(new PointF(bounds.x, bounds.y), size);\n      internalBounds = this.calculateBounds(internalBounds, size.width, bounds.width, bounds.x);\n      this.text = result.lines[i].text;\n\n      if (bounds.y + size.height > page.graphics.clientSize.height) {\n        if (i !== 0) {\n          page = page.graphics.getNextPage();\n          bounds = new RectangleF(bounds.x, 0, bounds.width, size.height);\n          internalBounds.y = 0;\n        } else {\n          break;\n        }\n      }\n\n      this.uriAnnotation = new PdfUriAnnotation(internalBounds, this.url);\n      this.uriAnnotation.dictionary.items.setValue('Border', this.defaultBorder);\n      page.annotations.add(this.uriAnnotation);\n      layoutResult = this.drawText(page, bounds);\n      bounds.y += size.height;\n    }\n\n    return layoutResult;\n  }\n  /* tslint:disable */\n\n\n  calculateBounds(currentBounds, lineWidth, maximumWidth, startPosition) {\n    if (this.stringFormat != null && typeof this.stringFormat !== 'undefined' && this.stringFormat.alignment === PdfTextAlignment.Center) {\n      currentBounds.x = startPosition + (maximumWidth - lineWidth) / 2;\n      currentBounds.width = lineWidth;\n    } else if (this.stringFormat != null && typeof this.stringFormat !== 'undefined' && this.stringFormat.alignment === PdfTextAlignment.Right) {\n      currentBounds.x = startPosition + (maximumWidth - lineWidth);\n      currentBounds.width = lineWidth;\n    } else if (this.stringFormat != null && typeof this.stringFormat !== 'undefined' && this.stringFormat.alignment === PdfTextAlignment.Justify) {\n      currentBounds.x = startPosition;\n      currentBounds.width = maximumWidth;\n    } else {\n      currentBounds.width = startPosition;\n      currentBounds.width = lineWidth;\n    }\n\n    return currentBounds;\n  }\n\n}\n/**\n * PdfNumbersConvertor.ts class for EJ2-PDF\n * @private\n */\n\n/**\n * `PdfNumbersConvertor` for convert page number into numbers, roman letters, etc.,\n * @private\n */\n\n\nlet PdfNumbersConvertor = /*#__PURE__*/(() => {\n  class PdfNumbersConvertor {\n    // Static methods\n\n    /**\n     * Convert string value from page number with correct format.\n     * @private\n     */\n    static convert(intArabic, numberStyle) {\n      let result = '';\n\n      switch (numberStyle) {\n        case PdfNumberStyle.None:\n          result = '';\n          break;\n\n        case PdfNumberStyle.Numeric:\n          result = intArabic.toString();\n          break;\n\n        case PdfNumberStyle.LowerLatin:\n          result = this.arabicToLetter(intArabic).toLowerCase();\n          break;\n\n        case PdfNumberStyle.LowerRoman:\n          result = this.arabicToRoman(intArabic).toLowerCase();\n          break;\n\n        case PdfNumberStyle.UpperLatin:\n          result = this.arabicToLetter(intArabic);\n          break;\n\n        case PdfNumberStyle.UpperRoman:\n          result = this.arabicToRoman(intArabic);\n          break;\n      }\n\n      return result;\n    }\n    /**\n     * Converts `arabic to roman` letters.\n     * @private\n     */\n\n\n    static arabicToRoman(intArabic) {\n      let retval = '';\n      let retvalM = this.generateNumber(intArabic, 1000, 'M');\n      retval += retvalM.returnValue;\n      intArabic = retvalM.intArabic;\n      let retvalCM = this.generateNumber(intArabic, 900, 'CM');\n      retval += retvalCM.returnValue;\n      intArabic = retvalCM.intArabic;\n      let retvalD = this.generateNumber(intArabic, 500, 'D');\n      retval += retvalD.returnValue;\n      intArabic = retvalD.intArabic;\n      let retvalCD = this.generateNumber(intArabic, 400, 'CD');\n      retval += retvalCD.returnValue;\n      intArabic = retvalCD.intArabic;\n      let retvalC = this.generateNumber(intArabic, 100, 'C');\n      retval += retvalC.returnValue;\n      intArabic = retvalC.intArabic;\n      let retvalXC = this.generateNumber(intArabic, 90, 'XC');\n      retval += retvalXC.returnValue;\n      intArabic = retvalXC.intArabic;\n      let retvalL = this.generateNumber(intArabic, 50, 'L');\n      retval += retvalL.returnValue;\n      intArabic = retvalL.intArabic;\n      let retvalXL = this.generateNumber(intArabic, 40, 'XL');\n      retval += retvalXL.returnValue;\n      intArabic = retvalXL.intArabic;\n      let retvalX = this.generateNumber(intArabic, 10, 'X');\n      retval += retvalX.returnValue;\n      intArabic = retvalX.intArabic;\n      let retvalIX = this.generateNumber(intArabic, 9, 'IX');\n      retval += retvalIX.returnValue;\n      intArabic = retvalIX.intArabic;\n      let retvalV = this.generateNumber(intArabic, 5, 'V');\n      retval += retvalV.returnValue;\n      intArabic = retvalV.intArabic;\n      let retvalIV = this.generateNumber(intArabic, 4, 'IV');\n      retval += retvalIV.returnValue;\n      intArabic = retvalIV.intArabic;\n      let retvalI = this.generateNumber(intArabic, 1, 'I');\n      retval += retvalI.returnValue;\n      intArabic = retvalI.intArabic;\n      return retval.toString();\n    }\n    /**\n     * Converts `arabic to normal letters`.\n     * @private\n     */\n\n\n    static arabicToLetter(arabic) {\n      let stack = this.convertToLetter(arabic);\n      let result = '';\n\n      while (stack.length > 0) {\n        let num = stack.pop();\n        result = this.appendChar(result, num);\n      }\n\n      return result.toString();\n    }\n    /**\n     * Generate a string value of an input number.\n     * @private\n     */\n\n\n    static generateNumber(value, magnitude, letter) {\n      let numberstring = '';\n\n      while (value >= magnitude) {\n        value -= magnitude;\n        numberstring += letter;\n      }\n\n      return {\n        returnValue: numberstring.toString(),\n        intArabic: value\n      };\n    }\n    /**\n     * Convert a input number into letters.\n     * @private\n     */\n\n\n    static convertToLetter(arabic) {\n      if (arabic <= 0) {\n        throw Error('ArgumentOutOfRangeException-arabic, Value can not be less 0');\n      }\n\n      let stack = [];\n\n      while (arabic > this.letterLimit) {\n        let remainder = arabic % this.letterLimit;\n\n        if (remainder === 0.0) {\n          arabic = arabic / this.letterLimit - 1;\n          remainder = this.letterLimit;\n        } else {\n          arabic /= this.letterLimit;\n        }\n\n        stack.push(remainder);\n      }\n\n      stack.push(arabic);\n      return stack;\n    }\n    /**\n     * Convert number to actual string value.\n     * @private\n     */\n\n\n    static appendChar(builder, value) {\n      let letter = String.fromCharCode(PdfNumbersConvertor.acsiiStartIndex + value);\n      builder += letter;\n      return builder;\n    }\n\n  }\n\n  // Fields\n\n  /**\n   * numbers of letters in english [readonly].\n   * @default = 26.0\n   * @private\n   */\n  PdfNumbersConvertor.letterLimit = 26.0;\n  /**\n   * Resturns `acsii start index` value.\n   * @default 64\n   * @private\n   */\n\n  PdfNumbersConvertor.acsiiStartIndex = 65 - 1;\n  /**\n   * Represent class to store information about `template and value pairs`.\n   * @private\n   */\n\n  return PdfNumbersConvertor;\n})();\n\nclass PdfTemplateValuePair {\n  constructor(template, value) {\n    // Fields\n\n    /**\n     * Internal variable to store template.\n     * @default null\n     * @private\n     */\n    this.pdfTemplate = null;\n    /**\n     * Intenal variable to store value.\n     * @private\n     */\n\n    this.content = '';\n\n    if (typeof template === 'undefined') {//\n    } else {\n      this.template = template;\n      this.value = value;\n    }\n  } // Properties\n\n  /**\n   * Gets or sets the template.\n   * @private\n   */\n\n\n  get template() {\n    return this.pdfTemplate;\n  }\n\n  set template(value) {\n    this.pdfTemplate = value;\n  }\n  /**\n   * Gets or sets the value.\n   * @private\n   */\n\n\n  get value() {\n    return this.content;\n  }\n\n  set value(value) {\n    this.content = value;\n  }\n\n}\n/**\n * PdfAutomaticField.ts class for EJ2-PDF\n */\n\n/**\n * Represents automatic field which has the same value within the `PdfGraphics`.\n */\n\n\nclass PdfMultipleValueField extends PdfAutomaticField {\n  constructor() {\n    super(); //  Fields\n\n    /**\n     * Stores the instance of dictionary values of `graphics and template value pair`.\n     * @private\n     */\n\n    this.list = new TemporaryDictionary();\n  } // Implementation\n\n  /* tslint:disable */\n\n\n  performDraw(graphics, location, scalingX, scalingY) {\n    super.performDrawHelper(graphics, location, scalingX, scalingY);\n    let value = this.getValue(graphics);\n    let template = new PdfTemplate(this.getSize());\n    this.list.setValue(graphics, new PdfTemplateValuePair(template, value));\n    let size = this.getSize();\n    template.graphics.drawString(value, this.getFont(), this.pen, this.getBrush(), 0, 0, size.width, size.height, this.stringFormat);\n    let drawLocation = new PointF(location.x + this.location.x, location.y + this.location.y);\n    graphics.drawPdfTemplate(template, drawLocation, new SizeF(template.width * scalingX, template.height * scalingY));\n  }\n\n}\n/**\n * Represents PDF document `page number field`.\n * @public\n */\n\n\nclass PdfPageNumberField extends PdfMultipleValueField {\n  constructor(font, arg2) {\n    super(); // Fields\n\n    /**\n     * Stores the number style of the page number field.\n     * @private\n     */\n\n    this.internalNumberStyle = PdfNumberStyle.Numeric;\n\n    if (typeof arg2 === 'undefined') {\n      this.font = font;\n    } else if (arg2 instanceof PdfBrush) {\n      this.font = font;\n      this.brush = arg2;\n    } else {\n      this.font = font;\n      this.bounds = arg2;\n    }\n  } // Properties\n\n  /**\n   * Gets and sets the number style of the page number field.\n   * @private\n   */\n\n\n  get numberStyle() {\n    return this.internalNumberStyle;\n  }\n\n  set numberStyle(value) {\n    this.internalNumberStyle = value;\n  }\n  /**\n   * Return the `string` value of page number field.\n   * @public\n   */\n\n\n  getValue(graphics) {\n    let result = null;\n    let page = this.getPageFromGraphics(graphics);\n    result = this.internalGetValue(page);\n    return result;\n  }\n  /**\n   * Internal method to `get actual value of page number`.\n   * @private\n   */\n\n\n  internalGetValue(page) {\n    let document = page.document;\n    let pageIndex = document.pages.indexOf(page) + 1;\n    return PdfNumbersConvertor.convert(pageIndex, this.numberStyle);\n  }\n\n}\n/**\n * PdfCompositeField.ts class for EJ2-PDF\n */\n\n/**\n * Represents class which can concatenate multiple automatic fields into single string.\n */\n\n\nclass PdfCompositeField extends PdfMultipleValueField {\n  // Constructor\n\n  /**\n   * Initialize a new instance of `PdfCompositeField` class.\n   * @param font Font of the field.\n   * @param brush Color of the field.\n   * @param text Content of the field.\n   * @param list List of the automatic fields in specific order based on the text content.\n   */\n  constructor(font, brush, text, ...list) {\n    super(); // Fields\n\n    /**\n     * Stores the array of automatic fields.\n     * @private\n     */\n\n    this.internalAutomaticFields = null;\n    /**\n     * Stores the text value of the field.\n     * @private\n     */\n\n    this.internalText = '';\n    this.font = font;\n    this.brush = brush;\n    this.text = text;\n    this.automaticFields = list;\n  } // Properties\n\n  /**\n   * Gets and sets the content of the field.\n   * @public\n   */\n\n\n  get text() {\n    return this.internalText;\n  }\n\n  set text(value) {\n    this.internalText = value;\n  }\n  /**\n   * Gets and sets the list of the field to drawn.\n   * @public\n   */\n\n\n  get automaticFields() {\n    return this.internalAutomaticFields;\n  }\n\n  set automaticFields(value) {\n    this.internalAutomaticFields = value;\n  } // Implementation\n\n  /**\n   * Return the actual value generated from the list of automatic fields.\n   * @public\n   */\n\n\n  getValue(graphics) {\n    let text = this.text.toString();\n\n    if (typeof this.automaticFields !== 'undefined' && this.automaticFields != null && this.automaticFields.length > 0) {\n      for (let i = 0; i < this.automaticFields.length; i++) {\n        let automaticField = this.automaticFields[i];\n        text = text.replace('{' + i + '}', automaticField.getValue(graphics));\n      }\n    }\n\n    return text;\n  }\n\n}\n/**\n * PdfSingleValueField.ts class for EJ2-PDF\n */\n\n/**\n * Represents automatic field which has the same value in the whole document.\n */\n\n\nclass PdfSingleValueField extends PdfAutomaticField {\n  // Constructors\n  constructor() {\n    super(); // Fields\n\n    /* tslint:disable */\n\n    this.list = new TemporaryDictionary();\n    /* tslint:enable */\n\n    this.painterGraphics = [];\n  }\n\n  performDraw(graphics, location, scalingX, scalingY) {\n    super.performDrawHelper(graphics, location, scalingX, scalingY);\n    let page = this.getPageFromGraphics(graphics);\n    let document = page.document;\n    let textValue = this.getValue(graphics);\n    /* tslint:disable */\n\n    if (this.list.containsKey(document)) {\n      let pair = this.list.getValue(document);\n      let drawLocation = new PointF(location.x + this.location.x, location.y + this.location.y);\n      graphics.drawPdfTemplate(pair.template, drawLocation, new SizeF(pair.template.width * scalingX, pair.template.height * scalingY));\n      this.painterGraphics.push(graphics);\n    } else {\n      let size = this.getSize();\n      let template = new PdfTemplate(size);\n      this.list.setValue(document, new PdfTemplateValuePair(template, textValue));\n      template.graphics.drawString(textValue, this.getFont(), this.pen, this.getBrush(), 0, 0, size.width, size.height, this.stringFormat);\n      let drawLocation = new PointF(location.x + this.location.x, location.y + this.location.y);\n      graphics.drawPdfTemplate(template, drawLocation, new SizeF(template.width * scalingX, template.height * scalingY));\n      this.painterGraphics.push(graphics);\n    }\n    /* tslint:enable */\n\n  }\n\n}\n/**\n * PdfPageCountField.ts class for EJ2-PDF\n */\n\n/**\n * Represents total PDF document page count automatic field.\n */\n\n\nclass PdfPageCountField extends PdfSingleValueField {\n  constructor(font, arg2) {\n    super(); // Fields\n\n    /**\n     * Stores the number style of the field.\n     * @private\n     */\n\n    this.internalNumberStyle = PdfNumberStyle.Numeric;\n\n    if (typeof arg2 === 'undefined') {\n      this.font = font;\n    } else if (arg2 instanceof PdfBrush) {\n      this.font = font;\n      this.brush = arg2;\n    } else {\n      this.font = font;\n      this.bounds = arg2;\n    }\n  } // Properties\n\n  /**\n   * Gets and sets the number style of the field.\n   * @public\n   */\n\n\n  get numberStyle() {\n    return this.internalNumberStyle;\n  }\n\n  set numberStyle(value) {\n    this.internalNumberStyle = value;\n  } // Implementation\n\n  /**\n   * Return the actual value of the content to drawn.\n   * @public\n   */\n\n\n  getValue(graphics) {\n    let result = null;\n    let page = this.getPageFromGraphics(graphics);\n    let document = page.section.parent.document;\n    let count = document.pages.count;\n    result = PdfNumbersConvertor.convert(count, this.numberStyle);\n    return result;\n  }\n\n}\n/**\n * public Enum for `PdfDestinationMode`.\n * @private\n */\n\n\nvar PdfDestinationMode = /*#__PURE__*/(() => {\n  (function (PdfDestinationMode) {\n    /**\n     * Specifies the type of `Location`.\n     * @private\n     */\n    PdfDestinationMode[PdfDestinationMode[\"Location\"] = 0] = \"Location\";\n    /**\n     * Specifies the type of `FitToPage`.\n     * @private\n     */\n\n    PdfDestinationMode[PdfDestinationMode[\"FitToPage\"] = 1] = \"FitToPage\";\n    /**\n     * Specifies the type of `FitR`.\n     * @private\n     */\n\n    PdfDestinationMode[PdfDestinationMode[\"FitR\"] = 2] = \"FitR\";\n  })(PdfDestinationMode || (PdfDestinationMode = {}));\n\n  return PdfDestinationMode;\n})();\n\n/**\n * `PdfDestination` class represents an anchor in the document\n * where bookmarks or annotations can direct when clicked.\n */\nclass PdfDestination {\n  constructor(arg1, arg2) {\n    // Fields\n\n    /**\n     * Internal variable for accessing fields from `DictionryProperties` class.\n     * @private\n     */\n    this.dictionaryProperties = new DictionaryProperties();\n    /**\n     * Type of the `destination`.\n     * @private\n     */\n\n    this.destinationMode = PdfDestinationMode.Location;\n    /**\n     * `Zoom` factor.\n     * @private\n     * @default 0\n     */\n\n    this.zoomFactor = 0;\n    /**\n     * `Location` of the destination.\n     * @default new PointF() with 0 ,0 as co-ordinates\n     * @private\n     */\n\n    this.destinationLocation = new PointF(0, 0);\n    /**\n     * `Bounds` of the destination as RectangleF.\n     * @default RectangleF.Empty\n     * @private\n     */\n\n    this.bounds = new RectangleF();\n    /**\n     * Pdf primitive representing `this` object.\n     * @private\n     */\n\n    this.array = new PdfArray();\n    let angle = PdfPageRotateAngle.RotateAngle0;\n    this.destinationLocation = new PointF(0, this.destinationLocation.y);\n    this.pdfPage = arg1;\n\n    if (arg2 instanceof PointF) {\n      this.destinationLocation = arg2;\n    } else {\n      this.bounds = arg2;\n    }\n  } // Properties\n\n  /**\n   * Gets and Sets the `zoom` factor.\n   * @private\n   */\n\n\n  get zoom() {\n    return this.zoomFactor;\n  }\n\n  set zoom(value) {\n    this.zoomFactor = value;\n    this.initializePrimitive();\n  }\n  /**\n   * Gets and Sets the `page` object.\n   * @private\n   */\n\n\n  get page() {\n    return this.pdfPage;\n  }\n\n  set page(value) {\n    this.pdfPage = value;\n    this.initializePrimitive();\n  }\n  /**\n   * Gets and Sets the destination `mode`.\n   * @private\n   */\n\n\n  get mode() {\n    return this.destinationMode;\n  }\n\n  set mode(value) {\n    this.destinationMode = value;\n    this.initializePrimitive();\n  }\n  /**\n   * Gets and Sets the `location`.\n   * @private\n   */\n\n\n  get location() {\n    return this.destinationLocation;\n  }\n\n  set location(value) {\n    this.destinationLocation = value;\n    this.initializePrimitive();\n  }\n  /**\n   * `Translates` co-ordinates to PDF co-ordinate system (lower/left).\n   * @private\n   */\n\n\n  pointToNativePdf(page, point) {\n    let section = page.section;\n    return section.pointToNativePdf(page, point);\n  }\n  /**\n   * `In fills` array by correct values.\n   * @private\n   */\n\n\n  initializePrimitive() {\n    this.array.clear();\n    this.array.add(new PdfReferenceHolder(this.pdfPage));\n\n    switch (this.destinationMode) {\n      case PdfDestinationMode.Location:\n        let simplePage = this.pdfPage;\n        let point = new PointF();\n        point = this.pointToNativePdf(simplePage, this.destinationLocation);\n        this.array.add(new PdfName(this.dictionaryProperties.xyz));\n        this.array.add(new PdfNumber(point.x));\n        this.array.add(new PdfNumber(point.y));\n        this.array.add(new PdfNumber(this.zoomFactor));\n        break;\n\n      case PdfDestinationMode.FitToPage:\n        this.array.add(new PdfName(this.dictionaryProperties.fit));\n        break;\n    }\n  }\n  /**\n   * Gets the `element` representing this object.\n   * @private\n   */\n\n\n  get element() {\n    this.initializePrimitive();\n    return this.array;\n  }\n\n}\n\nclass PdfFunction {\n  //Constructor\n\n  /**\n   * Initializes a new instance of the `PdfFunction` class.\n   * @public\n   */\n  constructor(dictionary) {\n    //Field\n\n    /**\n     * Internal variable to store dictionary.\n     * @private\n     */\n    this.mDictionary = null;\n    /**\n     * Local variable to store the dictionary properties.\n     * @private\n     */\n\n    this.mDictionaryProperties = new DictionaryProperties();\n    this.mDictionary = dictionary;\n  } //Properties\n\n  /**\n   * Gets or sets the domain of the function.\n   * @public\n   */\n\n\n  get domain() {\n    let domain = this.mDictionary.items.getValue(this.mDictionaryProperties.domain);\n    return domain;\n  }\n\n  set domain(value) {\n    this.mDictionary.items.setValue(this.mDictionaryProperties.domain, value);\n  }\n  /**\n   * Gets or sets the range.\n   * @public\n   */\n\n\n  get range() {\n    let range = this.mDictionary.items.getValue(this.mDictionaryProperties.range);\n    return range;\n  }\n\n  set range(value) {\n    this.mDictionary.items.setValue(this.mDictionaryProperties.range, value);\n  }\n  /**\n   * Gets the dictionary.\n   */\n\n\n  get dictionary() {\n    return this.mDictionary;\n  } //IPdfWrapper Members\n\n  /**\n   * Gets the element.\n   */\n\n\n  get element() {\n    return this.mDictionary;\n  }\n\n}\n/**\n * PdfSampledFunction.ts class for EJ2-PDF\n * Implements PDF Sampled Function.\n */\n\n\nclass PdfSampledFunction extends PdfFunction {\n  /**\n   * Initializes a new instance of the `PdfSampledFunction` class.\n   * @public\n   */\n  constructor(domain, range, sizes, samples) {\n    super(new PdfStream());\n\n    if (typeof domain === 'undefined') {\n      this.dictionary.items.setValue(this.mDictionaryProperties.functionType, new PdfNumber(0));\n    } else {\n      this.dictionary.items.setValue(this.mDictionaryProperties.functionType, new PdfNumber(0));\n      this.checkParams(domain, range, sizes, samples);\n      this.setDomainAndRange(domain, range);\n      this.setSizeAndValues(sizes, samples);\n    }\n  } // Helper methods\n\n  /**\n   * Checks the input parameters.\n   */\n\n\n  checkParams(domain, range, sizes, samples) {\n    let rLength = range.length;\n    let dLength = domain.length;\n    let sLength = samples.length;\n  }\n  /**\n   * Sets the domain and range.\n   */\n\n\n  setDomainAndRange(domain, range) {\n    this.domain = new PdfArray(domain);\n    this.range = new PdfArray(range);\n  }\n  /**\n   * Sets the size and values.\n   */\n\n\n  setSizeAndValues(sizes, samples) {\n    let s = this.dictionary;\n    this.dictionary.items.setValue(this.mDictionaryProperties.size, new PdfArray(sizes));\n    this.dictionary.items.setValue(this.mDictionaryProperties.bitsPerSample, new PdfNumber(8));\n    s.writeBytes(samples);\n  }\n\n}\n/**\n * Specifies the constant values specifying whether to extend the shading\n * beyond the starting and ending points of the axis.\n */\n\n\nvar PdfExtend = /*#__PURE__*/(() => {\n  (function (PdfExtend) {\n    /**\n     * Do not extend any point.\n     */\n    PdfExtend[PdfExtend[\"None\"] = 0] = \"None\";\n    /**\n     * Extend start point.\n     */\n\n    PdfExtend[PdfExtend[\"Start\"] = 1] = \"Start\";\n    /**\n     * Extend end point.\n     */\n\n    PdfExtend[PdfExtend[\"End\"] = 2] = \"End\";\n    /**\n     * Extend both start and end points.\n     */\n\n    PdfExtend[PdfExtend[\"Both\"] = 3] = \"Both\";\n  })(PdfExtend || (PdfExtend = {}));\n\n  return PdfExtend;\n})();\n\n/**\n * Specifies the gradient direction of the linear gradient brush.\n */\nvar PdfLinearGradientMode = /*#__PURE__*/(() => {\n  (function (PdfLinearGradientMode) {\n    /**\n     * Specifies a gradient from upper right to lower left.\n     */\n    PdfLinearGradientMode[PdfLinearGradientMode[\"BackwardDiagonal\"] = 0] = \"BackwardDiagonal\";\n    /**\n     * Specifies a gradient from upper left to lower right.\n     */\n\n    PdfLinearGradientMode[PdfLinearGradientMode[\"ForwardDiagonal\"] = 1] = \"ForwardDiagonal\";\n    /**\n     * Specifies a gradient from left to right.\n     */\n\n    PdfLinearGradientMode[PdfLinearGradientMode[\"Horizontal\"] = 2] = \"Horizontal\";\n    /**\n     * Specifies a gradient from top to bottom.\n     */\n\n    PdfLinearGradientMode[PdfLinearGradientMode[\"Vertical\"] = 3] = \"Vertical\";\n  })(PdfLinearGradientMode || (PdfLinearGradientMode = {}));\n\n  return PdfLinearGradientMode;\n})();\n\n/**\n * Shading type constants.\n */\nvar ShadingType = /*#__PURE__*/(() => {\n  (function (ShadingType) {\n    /**\n     * Function-based shading.\n     */\n    ShadingType[ShadingType[\"Function\"] = 1] = \"Function\";\n    /**\n     * Axial shading.\n     */\n\n    ShadingType[ShadingType[\"Axial\"] = 2] = \"Axial\";\n    /**\n     * Radial shading.\n     */\n\n    ShadingType[ShadingType[\"Radial\"] = 3] = \"Radial\";\n  })(ShadingType || (ShadingType = {}));\n\n  return ShadingType;\n})();\nvar KnownColor = /*#__PURE__*/(() => {\n  (function (KnownColor) {\n    KnownColor[KnownColor[\"ActiveBorder\"] = 1] = \"ActiveBorder\";\n    KnownColor[KnownColor[\"ActiveCaption\"] = 2] = \"ActiveCaption\";\n    KnownColor[KnownColor[\"ActiveCaptionText\"] = 3] = \"ActiveCaptionText\";\n    KnownColor[KnownColor[\"AppWorkspace\"] = 4] = \"AppWorkspace\";\n    KnownColor[KnownColor[\"Control\"] = 5] = \"Control\";\n    KnownColor[KnownColor[\"ControlDark\"] = 6] = \"ControlDark\";\n    KnownColor[KnownColor[\"ControlDarkDark\"] = 7] = \"ControlDarkDark\";\n    KnownColor[KnownColor[\"ControlLight\"] = 8] = \"ControlLight\";\n    KnownColor[KnownColor[\"ControlLightLight\"] = 9] = \"ControlLightLight\";\n    KnownColor[KnownColor[\"ControlText\"] = 10] = \"ControlText\";\n    KnownColor[KnownColor[\"Desktop\"] = 11] = \"Desktop\";\n    KnownColor[KnownColor[\"GrayText\"] = 12] = \"GrayText\";\n    KnownColor[KnownColor[\"Highlight\"] = 13] = \"Highlight\";\n    KnownColor[KnownColor[\"HighlightText\"] = 14] = \"HighlightText\";\n    KnownColor[KnownColor[\"HotTrack\"] = 15] = \"HotTrack\";\n    KnownColor[KnownColor[\"InactiveBorder\"] = 16] = \"InactiveBorder\";\n    KnownColor[KnownColor[\"InactiveCaption\"] = 17] = \"InactiveCaption\";\n    KnownColor[KnownColor[\"InactiveCaptionText\"] = 18] = \"InactiveCaptionText\";\n    KnownColor[KnownColor[\"Info\"] = 19] = \"Info\";\n    KnownColor[KnownColor[\"InfoText\"] = 20] = \"InfoText\";\n    KnownColor[KnownColor[\"Menu\"] = 21] = \"Menu\";\n    KnownColor[KnownColor[\"MenuText\"] = 22] = \"MenuText\";\n    KnownColor[KnownColor[\"ScrollBar\"] = 23] = \"ScrollBar\";\n    KnownColor[KnownColor[\"Window\"] = 24] = \"Window\";\n    KnownColor[KnownColor[\"WindowFrame\"] = 25] = \"WindowFrame\";\n    KnownColor[KnownColor[\"WindowText\"] = 26] = \"WindowText\";\n    KnownColor[KnownColor[\"Transparent\"] = 27] = \"Transparent\";\n    KnownColor[KnownColor[\"AliceBlue\"] = 28] = \"AliceBlue\";\n    KnownColor[KnownColor[\"AntiqueWhite\"] = 29] = \"AntiqueWhite\";\n    KnownColor[KnownColor[\"Aqua\"] = 30] = \"Aqua\";\n    KnownColor[KnownColor[\"Aquamarine\"] = 31] = \"Aquamarine\";\n    KnownColor[KnownColor[\"Azure\"] = 32] = \"Azure\";\n    KnownColor[KnownColor[\"Beige\"] = 33] = \"Beige\";\n    KnownColor[KnownColor[\"Bisque\"] = 34] = \"Bisque\";\n    KnownColor[KnownColor[\"Black\"] = 35] = \"Black\";\n    KnownColor[KnownColor[\"BlanchedAlmond\"] = 36] = \"BlanchedAlmond\";\n    KnownColor[KnownColor[\"Blue\"] = 37] = \"Blue\";\n    KnownColor[KnownColor[\"BlueViolet\"] = 38] = \"BlueViolet\";\n    KnownColor[KnownColor[\"Brown\"] = 39] = \"Brown\";\n    KnownColor[KnownColor[\"BurlyWood\"] = 40] = \"BurlyWood\";\n    KnownColor[KnownColor[\"CadetBlue\"] = 41] = \"CadetBlue\";\n    KnownColor[KnownColor[\"Chartreuse\"] = 42] = \"Chartreuse\";\n    KnownColor[KnownColor[\"Chocolate\"] = 43] = \"Chocolate\";\n    KnownColor[KnownColor[\"Coral\"] = 44] = \"Coral\";\n    KnownColor[KnownColor[\"CornflowerBlue\"] = 45] = \"CornflowerBlue\";\n    KnownColor[KnownColor[\"Cornsilk\"] = 46] = \"Cornsilk\";\n    KnownColor[KnownColor[\"Crimson\"] = 47] = \"Crimson\";\n    KnownColor[KnownColor[\"Cyan\"] = 48] = \"Cyan\";\n    KnownColor[KnownColor[\"DarkBlue\"] = 49] = \"DarkBlue\";\n    KnownColor[KnownColor[\"DarkCyan\"] = 50] = \"DarkCyan\";\n    KnownColor[KnownColor[\"DarkGoldenrod\"] = 51] = \"DarkGoldenrod\";\n    KnownColor[KnownColor[\"DarkGray\"] = 52] = \"DarkGray\";\n    KnownColor[KnownColor[\"DarkGreen\"] = 53] = \"DarkGreen\";\n    KnownColor[KnownColor[\"DarkKhaki\"] = 54] = \"DarkKhaki\";\n    KnownColor[KnownColor[\"DarkMagenta\"] = 55] = \"DarkMagenta\";\n    KnownColor[KnownColor[\"DarkOliveGreen\"] = 56] = \"DarkOliveGreen\";\n    KnownColor[KnownColor[\"DarkOrange\"] = 57] = \"DarkOrange\";\n    KnownColor[KnownColor[\"DarkOrchid\"] = 58] = \"DarkOrchid\";\n    KnownColor[KnownColor[\"DarkRed\"] = 59] = \"DarkRed\";\n    KnownColor[KnownColor[\"DarkSalmon\"] = 60] = \"DarkSalmon\";\n    KnownColor[KnownColor[\"DarkSeaGreen\"] = 61] = \"DarkSeaGreen\";\n    KnownColor[KnownColor[\"DarkSlateBlue\"] = 62] = \"DarkSlateBlue\";\n    KnownColor[KnownColor[\"DarkSlateGray\"] = 63] = \"DarkSlateGray\";\n    KnownColor[KnownColor[\"DarkTurquoise\"] = 64] = \"DarkTurquoise\";\n    KnownColor[KnownColor[\"DarkViolet\"] = 65] = \"DarkViolet\";\n    KnownColor[KnownColor[\"DeepPink\"] = 66] = \"DeepPink\";\n    KnownColor[KnownColor[\"DeepSkyBlue\"] = 67] = \"DeepSkyBlue\";\n    KnownColor[KnownColor[\"DimGray\"] = 68] = \"DimGray\";\n    KnownColor[KnownColor[\"DodgerBlue\"] = 69] = \"DodgerBlue\";\n    KnownColor[KnownColor[\"Firebrick\"] = 70] = \"Firebrick\";\n    KnownColor[KnownColor[\"FloralWhite\"] = 71] = \"FloralWhite\";\n    KnownColor[KnownColor[\"ForestGreen\"] = 72] = \"ForestGreen\";\n    KnownColor[KnownColor[\"Fuchsia\"] = 73] = \"Fuchsia\";\n    KnownColor[KnownColor[\"Gainsboro\"] = 74] = \"Gainsboro\";\n    KnownColor[KnownColor[\"GhostWhite\"] = 75] = \"GhostWhite\";\n    KnownColor[KnownColor[\"Gold\"] = 76] = \"Gold\";\n    KnownColor[KnownColor[\"Goldenrod\"] = 77] = \"Goldenrod\";\n    KnownColor[KnownColor[\"Gray\"] = 78] = \"Gray\";\n    KnownColor[KnownColor[\"Green\"] = 79] = \"Green\";\n    KnownColor[KnownColor[\"GreenYellow\"] = 80] = \"GreenYellow\";\n    KnownColor[KnownColor[\"Honeydew\"] = 81] = \"Honeydew\";\n    KnownColor[KnownColor[\"HotPink\"] = 82] = \"HotPink\";\n    KnownColor[KnownColor[\"IndianRed\"] = 83] = \"IndianRed\";\n    KnownColor[KnownColor[\"Indigo\"] = 84] = \"Indigo\";\n    KnownColor[KnownColor[\"Ivory\"] = 85] = \"Ivory\";\n    KnownColor[KnownColor[\"Khaki\"] = 86] = \"Khaki\";\n    KnownColor[KnownColor[\"Lavender\"] = 87] = \"Lavender\";\n    KnownColor[KnownColor[\"LavenderBlush\"] = 88] = \"LavenderBlush\";\n    KnownColor[KnownColor[\"LawnGreen\"] = 89] = \"LawnGreen\";\n    KnownColor[KnownColor[\"LemonChiffon\"] = 90] = \"LemonChiffon\";\n    KnownColor[KnownColor[\"LightBlue\"] = 91] = \"LightBlue\";\n    KnownColor[KnownColor[\"LightCoral\"] = 92] = \"LightCoral\";\n    KnownColor[KnownColor[\"LightCyan\"] = 93] = \"LightCyan\";\n    KnownColor[KnownColor[\"LightGoldenrodYellow\"] = 94] = \"LightGoldenrodYellow\";\n    KnownColor[KnownColor[\"LightGray\"] = 95] = \"LightGray\";\n    KnownColor[KnownColor[\"LightGreen\"] = 96] = \"LightGreen\";\n    KnownColor[KnownColor[\"LightPink\"] = 97] = \"LightPink\";\n    KnownColor[KnownColor[\"LightSalmon\"] = 98] = \"LightSalmon\";\n    KnownColor[KnownColor[\"LightSeaGreen\"] = 99] = \"LightSeaGreen\";\n    KnownColor[KnownColor[\"LightSkyBlue\"] = 100] = \"LightSkyBlue\";\n    KnownColor[KnownColor[\"LightSlateGray\"] = 101] = \"LightSlateGray\";\n    KnownColor[KnownColor[\"LightSteelBlue\"] = 102] = \"LightSteelBlue\";\n    KnownColor[KnownColor[\"LightYellow\"] = 103] = \"LightYellow\";\n    KnownColor[KnownColor[\"Lime\"] = 104] = \"Lime\";\n    KnownColor[KnownColor[\"LimeGreen\"] = 105] = \"LimeGreen\";\n    KnownColor[KnownColor[\"Linen\"] = 106] = \"Linen\";\n    KnownColor[KnownColor[\"Magenta\"] = 107] = \"Magenta\";\n    KnownColor[KnownColor[\"Maroon\"] = 108] = \"Maroon\";\n    KnownColor[KnownColor[\"MediumAquamarine\"] = 109] = \"MediumAquamarine\";\n    KnownColor[KnownColor[\"MediumBlue\"] = 110] = \"MediumBlue\";\n    KnownColor[KnownColor[\"MediumOrchid\"] = 111] = \"MediumOrchid\";\n    KnownColor[KnownColor[\"MediumPurple\"] = 112] = \"MediumPurple\";\n    KnownColor[KnownColor[\"MediumSeaGreen\"] = 113] = \"MediumSeaGreen\";\n    KnownColor[KnownColor[\"MediumSlateBlue\"] = 114] = \"MediumSlateBlue\";\n    KnownColor[KnownColor[\"MediumSpringGreen\"] = 115] = \"MediumSpringGreen\";\n    KnownColor[KnownColor[\"MediumTurquoise\"] = 116] = \"MediumTurquoise\";\n    KnownColor[KnownColor[\"MediumVioletRed\"] = 117] = \"MediumVioletRed\";\n    KnownColor[KnownColor[\"MidnightBlue\"] = 118] = \"MidnightBlue\";\n    KnownColor[KnownColor[\"MintCream\"] = 119] = \"MintCream\";\n    KnownColor[KnownColor[\"MistyRose\"] = 120] = \"MistyRose\";\n    KnownColor[KnownColor[\"Moccasin\"] = 121] = \"Moccasin\";\n    KnownColor[KnownColor[\"NavajoWhite\"] = 122] = \"NavajoWhite\";\n    KnownColor[KnownColor[\"Navy\"] = 123] = \"Navy\";\n    KnownColor[KnownColor[\"OldLace\"] = 124] = \"OldLace\";\n    KnownColor[KnownColor[\"Olive\"] = 125] = \"Olive\";\n    KnownColor[KnownColor[\"OliveDrab\"] = 126] = \"OliveDrab\";\n    KnownColor[KnownColor[\"Orange\"] = 127] = \"Orange\";\n    KnownColor[KnownColor[\"OrangeRed\"] = 128] = \"OrangeRed\";\n    KnownColor[KnownColor[\"Orchid\"] = 129] = \"Orchid\";\n    KnownColor[KnownColor[\"PaleGoldenrod\"] = 130] = \"PaleGoldenrod\";\n    KnownColor[KnownColor[\"PaleGreen\"] = 131] = \"PaleGreen\";\n    KnownColor[KnownColor[\"PaleTurquoise\"] = 132] = \"PaleTurquoise\";\n    KnownColor[KnownColor[\"PaleVioletRed\"] = 133] = \"PaleVioletRed\";\n    KnownColor[KnownColor[\"PapayaWhip\"] = 134] = \"PapayaWhip\";\n    KnownColor[KnownColor[\"PeachPuff\"] = 135] = \"PeachPuff\";\n    KnownColor[KnownColor[\"Peru\"] = 136] = \"Peru\";\n    KnownColor[KnownColor[\"Pink\"] = 137] = \"Pink\";\n    KnownColor[KnownColor[\"Plum\"] = 138] = \"Plum\";\n    KnownColor[KnownColor[\"PowderBlue\"] = 139] = \"PowderBlue\";\n    KnownColor[KnownColor[\"Purple\"] = 140] = \"Purple\";\n    KnownColor[KnownColor[\"Red\"] = 141] = \"Red\";\n    KnownColor[KnownColor[\"RosyBrown\"] = 142] = \"RosyBrown\";\n    KnownColor[KnownColor[\"RoyalBlue\"] = 143] = \"RoyalBlue\";\n    KnownColor[KnownColor[\"SaddleBrown\"] = 144] = \"SaddleBrown\";\n    KnownColor[KnownColor[\"Salmon\"] = 145] = \"Salmon\";\n    KnownColor[KnownColor[\"SandyBrown\"] = 146] = \"SandyBrown\";\n    KnownColor[KnownColor[\"SeaGreen\"] = 147] = \"SeaGreen\";\n    KnownColor[KnownColor[\"SeaShell\"] = 148] = \"SeaShell\";\n    KnownColor[KnownColor[\"Sienna\"] = 149] = \"Sienna\";\n    KnownColor[KnownColor[\"Silver\"] = 150] = \"Silver\";\n    KnownColor[KnownColor[\"SkyBlue\"] = 151] = \"SkyBlue\";\n    KnownColor[KnownColor[\"SlateBlue\"] = 152] = \"SlateBlue\";\n    KnownColor[KnownColor[\"SlateGray\"] = 153] = \"SlateGray\";\n    KnownColor[KnownColor[\"Snow\"] = 154] = \"Snow\";\n    KnownColor[KnownColor[\"SpringGreen\"] = 155] = \"SpringGreen\";\n    KnownColor[KnownColor[\"SteelBlue\"] = 156] = \"SteelBlue\";\n    KnownColor[KnownColor[\"Tan\"] = 157] = \"Tan\";\n    KnownColor[KnownColor[\"Teal\"] = 158] = \"Teal\";\n    KnownColor[KnownColor[\"Thistle\"] = 159] = \"Thistle\";\n    KnownColor[KnownColor[\"Tomato\"] = 160] = \"Tomato\";\n    KnownColor[KnownColor[\"Turquoise\"] = 161] = \"Turquoise\";\n    KnownColor[KnownColor[\"Violet\"] = 162] = \"Violet\";\n    KnownColor[KnownColor[\"Wheat\"] = 163] = \"Wheat\";\n    KnownColor[KnownColor[\"White\"] = 164] = \"White\";\n    KnownColor[KnownColor[\"WhiteSmoke\"] = 165] = \"WhiteSmoke\";\n    KnownColor[KnownColor[\"Yellow\"] = 166] = \"Yellow\";\n    KnownColor[KnownColor[\"YellowGreen\"] = 167] = \"YellowGreen\";\n    KnownColor[KnownColor[\"ButtonFace\"] = 168] = \"ButtonFace\";\n    KnownColor[KnownColor[\"ButtonHighlight\"] = 169] = \"ButtonHighlight\";\n    KnownColor[KnownColor[\"ButtonShadow\"] = 170] = \"ButtonShadow\";\n    KnownColor[KnownColor[\"GradientActiveCaption\"] = 171] = \"GradientActiveCaption\";\n    KnownColor[KnownColor[\"GradientInactiveCaption\"] = 172] = \"GradientInactiveCaption\";\n    KnownColor[KnownColor[\"MenuBar\"] = 173] = \"MenuBar\";\n    KnownColor[KnownColor[\"MenuHighlight\"] = 174] = \"MenuHighlight\";\n  })(KnownColor || (KnownColor = {}));\n\n  return KnownColor;\n})();\n\n/**\n * PdfBrushes.ts class for EJ2-PDF\n */\n\n/**\n * `PdfBrushes` class provides objects used to fill the interiors of graphical shapes such as rectangles,\n * ellipses, pies, polygons, and paths.\n * @private\n */\nclass PdfBrushes {\n  //Static Properties\n\n  /**\n   * Gets the AliceBlue brush.\n   * @public\n   */\n  static get AliceBlue() {\n    let brush = null;\n\n    if (this.sBrushes.containsKey(KnownColor.AliceBlue)) {\n      brush = this.sBrushes.getValue(KnownColor.AliceBlue);\n    }\n\n    if (brush == null) {\n      brush = this.getBrush(KnownColor.AliceBlue);\n    }\n\n    return brush;\n  }\n  /**\n   * Gets the antique white brush.\n   * @public\n   */\n\n\n  static get AntiqueWhite() {\n    let brush = null;\n\n    if (this.sBrushes.containsKey(KnownColor.AntiqueWhite)) {\n      brush = this.sBrushes.getValue(KnownColor.AntiqueWhite);\n    }\n\n    if (brush == null) {\n      brush = this.getBrush(KnownColor.AntiqueWhite);\n    }\n\n    return brush;\n  }\n  /**\n   * Gets the Aqua default brush.\n   * @public\n   */\n\n\n  static get Aqua() {\n    let brush = null;\n\n    if (this.sBrushes.containsKey(KnownColor.Aqua)) {\n      brush = this.sBrushes.getValue(KnownColor.Aqua);\n    }\n\n    if (brush == null) {\n      brush = this.getBrush(KnownColor.Aqua);\n    }\n\n    return brush;\n  }\n  /**\n   * Gets the Aquamarine default brush.\n   * @public\n   */\n\n\n  static get Aquamarine() {\n    let brush = null;\n\n    if (this.sBrushes.containsKey(KnownColor.Aquamarine)) {\n      brush = this.sBrushes.getValue(KnownColor.Aquamarine);\n    }\n\n    if (brush == null) {\n      brush = this.getBrush(KnownColor.Aquamarine);\n    }\n\n    return brush;\n  }\n  /**\n   * Gets the Azure default brush.\n   * @public\n   */\n\n\n  static get Azure() {\n    let brush = null;\n\n    if (this.sBrushes.containsKey(KnownColor.Azure)) {\n      brush = this.sBrushes.getValue(KnownColor.Azure);\n    }\n\n    if (brush == null) {\n      brush = this.getBrush(KnownColor.Azure);\n    }\n\n    return brush;\n  }\n  /**\n   * Gets the Beige default brush.\n   * @public\n   */\n\n\n  static get Beige() {\n    let brush = null;\n\n    if (this.sBrushes.containsKey(KnownColor.Beige)) {\n      brush = this.sBrushes.getValue(KnownColor.Beige);\n    }\n\n    if (brush == null) {\n      brush = this.getBrush(KnownColor.Beige);\n    }\n\n    return brush;\n  }\n  /**\n   * Gets the Bisque default brush.\n   * @public\n   */\n\n\n  static get Bisque() {\n    let brush = null;\n\n    if (this.sBrushes.containsKey(KnownColor.Bisque)) {\n      brush = this.sBrushes.getValue(KnownColor.Bisque);\n    }\n\n    if (brush == null) {\n      brush = this.getBrush(KnownColor.Bisque);\n    }\n\n    return brush;\n  }\n  /**\n   * Gets the Black default brush.\n   * @public\n   */\n\n\n  static get Black() {\n    let brush = null;\n\n    if (this.sBrushes.containsKey(KnownColor.Black)) {\n      brush = this.sBrushes.getValue(KnownColor.Black);\n    }\n\n    if (brush == null) {\n      brush = this.getBrush(KnownColor.Black);\n    }\n\n    return brush;\n  }\n  /**\n   * Gets the BlanchedAlmond default brush.\n   * @public\n   */\n\n\n  static get BlanchedAlmond() {\n    let brush = null;\n\n    if (this.sBrushes.containsKey(KnownColor.BlanchedAlmond)) {\n      brush = this.sBrushes.getValue(KnownColor.BlanchedAlmond);\n    }\n\n    if (brush == null) {\n      brush = this.getBrush(KnownColor.BlanchedAlmond);\n    }\n\n    return brush;\n  }\n  /**\n   * Gets the Blue default brush.\n   * @public\n   */\n\n\n  static get Blue() {\n    let brush = null;\n\n    if (this.sBrushes.containsKey(KnownColor.Blue)) {\n      brush = this.sBrushes.getValue(KnownColor.Blue);\n    }\n\n    if (brush == null) {\n      brush = this.getBrush(KnownColor.Blue);\n    }\n\n    return brush;\n  }\n  /**\n   * Gets the BlueViolet default brush.\n   * @public\n   */\n\n\n  static get BlueViolet() {\n    let brush = null;\n\n    if (this.sBrushes.containsKey(KnownColor.BlueViolet)) {\n      brush = this.sBrushes.getValue(KnownColor.BlueViolet);\n    }\n\n    if (brush == null) {\n      brush = this.getBrush(KnownColor.BlueViolet);\n    }\n\n    return brush;\n  }\n  /**\n   * Gets the Brown default brush.\n   * @public\n   */\n\n\n  static get Brown() {\n    let brush = null;\n\n    if (this.sBrushes.containsKey(KnownColor.Brown)) {\n      brush = this.sBrushes.getValue(KnownColor.Brown);\n    }\n\n    if (brush == null) {\n      brush = this.getBrush(KnownColor.Brown);\n    }\n\n    return brush;\n  }\n  /**\n   * Gets the BurlyWood default brush.\n   * @public\n   */\n\n\n  static get BurlyWood() {\n    let brush = null;\n\n    if (this.sBrushes.containsKey(KnownColor.BurlyWood)) {\n      brush = this.sBrushes.getValue(KnownColor.BurlyWood);\n    }\n\n    if (brush == null) {\n      brush = this.getBrush(KnownColor.BurlyWood);\n    }\n\n    return brush;\n  }\n  /**\n   * Gets the CadetBlue default brush.\n   * @public\n   */\n\n\n  static get CadetBlue() {\n    let brush = null;\n\n    if (this.sBrushes.containsKey(KnownColor.CadetBlue)) {\n      brush = this.sBrushes.getValue(KnownColor.CadetBlue);\n    }\n\n    if (brush == null) {\n      brush = this.getBrush(KnownColor.CadetBlue);\n    }\n\n    return brush;\n  }\n  /**\n   * Gets the Chartreuse default brush.\n   * @public\n   */\n\n\n  static get Chartreuse() {\n    let brush = null;\n\n    if (this.sBrushes.containsKey(KnownColor.Chartreuse)) {\n      brush = this.sBrushes.getValue(KnownColor.Chartreuse);\n    }\n\n    if (brush == null) {\n      brush = this.getBrush(KnownColor.Chartreuse);\n    }\n\n    return brush;\n  }\n  /**\n   * Gets the Chocolate default brush.\n   * @public\n   */\n\n\n  static get Chocolate() {\n    let brush = null;\n\n    if (this.sBrushes.containsKey(KnownColor.Chocolate)) {\n      brush = this.sBrushes.getValue(KnownColor.Chocolate);\n    }\n\n    if (brush == null) {\n      brush = this.getBrush(KnownColor.Chocolate);\n    }\n\n    return brush;\n  }\n  /**\n   * Gets the Coral default brush.\n   * @public\n   */\n\n\n  static get Coral() {\n    let brush = null;\n\n    if (this.sBrushes.containsKey(KnownColor.Coral)) {\n      brush = this.sBrushes.getValue(KnownColor.Coral);\n    }\n\n    if (brush == null) {\n      brush = this.getBrush(KnownColor.Coral);\n    }\n\n    return brush;\n  }\n  /**\n   * Gets the CornflowerBlue default brush.\n   * @public\n   */\n\n\n  static get CornflowerBlue() {\n    let brush = null;\n\n    if (this.sBrushes.containsKey(KnownColor.CornflowerBlue)) {\n      brush = this.sBrushes.getValue(KnownColor.CornflowerBlue);\n    }\n\n    if (brush == null) {\n      brush = this.getBrush(KnownColor.CornflowerBlue);\n    }\n\n    return brush;\n  }\n  /**\n   * Gets the Corn silk default brush.\n   * @public\n   */\n\n\n  static get Cornsilk() {\n    let brush = null;\n\n    if (this.sBrushes.containsKey(KnownColor.Cornsilk)) {\n      brush = this.sBrushes.getValue(KnownColor.Cornsilk);\n    }\n\n    if (brush == null) {\n      brush = this.getBrush(KnownColor.Cornsilk);\n    }\n\n    return brush;\n  }\n  /**\n   *  Gets the Crimson default brush.\n   * @public\n   */\n\n\n  static get Crimson() {\n    let brush = null;\n\n    if (this.sBrushes.containsKey(KnownColor.Crimson)) {\n      brush = this.sBrushes.getValue(KnownColor.Crimson);\n    }\n\n    if (brush == null) {\n      brush = this.getBrush(KnownColor.Crimson);\n    }\n\n    return brush;\n  }\n  /**\n   * Gets the Cyan default brush.\n   * @public\n   */\n\n\n  static get Cyan() {\n    let brush = null;\n\n    if (this.sBrushes.containsKey(KnownColor.Cyan)) {\n      brush = this.sBrushes.getValue(KnownColor.Cyan);\n    }\n\n    if (brush == null) {\n      brush = this.getBrush(KnownColor.Cyan);\n    }\n\n    return brush;\n  }\n  /**\n   * Gets the DarkBlue default brush.\n   * @public\n   */\n\n\n  static get DarkBlue() {\n    let brush = null;\n\n    if (this.sBrushes.containsKey(KnownColor.DarkBlue)) {\n      brush = this.sBrushes.getValue(KnownColor.DarkBlue);\n    }\n\n    if (brush == null) {\n      brush = this.getBrush(KnownColor.DarkBlue);\n    }\n\n    return brush;\n  }\n  /**\n   * Gets the DarkCyan default brush.\n   * @public\n   */\n\n\n  static get DarkCyan() {\n    let brush = null;\n\n    if (this.sBrushes.containsKey(KnownColor.DarkCyan)) {\n      brush = this.sBrushes.getValue(KnownColor.DarkCyan);\n    }\n\n    if (brush == null) {\n      brush = this.getBrush(KnownColor.DarkCyan);\n    }\n\n    return brush;\n  }\n  /**\n   * Gets the DarkGoldenrod default brush.\n   * @public\n   */\n\n\n  static get DarkGoldenrod() {\n    let brush = null;\n\n    if (this.sBrushes.containsKey(KnownColor.DarkGoldenrod)) {\n      brush = this.sBrushes.getValue(KnownColor.DarkGoldenrod);\n    }\n\n    if (brush == null) {\n      brush = this.getBrush(KnownColor.DarkGoldenrod);\n    }\n\n    return brush;\n  }\n  /**\n   * Gets the DarkGray default brush.\n   * @public\n   */\n\n\n  static get DarkGray() {\n    let brush = null;\n\n    if (this.sBrushes.containsKey(KnownColor.DarkGray)) {\n      brush = this.sBrushes.getValue(KnownColor.DarkGray);\n    }\n\n    if (brush == null) {\n      brush = this.getBrush(KnownColor.DarkGray);\n    }\n\n    return brush;\n  }\n  /**\n   * Gets the DarkGreen default brush.\n   * @public\n   */\n\n\n  static get DarkGreen() {\n    let brush = null;\n\n    if (this.sBrushes.containsKey(KnownColor.DarkGreen)) {\n      brush = this.sBrushes.getValue(KnownColor.DarkGreen);\n    }\n\n    if (brush == null) {\n      brush = this.getBrush(KnownColor.DarkGreen);\n    }\n\n    return brush;\n  }\n  /**\n   * Gets the DarkKhaki default brush.\n   * @public\n   */\n\n\n  static get DarkKhaki() {\n    let brush = null;\n\n    if (this.sBrushes.containsKey(KnownColor.DarkKhaki)) {\n      brush = this.sBrushes.getValue(KnownColor.DarkKhaki);\n    }\n\n    if (brush == null) {\n      brush = this.getBrush(KnownColor.DarkKhaki);\n    }\n\n    return brush;\n  }\n  /**\n   * Gets the DarkMagenta default brush.\n   * @public\n   */\n\n\n  static get DarkMagenta() {\n    let brush = null;\n\n    if (this.sBrushes.containsKey(KnownColor.DarkMagenta)) {\n      brush = this.sBrushes.getValue(KnownColor.DarkMagenta);\n    }\n\n    if (brush == null) {\n      brush = this.getBrush(KnownColor.DarkMagenta);\n    }\n\n    return brush;\n  }\n  /**\n   * Gets the DarkOliveGreen default brush.\n   * @public\n   */\n\n\n  static get DarkOliveGreen() {\n    let brush = null;\n\n    if (this.sBrushes.containsKey(KnownColor.DarkOliveGreen)) {\n      brush = this.sBrushes.getValue(KnownColor.DarkOliveGreen);\n    }\n\n    if (brush == null) {\n      brush = this.getBrush(KnownColor.DarkOliveGreen);\n    }\n\n    return brush;\n  }\n  /**\n   * Gets the DarkOrange default brush.\n   * @public\n   */\n\n\n  static get DarkOrange() {\n    let brush = null;\n\n    if (this.sBrushes.containsKey(KnownColor.DarkOrange)) {\n      brush = this.sBrushes.getValue(KnownColor.DarkOrange);\n    }\n\n    if (brush == null) {\n      brush = this.getBrush(KnownColor.DarkOrange);\n    }\n\n    return brush;\n  }\n  /**\n   * Gets the DarkOrchid default brush.\n   * @public\n   */\n\n\n  static get DarkOrchid() {\n    let brush = null;\n\n    if (this.sBrushes.containsKey(KnownColor.DarkOrchid)) {\n      brush = this.sBrushes.getValue(KnownColor.DarkOrchid);\n    }\n\n    if (brush == null) {\n      brush = this.getBrush(KnownColor.DarkOrchid);\n    }\n\n    return brush;\n  }\n  /**\n   * Gets the DarkRed default brush.\n   * @public\n   */\n\n\n  static get DarkRed() {\n    let brush = null;\n\n    if (this.sBrushes.containsKey(KnownColor.DarkRed)) {\n      brush = this.sBrushes.getValue(KnownColor.DarkRed);\n    }\n\n    if (brush == null) {\n      brush = this.getBrush(KnownColor.DarkRed);\n    }\n\n    return brush;\n  }\n  /**\n   * Gets the DarkSalmon default brush.\n   * @public\n   */\n\n\n  static get DarkSalmon() {\n    let brush = null;\n\n    if (this.sBrushes.containsKey(KnownColor.DarkSalmon)) {\n      brush = this.sBrushes.getValue(KnownColor.DarkSalmon);\n    }\n\n    if (brush == null) {\n      brush = this.getBrush(KnownColor.DarkSalmon);\n    }\n\n    return brush;\n  }\n  /**\n   * Gets the DarkSeaGreen default brush.\n   * @public\n   */\n\n\n  static get DarkSeaGreen() {\n    let brush = null;\n\n    if (this.sBrushes.containsKey(KnownColor.DarkSeaGreen)) {\n      brush = this.sBrushes.getValue(KnownColor.DarkSeaGreen);\n    }\n\n    if (brush == null) {\n      brush = this.getBrush(KnownColor.DarkSeaGreen);\n    }\n\n    return brush;\n  }\n  /**\n   * Gets the DarkSlateBlue default brush.\n   * @public\n   */\n\n\n  static get DarkSlateBlue() {\n    let brush = null;\n\n    if (this.sBrushes.containsKey(KnownColor.DarkSlateBlue)) {\n      brush = this.sBrushes.getValue(KnownColor.DarkSlateBlue);\n    }\n\n    if (brush == null) {\n      brush = this.getBrush(KnownColor.DarkSlateBlue);\n    }\n\n    return brush;\n  }\n  /**\n   * Gets the DarkSlateGray default brush.\n   * @public\n   */\n\n\n  static get DarkSlateGray() {\n    let brush = null;\n\n    if (this.sBrushes.containsKey(KnownColor.DarkSlateGray)) {\n      brush = this.sBrushes.getValue(KnownColor.DarkSlateGray);\n    }\n\n    if (brush == null) {\n      brush = this.getBrush(KnownColor.DarkSlateGray);\n    }\n\n    return brush;\n  }\n  /**\n   * Gets the DarkTurquoise default brush.\n   * @public\n   */\n\n\n  static get DarkTurquoise() {\n    let brush = null;\n\n    if (this.sBrushes.containsKey(KnownColor.DarkTurquoise)) {\n      brush = this.sBrushes.getValue(KnownColor.DarkTurquoise);\n    }\n\n    if (brush == null) {\n      brush = this.getBrush(KnownColor.DarkTurquoise);\n    }\n\n    return brush;\n  }\n  /**\n   * Gets the DarkViolet default brush.\n   * @public\n   */\n\n\n  static get DarkViolet() {\n    let brush = null;\n\n    if (this.sBrushes.containsKey(KnownColor.DarkViolet)) {\n      brush = this.sBrushes.getValue(KnownColor.DarkViolet);\n    }\n\n    if (brush == null) {\n      brush = this.getBrush(KnownColor.DarkViolet);\n    }\n\n    return brush;\n  }\n  /**\n   * Gets the DeepPink default brush.\n   * @public\n   */\n\n\n  static get DeepPink() {\n    let brush = null;\n\n    if (this.sBrushes.containsKey(KnownColor.DeepPink)) {\n      brush = this.sBrushes.getValue(KnownColor.DeepPink);\n    }\n\n    if (brush == null) {\n      brush = this.getBrush(KnownColor.DeepPink);\n    }\n\n    return brush;\n  }\n  /**\n   * Gets the DeepSkyBlue default brush.\n   * @public\n   */\n\n\n  static get DeepSkyBlue() {\n    let brush = null;\n\n    if (this.sBrushes.containsKey(KnownColor.DeepSkyBlue)) {\n      brush = this.sBrushes.getValue(KnownColor.DeepSkyBlue);\n    }\n\n    if (brush == null) {\n      brush = this.getBrush(KnownColor.DeepSkyBlue);\n    }\n\n    return brush;\n  }\n  /**\n   * Gets the DimGray default brush.\n   * @public\n   */\n\n\n  static get DimGray() {\n    let brush = null;\n\n    if (this.sBrushes.containsKey(KnownColor.DimGray)) {\n      brush = this.sBrushes.getValue(KnownColor.DimGray);\n    }\n\n    if (brush == null) {\n      brush = this.getBrush(KnownColor.DimGray);\n    }\n\n    return brush;\n  }\n  /**\n   * Gets the DodgerBlue default brush.\n   * @public\n   */\n\n\n  static get DodgerBlue() {\n    let brush = null;\n\n    if (this.sBrushes.containsKey(KnownColor.DodgerBlue)) {\n      brush = this.sBrushes.getValue(KnownColor.DodgerBlue);\n    }\n\n    if (brush == null) {\n      brush = this.getBrush(KnownColor.DodgerBlue);\n    }\n\n    return brush;\n  }\n  /**\n   * Gets the Firebrick default brush.\n   * @public\n   */\n\n\n  static get Firebrick() {\n    let brush = null;\n\n    if (this.sBrushes.containsKey(KnownColor.Firebrick)) {\n      brush = this.sBrushes.getValue(KnownColor.Firebrick);\n    }\n\n    if (brush == null) {\n      brush = this.getBrush(KnownColor.Firebrick);\n    }\n\n    return brush;\n  }\n  /**\n   * Gets the FloralWhite default brush.\n   * @public\n   */\n\n\n  static get FloralWhite() {\n    let brush = null;\n\n    if (this.sBrushes.containsKey(KnownColor.FloralWhite)) {\n      brush = this.sBrushes.getValue(KnownColor.FloralWhite);\n    }\n\n    if (brush == null) {\n      brush = this.getBrush(KnownColor.FloralWhite);\n    }\n\n    return brush;\n  }\n  /**\n   * Gets the ForestGreen default brush.\n   * @public\n   */\n\n\n  static get ForestGreen() {\n    let brush = null;\n\n    if (this.sBrushes.containsKey(KnownColor.ForestGreen)) {\n      brush = this.sBrushes.getValue(KnownColor.ForestGreen);\n    }\n\n    if (brush == null) {\n      brush = this.getBrush(KnownColor.ForestGreen);\n    }\n\n    return brush;\n  }\n  /**\n   * Gets the Fuchsia default brush.\n   * @public\n   */\n\n\n  static get Fuchsia() {\n    let brush = null;\n\n    if (this.sBrushes.containsKey(KnownColor.Fuchsia)) {\n      brush = this.sBrushes.getValue(KnownColor.Fuchsia);\n    }\n\n    if (brush == null) {\n      brush = this.getBrush(KnownColor.Fuchsia);\n    }\n\n    return brush;\n  }\n  /**\n   * Gets the Gainsborough default brush.\n   * @public\n   */\n\n\n  static get Gainsboro() {\n    let brush = null;\n\n    if (this.sBrushes.containsKey(KnownColor.Gainsboro)) {\n      brush = this.sBrushes.getValue(KnownColor.Gainsboro);\n    }\n\n    if (brush == null) {\n      brush = this.getBrush(KnownColor.Gainsboro);\n    }\n\n    return brush;\n  }\n  /**\n   * Gets the GhostWhite default brush.\n   * @public\n   */\n\n\n  static get GhostWhite() {\n    let brush = null;\n\n    if (this.sBrushes.containsKey(KnownColor.GhostWhite)) {\n      brush = this.sBrushes.getValue(KnownColor.GhostWhite);\n    }\n\n    if (brush == null) {\n      brush = this.getBrush(KnownColor.GhostWhite);\n    }\n\n    return brush;\n  }\n  /**\n   * Gets the Gold default brush.\n   * @public\n   */\n\n\n  static get Gold() {\n    let brush = null;\n\n    if (this.sBrushes.containsKey(KnownColor.Gold)) {\n      brush = this.sBrushes.getValue(KnownColor.Gold);\n    }\n\n    if (brush == null) {\n      brush = this.getBrush(KnownColor.Gold);\n    }\n\n    return brush;\n  }\n  /**\n   * Gets the Goldenrod default brush.\n   * @public\n   */\n\n\n  static get Goldenrod() {\n    let brush = null;\n\n    if (this.sBrushes.containsKey(KnownColor.Goldenrod)) {\n      brush = this.sBrushes.getValue(KnownColor.Goldenrod);\n    }\n\n    if (brush == null) {\n      brush = this.getBrush(KnownColor.Goldenrod);\n    }\n\n    return brush;\n  }\n  /**\n   * Gets the Gray default brush.\n   * @public\n   */\n\n\n  static get Gray() {\n    let brush = null;\n\n    if (this.sBrushes.containsKey(KnownColor.Gray)) {\n      brush = this.sBrushes.getValue(KnownColor.Gray);\n    }\n\n    if (brush == null) {\n      brush = this.getBrush(KnownColor.Gray);\n    }\n\n    return brush;\n  }\n  /**\n   * Gets the Green default brush.\n   * @public\n   */\n\n\n  static get Green() {\n    let brush = null;\n\n    if (this.sBrushes.containsKey(KnownColor.Green)) {\n      brush = this.sBrushes.getValue(KnownColor.Green);\n    }\n\n    if (brush == null) {\n      brush = this.getBrush(KnownColor.Green);\n    }\n\n    return brush;\n  }\n  /**\n   * Gets the GreenYellow default brush.\n   * @public\n   */\n\n\n  static get GreenYellow() {\n    let brush = null;\n\n    if (this.sBrushes.containsKey(KnownColor.GreenYellow)) {\n      brush = this.sBrushes.getValue(KnownColor.GreenYellow);\n    }\n\n    if (brush == null) {\n      brush = this.getBrush(KnownColor.GreenYellow);\n    }\n\n    return brush;\n  }\n  /**\n   * Gets the Honeydew default brush.\n   * @public\n   */\n\n\n  static get Honeydew() {\n    let brush = null;\n\n    if (this.sBrushes.containsKey(KnownColor.Honeydew)) {\n      brush = this.sBrushes.getValue(KnownColor.Honeydew);\n    }\n\n    if (brush == null) {\n      brush = this.getBrush(KnownColor.Honeydew);\n    }\n\n    return brush;\n  }\n  /**\n   * Gets the HotPink default brush.\n   * @public\n   */\n\n\n  static get HotPink() {\n    let brush = null;\n\n    if (this.sBrushes.containsKey(KnownColor.HotPink)) {\n      brush = this.sBrushes.getValue(KnownColor.HotPink);\n    }\n\n    if (brush == null) {\n      brush = this.getBrush(KnownColor.HotPink);\n    }\n\n    return brush;\n  }\n  /**\n   * Gets the IndianRed default brush.\n   * @public\n   */\n\n\n  static get IndianRed() {\n    let brush = null;\n\n    if (this.sBrushes.containsKey(KnownColor.IndianRed)) {\n      brush = this.sBrushes.getValue(KnownColor.IndianRed);\n    }\n\n    if (brush == null) {\n      brush = this.getBrush(KnownColor.IndianRed);\n    }\n\n    return brush;\n  }\n  /**\n   * Gets the Indigo default brush.\n   * @public\n   */\n\n\n  static get Indigo() {\n    let brush = null;\n\n    if (this.sBrushes.containsKey(KnownColor.Indigo)) {\n      brush = this.sBrushes.getValue(KnownColor.Indigo);\n    }\n\n    if (brush == null) {\n      brush = this.getBrush(KnownColor.Indigo);\n    }\n\n    return brush;\n  }\n  /**\n   * Gets the Ivory default brush.\n   * @public\n   */\n\n\n  static get Ivory() {\n    let brush = null;\n\n    if (this.sBrushes.containsKey(KnownColor.Ivory)) {\n      brush = this.sBrushes.getValue(KnownColor.Ivory);\n    }\n\n    if (brush == null) {\n      brush = this.getBrush(KnownColor.Ivory);\n    }\n\n    return brush;\n  }\n  /**\n   * Gets the Khaki default brush.\n   * @public\n   */\n\n\n  static get Khaki() {\n    let brush = null;\n\n    if (this.sBrushes.containsKey(KnownColor.Khaki)) {\n      brush = this.sBrushes.getValue(KnownColor.Khaki);\n    }\n\n    if (brush == null) {\n      brush = this.getBrush(KnownColor.Khaki);\n    }\n\n    return brush;\n  }\n  /**\n   * Gets the Lavender default brush.\n   * @public\n   */\n\n\n  static get Lavender() {\n    let brush = null;\n\n    if (this.sBrushes.containsKey(KnownColor.Lavender)) {\n      brush = this.sBrushes.getValue(KnownColor.Lavender);\n    }\n\n    if (brush == null) {\n      brush = this.getBrush(KnownColor.Lavender);\n    }\n\n    return brush;\n  }\n  /**\n   * Gets the LavenderBlush default brush.\n   * @public\n   */\n\n\n  static get LavenderBlush() {\n    let brush = null;\n\n    if (this.sBrushes.containsKey(KnownColor.LavenderBlush)) {\n      brush = this.sBrushes.getValue(KnownColor.LavenderBlush);\n    }\n\n    if (brush == null) {\n      brush = this.getBrush(KnownColor.LavenderBlush);\n    }\n\n    return brush;\n  }\n  /**\n   * Gets the LawnGreen default brush.\n   * @public\n   */\n\n\n  static get LawnGreen() {\n    let brush = null;\n\n    if (this.sBrushes.containsKey(KnownColor.LawnGreen)) {\n      brush = this.sBrushes.getValue(KnownColor.LawnGreen);\n    }\n\n    if (brush == null) {\n      brush = this.getBrush(KnownColor.LawnGreen);\n    }\n\n    return brush;\n  }\n  /**\n   * Gets the LemonChiffon default brush.\n   * @public\n   */\n\n\n  static get LemonChiffon() {\n    let brush = null;\n\n    if (this.sBrushes.containsKey(KnownColor.LemonChiffon)) {\n      brush = this.sBrushes.getValue(KnownColor.LemonChiffon);\n    }\n\n    if (brush == null) {\n      brush = this.getBrush(KnownColor.LemonChiffon);\n    }\n\n    return brush;\n  }\n  /**\n   * Gets the LightBlue default brush.\n   * @public\n   */\n\n\n  static get LightBlue() {\n    let brush = null;\n\n    if (this.sBrushes.containsKey(KnownColor.LightBlue)) {\n      brush = this.sBrushes.getValue(KnownColor.LightBlue);\n    }\n\n    if (brush == null) {\n      brush = this.getBrush(KnownColor.LightBlue);\n    }\n\n    return brush;\n  }\n  /**\n   * Gets the LightCoral default brush.\n   * @public\n   */\n\n\n  static get LightCoral() {\n    let brush = null;\n\n    if (this.sBrushes.containsKey(KnownColor.LightCoral)) {\n      brush = this.sBrushes.getValue(KnownColor.LightCoral);\n    }\n\n    if (brush == null) {\n      brush = this.getBrush(KnownColor.LightCoral);\n    }\n\n    return brush;\n  }\n  /**\n   * Gets the LightCyan default brush.\n   * @public\n   */\n\n\n  static get LightCyan() {\n    let brush = null;\n\n    if (this.sBrushes.containsKey(KnownColor.LightCyan)) {\n      brush = this.sBrushes.getValue(KnownColor.LightCyan);\n    }\n\n    if (brush == null) {\n      brush = this.getBrush(KnownColor.LightCyan);\n    }\n\n    return brush;\n  }\n  /**\n   * Gets the LightGoldenrodYellow default brush.\n   * @public\n   */\n\n\n  static get LightGoldenrodYellow() {\n    let brush = null;\n\n    if (this.sBrushes.containsKey(KnownColor.LightGoldenrodYellow)) {\n      brush = this.sBrushes.getValue(KnownColor.LightGoldenrodYellow);\n    }\n\n    if (brush == null) {\n      brush = this.getBrush(KnownColor.LightGoldenrodYellow);\n    }\n\n    return brush;\n  }\n  /**\n   * Gets the LightGray default brush.\n   * @public\n   */\n\n\n  static get LightGray() {\n    let brush = null;\n\n    if (this.sBrushes.containsKey(KnownColor.LightGray)) {\n      brush = this.sBrushes.getValue(KnownColor.LightGray);\n    }\n\n    if (brush == null) {\n      brush = this.getBrush(KnownColor.LightGray);\n    }\n\n    return brush;\n  }\n  /**\n   * Gets the LightGreen default brush.\n   * @public\n   */\n\n\n  static get LightGreen() {\n    let brush = null;\n\n    if (this.sBrushes.containsKey(KnownColor.LightGreen)) {\n      brush = this.sBrushes.getValue(KnownColor.LightGreen);\n    }\n\n    if (brush == null) {\n      brush = this.getBrush(KnownColor.LightGreen);\n    }\n\n    return brush;\n  }\n  /**\n   * Gets the LightPink default brush.\n   * @public\n   */\n\n\n  static get LightPink() {\n    let brush = null;\n\n    if (this.sBrushes.containsKey(KnownColor.LightPink)) {\n      brush = this.sBrushes.getValue(KnownColor.LightPink);\n    }\n\n    if (brush == null) {\n      brush = this.getBrush(KnownColor.LightPink);\n    }\n\n    return brush;\n  }\n  /**\n   * Gets the LightSalmon default brush.\n   * @public\n   */\n\n\n  static get LightSalmon() {\n    let brush = null;\n\n    if (this.sBrushes.containsKey(KnownColor.LightSalmon)) {\n      brush = this.sBrushes.getValue(KnownColor.LightSalmon);\n    }\n\n    if (brush == null) {\n      brush = this.getBrush(KnownColor.LightSalmon);\n    }\n\n    return brush;\n  }\n  /**\n   * Gets the LightSeaGreen default brush.\n   * @public\n   */\n\n\n  static get LightSeaGreen() {\n    let brush = null;\n\n    if (this.sBrushes.containsKey(KnownColor.LightSeaGreen)) {\n      brush = this.sBrushes.getValue(KnownColor.LightSeaGreen);\n    }\n\n    if (brush == null) {\n      brush = this.getBrush(KnownColor.LightSeaGreen);\n    }\n\n    return brush;\n  }\n  /**\n   * Gets the LightSkyBlue default brush.\n   * @public\n   */\n\n\n  static get LightSkyBlue() {\n    let brush = null;\n\n    if (this.sBrushes.containsKey(KnownColor.LightSkyBlue)) {\n      brush = this.sBrushes.getValue(KnownColor.LightSkyBlue);\n    }\n\n    if (brush == null) {\n      brush = this.getBrush(KnownColor.LightSkyBlue);\n    }\n\n    return brush;\n  }\n  /**\n   * Gets the LightSlateGray default brush.\n   * @public\n   */\n\n\n  static get LightSlateGray() {\n    let brush = null;\n\n    if (this.sBrushes.containsKey(KnownColor.LightSlateGray)) {\n      brush = this.sBrushes.getValue(KnownColor.LightSlateGray);\n    }\n\n    if (brush == null) {\n      brush = this.getBrush(KnownColor.LightSlateGray);\n    }\n\n    return brush;\n  }\n  /**\n   * Gets the LightSteelBlue default brush.\n   * @public\n   */\n\n\n  static get LightSteelBlue() {\n    let brush = null;\n\n    if (this.sBrushes.containsKey(KnownColor.LightSteelBlue)) {\n      brush = this.sBrushes.getValue(KnownColor.LightSteelBlue);\n    }\n\n    if (brush == null) {\n      brush = this.getBrush(KnownColor.LightSteelBlue);\n    }\n\n    return brush;\n  }\n  /**\n   * Gets the LightYellow default brush.\n   * @public\n   */\n\n\n  static get LightYellow() {\n    let brush = null;\n\n    if (this.sBrushes.containsKey(KnownColor.LightYellow)) {\n      brush = this.sBrushes.getValue(KnownColor.LightYellow);\n    }\n\n    if (brush == null) {\n      brush = this.getBrush(KnownColor.LightYellow);\n    }\n\n    return brush;\n  }\n  /**\n   * Gets the Lime default brush.\n   * @public\n   */\n\n\n  static get Lime() {\n    let brush = null;\n\n    if (this.sBrushes.containsKey(KnownColor.Lime)) {\n      brush = this.sBrushes.getValue(KnownColor.Lime);\n    }\n\n    if (brush == null) {\n      brush = this.getBrush(KnownColor.Lime);\n    }\n\n    return brush;\n  }\n  /**\n   * Gets the LimeGreen default brush.\n   * @public\n   */\n\n\n  static get LimeGreen() {\n    let brush = null;\n\n    if (this.sBrushes.containsKey(KnownColor.LimeGreen)) {\n      brush = this.sBrushes.getValue(KnownColor.LimeGreen);\n    }\n\n    if (brush == null) {\n      brush = this.getBrush(KnownColor.LimeGreen);\n    }\n\n    return brush;\n  }\n  /**\n   * Gets the Linen default brush.\n   * @public\n   */\n\n\n  static get Linen() {\n    let brush = null;\n\n    if (this.sBrushes.containsKey(KnownColor.Linen)) {\n      brush = this.sBrushes.getValue(KnownColor.Linen);\n    }\n\n    if (brush == null) {\n      brush = this.getBrush(KnownColor.Linen);\n    }\n\n    return brush;\n  }\n  /**\n   * Gets the Magenta default brush.\n   * @public\n   */\n\n\n  static get Magenta() {\n    let brush = null;\n\n    if (this.sBrushes.containsKey(KnownColor.Magenta)) {\n      brush = this.sBrushes.getValue(KnownColor.Magenta);\n    }\n\n    if (brush == null) {\n      brush = this.getBrush(KnownColor.Magenta);\n    }\n\n    return brush;\n  }\n  /**\n   * Gets the Maroon default brush.\n   * @public\n   */\n\n\n  static get Maroon() {\n    let brush = null;\n\n    if (this.sBrushes.containsKey(KnownColor.Maroon)) {\n      brush = this.sBrushes.getValue(KnownColor.Maroon);\n    }\n\n    if (brush == null) {\n      brush = this.getBrush(KnownColor.Maroon);\n    }\n\n    return brush;\n  }\n  /**\n   * Gets the MediumAquamarine default brush.\n   * @public\n   */\n\n\n  static get MediumAquamarine() {\n    let brush = null;\n\n    if (this.sBrushes.containsKey(KnownColor.MediumAquamarine)) {\n      brush = this.sBrushes.getValue(KnownColor.MediumAquamarine);\n    }\n\n    if (brush == null) {\n      brush = this.getBrush(KnownColor.MediumAquamarine);\n    }\n\n    return brush;\n  }\n  /**\n   * Gets the MediumBlue default brush.\n   * @public\n   */\n\n\n  static get MediumBlue() {\n    let brush = null;\n\n    if (this.sBrushes.containsKey(KnownColor.MediumBlue)) {\n      brush = this.sBrushes.getValue(KnownColor.MediumBlue);\n    }\n\n    if (brush == null) {\n      brush = this.getBrush(KnownColor.MediumBlue);\n    }\n\n    return brush;\n  }\n  /**\n   * Gets the MediumOrchid default brush.\n   * @public\n   */\n\n\n  static get MediumOrchid() {\n    let brush = null;\n\n    if (this.sBrushes.containsKey(KnownColor.MediumOrchid)) {\n      brush = this.sBrushes.getValue(KnownColor.MediumOrchid);\n    }\n\n    if (brush == null) {\n      brush = this.getBrush(KnownColor.MediumOrchid);\n    }\n\n    return brush;\n  }\n  /**\n   * Gets the MediumPurple default brush.\n   * @public\n   */\n\n\n  static get MediumPurple() {\n    let brush = null;\n\n    if (this.sBrushes.containsKey(KnownColor.MediumPurple)) {\n      brush = this.sBrushes.getValue(KnownColor.MediumPurple);\n    }\n\n    if (brush == null) {\n      brush = this.getBrush(KnownColor.MediumPurple);\n    }\n\n    return brush;\n  }\n  /**\n   * Gets the MediumSeaGreen default brush.\n   * @public\n   */\n\n\n  static get MediumSeaGreen() {\n    let brush = null;\n\n    if (this.sBrushes.containsKey(KnownColor.MediumSeaGreen)) {\n      brush = this.sBrushes.getValue(KnownColor.MediumSeaGreen);\n    }\n\n    if (brush == null) {\n      brush = this.getBrush(KnownColor.MediumSeaGreen);\n    }\n\n    return brush;\n  }\n  /**\n   * Gets the MediumSlateBlue default brush.\n   * @public\n   */\n\n\n  static get MediumSlateBlue() {\n    let brush = null;\n\n    if (this.sBrushes.containsKey(KnownColor.MediumSlateBlue)) {\n      brush = this.sBrushes.getValue(KnownColor.MediumSlateBlue);\n    }\n\n    if (brush == null) {\n      brush = this.getBrush(KnownColor.MediumSlateBlue);\n    }\n\n    return brush;\n  }\n  /**\n   * Gets the MediumSpringGreen default brush.\n   * @public\n   */\n\n\n  static get MediumSpringGreen() {\n    let brush = null;\n\n    if (this.sBrushes.containsKey(KnownColor.MediumSpringGreen)) {\n      brush = this.sBrushes.getValue(KnownColor.MediumSpringGreen);\n    }\n\n    if (brush == null) {\n      brush = this.getBrush(KnownColor.MediumSpringGreen);\n    }\n\n    return brush;\n  }\n  /**\n   * Gets the MediumTurquoise default brush.\n   * @public\n   */\n\n\n  static get MediumTurquoise() {\n    let brush = null;\n\n    if (this.sBrushes.containsKey(KnownColor.MediumTurquoise)) {\n      brush = this.sBrushes.getValue(KnownColor.MediumTurquoise);\n    }\n\n    if (brush == null) {\n      brush = this.getBrush(KnownColor.MediumTurquoise);\n    }\n\n    return brush;\n  }\n  /**\n   * Gets the MediumVioletRed default brush.\n   * @public\n   */\n\n\n  static get MediumVioletRed() {\n    let brush = null;\n\n    if (this.sBrushes.containsKey(KnownColor.MediumVioletRed)) {\n      brush = this.sBrushes.getValue(KnownColor.MediumVioletRed);\n    }\n\n    if (brush == null) {\n      brush = this.getBrush(KnownColor.MediumVioletRed);\n    }\n\n    return brush;\n  }\n  /**\n   * Gets the MidnightBlue default brush.\n   * @public\n   */\n\n\n  static get MidnightBlue() {\n    let brush = null;\n\n    if (this.sBrushes.containsKey(KnownColor.MidnightBlue)) {\n      brush = this.sBrushes.getValue(KnownColor.MidnightBlue);\n    }\n\n    if (brush == null) {\n      brush = this.getBrush(KnownColor.MidnightBlue);\n    }\n\n    return brush;\n  }\n  /**\n   * Gets the MintCream default brush.\n   * @public\n   */\n\n\n  static get MintCream() {\n    let brush = null;\n\n    if (this.sBrushes.containsKey(KnownColor.MintCream)) {\n      brush = this.sBrushes.getValue(KnownColor.MintCream);\n    }\n\n    if (brush == null) {\n      brush = this.getBrush(KnownColor.MintCream);\n    }\n\n    return brush;\n  }\n  /**\n   * Gets the MistyRose default brush.\n   * @public\n   */\n\n\n  static get MistyRose() {\n    let brush = null;\n\n    if (this.sBrushes.containsKey(KnownColor.MistyRose)) {\n      brush = this.sBrushes.getValue(KnownColor.MistyRose);\n    }\n\n    if (brush == null) {\n      brush = this.getBrush(KnownColor.MistyRose);\n    }\n\n    return brush;\n  }\n  /**\n   * Gets the Moccasin default brush.\n   * @public\n   */\n\n\n  static get Moccasin() {\n    let brush = null;\n\n    if (this.sBrushes.containsKey(KnownColor.Moccasin)) {\n      brush = this.sBrushes.getValue(KnownColor.Moccasin);\n    }\n\n    if (brush == null) {\n      brush = this.getBrush(KnownColor.Moccasin);\n    }\n\n    return brush;\n  }\n  /**\n   * Gets the NavajoWhite default brush.\n   * @public\n   */\n\n\n  static get NavajoWhite() {\n    let brush = null;\n\n    if (this.sBrushes.containsKey(KnownColor.NavajoWhite)) {\n      brush = this.sBrushes.getValue(KnownColor.NavajoWhite);\n    }\n\n    if (brush == null) {\n      brush = this.getBrush(KnownColor.NavajoWhite);\n    }\n\n    return brush;\n  }\n  /**\n   * Gets the Navy default brush.\n   * @public\n   */\n\n\n  static get Navy() {\n    let brush = null;\n\n    if (this.sBrushes.containsKey(KnownColor.Navy)) {\n      brush = this.sBrushes.getValue(KnownColor.Navy);\n    }\n\n    if (brush == null) {\n      brush = this.getBrush(KnownColor.Navy);\n    }\n\n    return brush;\n  }\n  /**\n   * Gets the OldLace default brush.\n   * @public\n   */\n\n\n  static get OldLace() {\n    let brush = null;\n\n    if (this.sBrushes.containsKey(KnownColor.OldLace)) {\n      brush = this.sBrushes.getValue(KnownColor.OldLace);\n    }\n\n    if (brush == null) {\n      brush = this.getBrush(KnownColor.OldLace);\n    }\n\n    return brush;\n  }\n  /**\n   * Gets the Olive default brush.\n   * @public\n   */\n\n\n  static get Olive() {\n    let brush = null;\n\n    if (this.sBrushes.containsKey(KnownColor.Olive)) {\n      brush = this.sBrushes.getValue(KnownColor.Olive);\n    }\n\n    if (brush == null) {\n      brush = this.getBrush(KnownColor.Olive);\n    }\n\n    return brush;\n  }\n  /**\n   * Gets the OliveDrab default brush.\n   * @public\n   */\n\n\n  static get OliveDrab() {\n    let brush = null;\n\n    if (this.sBrushes.containsKey(KnownColor.OliveDrab)) {\n      brush = this.sBrushes.getValue(KnownColor.OliveDrab);\n    }\n\n    if (brush == null) {\n      brush = this.getBrush(KnownColor.OliveDrab);\n    }\n\n    return brush;\n  }\n  /**\n   * Gets the Orange default brush.\n   * @public\n   */\n\n\n  static get Orange() {\n    let brush = null;\n\n    if (this.sBrushes.containsKey(KnownColor.Orange)) {\n      brush = this.sBrushes.getValue(KnownColor.Orange);\n    }\n\n    if (brush == null) {\n      brush = this.getBrush(KnownColor.Orange);\n    }\n\n    return brush;\n  }\n  /**\n   * Gets the OrangeRed default brush.\n   * @public\n   */\n\n\n  static get OrangeRed() {\n    let brush = null;\n\n    if (this.sBrushes.containsKey(KnownColor.OrangeRed)) {\n      brush = this.sBrushes.getValue(KnownColor.OrangeRed);\n    }\n\n    if (brush == null) {\n      brush = this.getBrush(KnownColor.OrangeRed);\n    }\n\n    return brush;\n  }\n  /**\n   * Gets the Orchid default brush.\n   * @public\n   */\n\n\n  static get Orchid() {\n    let brush = null;\n\n    if (this.sBrushes.containsKey(KnownColor.Orchid)) {\n      brush = this.sBrushes.getValue(KnownColor.Orchid);\n    }\n\n    if (brush == null) {\n      brush = this.getBrush(KnownColor.Orchid);\n    }\n\n    return brush;\n  }\n  /**\n   * Gets the PaleGoldenrod default brush.\n   * @public\n   */\n\n\n  static get PaleGoldenrod() {\n    let brush = null;\n\n    if (this.sBrushes.containsKey(KnownColor.PaleGoldenrod)) {\n      brush = this.sBrushes.getValue(KnownColor.PaleGoldenrod);\n    }\n\n    if (brush == null) {\n      brush = this.getBrush(KnownColor.PaleGoldenrod);\n    }\n\n    return brush;\n  }\n  /**\n   * Gets the PaleGreen default brush.\n   * @public\n   */\n\n\n  static get PaleGreen() {\n    let brush = null;\n\n    if (this.sBrushes.containsKey(KnownColor.PaleGreen)) {\n      brush = this.sBrushes.getValue(KnownColor.PaleGreen);\n    }\n\n    if (brush == null) {\n      brush = this.getBrush(KnownColor.PaleGreen);\n    }\n\n    return brush;\n  }\n  /**\n   * Gets the PaleTurquoise default brush.\n   * @public\n   */\n\n\n  static get PaleTurquoise() {\n    let brush = null;\n\n    if (this.sBrushes.containsKey(KnownColor.PaleTurquoise)) {\n      brush = this.sBrushes.getValue(KnownColor.PaleTurquoise);\n    }\n\n    if (brush == null) {\n      brush = this.getBrush(KnownColor.PaleTurquoise);\n    }\n\n    return brush;\n  }\n  /**\n   * Gets the PaleVioletRed default brush.\n   * @public\n   */\n\n\n  static get PaleVioletRed() {\n    let brush = null;\n\n    if (this.sBrushes.containsKey(KnownColor.PaleVioletRed)) {\n      brush = this.sBrushes.getValue(KnownColor.PaleVioletRed);\n    }\n\n    if (brush == null) {\n      brush = this.getBrush(KnownColor.PaleVioletRed);\n    }\n\n    return brush;\n  }\n  /**\n   * Gets the PapayaWhip default brush.\n   * @public\n   */\n\n\n  static get PapayaWhip() {\n    let brush = null;\n\n    if (this.sBrushes.containsKey(KnownColor.PapayaWhip)) {\n      brush = this.sBrushes.getValue(KnownColor.PapayaWhip);\n    }\n\n    if (brush == null) {\n      brush = this.getBrush(KnownColor.PapayaWhip);\n    }\n\n    return brush;\n  }\n  /**\n   * Gets the PeachPuff default brush.\n   * @public\n   */\n\n\n  static get PeachPuff() {\n    let brush = null;\n\n    if (this.sBrushes.containsKey(KnownColor.PeachPuff)) {\n      brush = this.sBrushes.getValue(KnownColor.PeachPuff);\n    }\n\n    if (brush == null) {\n      brush = this.getBrush(KnownColor.PeachPuff);\n    }\n\n    return brush;\n  }\n  /**\n   * Gets the Peru default brush.\n   * @public\n   */\n\n\n  static get Peru() {\n    let brush = null;\n\n    if (this.sBrushes.containsKey(KnownColor.Peru)) {\n      brush = this.sBrushes.getValue(KnownColor.Peru);\n    }\n\n    if (brush == null) {\n      brush = this.getBrush(KnownColor.Peru);\n    }\n\n    return brush;\n  }\n  /**\n   * Gets the Pink default brush.\n   * @public\n   */\n\n\n  static get Pink() {\n    let brush = null;\n\n    if (this.sBrushes.containsKey(KnownColor.Pink)) {\n      brush = this.sBrushes.getValue(KnownColor.Pink);\n    }\n\n    if (brush == null) {\n      brush = this.getBrush(KnownColor.Pink);\n    }\n\n    return brush;\n  }\n  /**\n   * Gets the Plum default brush.\n   * @public\n   */\n\n\n  static get Plum() {\n    let brush = null;\n\n    if (this.sBrushes.containsKey(KnownColor.Plum)) {\n      brush = this.sBrushes.getValue(KnownColor.Plum);\n    }\n\n    if (brush == null) {\n      brush = this.getBrush(KnownColor.Plum);\n    }\n\n    return brush;\n  }\n  /**\n   * Gets the PowderBlue default brush.\n   * @public\n   */\n\n\n  static get PowderBlue() {\n    let brush = null;\n\n    if (this.sBrushes.containsKey(KnownColor.PowderBlue)) {\n      brush = this.sBrushes.getValue(KnownColor.PowderBlue);\n    }\n\n    if (brush == null) {\n      brush = this.getBrush(KnownColor.PowderBlue);\n    }\n\n    return brush;\n  }\n  /**\n   * Gets the Purple default brush.\n   * @public\n   */\n\n\n  static get Purple() {\n    let brush = null;\n\n    if (this.sBrushes.containsKey(KnownColor.Purple)) {\n      brush = this.sBrushes.getValue(KnownColor.Purple);\n    }\n\n    if (brush == null) {\n      brush = this.getBrush(KnownColor.Purple);\n    }\n\n    return brush;\n  }\n  /**\n   * Gets the Red default brush.\n   * @public\n   */\n\n\n  static get Red() {\n    let brush = null;\n\n    if (this.sBrushes.containsKey(KnownColor.Red)) {\n      brush = this.sBrushes.getValue(KnownColor.Red);\n    }\n\n    if (brush == null) {\n      brush = this.getBrush(KnownColor.Red);\n    }\n\n    return brush;\n  }\n  /**\n   * Gets the RosyBrown default brush.\n   * @public\n   */\n\n\n  static get RosyBrown() {\n    let brush = null;\n\n    if (this.sBrushes.containsKey(KnownColor.RosyBrown)) {\n      brush = this.sBrushes.getValue(KnownColor.RosyBrown);\n    }\n\n    if (brush == null) {\n      brush = this.getBrush(KnownColor.RosyBrown);\n    }\n\n    return brush;\n  }\n  /**\n   * Gets the RoyalBlue default brush.\n   * @public\n   */\n\n\n  static get RoyalBlue() {\n    let brush = null;\n\n    if (this.sBrushes.containsKey(KnownColor.RoyalBlue)) {\n      brush = this.sBrushes.getValue(KnownColor.RoyalBlue);\n    }\n\n    if (brush == null) {\n      brush = this.getBrush(KnownColor.RoyalBlue);\n    }\n\n    return brush;\n  }\n  /**\n   * Gets the SaddleBrown default brush.\n   * @public\n   */\n\n\n  static get SaddleBrown() {\n    let brush = null;\n\n    if (this.sBrushes.containsKey(KnownColor.SaddleBrown)) {\n      brush = this.sBrushes.getValue(KnownColor.SaddleBrown);\n    }\n\n    if (brush == null) {\n      brush = this.getBrush(KnownColor.SaddleBrown);\n    }\n\n    return brush;\n  }\n  /**\n   * Gets the Salmon default brush.\n   * @public\n   */\n\n\n  static get Salmon() {\n    let brush = null;\n\n    if (this.sBrushes.containsKey(KnownColor.Salmon)) {\n      brush = this.sBrushes.getValue(KnownColor.Salmon);\n    }\n\n    if (brush == null) {\n      brush = this.getBrush(KnownColor.Salmon);\n    }\n\n    return brush;\n  }\n  /**\n   * Gets the SandyBrown default brush.\n   * @public\n   */\n\n\n  static get SandyBrown() {\n    let brush = null;\n\n    if (this.sBrushes.containsKey(KnownColor.SandyBrown)) {\n      brush = this.sBrushes.getValue(KnownColor.SandyBrown);\n    }\n\n    if (brush == null) {\n      brush = this.getBrush(KnownColor.SandyBrown);\n    }\n\n    return brush;\n  }\n  /**\n   * Gets the SeaGreen default brush.\n   * @public\n   */\n\n\n  static get SeaGreen() {\n    let brush = null;\n\n    if (this.sBrushes.containsKey(KnownColor.SeaGreen)) {\n      brush = this.sBrushes.getValue(KnownColor.SeaGreen);\n    }\n\n    if (brush == null) {\n      brush = this.getBrush(KnownColor.SeaGreen);\n    }\n\n    return brush;\n  }\n  /**\n   * Gets the SeaShell default brush.\n   * @public\n   */\n\n\n  static get SeaShell() {\n    let brush = null;\n\n    if (this.sBrushes.containsKey(KnownColor.SeaShell)) {\n      brush = this.sBrushes.getValue(KnownColor.SeaShell);\n    }\n\n    if (brush == null) {\n      brush = this.getBrush(KnownColor.SeaShell);\n    }\n\n    return brush;\n  }\n  /**\n   * Gets the Sienna default brush.\n   * @public\n   */\n\n\n  static get Sienna() {\n    let brush = null;\n\n    if (this.sBrushes.containsKey(KnownColor.Sienna)) {\n      brush = this.sBrushes.getValue(KnownColor.Sienna);\n    }\n\n    if (brush == null) {\n      brush = this.getBrush(KnownColor.Sienna);\n    }\n\n    return brush;\n  }\n  /**\n   * Gets the Silver default brush.\n   * @public\n   */\n\n\n  static get Silver() {\n    let brush = null;\n\n    if (this.sBrushes.containsKey(KnownColor.Silver)) {\n      brush = this.sBrushes.getValue(KnownColor.Silver);\n    }\n\n    if (brush == null) {\n      brush = this.getBrush(KnownColor.Silver);\n    }\n\n    return brush;\n  }\n  /**\n   * Gets the SkyBlue default brush.\n   * @public\n   */\n\n\n  static get SkyBlue() {\n    let brush = null;\n\n    if (this.sBrushes.containsKey(KnownColor.SkyBlue)) {\n      brush = this.sBrushes.getValue(KnownColor.SkyBlue);\n    }\n\n    if (brush == null) {\n      brush = this.getBrush(KnownColor.SkyBlue);\n    }\n\n    return brush;\n  }\n  /**\n   * Gets the SlateBlue default brush.\n   * @public\n   */\n\n\n  static get SlateBlue() {\n    let brush = null;\n\n    if (this.sBrushes.containsKey(KnownColor.SlateBlue)) {\n      brush = this.sBrushes.getValue(KnownColor.SlateBlue);\n    }\n\n    if (brush == null) {\n      brush = this.getBrush(KnownColor.SlateBlue);\n    }\n\n    return brush;\n  }\n  /**\n   * Gets the SlateGray default brush.\n   * @public\n   */\n\n\n  static get SlateGray() {\n    let brush = null;\n\n    if (this.sBrushes.containsKey(KnownColor.SlateGray)) {\n      brush = this.sBrushes.getValue(KnownColor.SlateGray);\n    }\n\n    if (brush == null) {\n      brush = this.getBrush(KnownColor.SlateGray);\n    }\n\n    return brush;\n  }\n  /**\n   * Gets the Snow default brush.\n   * @public\n   */\n\n\n  static get Snow() {\n    let brush = null;\n\n    if (this.sBrushes.containsKey(KnownColor.Snow)) {\n      brush = this.sBrushes.getValue(KnownColor.Snow);\n    }\n\n    if (brush == null) {\n      brush = this.getBrush(KnownColor.Snow);\n    }\n\n    return brush;\n  }\n  /**\n   * Gets the SpringGreen default brush.\n   * @public\n   */\n\n\n  static get SpringGreen() {\n    let brush = null;\n\n    if (this.sBrushes.containsKey(KnownColor.SpringGreen)) {\n      brush = this.sBrushes.getValue(KnownColor.SpringGreen);\n    }\n\n    if (brush == null) {\n      brush = this.getBrush(KnownColor.SpringGreen);\n    }\n\n    return brush;\n  }\n  /**\n   * Gets the SteelBlue default brush.\n   * @public\n   */\n\n\n  static get SteelBlue() {\n    let brush = null;\n\n    if (this.sBrushes.containsKey(KnownColor.SteelBlue)) {\n      brush = this.sBrushes.getValue(KnownColor.SteelBlue);\n    }\n\n    if (brush == null) {\n      brush = this.getBrush(KnownColor.SteelBlue);\n    }\n\n    return brush;\n  }\n  /**\n   * Gets the Tan default brush.\n   * @public\n   */\n\n\n  static get Tan() {\n    let brush = null;\n\n    if (this.sBrushes.containsKey(KnownColor.Tan)) {\n      brush = this.sBrushes.getValue(KnownColor.Tan);\n    }\n\n    if (brush == null) {\n      brush = this.getBrush(KnownColor.Tan);\n    }\n\n    return brush;\n  }\n  /**\n   * Gets the Teal default brush.\n   * @public\n   */\n\n\n  static get Teal() {\n    let brush = null;\n\n    if (this.sBrushes.containsKey(KnownColor.Teal)) {\n      brush = this.sBrushes.getValue(KnownColor.Teal);\n    }\n\n    if (brush == null) {\n      brush = this.getBrush(KnownColor.Teal);\n    }\n\n    return brush;\n  }\n  /**\n   * Gets the Thistle default brush.\n   * @public\n   */\n\n\n  static get Thistle() {\n    let brush = null;\n\n    if (this.sBrushes.containsKey(KnownColor.Thistle)) {\n      brush = this.sBrushes.getValue(KnownColor.Thistle);\n    }\n\n    if (brush == null) {\n      brush = this.getBrush(KnownColor.Thistle);\n    }\n\n    return brush;\n  }\n  /**\n   * Gets the Tomato default brush.\n   * @public\n   */\n\n\n  static get Tomato() {\n    let brush = null;\n\n    if (this.sBrushes.containsKey(KnownColor.Tomato)) {\n      brush = this.sBrushes.getValue(KnownColor.Tomato);\n    }\n\n    if (brush == null) {\n      brush = this.getBrush(KnownColor.Tomato);\n    }\n\n    return brush;\n  }\n  /**\n   * Gets the Transparent default brush.\n   * @public\n   */\n\n\n  static get Transparent() {\n    let brush = null;\n\n    if (this.sBrushes.containsKey(KnownColor.Transparent)) {\n      brush = this.sBrushes.getValue(KnownColor.Transparent);\n    }\n\n    if (brush == null) {\n      brush = this.getBrush(KnownColor.Transparent);\n    }\n\n    return brush;\n  }\n  /**\n   * Gets the Turquoise default brush.\n   * @public\n   */\n\n\n  static get Turquoise() {\n    let brush = null;\n\n    if (this.sBrushes.containsKey(KnownColor.Turquoise)) {\n      brush = this.sBrushes.getValue(KnownColor.Turquoise);\n    }\n\n    if (brush == null) {\n      brush = this.getBrush(KnownColor.Turquoise);\n    }\n\n    return brush;\n  }\n  /**\n   * Gets the Violet default brush.\n   * @public\n   */\n\n\n  static get Violet() {\n    let brush = null;\n\n    if (this.sBrushes.containsKey(KnownColor.Violet)) {\n      brush = this.sBrushes.getValue(KnownColor.Violet);\n    }\n\n    if (brush == null) {\n      brush = this.getBrush(KnownColor.Violet);\n    }\n\n    return brush;\n  }\n  /**\n   * Gets the Wheat default brush.\n   * @public\n   */\n\n\n  static get Wheat() {\n    let brush = null;\n\n    if (this.sBrushes.containsKey(KnownColor.Wheat)) {\n      brush = this.sBrushes.getValue(KnownColor.Wheat);\n    }\n\n    if (brush == null) {\n      brush = this.getBrush(KnownColor.Wheat);\n    }\n\n    return brush;\n  }\n  /**\n   * Gets the White default brush.\n   * @public\n   */\n\n\n  static get White() {\n    let brush = null;\n\n    if (this.sBrushes.containsKey(KnownColor.White)) {\n      brush = this.sBrushes.getValue(KnownColor.White);\n    }\n\n    if (brush == null) {\n      brush = this.getBrush(KnownColor.White);\n    }\n\n    return brush;\n  }\n  /**\n   * Gets the WhiteSmoke default brush.\n   * @public\n   */\n\n\n  static get WhiteSmoke() {\n    let brush = null;\n\n    if (this.sBrushes.containsKey(KnownColor.WhiteSmoke)) {\n      brush = this.sBrushes.getValue(KnownColor.WhiteSmoke);\n    }\n\n    if (brush == null) {\n      brush = this.getBrush(KnownColor.WhiteSmoke);\n    }\n\n    return brush;\n  }\n  /**\n   * Gets the Yellow default brush.\n   * @public\n   */\n\n\n  static get Yellow() {\n    let brush = null;\n\n    if (this.sBrushes.containsKey(KnownColor.Yellow)) {\n      brush = this.sBrushes.getValue(KnownColor.Yellow);\n    }\n\n    if (brush == null) {\n      brush = this.getBrush(KnownColor.Yellow);\n    }\n\n    return brush;\n  }\n  /**\n   * Gets the YellowGreen default brush.\n   * @public\n   */\n\n\n  static get YellowGreen() {\n    let brush = null;\n\n    if (this.sBrushes.containsKey(KnownColor.YellowGreen)) {\n      brush = this.sBrushes.getValue(KnownColor.YellowGreen);\n    }\n\n    if (brush == null) {\n      brush = this.getBrush(KnownColor.YellowGreen);\n    }\n\n    return brush;\n  }\n  /**\n   * Get the brush.\n   */\n\n\n  static getBrush(colorName) {\n    let pdfColor = this.getColorValue(colorName);\n    let brush = new PdfSolidBrush(pdfColor);\n    this.sBrushes.setValue(colorName, brush);\n    return brush;\n  }\n  /**\n   * Get the color value.\n   * @param colorName The KnownColor name.\n   */\n\n  /* tslint:disable */\n\n\n  static getColorValue(colorName) {\n    let color = new PdfColor();\n\n    switch (colorName) {\n      case KnownColor.Transparent:\n        color = new PdfColor(0, 255, 255, 255);\n        break;\n\n      case KnownColor.AliceBlue:\n        color = new PdfColor(255, 240, 248, 255);\n        break;\n\n      case KnownColor.AntiqueWhite:\n        color = new PdfColor(255, 250, 235, 215);\n        break;\n\n      case KnownColor.Aqua:\n        color = new PdfColor(255, 0, 255, 255);\n        break;\n\n      case KnownColor.Aquamarine:\n        color = new PdfColor(255, 127, 255, 212);\n        break;\n\n      case KnownColor.Azure:\n        color = new PdfColor(255, 240, 255, 255);\n        break;\n\n      case KnownColor.Beige:\n        color = new PdfColor(255, 245, 245, 220);\n        break;\n\n      case KnownColor.Bisque:\n        color = new PdfColor(255, 255, 228, 196);\n        break;\n\n      case KnownColor.Black:\n        color = new PdfColor(255, 0, 0, 0);\n        break;\n\n      case KnownColor.BlanchedAlmond:\n        color = new PdfColor(255, 255, 235, 205);\n        break;\n\n      case KnownColor.Blue:\n        color = new PdfColor(255, 0, 0, 255);\n        break;\n\n      case KnownColor.BlueViolet:\n        color = new PdfColor(255, 138, 43, 226);\n        break;\n\n      case KnownColor.Brown:\n        color = new PdfColor(255, 165, 42, 42);\n        break;\n\n      case KnownColor.BurlyWood:\n        color = new PdfColor(255, 222, 184, 135);\n        break;\n\n      case KnownColor.CadetBlue:\n        color = new PdfColor(255, 95, 158, 160);\n        break;\n\n      case KnownColor.Chartreuse:\n        color = new PdfColor(255, 127, 255, 0);\n        break;\n\n      case KnownColor.Chocolate:\n        color = new PdfColor(255, 210, 105, 30);\n        break;\n\n      case KnownColor.Coral:\n        color = new PdfColor(255, 255, 127, 80);\n        break;\n\n      case KnownColor.CornflowerBlue:\n        color = new PdfColor(255, 100, 149, 237);\n        break;\n\n      case KnownColor.Cornsilk:\n        color = new PdfColor(255, 255, 248, 220);\n        break;\n\n      case KnownColor.Crimson:\n        color = new PdfColor(255, 220, 20, 60);\n        break;\n\n      case KnownColor.Cyan:\n        color = new PdfColor(255, 0, 255, 255);\n        break;\n\n      case KnownColor.DarkBlue:\n        color = new PdfColor(255, 0, 0, 139);\n        break;\n\n      case KnownColor.DarkCyan:\n        color = new PdfColor(255, 0, 139, 139);\n        break;\n\n      case KnownColor.DarkGoldenrod:\n        color = new PdfColor(255, 184, 134, 11);\n        break;\n\n      case KnownColor.DarkGray:\n        color = new PdfColor(255, 169, 169, 169);\n        break;\n\n      case KnownColor.DarkGreen:\n        color = new PdfColor(255, 0, 100, 0);\n        break;\n\n      case KnownColor.DarkKhaki:\n        color = new PdfColor(255, 189, 183, 107);\n        break;\n\n      case KnownColor.DarkMagenta:\n        color = new PdfColor(255, 139, 0, 139);\n        break;\n\n      case KnownColor.DarkOliveGreen:\n        color = new PdfColor(255, 85, 107, 47);\n        break;\n\n      case KnownColor.DarkOrange:\n        color = new PdfColor(255, 255, 140, 0);\n        break;\n\n      case KnownColor.DarkOrchid:\n        color = new PdfColor(255, 153, 50, 204);\n        break;\n\n      case KnownColor.DarkRed:\n        color = new PdfColor(255, 139, 0, 0);\n        break;\n\n      case KnownColor.DarkSalmon:\n        color = new PdfColor(255, 233, 150, 122);\n        break;\n\n      case KnownColor.DarkSeaGreen:\n        color = new PdfColor(255, 143, 188, 139);\n        break;\n\n      case KnownColor.DarkSlateBlue:\n        color = new PdfColor(255, 72, 61, 139);\n        break;\n\n      case KnownColor.DarkSlateGray:\n        color = new PdfColor(255, 47, 79, 79);\n        break;\n\n      case KnownColor.DarkTurquoise:\n        color = new PdfColor(255, 0, 206, 209);\n        break;\n\n      case KnownColor.DarkViolet:\n        color = new PdfColor(255, 148, 0, 211);\n        break;\n\n      case KnownColor.DeepPink:\n        color = new PdfColor(255, 255, 20, 147);\n        break;\n\n      case KnownColor.DeepSkyBlue:\n        color = new PdfColor(255, 0, 191, 255);\n        break;\n\n      case KnownColor.DimGray:\n        color = new PdfColor(255, 105, 105, 105);\n        break;\n\n      case KnownColor.DodgerBlue:\n        color = new PdfColor(255, 30, 144, 255);\n        break;\n\n      case KnownColor.Firebrick:\n        color = new PdfColor(255, 178, 34, 34);\n        break;\n\n      case KnownColor.FloralWhite:\n        color = new PdfColor(255, 255, 250, 240);\n        break;\n\n      case KnownColor.ForestGreen:\n        color = new PdfColor(255, 34, 139, 34);\n        break;\n\n      case KnownColor.Fuchsia:\n        color = new PdfColor(255, 255, 0, 255);\n        break;\n\n      case KnownColor.Gainsboro:\n        color = new PdfColor(255, 220, 220, 220);\n        break;\n\n      case KnownColor.GhostWhite:\n        color = new PdfColor(255, 248, 248, 255);\n        break;\n\n      case KnownColor.Gold:\n        color = new PdfColor(255, 255, 215, 0);\n        break;\n\n      case KnownColor.Goldenrod:\n        color = new PdfColor(255, 218, 165, 32);\n        break;\n\n      case KnownColor.Gray:\n        color = new PdfColor(255, 128, 128, 128);\n        break;\n\n      case KnownColor.Green:\n        color = new PdfColor(255, 0, 128, 0);\n        break;\n\n      case KnownColor.GreenYellow:\n        color = new PdfColor(255, 173, 255, 47);\n        break;\n\n      case KnownColor.Honeydew:\n        color = new PdfColor(255, 240, 255, 240);\n        break;\n\n      case KnownColor.HotPink:\n        color = new PdfColor(255, 255, 105, 180);\n        break;\n\n      case KnownColor.IndianRed:\n        color = new PdfColor(255, 205, 92, 92);\n        break;\n\n      case KnownColor.Indigo:\n        color = new PdfColor(255, 75, 0, 130);\n        break;\n\n      case KnownColor.Ivory:\n        color = new PdfColor(255, 255, 255, 240);\n        break;\n\n      case KnownColor.Khaki:\n        color = new PdfColor(255, 240, 230, 140);\n        break;\n\n      case KnownColor.Lavender:\n        color = new PdfColor(255, 230, 230, 250);\n        break;\n\n      case KnownColor.LavenderBlush:\n        color = new PdfColor(255, 255, 240, 245);\n        break;\n\n      case KnownColor.LawnGreen:\n        color = new PdfColor(255, 124, 252, 0);\n        break;\n\n      case KnownColor.LemonChiffon:\n        color = new PdfColor(255, 255, 250, 205);\n        break;\n\n      case KnownColor.LightBlue:\n        color = new PdfColor(255, 173, 216, 230);\n        break;\n\n      case KnownColor.LightCoral:\n        color = new PdfColor(255, 240, 128, 128);\n        break;\n\n      case KnownColor.LightCyan:\n        color = new PdfColor(255, 224, 255, 255);\n        break;\n\n      case KnownColor.LightGoldenrodYellow:\n        color = new PdfColor(255, 250, 250, 210);\n        break;\n\n      case KnownColor.LightGreen:\n        color = new PdfColor(255, 144, 238, 144);\n        break;\n\n      case KnownColor.LightGray:\n        color = new PdfColor(255, 211, 211, 211);\n        break;\n\n      case KnownColor.LightPink:\n        color = new PdfColor(255, 255, 182, 193);\n        break;\n\n      case KnownColor.LightSalmon:\n        color = new PdfColor(255, 255, 160, 122);\n        break;\n\n      case KnownColor.LightSeaGreen:\n        color = new PdfColor(255, 32, 178, 170);\n        break;\n\n      case KnownColor.LightSkyBlue:\n        color = new PdfColor(255, 135, 206, 250);\n        break;\n\n      case KnownColor.LightSlateGray:\n        color = new PdfColor(255, 119, 136, 153);\n        break;\n\n      case KnownColor.LightSteelBlue:\n        color = new PdfColor(255, 176, 196, 222);\n        break;\n\n      case KnownColor.LightYellow:\n        color = new PdfColor(255, 255, 255, 224);\n        break;\n\n      case KnownColor.Lime:\n        color = new PdfColor(255, 0, 255, 0);\n        break;\n\n      case KnownColor.LimeGreen:\n        color = new PdfColor(255, 50, 205, 50);\n        break;\n\n      case KnownColor.Linen:\n        color = new PdfColor(255, 250, 240, 230);\n        break;\n\n      case KnownColor.Magenta:\n        color = new PdfColor(255, 255, 0, 255);\n        break;\n\n      case KnownColor.Maroon:\n        color = new PdfColor(255, 128, 0, 0);\n        break;\n\n      case KnownColor.MediumAquamarine:\n        color = new PdfColor(255, 102, 205, 170);\n        break;\n\n      case KnownColor.MediumBlue:\n        color = new PdfColor(255, 0, 0, 205);\n        break;\n\n      case KnownColor.MediumOrchid:\n        color = new PdfColor(255, 186, 85, 211);\n        break;\n\n      case KnownColor.MediumPurple:\n        color = new PdfColor(255, 147, 112, 219);\n        break;\n\n      case KnownColor.MediumSeaGreen:\n        color = new PdfColor(255, 60, 179, 113);\n        break;\n\n      case KnownColor.MediumSlateBlue:\n        color = new PdfColor(255, 123, 104, 238);\n        break;\n\n      case KnownColor.MediumSpringGreen:\n        color = new PdfColor(255, 0, 250, 154);\n        break;\n\n      case KnownColor.MediumTurquoise:\n        color = new PdfColor(255, 72, 209, 204);\n        break;\n\n      case KnownColor.MediumVioletRed:\n        color = new PdfColor(255, 199, 21, 133);\n        break;\n\n      case KnownColor.MidnightBlue:\n        color = new PdfColor(255, 25, 25, 112);\n        break;\n\n      case KnownColor.MintCream:\n        color = new PdfColor(255, 245, 255, 250);\n        break;\n\n      case KnownColor.MistyRose:\n        color = new PdfColor(255, 255, 228, 225);\n        break;\n\n      case KnownColor.Moccasin:\n        color = new PdfColor(255, 255, 228, 181);\n        break;\n\n      case KnownColor.NavajoWhite:\n        color = new PdfColor(255, 255, 222, 173);\n        break;\n\n      case KnownColor.Navy:\n        color = new PdfColor(255, 0, 0, 128);\n        break;\n\n      case KnownColor.OldLace:\n        color = new PdfColor(255, 253, 245, 230);\n        break;\n\n      case KnownColor.Olive:\n        color = new PdfColor(255, 128, 128, 0);\n        break;\n\n      case KnownColor.OliveDrab:\n        color = new PdfColor(255, 107, 142, 35);\n        break;\n\n      case KnownColor.Orange:\n        color = new PdfColor(255, 255, 165, 0);\n        break;\n\n      case KnownColor.OrangeRed:\n        color = new PdfColor(255, 255, 69, 0);\n        break;\n\n      case KnownColor.Orchid:\n        color = new PdfColor(255, 218, 112, 214);\n        break;\n\n      case KnownColor.PaleGoldenrod:\n        color = new PdfColor(255, 238, 232, 170);\n        break;\n\n      case KnownColor.PaleGreen:\n        color = new PdfColor(255, 152, 251, 152);\n        break;\n\n      case KnownColor.PaleTurquoise:\n        color = new PdfColor(255, 175, 238, 238);\n        break;\n\n      case KnownColor.PaleVioletRed:\n        color = new PdfColor(255, 219, 112, 147);\n        break;\n\n      case KnownColor.PapayaWhip:\n        color = new PdfColor(255, 255, 239, 213);\n        break;\n\n      case KnownColor.PeachPuff:\n        color = new PdfColor(255, 255, 218, 185);\n        break;\n\n      case KnownColor.Peru:\n        color = new PdfColor(255, 205, 133, 63);\n        break;\n\n      case KnownColor.Pink:\n        color = new PdfColor(255, 255, 192, 203);\n        break;\n\n      case KnownColor.Plum:\n        color = new PdfColor(255, 221, 160, 221);\n        break;\n\n      case KnownColor.PowderBlue:\n        color = new PdfColor(255, 176, 224, 230);\n        break;\n\n      case KnownColor.Purple:\n        color = new PdfColor(255, 128, 0, 128);\n        break;\n\n      case KnownColor.Red:\n        color = new PdfColor(255, 255, 0, 0);\n        break;\n\n      case KnownColor.RosyBrown:\n        color = new PdfColor(255, 188, 143, 143);\n        break;\n\n      case KnownColor.RoyalBlue:\n        color = new PdfColor(255, 65, 105, 225);\n        break;\n\n      case KnownColor.SaddleBrown:\n        color = new PdfColor(255, 139, 69, 19);\n        break;\n\n      case KnownColor.Salmon:\n        color = new PdfColor(255, 250, 128, 114);\n        break;\n\n      case KnownColor.SandyBrown:\n        color = new PdfColor(255, 244, 164, 96);\n        break;\n\n      case KnownColor.SeaGreen:\n        color = new PdfColor(255, 46, 139, 87);\n        break;\n\n      case KnownColor.SeaShell:\n        color = new PdfColor(255, 255, 245, 238);\n        break;\n\n      case KnownColor.Sienna:\n        color = new PdfColor(255, 160, 82, 45);\n        break;\n\n      case KnownColor.Silver:\n        color = new PdfColor(255, 192, 192, 192);\n        break;\n\n      case KnownColor.SkyBlue:\n        color = new PdfColor(255, 135, 206, 235);\n        break;\n\n      case KnownColor.SlateBlue:\n        color = new PdfColor(255, 106, 90, 205);\n        break;\n\n      case KnownColor.SlateGray:\n        color = new PdfColor(255, 112, 128, 144);\n        break;\n\n      case KnownColor.Snow:\n        color = new PdfColor(255, 255, 250, 250);\n        break;\n\n      case KnownColor.SpringGreen:\n        color = new PdfColor(255, 0, 255, 127);\n        break;\n\n      case KnownColor.SteelBlue:\n        color = new PdfColor(255, 70, 130, 180);\n        break;\n\n      case KnownColor.Tan:\n        color = new PdfColor(255, 210, 180, 140);\n        break;\n\n      case KnownColor.Teal:\n        color = new PdfColor(255, 0, 128, 128);\n        break;\n\n      case KnownColor.Thistle:\n        color = new PdfColor(255, 216, 191, 216);\n        break;\n\n      case KnownColor.Tomato:\n        color = new PdfColor(255, 255, 99, 71);\n        break;\n\n      case KnownColor.Turquoise:\n        color = new PdfColor(255, 64, 224, 208);\n        break;\n\n      case KnownColor.Violet:\n        color = new PdfColor(255, 238, 130, 238);\n        break;\n\n      case KnownColor.Wheat:\n        color = new PdfColor(255, 245, 222, 179);\n        break;\n\n      case KnownColor.White:\n        color = new PdfColor(255, 255, 255, 255);\n        break;\n\n      case KnownColor.WhiteSmoke:\n        color = new PdfColor(255, 245, 245, 245);\n        break;\n\n      case KnownColor.Yellow:\n        color = new PdfColor(255, 255, 255, 0);\n        break;\n\n      case KnownColor.YellowGreen:\n        color = new PdfColor(255, 154, 205, 50);\n        break;\n    }\n\n    return color;\n  }\n\n} //Static Fields\n\n/**\n * Local variable to store the brushes.\n */\n\n\nPdfBrushes.sBrushes = new Dictionary();\n/**\n * PdfBlend.ts class for EJ2-PDF\n */\n\n/**\n * `PdfBlend` Represents the blend color space\n * @private\n */\n\nclass PdfBlend {\n  constructor(count) {\n    //Constants\n\n    /**\n     * precision of the GCD calculations.\n     * @private\n     */\n    this.precision = 1000; //\n  } //Properties\n\n  /**\n   * Gets or sets the array of factor to the blend.\n   * @public\n   */\n\n\n  get factors() {\n    return this.mFactors;\n  }\n\n  set factors(value) {\n    if (value == null) {\n      throw new Error('ArgumentNullException : Factors');\n    }\n\n    this.mFactors = value;\n  }\n  /**\n   * 'positions' Gets or sets the array of positions\n   * @public\n   */\n\n\n  get positions() {\n    return this.mPositions;\n  }\n\n  set positions(value) {\n    let positionarray = value;\n\n    for (let i = 0; i < positionarray.length; i++) {\n      if (positionarray[i] < 0 || positionarray[i] > 1) {\n        positionarray[i] = 0;\n      }\n    }\n\n    this.mPositions = positionarray;\n    this.mPositions = value;\n  }\n  /**\n   * Gets the number of elements that specify the blend.\n   * @protected\n   */\n\n\n  get count() {\n    return this.mCount;\n  } //Implementation\n\n  /**\n   * Generates a correct color blend.\n   * @param colours The colours.\n   * @param colorSpace The color space.\n   */\n\n\n  generateColorBlend(colours, colorSpace) {\n    if (colours == null) {\n      throw new Error('ArgumentNullException : colours');\n    }\n\n    if (this.positions == null) {\n      this.positions = [0];\n    }\n\n    let cBlend = new PdfColorBlend(this.count);\n    let positions = this.positions;\n    let clrs = null;\n\n    if (positions.length === 1) {\n      positions = [3];\n      positions[0] = 0;\n      positions[1] = this.positions[0];\n      positions[2] = 1;\n      /* tslint:disable */\n\n      clrs = new Array(3);\n      clrs[0] = colours[0];\n      clrs[1] = colours[0];\n      clrs[2] = colours[1];\n    } else {\n      let c1 = colours[0];\n      let c2 = colours[1];\n      /* tslint:disable */\n\n      clrs = new Array(this.count);\n      let i = 0;\n      let count = this.count;\n\n      for (i = 0; i < count; ++i) {\n        clrs[i] = this.interpolate(this.mFactors[i], c1, c2, colorSpace);\n      }\n    }\n\n    cBlend.positions = positions;\n    cBlend.colors = clrs;\n    return cBlend;\n  }\n  /**\n   * 'clonePdfBlend' Clones this instance.\n   * @public\n   */\n\n\n  clonePdfBlend() {\n    let blend = this;\n\n    if (this.mFactors != null) {\n      blend.factors = this.mFactors;\n    }\n\n    if (this.positions != null) {\n      blend.positions = this.positions;\n    }\n\n    return blend;\n  }\n\n  gcd(u, v) {\n    if (typeof u === 'number' && typeof v === 'number' && typeof v !== 'undefined') {\n      if (u < 0 || u > 1) {\n        throw new Error('ArgumentOutOfRangeException : u');\n      }\n\n      if (v < 0 || v > 1) {\n        throw new Error('ArgumentOutOfRangeException : v');\n      }\n\n      let iU = Math.max(1, u * this.precision);\n      let iV = Math.max(1, v * this.precision);\n      let iResult = this.gcdInt(iU, iV);\n      let result = iResult / this.precision;\n      return result;\n    } else {\n      let values = u;\n\n      if (values == null) {\n        throw new Error('ArgumentNullException : values');\n      }\n\n      if (values.length < 1) {\n        throw new Error('ArgumentException : Not enough values in the array. - values');\n      }\n\n      let gcd = values[0];\n\n      if (values.length > 1) {\n        let count = values.length;\n\n        for (let i = 1; i < count; ++i) {\n          gcd = this.gcd(values[i], gcd);\n\n          if (gcd === 1 / this.precision) {\n            break;\n          }\n        }\n      }\n\n      return gcd;\n    }\n  }\n  /**\n   * Calculate the GCD int of the specified values.\n   * @param u The u.\n   * @param v The v.\n   */\n\n\n  gcdInt(u, v) {\n    if (u <= 0) {\n      throw new Error('ArgumentOutOfRangeException' + u + 'The arguments cannot be less or equal to zero.');\n    }\n\n    if (v <= 0) {\n      throw new Error('ArgumentOutOfRangeException' + v + 'The arguments cannot be less or equal to zero.');\n    }\n\n    if (u === 1 || v === 1) {\n      return 1;\n    }\n\n    let shift = 0;\n\n    while (this.isEven(u, v)) {\n      ++shift;\n      u >>= 1;\n      v >>= 1;\n    }\n\n    while ((u & 1) <= 0) {\n      u >>= 1;\n    }\n\n    do {\n      while ((v & 1) <= 0) {\n        v >>= 1;\n      }\n\n      if (u > v) {\n        let t = v;\n        v = u;\n        u = t;\n      }\n\n      v = v - u;\n    } while (v !== 0);\n\n    return u << shift;\n  }\n\n  isEven(arg1, arg2) {\n    if (typeof arg2 === 'number' && typeof arg2 !== 'undefined') {\n      let result = true;\n      result = result && (arg1 & 1) <= 0; //  Is u even?\n\n      result = result && (arg2 & 1) <= 0; //  Is v even?\n\n      return result;\n    } else {\n      return (arg1 & 1) <= 0;\n    }\n  }\n\n  interpolate(t, color1, color2, colorSpace) {\n    if (color1 instanceof PdfColor) {\n      let color = new PdfColor();\n\n      switch (colorSpace) {\n        case PdfColorSpace.Rgb:\n          let red = this.interpolate(t, color1.red, color2.red);\n          let green = this.interpolate(t, color1.green, color2.green);\n          let blue = this.interpolate(t, color1.blue, color2.blue);\n          color = new PdfColor(red, green, blue);\n          break;\n\n        case PdfColorSpace.GrayScale:\n          let gray = this.interpolate(t, color1.gray, color2.gray);\n          color = new PdfColor(gray);\n          break;\n\n        case PdfColorSpace.Cmyk:\n          let cyan = this.interpolate(t, color1.c, color2.c);\n          let magenta = this.interpolate(t, color1.m, color2.m);\n          let yellow = this.interpolate(t, color1.y, color2.y);\n          let black = this.interpolate(t, color1.k, color2.k);\n          color = new PdfColor(cyan, magenta, yellow, black);\n          break;\n      }\n\n      return color;\n    } else {\n      let t0 = 0;\n      let t1 = 1;\n      let result = 0;\n\n      if (t === t0) {\n        result = color1;\n      } else if (t === t1) {\n        result = color2;\n      } else {\n        result = color1 + (t - t0) * ((color2 - color1) / (t1 - t0));\n      }\n\n      return result;\n    }\n  }\n\n}\n/**\n * PdfColorBlend.ts class for EJ2-PDF\n */\n\n/**\n * `PdfColorBlend` Represents the arrays of colors and positions used for\n *  interpolating color blending in a multicolor gradient.\n * @private\n */\n\n\nclass PdfColorBlend extends PdfBlend {\n  constructor(count) {\n    super();\n\n    if (typeof count === 'number') {\n      super(count);\n    }\n  } //Properties\n\n  /**\n   * Gets or sets the array of colors.\n   * @public\n   */\n\n\n  get colors() {\n    return this.mcolors;\n  }\n\n  set colors(value) {\n    if (value == null) {\n      throw new Error('ArgumentNullException : Colors');\n    }\n\n    this.mcolors = value;\n  } //Implementation\n\n  /**\n   * Gets the function.\n   * @param colorSpace The color space.\n   * @public\n   */\n\n\n  getFunction(colorSpace) {\n    let domain = [0, 1];\n    let colourComponents = this.getColorComponentsCount(colorSpace);\n    let maxComponentValue = this.getMaxComponentValue(colorSpace);\n    let range = this.setRange(colourComponents, maxComponentValue);\n    let func = null;\n\n    if (this.mbrush == null && typeof this.mbrush === 'undefined') {\n      let sizes = [1];\n      let samplesCount;\n      let step = 1;\n\n      if (this.positions.length === 2) {\n        samplesCount = 2;\n      } else {\n        let positions = this.positions;\n        let intervals = this.getIntervals(positions);\n        let gcd = this.gcd(intervals);\n        step = gcd;\n        samplesCount = 1 / gcd + 1;\n      }\n\n      sizes[0] = samplesCount;\n      let samples = this.getSamplesValues(colorSpace, samplesCount, maxComponentValue, step);\n      func = new PdfSampledFunction(domain, range, sizes, samples);\n      return func;\n    }\n\n    return func;\n  }\n  /**\n   * 'cloneColorBlend' Clones this instance.\n   * @public\n   */\n\n\n  cloneColorBlend() {\n    let cBlend = this;\n\n    if (this.mcolors != null && typeof this.mcolors !== 'undefined') {\n      cBlend.colors = this.mcolors;\n    }\n\n    if (this.positions != null && typeof this.positions !== 'undefined') {\n      cBlend.positions = this.positions;\n    }\n\n    return cBlend;\n  }\n  /**\n   * Sets the range.\n   * @param colourComponents The colour components.\n   * @param maxValue The max value.\n   */\n\n\n  setRange(colourComponents, maxValue) {\n    let range = [colourComponents * 2];\n\n    for (let i = 0; i < colourComponents; ++i) {\n      range[i * 2] = 0;\n      range[i * 2 + 1] = 1;\n    }\n\n    return range;\n  }\n  /**\n   * Calculates the color components count according to colour space.\n   * @param colorSpace The color space.\n   */\n\n\n  getColorComponentsCount(colorSpace) {\n    let count = 0;\n\n    switch (colorSpace) {\n      case PdfColorSpace.Rgb:\n        count = 3;\n        break;\n\n      case PdfColorSpace.Cmyk:\n        count = 4;\n        break;\n\n      case PdfColorSpace.GrayScale:\n        count = 1;\n        break;\n\n      default:\n        throw new Error('ArgumentException - Unsupported color space: ' + colorSpace + ' colorSpace');\n    }\n\n    return count;\n  }\n  /**\n   * Gets samples values for specified colour space.\n   * @param colorSpace The color space.\n   * @param sampleCount The sample count.\n   * @param maxComponentValue The max component value.\n   * @param step The step.\n   */\n\n\n  getSamplesValues(colorSpace, sampleCount, maxComponentValue, step) {\n    let values;\n\n    switch (colorSpace) {\n      case PdfColorSpace.GrayScale:\n        values = this.getGrayscaleSamples(sampleCount, maxComponentValue, step);\n        break;\n\n      case PdfColorSpace.Cmyk:\n        values = this.getCmykSamples(sampleCount, maxComponentValue, step);\n        break;\n\n      case PdfColorSpace.Rgb:\n        values = this.getRgbSamples(sampleCount, maxComponentValue, step);\n        break;\n\n      default:\n        throw new Error('ArgumentException - Unsupported color space: ' + colorSpace + ' colorSpace');\n    }\n\n    return values;\n  }\n  /**\n   * Gets the grayscale samples.\n   * @param sampleCount The sample count.\n   * @param maxComponentValue The max component value.\n   * @param step The step.\n   */\n\n\n  getGrayscaleSamples(sampleCount, maxComponentValue, step) {\n    let values = [sampleCount * 2];\n\n    for (let i = 0; i < sampleCount; ++i) {\n      let color = this.getNextColor(i, step, PdfColorSpace.GrayScale);\n    }\n\n    return values;\n  }\n  /**\n   * Gets the RGB samples.\n   * @param sampleCount The sample count.\n   * @param maxComponentValue The max component value.\n   * @param step The step.\n   */\n\n\n  getRgbSamples(sampleCount, maxComponentValue, step) {\n    let values = [sampleCount * 3];\n\n    for (let i = 0; i < sampleCount; ++i) {\n      let color = this.getNextColor(i, step, PdfColorSpace.Rgb);\n      let index = i * 3;\n      values[index] = color.r;\n      values[index + 1] = color.g;\n      values[index + 2] = color.b;\n    }\n\n    return values;\n  }\n  /**\n   * Gets the CMYK samples.\n   * @param sampleCount The sample count.\n   * @param maxComponentValue The max component value.\n   * @param step The step.\n   */\n\n\n  getCmykSamples(sampleCount, maxComponentValue, step) {\n    let values = [sampleCount * 4];\n\n    for (let i = 0; i < sampleCount; i++) {\n      let color = this.getNextColor(i, step, PdfColorSpace.Cmyk);\n      let index = i * 4;\n      values[index] = color.c * maxComponentValue;\n      values[index + 1] = color.m * maxComponentValue;\n      values[index + 2] = color.y * maxComponentValue;\n      values[index + 3] = color.k * maxComponentValue;\n    }\n\n    return values;\n  }\n  /**\n   * Calculates the color that should be at the specified index.\n   * @param index The index.\n   * @param step The step.\n   * @param colorSpace The color space.\n   */\n\n\n  getNextColor(index, step, colorSpace) {\n    let position = step * index;\n    let indexHi;\n    let indexLow;\n    let result = this.getIndices(position, indexLow, indexHi);\n    indexLow = result.indexLow;\n    indexHi = result.indexHi;\n    let color;\n\n    if (indexLow === indexHi) {\n      color = this.mcolors[indexLow];\n    } else {\n      let positionLow = this.positions[indexLow];\n      let positionHi = this.positions[indexHi];\n      let colorLow = this.mcolors[indexLow];\n      let colorHi = this.mcolors[indexHi];\n      let t = (position - positionLow) / (positionHi - positionLow);\n      color = this.interpolate(t, colorLow, colorHi, colorSpace);\n    }\n\n    return color;\n  }\n  /**\n   * Gets the indices.\n   * @param position The position.\n   * @param indexLow The index low.\n   * @param indexHi The index hi.\n   */\n\n\n  getIndices(position, indexLow, indexHi) {\n    let positions = this.positions;\n    indexLow = 0;\n    indexHi = 0;\n\n    for (let i = 0; i < this.mcolors.length; ++i) {\n      let currPos = positions[i];\n\n      if (currPos === position) {\n        indexHi = i;\n        indexLow = i;\n        break;\n      } else if (currPos > position) {\n        indexHi = i;\n        break;\n      }\n\n      indexLow = i;\n      indexHi = i;\n    }\n\n    return {\n      indexLow: indexLow,\n      indexHi: indexHi\n    };\n  }\n  /**\n   * Calculates the max component value.\n   * @param colorSpace The color space.\n   */\n\n\n  getMaxComponentValue(colorSpace) {\n    let result = 0;\n\n    switch (colorSpace) {\n      case PdfColorSpace.Cmyk:\n      case PdfColorSpace.Rgb:\n        result = 255;\n        break;\n\n      case PdfColorSpace.GrayScale:\n        result = 65535;\n        break;\n\n      default:\n        throw new Error('ArgumentException - Unsupported color space: ' + colorSpace + 'colorSpace');\n    }\n\n    return result;\n  }\n  /**\n   * Gets an intervals array from the positions array.\n   * @param positions The positions array.\n   */\n\n\n  getIntervals(positions) {\n    let count = positions.length;\n    let intervals = [count - 1];\n    let prev = positions[0];\n\n    for (let i = 1; i < count; ++i) {\n      let v = positions[i];\n      intervals[i - 1] = v - prev;\n      prev = v;\n    }\n\n    return intervals;\n  }\n\n}\n/**\n * PdfLinearGradientBrush.ts class for EJ2-PDF\n */\n\n/**\n * `PdfLinearGradientBrush` Implements linear gradient brush by using PDF axial shading pattern.\n * @private\n */\n\n\nclass PdfLinearGradientBrush extends PdfGradientBrush {\n  /**\n   * Initializes a new instance of the `PdfLinearGradientBrush` class.\n   * @public\n   */\n\n  /* tslint:disable-next-line:max-line-length */\n  constructor(arg1, arg2, arg3, arg4) {\n    super(new PdfDictionary());\n    /**\n     * Local variable to store the dictionary properties.\n     * @private\n     */\n\n    this.mDictionaryProperties = new DictionaryProperties();\n\n    if (arg1 instanceof PointF && arg2 instanceof PointF && arg3 instanceof PdfColor && arg4 instanceof PdfColor) {\n      this.initialize(arg3, arg4);\n      this.mPointStart = arg1;\n      this.mPointEnd = arg2;\n      this.setPoints(this.mPointStart, this.mPointEnd);\n    } else if (arg1 instanceof Rectangle) {\n      this.initialize(arg2, arg3);\n      /* tslint:disable-next-line:max-line-length */\n\n      if (arg4 === PdfLinearGradientMode.BackwardDiagonal || arg4 === PdfLinearGradientMode.ForwardDiagonal || arg4 === PdfLinearGradientMode.Horizontal || arg4 === PdfLinearGradientMode.Vertical) {\n        this.mBoundaries = arg1;\n\n        switch (arg4) {\n          case PdfLinearGradientMode.BackwardDiagonal:\n            this.mPointStart = new PointF(arg1.right, arg1.top);\n            this.mPointEnd = new PointF(arg1.left, arg1.bottom);\n            break;\n\n          case PdfLinearGradientMode.ForwardDiagonal:\n            this.mPointStart = new PointF(arg1.left, arg1.top);\n            this.mPointEnd = new PointF(arg1.right, arg1.bottom);\n            break;\n\n          case PdfLinearGradientMode.Horizontal:\n            this.mPointStart = new PointF(arg1.left, arg1.top);\n            this.mPointEnd = new PointF(arg1.right, arg1.top);\n            break;\n\n          case PdfLinearGradientMode.Vertical:\n            this.mPointStart = new PointF(arg1.left, arg1.top);\n            this.mPointEnd = new PointF(arg1.left, arg1.bottom);\n            break;\n\n          default:\n            throw new Error('ArgumentException -- Unsupported linear gradient mode: ' + arg4 + ' mode');\n        }\n\n        this.setPoints(this.mPointStart, this.mPointEnd);\n      } else if (typeof arg4 === 'number' && typeof arg4 !== 'undefined') {\n        this.mBoundaries = arg1;\n        arg4 = arg4 % 360;\n\n        if (arg4 === 0) {\n          this.mPointStart = new PointF(arg1.left, arg1.top);\n          this.mPointEnd = new PointF(arg1.right, arg1.top);\n        } else if (arg4 === 90) {\n          this.mPointStart = new PointF(arg1.left, arg1.top);\n          this.mPointEnd = new PointF(arg1.left, arg1.bottom);\n        } else if (arg4 === 180) {\n          this.mPointEnd = new PointF(arg1.left, arg1.top);\n          this.mPointStart = new PointF(arg1.right, arg1.top);\n        } else if (arg4 === 270) {\n          this.mPointEnd = new PointF(arg1.left, arg1.top);\n          this.mPointStart = new PointF(arg1.left, arg1.bottom);\n        } else {\n          let d2r = Math.PI / 180;\n          let radAngle = arg4 * d2r;\n          let k = Math.tan(radAngle);\n          let x = this.mBoundaries.left + (this.mBoundaries.right - this.mBoundaries.left) / 2;\n          let y = this.mBoundaries.top + (this.mBoundaries.bottom - this.mBoundaries.top) / 2;\n          let centre = new PointF(x, y);\n          x = this.mBoundaries.width / (2 * Math.cos(radAngle));\n          y = k * x;\n          x = x + centre.x;\n          y = y + centre.y;\n          let p1 = new PointF(x, y);\n          let cp1 = this.subPoints(p1, centre); //  P1 - P0\n\n          let p = this.choosePoint(arg4);\n          let coef = this.mulPoints(this.subPoints(p, centre), cp1) / this.mulPoints(cp1, cp1);\n          this.mPointEnd = this.addPoints(centre, this.mulPoint(cp1, coef)); //  Parametric line equation.\n\n          this.mPointStart = this.addPoints(centre, this.mulPoint(cp1, coef * -1));\n        }\n\n        this.setPoints(this.mPointEnd, this.mPointStart);\n      }\n    }\n  }\n  /**\n   * Initializes a new instance of the `PdfLinearGradientBrush` class.\n   * @param color1 The starting color of the gradient.\n   * @param color2 The end color of the gradient.\n   */\n\n\n  initialize(color1, color2) {\n    this.mColours = [color1, color2];\n    this.mColourBlend = new PdfColorBlend(2);\n    this.mColourBlend.positions = [0, 1];\n    this.mColourBlend.colors = this.mColours;\n    this.initShading();\n  } //Properties\n\n  /**\n   * Gets or sets a PdfBlend that specifies positions\n   * and factors that define a custom falloff for the gradient.\n   * @public\n   */\n\n\n  get blend() {\n    return this.mBlend;\n  }\n\n  set blend(value) {\n    if (value == null) {\n      throw new Error('ArgumentNullException : Blend');\n    }\n\n    if (this.mColours == null) {\n      throw new Error('NotSupportedException : There is no starting and ending colours specified.');\n    }\n\n    this.mBlend = value; //  TODO: generate correct colour blend.\n\n    this.mColourBlend = this.mBlend.generateColorBlend(this.mColours, this.colorSpace);\n    this.resetFunction();\n  }\n  /**\n   * Gets or sets a ColorBlend that defines a multicolor linear gradient.\n   * @public\n   */\n\n\n  get interpolationColors() {\n    return this.mColourBlend;\n  }\n\n  set interpolationColors(value) {\n    if (value == null) {\n      throw new Error('ArgumentNullException : InterpolationColors');\n    }\n\n    this.mBlend = null;\n    this.mColours = null;\n    this.mColourBlend = value;\n    this.resetFunction();\n  }\n  /**\n   * Gets or sets the starting and ending colors of the gradient.\n   * @public\n   */\n\n\n  get linearColors() {\n    return this.mColours;\n  }\n\n  set linearColors(value) {\n    if (value == null) {\n      throw new Error('ArgumentNullException : LinearColors');\n    }\n\n    if (value.length < 2) {\n      throw new Error('ArgumentException : The array is too small - LinearColors');\n    }\n\n    if (this.mColours == null && typeof this.mColours === 'undefined') {\n      this.mColours = [value[0], value[1]];\n    } else {\n      this.mColours[0] = value[0];\n      this.mColours[1] = value[1];\n    }\n\n    if (this.mBlend == null && typeof this.mBlend === 'undefined') {\n      //  Set correct colour blend.\n      this.mColourBlend = new PdfColorBlend(2);\n      this.mColourBlend.colors = this.mColours;\n      this.mColourBlend.positions = [0, 1];\n    } else {\n      this.mColourBlend = this.mBlend.generateColorBlend(this.mColours, this.colorSpace);\n    }\n\n    this.resetFunction();\n  }\n  /**\n   * Gets a rectangular region that defines the boundaries of the gradient.\n   * @public\n   */\n\n\n  get rectangle() {\n    return this.mBoundaries;\n  }\n  /**\n   * Gets or sets the value indicating whether the gradient should extend starting and ending points.\n   * @public\n   */\n\n\n  get extend() {\n    let result = PdfExtend.None;\n    let extend = this.shading.items.getValue(this.mDictionaryProperties.extend);\n\n    if (extend != null) {\n      let extStart = extend.items(0);\n      let extEnd = extend.items(1);\n\n      if (extStart.value) {\n        result = result | PdfExtend.Start;\n      }\n\n      if (extEnd.value) {\n        result = result | PdfExtend.End;\n      }\n    }\n\n    return result;\n  }\n\n  set extend(value) {\n    let extend = this.shading.items.getValue(this.mDictionaryProperties.extend);\n    let extStart;\n    let extEnd;\n\n    if (extend == null) {\n      extStart = new PdfBoolean(false);\n      extEnd = new PdfBoolean(false);\n      extend = new PdfArray();\n      extend.add(extStart);\n      extend.add(extEnd);\n      this.shading.items.setValue(this.mDictionaryProperties.extend, extend);\n    } else {\n      extStart = extend.items(0);\n      extEnd = extend.items(1);\n    } // extStart.value = ((value && PdfExtend.Start) > 0);\n    // extEnd.value = ((value && PdfExtend.End) > 0);\n\n  } //Implementation\n\n  /**\n   * Adds two points to each other.\n   * @param point1 The point1.\n   * @param point2 The point2.\n   */\n\n\n  addPoints(point1, point2) {\n    let x = point1.x + point2.x;\n    let y = point1.y + point2.y;\n    let result = new PointF(x, y);\n    return result;\n  }\n  /**\n   * Subs the second point from the first one.\n   * @param point1 The point1.\n   * @param point2 The point2.\n   */\n\n\n  subPoints(point1, point2) {\n    let x = point1.x - point2.x;\n    let y = point1.y - point2.y;\n    let result = new PointF(x, y);\n    return result;\n  }\n  /**\n   * Makes scalar multiplication of two points.\n   * @param point1 The point1.\n   * @param point2 The point2.\n   */\n\n\n  mulPoints(point1, point2) {\n    let result = point1.x * point2.x + point1.y * point2.y;\n    return result;\n  }\n  /**\n   * Multiplies the point by the value specified.\n   * @param point The point1.\n   * @param value The value.\n   */\n\n\n  mulPoint(point, value) {\n    point.x = point.x * value;\n    point.y = point.y * value;\n    return point;\n  }\n  /**\n   * Choose the point according to the angle.\n   * @param angle The angle.\n   */\n\n\n  choosePoint(angle) {\n    let point = new PointF(0, 0); //  Choose the correct point.\n\n    if (angle < 90 && angle > 0) {\n      point = new PointF(this.mBoundaries.right, this.mBoundaries.bottom);\n    } else if (angle < 180 && angle > 90) {\n      point = new PointF(this.mBoundaries.left, this.mBoundaries.bottom);\n    } else if (angle < 270 && angle > 180) {\n      point = new PointF(this.mBoundaries.left, this.mBoundaries.top);\n    } else if (angle > 270) {\n      point = new PointF(this.mBoundaries.right, this.mBoundaries.top);\n    } else {\n      throw new Error('PdfException - Internal error.');\n    }\n\n    return point;\n  }\n  /**\n   * Sets the start and end points.\n   * @param point1 The point1.\n   * @param point2 The point2.\n   */\n\n\n  setPoints(point1, point2) {\n    let points = new PdfArray();\n    points.add(new PdfNumber(point1.x));\n    points.add(new PdfNumber(this.updateY(point1.y)));\n    points.add(new PdfNumber(point2.x));\n    points.add(new PdfNumber(this.updateY(point2.y)));\n    this.shading.items.setValue(this.mDictionaryProperties.coords, points);\n  }\n  /**\n   * Updates y co-ordinate.\n   * @param y Y co-ordinate..\n   */\n\n\n  updateY(y) {\n    if (y !== 0) {\n      return -y;\n    } else {\n      return y;\n    }\n  } //Overrides\n\n  /**\n   * Initializes the shading dictionary.\n   * @private\n   */\n\n\n  initShading() {\n    this.colorSpace = PdfColorSpace.Rgb;\n    this.function = this.mColourBlend.getFunction(this.colorSpace);\n    this.shading.items.setValue(this.mDictionaryProperties.shadingType, new PdfNumber(ShadingType.Axial));\n  } //Overrides\n\n  /**\n   * Creates a new copy of a brush.\n   * @public\n   */\n\n\n  clone() {\n    let brush = this;\n    brush.resetPatternDictionary(new PdfDictionary(this.patternDictionary));\n    brush.shading = new PdfDictionary();\n    brush.initShading();\n    brush.setPoints(brush.mPointStart, brush.mPointEnd);\n\n    if (brush !== null && brush instanceof PdfLinearGradientBrush) {\n      if (this.matrix != null && typeof this.matrix !== 'undefined') {\n        brush.matrix = this.matrix.clone();\n      }\n    }\n\n    if (this.mColours != null && typeof this.mColours !== 'undefined') {\n      brush.mColours = this.mColours;\n    }\n\n    if (this.blend != null && typeof this.blend !== 'undefined') {\n      brush.blend = this.blend.clonePdfBlend();\n    } else if (this.interpolationColors != null && typeof this.interpolationColors !== 'undefined') {\n      brush.interpolationColors = this.interpolationColors.cloneColorBlend();\n    }\n\n    brush.extend = this.extend;\n    this.cloneBackgroundValue(brush);\n    this.cloneAntiAliasingValue(brush);\n    return brush;\n  }\n  /**\n   * Resets the function.\n   * @public\n   */\n\n\n  resetFunction() {\n    this.function = this.mColourBlend.getFunction(this.colorSpace);\n  }\n\n}\n/**\n * PdfRadialGradientBrush.ts class for EJ2-PDF\n */\n\n/**\n * `PdfRadialGradientBrush` Represent radial gradient brush.\n * @private\n */\n\n\nclass PdfRadialGradientBrush extends PdfGradientBrush {\n  //Constructor\n\n  /**\n   * Initializes a new instance of the `PdfRadialGradientBrush` class.\n   * @public\n   */\n\n  /* tslint:disable-next-line:max-line-length */\n  constructor(centerStart, radiusStart, centerEnd, radiusEnd, colorStart, colorEnd) {\n    super(new PdfDictionary());\n    /**\n     * Local varaible to store the dictionary properties.\n     */\n\n    this.mDictionaryProperties = new DictionaryProperties();\n    this.initialize(colorStart, colorEnd);\n\n    if (radiusStart < 0) {\n      throw new Error('ArgumentOutOfRangeException : radiusStart - The radius cannot be less then zero.');\n    }\n\n    if (radiusEnd < 0) {\n      throw new Error('ArgumentOutOfRangeException : radiusEnd - The radius cannpt be less then zero.');\n    }\n\n    this.mPointEnd = centerEnd;\n    this.mPointStart = centerStart;\n    this.mRadiusStart = radiusStart;\n    this.mRadiusEnd = radiusEnd;\n    this.setPoints(this.mPointStart, this.mPointEnd, this.mRadiusStart, this.mRadiusEnd);\n  }\n  /**\n   * Initializes a new instance of the `PdfRadialGradientBrush` class.\n   * @param color1 The color1.\n   * @param color2 The color2.\n   */\n\n\n  initialize(color1, color2) {\n    this.mColour = [color1, color2];\n    this.mColourBlends = new PdfColorBlend(2);\n    this.mColourBlends.positions = [0, 1];\n    this.mColourBlends.colors = this.mColour;\n    this.initShading();\n  } //Properties\n\n  /**\n   * Gets or sets a PdfBlend that specifies positions and factors that define a custom falloff for the gradient.\n   * @public\n   */\n\n\n  get blend() {\n    return this.mBlend;\n  }\n\n  set blend(value) {\n    if (value == null) {\n      throw new Error('ArgumentNullException : Blend');\n    }\n\n    if (this.mColour == null && typeof this.mColour === 'undefined') {\n      throw new Error('NotSupportedException : There is no starting and ending colours specified.');\n    }\n\n    this.mBlend = value;\n    this.mColourBlends = this.mBlend.generateColorBlend(this.mColour, this.colorSpace);\n    this.resetFunction();\n  }\n  /**\n   * Gets or sets a ColorBlend that defines a multicolor radial gradient.\n   * @public\n   */\n\n\n  get interpolationColors() {\n    return this.mColourBlends;\n  }\n\n  set interpolationColors(value) {\n    if (value == null) {\n      throw new Error('ArgumentNullException : InterpolationColors');\n    }\n\n    this.mBlend = null;\n    this.mColour = null;\n    this.mColourBlends = value;\n    this.resetFunction();\n  }\n  /**\n   * Gets or sets the starting and ending colors of the radial gradient.\n   * @public\n   */\n\n\n  get linearColors() {\n    return this.mColour;\n  }\n\n  set linearColors(value) {\n    if (value == null) {\n      throw new Error('ArgumentNullException : radial LinearColors');\n    }\n\n    if (value.length < 2) {\n      throw new Error('ArgumentException : The array is too small LinearColors');\n    }\n\n    if (this.mColour == null && typeof this.mColour === 'undefined') {\n      this.mColour = [value[0], value[1]];\n    } else {\n      this.mColour[0] = value[0];\n      this.mColour[1] = value[1];\n    }\n\n    if (this.mBlend == null && typeof this.mBlend === 'undefined') {\n      //  Set correct colour blend.\n      this.mColourBlends = new PdfColorBlend(2);\n      this.mColourBlends.colors = this.mColour;\n      this.mColourBlends.positions = [0, 1];\n    } else {\n      this.mColourBlends = this.mBlend.generateColorBlend(this.mColour, this.colorSpace);\n    }\n\n    this.resetFunction();\n  }\n  /**\n   * Gets or sets the rectangle.\n   * @public\n   */\n\n\n  get rectangle() {\n    return this.mBoundaries;\n  }\n\n  set rectangle(value) {\n    this.mBoundaries = value;\n    this.bBox = PdfArray.fromRectangle(value);\n  }\n  /**\n   * Gets or sets the value indicating whether the gradient\n   *  should extend starting and ending points.\n   * @public\n   */\n\n\n  get extend() {\n    let result1 = PdfExtend.None;\n    let extend1 = this.shading.items.getValue(this.mDictionaryProperties.extend);\n\n    if (extend1 !== null && typeof extend1 !== 'undefined') {\n      let extStart = extend1.items(0);\n      let extEnd = extend1.items(1);\n\n      if (extStart.value) {\n        result1 = result1 | PdfExtend.Start;\n      }\n\n      if (extEnd.value) {\n        result1 = result1 | PdfExtend.End;\n      }\n    }\n\n    return result1;\n  }\n\n  set extend(value) {\n    let extend = this.shading.items.getValue(this.mDictionaryProperties.extend);\n    let extStart;\n    let extEnd1;\n\n    if (extend == null && typeof extend === 'undefined') {\n      extStart = new PdfBoolean(false);\n      extEnd1 = new PdfBoolean(false);\n      extend = new PdfArray();\n      extend.add(extStart);\n      extend.add(extEnd1);\n      this.shading.items.setValue(this.mDictionaryProperties.extend, extend);\n    } else {\n      extStart = extend.items(0);\n      extEnd1 = extend.items(1);\n    }\n  } //Implementation\n\n  /**\n   * Sets the points.\n   * @param pointStart The point start.\n   * @param pointEnd The point end.\n   * @param radiusStart The radius start.\n   * @param radiusEnd The radius end.\n   */\n\n\n  setPoints(pointStart, pointEnd, radiusStart, radiusEnd) {\n    let points = new PdfArray();\n    points.add(new PdfNumber(pointStart.x));\n    points.add(new PdfNumber(this.updateY(pointStart.y)));\n    points.add(new PdfNumber(radiusStart));\n    points.add(new PdfNumber(pointEnd.x));\n    points.add(new PdfNumber(this.updateY(pointEnd.y)));\n\n    if (radiusStart !== radiusEnd) {\n      points.add(new PdfNumber(radiusEnd));\n    } else {\n      points.add(new PdfNumber(0));\n    }\n\n    this.shading.items.setValue(this.mDictionaryProperties.coords, points);\n  }\n  /**\n   * Update y co-ordinate.\n   * @param y Y co-ordinate.\n   */\n\n\n  updateY(y) {\n    if (y !== 0) {\n      return -y;\n    } else {\n      return y;\n    }\n  }\n  /**\n   * Initializess the shading dictionary.\n   * @private\n   */\n\n\n  initShading() {\n    this.colorSpace = PdfColorSpace.Rgb;\n    this.function = this.mColourBlends.getFunction(this.colorSpace);\n    this.shading.items.setValue(this.mDictionaryProperties.shadingType, new PdfNumber(ShadingType.Radial));\n  } //Overrides\n\n  /**\n   * Creates a new copy of a brush.\n   * @public\n   */\n\n\n  clone() {\n    let rBrush = this;\n    rBrush.resetPatternDictionary(new PdfDictionary(this.patternDictionary));\n    rBrush.shading = new PdfDictionary();\n    rBrush.initShading();\n    rBrush.setPoints(this.mPointStart, this.mPointEnd, this.mRadiusStart, this.mRadiusEnd);\n\n    if (rBrush instanceof PdfRadialGradientBrush) {\n      if (this.matrix !== null && typeof this.matrix !== 'undefined') {\n        rBrush.matrix = this.matrix.clone();\n      }\n    }\n\n    if (this.mColour !== null && typeof this.mColour !== 'undefined') {\n      rBrush.mColour = this.mColour;\n    }\n\n    if (this.blend !== null && typeof this.blend !== 'undefined') {\n      rBrush.blend = this.blend.clonePdfBlend();\n    } else if (this.interpolationColors !== null && typeof this.interpolationColors !== 'undefined') {\n      rBrush.interpolationColors = this.interpolationColors.cloneColorBlend();\n    }\n\n    rBrush.extend = this.extend;\n    this.cloneBackgroundValue(rBrush);\n    this.cloneAntiAliasingValue(rBrush);\n    return rBrush;\n  }\n  /**\n   * Resets the function.\n   * @public\n   */\n\n\n  resetFunction() {\n    this.function = this.mColourBlends.getFunction(this.colorSpace);\n  }\n\n}\n/**\n * public Enum for `PdfBorderOverlapStyle`.\n * @private\n */\n\n\nvar PdfBorderOverlapStyle = /*#__PURE__*/(() => {\n  (function (PdfBorderOverlapStyle) {\n    /**\n     * Specifies the type of `Overlap`.\n     * @private\n     */\n    PdfBorderOverlapStyle[PdfBorderOverlapStyle[\"Overlap\"] = 0] = \"Overlap\";\n    /**\n     * Specifies the type of `Inside`.\n     * @private\n     */\n\n    PdfBorderOverlapStyle[PdfBorderOverlapStyle[\"Inside\"] = 1] = \"Inside\";\n  })(PdfBorderOverlapStyle || (PdfBorderOverlapStyle = {}));\n\n  return PdfBorderOverlapStyle;\n})();\n\n/**\n * Base class for the `grid style`,\n */\nclass PdfGridStyleBase {\n  // Properties\n\n  /**\n   * Gets or sets the `background brush`.\n   * @private\n   */\n  get backgroundBrush() {\n    return this.gridBackgroundBrush;\n  }\n\n  set backgroundBrush(value) {\n    this.gridBackgroundBrush = value;\n  }\n  /**\n   * Gets or sets the `text brush`.\n   * @private\n   */\n\n\n  get textBrush() {\n    return this.gridTextBrush;\n  }\n\n  set textBrush(value) {\n    this.gridTextBrush = value;\n  }\n  /**\n   * Gets or sets the `text pen`.\n   * @private\n   */\n\n\n  get textPen() {\n    return this.gridTextPen;\n  }\n\n  set textPen(value) {\n    this.gridTextPen = value;\n  }\n  /**\n   * Gets or sets the `font`.\n   * @private\n   */\n\n\n  get font() {\n    return this.gridFont;\n  }\n\n  set font(value) {\n    this.gridFont = value;\n  }\n  /**\n   * Gets or sets the `background Image`.\n   * @private\n   */\n\n\n  get backgroundImage() {\n    return this.gridBackgroundImage;\n  }\n\n  set backgroundImage(value) {\n    this.gridBackgroundImage = value;\n  }\n\n}\n/**\n * `PdfGridStyle` class provides customization of the appearance for the 'PdfGrid'.\n */\n\n\nclass PdfGridStyle extends PdfGridStyleBase {\n  //constructor\n\n  /**\n   * Initialize a new instance for `PdfGridStyle` class.\n   * @private\n   */\n  constructor() {\n    super();\n    this.gridBorderOverlapStyle = PdfBorderOverlapStyle.Overlap;\n    this.bAllowHorizontalOverflow = false;\n    this.gridHorizontalOverflowType = PdfHorizontalOverflowType.LastPage;\n  } //Properties\n\n  /**\n   * Gets or sets the `cell spacing` of the 'PdfGrid'.\n   * @private\n   */\n\n\n  get cellSpacing() {\n    if (typeof this.gridCellSpacing === 'undefined') {\n      this.gridCellSpacing = 0;\n    }\n\n    return this.gridCellSpacing;\n  }\n\n  set cellSpacing(value) {\n    this.gridCellSpacing = value;\n  }\n  /**\n   * Gets or sets the type of the `horizontal overflow` of the 'PdfGrid'.\n   * @private\n   */\n\n\n  get horizontalOverflowType() {\n    return this.gridHorizontalOverflowType;\n  }\n\n  set horizontalOverflowType(value) {\n    this.gridHorizontalOverflowType = value;\n  }\n  /**\n   * Gets or sets a value indicating whether to `allow horizontal overflow`.\n   * @private\n   */\n\n\n  get allowHorizontalOverflow() {\n    return this.bAllowHorizontalOverflow;\n  }\n\n  set allowHorizontalOverflow(value) {\n    this.bAllowHorizontalOverflow = value;\n  }\n  /**\n   * Gets or sets the `cell padding`.\n   * @private\n   */\n\n\n  get cellPadding() {\n    if (typeof this.gridCellPadding === 'undefined') {\n      this.gridCellPadding = new PdfPaddings();\n    }\n\n    return this.gridCellPadding;\n  }\n\n  set cellPadding(value) {\n    if (typeof this.gridCellPadding === 'undefined') {\n      this.gridCellPadding = new PdfPaddings();\n      this.gridCellPadding = value;\n    } else {\n      this.gridCellPadding = value;\n    }\n  }\n  /**\n   * Gets or sets the `border overlap style` of the 'PdfGrid'.\n   * @private\n   */\n\n\n  get borderOverlapStyle() {\n    return this.gridBorderOverlapStyle;\n  }\n\n  set borderOverlapStyle(value) {\n    this.gridBorderOverlapStyle = value;\n  }\n\n}\n/**\n * `PdfGridCellStyle` class provides customization of the appearance for the 'PdfGridCell'.\n */\n\n\nclass PdfGridCellStyle extends PdfGridStyleBase {\n  /**\n   * Initializes a new instance of the `PdfGridCellStyle` class.\n   * @private\n   */\n  constructor() {\n    super();\n    /**\n     * @hidden\n     * @private\n     */\n\n    this.gridCellBorders = PdfBorders.default;\n  } //Properties\n\n  /**\n   * Gets the `string format` of the 'PdfGridCell'.\n   * @private\n   */\n\n\n  get stringFormat() {\n    return this.format;\n  }\n\n  set stringFormat(value) {\n    this.format = value;\n  }\n  /**\n   * Gets or sets the `border` of the 'PdfGridCell'.\n   * @private\n   */\n\n\n  get borders() {\n    return this.gridCellBorders;\n  }\n\n  set borders(value) {\n    this.gridCellBorders = value;\n  }\n  /**\n   * Gets or sets the `cell padding`.\n   * @private\n   */\n\n\n  get cellPadding() {\n    return this.gridCellPadding;\n  }\n\n  set cellPadding(value) {\n    if (this.gridCellPadding == null || typeof this.gridCellPadding === 'undefined') {\n      this.gridCellPadding = new PdfPaddings();\n    }\n\n    this.gridCellPadding = value;\n  }\n\n}\n/**\n * `PdfGridRowStyle` class provides customization of the appearance for the `PdfGridRow`.\n */\n\n\nclass PdfGridRowStyle {\n  // Properties\n\n  /**\n   * Gets or sets the `background brush`.\n   * @private\n   */\n  get backgroundBrush() {\n    return this.gridRowBackgroundBrush;\n  }\n\n  setBackgroundBrush(value) {\n    this.gridRowBackgroundBrush = value;\n\n    if (typeof this.parent !== 'undefined') {\n      for (let i = 0; i < this.parent.cells.count; i++) {\n        this.parent.cells.getCell(i).style.backgroundBrush = value;\n      }\n    }\n  }\n  /**\n   * Gets or sets the `text brush`.\n   * @private\n   */\n\n\n  get textBrush() {\n    return this.gridRowTextBrush;\n  }\n\n  setTextBrush(value) {\n    this.gridRowTextBrush = value;\n\n    if (typeof this.parent !== 'undefined') {\n      for (let i = 0; i < this.parent.cells.count; i++) {\n        this.parent.cells.getCell(i).style.textBrush = value;\n      }\n    }\n  }\n  /**\n   * Gets or sets the `text pen`.\n   * @private\n   */\n\n\n  get textPen() {\n    return this.gridRowTextPen;\n  }\n\n  setTextPen(value) {\n    this.gridRowTextPen = value;\n\n    if (typeof this.parent !== 'undefined') {\n      for (let i = 0; i < this.parent.cells.count; i++) {\n        this.parent.cells.getCell(i).style.textPen = value;\n      }\n    }\n  }\n  /**\n   * Gets or sets the `font`.\n   * @private\n   */\n\n\n  get font() {\n    return this.gridRowFont;\n  }\n\n  setFont(value) {\n    this.gridRowFont = value;\n\n    if (typeof this.parent !== 'undefined') {\n      for (let i = 0; i < this.parent.cells.count; i++) {\n        this.parent.cells.getCell(i).style.font = value;\n      }\n    }\n  }\n  /**\n   * Gets or sets the `border` of the current row.\n   * @private\n   */\n\n\n  get border() {\n    if (typeof this.gridRowBorder === 'undefined') {\n      this.setBorder(new PdfBorders());\n    }\n\n    return this.gridRowBorder;\n  }\n\n  setBorder(value) {\n    this.gridRowBorder = value;\n\n    if (typeof this.parent !== 'undefined') {\n      for (let i = 0; i < this.parent.cells.count; i++) {\n        this.parent.cells.getCell(i).style.borders = value;\n      }\n    }\n  }\n  /**\n   * sets the `parent row` of the current object.\n   * @private\n   */\n\n\n  setParent(parent) {\n    this.parent = parent;\n  }\n  /**\n   * Gets or sets the `backgroundImage` of the 'PdfGridCell'.\n   * @private\n   */\n\n\n  get backgroundImage() {\n    return this.gridRowBackgroundImage;\n  }\n  /**\n   * sets the `backgroundImage` of the 'PdfGridCell'.\n   * @private\n   */\n\n\n  setBackgroundImage(value) {\n    this.gridRowBackgroundImage = value;\n  } // Constructor\n\n  /**\n   * Initializes a new instance of the `PdfGridRowStyle` class.\n   * @private\n   */\n\n\n  constructor() {//\n  }\n\n}\n/**\n * public Enum for `PdfHorizontalOverflowType`.\n * @private\n */\n\n\nvar PdfHorizontalOverflowType = /*#__PURE__*/(() => {\n  (function (PdfHorizontalOverflowType) {\n    /**\n     * Specifies the type of `NextPage`.\n     * @private\n     */\n    PdfHorizontalOverflowType[PdfHorizontalOverflowType[\"NextPage\"] = 0] = \"NextPage\";\n    /**\n     * Specifies the type of `LastPage`.\n     * @private\n     */\n\n    PdfHorizontalOverflowType[PdfHorizontalOverflowType[\"LastPage\"] = 1] = \"LastPage\";\n  })(PdfHorizontalOverflowType || (PdfHorizontalOverflowType = {}));\n\n  return PdfHorizontalOverflowType;\n})();\n\n/**\n * `PdfGridCell` class represents the schema of a cell in a 'PdfGrid'.\n */\nclass PdfGridCell {\n  constructor(row) {\n    /**\n     * `Width` of the cell.\n     * @default 0\n     * @private\n     */\n    this.cellWidth = 0;\n    /**\n     * `Height` of the cell.\n     * @default 0\n     * @private\n     */\n\n    this.cellHeight = 0;\n    /**\n     * `tempval`to stores current width .\n     * @default 0\n     * @private\n     */\n\n    this.tempval = 0;\n    this.fontSpilt = false;\n    /**\n     * Specifies weather the `cell is drawn`.\n     * @default true\n     * @private\n     */\n\n    this.finsh = true;\n    /**\n     * The `remaining height` of row span.\n     * @default 0\n     * @private\n     */\n\n    this.rowSpanRemainingHeight = 0;\n    this.hasRowSpan = false;\n    this.hasColSpan = false;\n    /**\n     * the 'isFinish' is set to page finish\n     */\n\n    this.isFinish = true;\n    /**\n     * The `present' to store the current cell.\n     * @default false\n     * @private\n     */\n\n    this.present = false;\n    this.gridRowSpan = 1;\n    this.colSpan = 1;\n\n    if (typeof row !== 'undefined') {\n      this.gridRow = row;\n    }\n  } //Properties\n\n\n  get isCellMergeContinue() {\n    return this.internalIsCellMergeContinue;\n  }\n\n  set isCellMergeContinue(value) {\n    this.internalIsCellMergeContinue = value;\n  }\n\n  get isRowMergeContinue() {\n    return this.internalIsRowMergeContinue;\n  }\n\n  set isRowMergeContinue(value) {\n    this.internalIsRowMergeContinue = value;\n  }\n\n  get isCellMergeStart() {\n    return this.internalIsCellMergeStart;\n  }\n\n  set isCellMergeStart(value) {\n    this.internalIsCellMergeStart = value;\n  }\n\n  get isRowMergeStart() {\n    return this.internalIsRowMergeStart;\n  }\n\n  set isRowMergeStart(value) {\n    this.internalIsRowMergeStart = value;\n  }\n  /**\n   * Gets or sets the `remaining string` after the row split between pages.\n   * @private\n   */\n\n\n  get remainingString() {\n    return this.remaining;\n  }\n\n  set remainingString(value) {\n    this.remaining = value;\n  }\n  /**\n   * Gets or sets the `FinishedDrawingCell` .\n   * @private\n   */\n\n\n  get FinishedDrawingCell() {\n    return this.isFinish;\n  }\n\n  set FinishedDrawingCell(value) {\n    this.isFinish = value;\n  }\n  /**\n   * Gets or sets the `string format`.\n   * @private\n   */\n\n\n  get stringFormat() {\n    if (this.format == null) {\n      this.format = new PdfStringFormat();\n    }\n\n    return this.format;\n  }\n\n  set stringFormat(value) {\n    this.format = value;\n  }\n  /**\n   * Gets or sets the parent `row`.\n   * @private\n   */\n\n\n  get row() {\n    return this.gridRow;\n  }\n\n  set row(value) {\n    this.gridRow = value;\n  }\n  /**\n   * Gets or sets the `value` of the cell.\n   * @private\n   */\n\n\n  get value() {\n    return this.objectValue;\n  }\n\n  set value(value) {\n    this.objectValue = value;\n\n    if (this.objectValue instanceof PdfGrid) {\n      this.row.grid.isSingleGrid = false;\n      let grid = this.objectValue;\n      grid.ParentCell = this;\n      this.objectValue.isChildGrid = true;\n      let rowCount = this.row.grid.rows.count;\n\n      for (let i = 0; i < rowCount; i++) {\n        let row = this.row.grid.rows.getRow(i);\n        let colCount = row.cells.count;\n\n        for (let j = 0; j < colCount; j++) {\n          let cell = row.cells.getCell(j);\n          cell.parent = this;\n        }\n      }\n    }\n  }\n  /**\n   * Gets or sets a value that indicates the total number of rows that cell `spans` within a PdfGrid.\n   * @private\n   */\n\n\n  get rowSpan() {\n    return this.gridRowSpan;\n  }\n\n  set rowSpan(value) {\n    if (value < 1) {\n      throw new Error('ArgumentException : Invalid span specified, must be greater than or equal to 1');\n    } else {\n      this.gridRowSpan = value;\n      this.row.rowSpanExists = true;\n      this.row.grid.hasRowSpanSpan = true;\n    }\n  }\n  /**\n   * Gets or sets the cell `style`.\n   * @private\n   */\n\n\n  get style() {\n    if (this.cellStyle == null) {\n      this.cellStyle = new PdfGridCellStyle();\n    }\n\n    return this.cellStyle;\n  }\n\n  set style(value) {\n    this.cellStyle = value;\n  }\n  /**\n   * Gets the `height` of the PdfGrid cell.[Read-Only].\n   * @private\n   */\n\n\n  get height() {\n    if (this.cellHeight === 0) {\n      this.cellHeight = this.measureHeight();\n    }\n\n    return this.cellHeight;\n  }\n\n  set height(value) {\n    this.cellHeight = value;\n  }\n  /**\n   * Gets or sets a value that indicates the total number of columns that cell `spans` within a PdfGrid.\n   * @private\n   */\n\n\n  get columnSpan() {\n    return this.colSpan;\n  }\n\n  set columnSpan(value) {\n    if (value < 1) {\n      throw Error('Invalid span specified, must be greater than or equal to 1');\n    } else {\n      this.colSpan = value;\n      this.row.columnSpanExists = true;\n    }\n  }\n  /**\n   * Gets the `width` of the PdfGrid cell.[Read-Only].\n   * @private\n   */\n\n\n  get width() {\n    if (this.cellWidth === 0 || this.row.grid.isComplete) {\n      this.cellWidth = this.measureWidth();\n    }\n\n    return Math.round(this.cellWidth);\n  }\n\n  set width(value) {\n    this.cellWidth = value;\n  } //Implementation\n\n  /**\n   * `Calculates the width`.\n   * @private\n   */\n\n\n  measureWidth() {\n    // .. Calculate the cell text width.\n    // .....Add border widths, cell spacings and paddings to the width.\n    let width = 0;\n    let layouter = new PdfStringLayouter();\n\n    if (typeof this.objectValue === 'string') {\n      /* tslint:disable */\n      let slr = layouter.layout(this.objectValue, this.getTextFont(), this.stringFormat, new SizeF(Number.MAX_VALUE, Number.MAX_VALUE), false, new SizeF(0, 0));\n      width += slr.actualSize.width;\n      width += (this.style.borders.left.width + this.style.borders.right.width) * 2;\n    } else if (this.objectValue instanceof PdfGrid) {\n      width = this.objectValue.size.width; //width += this.objectValue.style.cellSpacing;\n    } else if (this.objectValue instanceof PdfImage || this.objectValue instanceof PdfBitmap) {\n      width += this.objectValue.width;\n    } else if (this.objectValue instanceof PdfTextWebLink) {\n      let webLink = this.objectValue;\n      let result = layouter.layout(webLink.text, webLink.font, webLink.stringFormat, new SizeF(0, 0), false, new SizeF(0, 0));\n      /* tslint:enable */\n\n      width += result.actualSize.width;\n      width += (this.style.borders.left.width + this.style.borders.right.width) * 2;\n    }\n\n    if (!(this.objectValue instanceof PdfGrid)) {\n      if (this.style.cellPadding != null) {\n        width += this.style.cellPadding.left + this.style.cellPadding.right;\n      } else {\n        width += this.row.grid.style.cellPadding.left + this.row.grid.style.cellPadding.right;\n      }\n    } else {\n      if (this.style.cellPadding != null || typeof this.style.cellPadding !== 'undefined') {\n        if (typeof this.style.cellPadding.left !== 'undefined' && this.style.cellPadding.hasLeftPad) {\n          width += this.style.cellPadding.left;\n        }\n\n        if (typeof this.style.cellPadding.right !== 'undefined' && this.style.cellPadding.hasRightPad) {\n          width += this.style.cellPadding.right;\n        }\n      } else {\n        if (typeof this.row.grid.style.cellPadding.left !== 'undefined' && this.row.grid.style.cellPadding.hasLeftPad) {\n          width += this.row.grid.style.cellPadding.left;\n        }\n\n        if (typeof this.row.grid.style.cellPadding.right !== 'undefined' && this.row.grid.style.cellPadding.hasRightPad) {\n          width += this.row.grid.style.cellPadding.right;\n        }\n      }\n    }\n\n    width += this.row.grid.style.cellSpacing;\n    return width;\n  }\n  /**\n   * Draw the `cell background`.\n   * @private\n   */\n\n\n  drawCellBackground(graphics, bounds) {\n    let backgroundBrush = this.getBackgroundBrush(); //graphics.isTemplateGraphics = true;\n\n    if (backgroundBrush != null) {\n      graphics.save();\n      graphics.drawRectangle(backgroundBrush, bounds.x, bounds.y, bounds.width, bounds.height);\n      graphics.restore();\n    }\n\n    if (this.style.backgroundImage != null) {\n      let image = this.getBackgroundImage();\n      graphics.drawImage(this.style.backgroundImage, bounds.x, bounds.y, bounds.width, bounds.height);\n    }\n  }\n  /**\n   * `Adjusts the text layout area`.\n   * @private\n   */\n\n  /* tslint:disable */\n\n\n  adjustContentLayoutArea(bounds) {\n    //Add Padding value to its Cell Bounds\n    let returnBounds = new RectangleF(bounds.x, bounds.y, bounds.width, bounds.height);\n\n    if (!(this.objectValue instanceof PdfGrid)) {\n      if (typeof this.style.cellPadding === 'undefined' || this.style.cellPadding == null) {\n        returnBounds.x += this.gridRow.grid.style.cellPadding.left + this.cellStyle.borders.left.width;\n        returnBounds.y += this.gridRow.grid.style.cellPadding.top + this.cellStyle.borders.top.width;\n        returnBounds.width -= this.gridRow.grid.style.cellPadding.right + this.gridRow.grid.style.cellPadding.left;\n        returnBounds.height -= this.gridRow.grid.style.cellPadding.bottom + this.gridRow.grid.style.cellPadding.top;\n        returnBounds.height -= this.cellStyle.borders.top.width + this.cellStyle.borders.bottom.width;\n      } else {\n        returnBounds.x += this.style.cellPadding.left + this.cellStyle.borders.left.width;\n        returnBounds.y += this.style.cellPadding.top + this.cellStyle.borders.top.width;\n        returnBounds.width -= this.style.cellPadding.right + this.style.cellPadding.left;\n        returnBounds.width -= this.cellStyle.borders.left.width + this.cellStyle.borders.right.width;\n        returnBounds.height -= this.style.cellPadding.bottom + this.style.cellPadding.top;\n        returnBounds.height -= this.cellStyle.borders.top.width + this.cellStyle.borders.bottom.width;\n\n        if (this.rowSpan === 1) {\n          returnBounds.width -= this.style.borders.left.width;\n        }\n      }\n    } else {\n      if (this.style.cellPadding == null || typeof this.style.cellPadding === 'undefined') {\n        if (typeof this.gridRow.grid.style.cellPadding.left !== 'undefined' && this.gridRow.grid.style.cellPadding.hasLeftPad) {\n          returnBounds.x += this.gridRow.grid.style.cellPadding.left + this.cellStyle.borders.left.width;\n          returnBounds.width -= this.gridRow.grid.style.cellPadding.left;\n        }\n\n        if (typeof this.gridRow.grid.style.cellPadding.top !== 'undefined' && this.gridRow.grid.style.cellPadding.hasTopPad) {\n          returnBounds.y += this.gridRow.grid.style.cellPadding.top + this.cellStyle.borders.top.width;\n          returnBounds.height -= this.gridRow.grid.style.cellPadding.top;\n        }\n\n        if (typeof this.gridRow.grid.style.cellPadding.right !== 'undefined' && this.gridRow.grid.style.cellPadding.hasRightPad) {\n          returnBounds.width -= this.gridRow.grid.style.cellPadding.right;\n        }\n\n        if (typeof this.gridRow.grid.style.cellPadding.bottom !== 'undefined' && this.gridRow.grid.style.cellPadding.hasBottomPad) {\n          returnBounds.height -= this.gridRow.grid.style.cellPadding.bottom;\n        }\n      } else {\n        if (typeof this.style.cellPadding.left !== 'undefined' && this.style.cellPadding.hasLeftPad) {\n          returnBounds.x += this.style.cellPadding.left + this.cellStyle.borders.left.width;\n          returnBounds.width -= this.style.cellPadding.left;\n        }\n\n        if (typeof this.style.cellPadding.top !== 'undefined' && this.style.cellPadding.hasTopPad) {\n          returnBounds.y += this.style.cellPadding.top + this.cellStyle.borders.top.width;\n          returnBounds.height -= this.style.cellPadding.top;\n        }\n\n        if (typeof this.style.cellPadding.right !== 'undefined' && this.style.cellPadding.hasRightPad) {\n          returnBounds.width -= this.style.cellPadding.right;\n        }\n\n        if (typeof this.style.cellPadding.bottom !== 'undefined' && this.style.cellPadding.hasBottomPad) {\n          returnBounds.height -= this.style.cellPadding.bottom;\n        }\n      }\n\n      returnBounds.width -= this.cellStyle.borders.left.width + this.cellStyle.borders.right.width;\n      returnBounds.height -= this.cellStyle.borders.top.width + this.cellStyle.borders.bottom.width;\n    }\n\n    return returnBounds;\n  }\n  /**\n   * `Draws` the specified graphics.\n   * @private\n   */\n\n\n  draw(graphics, bounds, cancelSubsequentSpans) {\n    let result = null;\n    /*if (cancelSubsequentSpans)\n    {\n        //..Cancel all subsequent cell spans, if no space exists.\n        let currentCellIndex : number = this.row.cells.indexOf(this);\n        for (let i : number = currentCellIndex + 1; i <= currentCellIndex + this.colSpan; i++)\n        {\n            this.row.cells.getCell(i).isCellMergeContinue = false;\n            this.row.cells.getCell(i).isRowMergeContinue = false;\n        }\n        this.colSpan = 1;\n    }*/\n    //..Skip cells which were already covered by spanmap.\n\n    if (this.internalIsCellMergeContinue || this.internalIsRowMergeContinue) {\n      if (this.internalIsCellMergeContinue && this.row.grid.style.allowHorizontalOverflow) {\n        if (this.row.rowOverflowIndex > 0 && this.row.cells.indexOf(this) != this.row.rowOverflowIndex + 1 || this.row.rowOverflowIndex == 0 && this.internalIsCellMergeContinue) {\n          return result;\n        }\n      } else {\n        return result;\n      }\n    } //Adjust bounds with Row and Column Spacing\n\n\n    bounds = this.adjustOuterLayoutArea(bounds, graphics);\n    this.drawCellBackground(graphics, bounds);\n    let textPen = this.getTextPen();\n    let textBrush = this.getTextBrush();\n\n    if (typeof textPen === 'undefined' && typeof textBrush === 'undefined') {\n      textBrush = new PdfSolidBrush(new PdfColor(0, 0, 0));\n    }\n\n    let font = this.getTextFont();\n    let strFormat = this.getStringFormat();\n    let innerLayoutArea = bounds;\n\n    if (innerLayoutArea.height >= graphics.clientSize.height) {\n      // If to break row to next page.\n      if (this.row.grid.allowRowBreakAcrossPages) {\n        innerLayoutArea.height -= innerLayoutArea.y; //bounds.height -= bounds.y;\n        // if(this.row.grid.isChildGrid)\n        // {\n        //     innerLayoutArea.height -= this.row.grid.ParentCell.row.grid.style.cellPadding.bottom;\n        // }\n      } // if user choose to cut the row whose height is more than page height.\n      // else\n      // {\n      //     innerLayoutArea.height = graphics.clientSize.height;\n      //     bounds.height = graphics.clientSize.height;\n      // }\n\n    }\n\n    innerLayoutArea = this.adjustContentLayoutArea(innerLayoutArea);\n\n    if (typeof this.objectValue === 'string' || typeof this.remaining === 'string') {\n      let temp;\n      let layoutRectangle;\n      if (innerLayoutArea.height < font.height) layoutRectangle = new RectangleF(innerLayoutArea.x, innerLayoutArea.y, innerLayoutArea.width, font.height);else layoutRectangle = innerLayoutArea;\n\n      if (innerLayoutArea.height < font.height && this.row.grid.isChildGrid && this.row.grid.ParentCell != null) {\n        let height = layoutRectangle.height - this.row.grid.ParentCell.row.grid.style.cellPadding.bottom - this.row.grid.style.cellPadding.bottom;\n\n        if (this.row.grid.splitChildRowIndex != -1) {\n          this.fontSpilt = true;\n          this.row.rowFontSplit = true;\n        }\n\n        if (height > 0 && height < font.height) layoutRectangle.height = height; // else if (height + this.row.grid.style.cellPadding.bottom > 0 && height + this.row.grid.style.cellPadding.bottom < font.height)\n        //     layoutRectangle.height = height + this.row.grid.style.cellPadding.bottom;\n        // else if (bounds.height < font.height)\n        //     layoutRectangle.height = bounds.height;\n        // else if (bounds.height - this.row.grid.ParentCell.row.grid.style.cellPadding.bottom < font.height)\n        //     layoutRectangle.height = bounds.height - this.row.grid.ParentCell.row.grid.style.cellPadding.bottom;                        \n      }\n\n      if (this.gridRow.grid.style.cellSpacing != 0) {\n        layoutRectangle.width -= this.gridRow.grid.style.cellSpacing;\n        bounds.width -= this.gridRow.grid.style.cellSpacing;\n      }\n\n      if (this.isFinish) {\n        // if (this.row.grid.splitChildRowIndex != -1 && !this.row.grid.isChildGrid && typeof this.remaining === 'undefined'){\n        //     this.remaining = '';\n        //     graphics.drawString(this.remaining, font, textPen, textBrush, layoutRectangle.x, layoutRectangle.y, layoutRectangle.width, layoutRectangle.height, strFormat);\n        // } else {\n        temp = this.remaining === '' ? this.remaining : this.objectValue;\n        graphics.drawString(temp, font, textPen, textBrush, layoutRectangle.x, layoutRectangle.y, layoutRectangle.width, layoutRectangle.height, strFormat);\n\n        if (this.row.grid.splitChildRowIndex != -1 && !this.row.grid.isChildGrid && typeof this.remaining === 'undefined') {\n          this.remaining = ''; //graphics.drawString(this.remaining, font, textPen, textBrush, layoutRectangle.x, layoutRectangle.y, layoutRectangle.width, layoutRectangle.height, strFormat);\n        }\n      } else {\n        if (typeof this.remaining == 'undefined' || this.remaining === null) {\n          this.remaining = '';\n        }\n\n        if (this.row.repeatFlag) {\n          graphics.drawString(this.remaining, font, textPen, textBrush, layoutRectangle.x, layoutRectangle.y, layoutRectangle.width, layoutRectangle.height, strFormat);\n        } //  else {\n        //     if(this.row.grid.ParentCell.row.repeatFlag) {\n        //         graphics.drawString((this.remaining as string), font, textPen, textBrush, layoutRectangle.x, layoutRectangle.y, layoutRectangle.width, layoutRectangle.height, strFormat);                    \n        //     } else {\n        //         layoutRectangle.height = this.row.height;\n        //         graphics.drawString((this.objectValue as string), font, textPen, textBrush, layoutRectangle.x, layoutRectangle.y, layoutRectangle.width, layoutRectangle.height, strFormat);\n        //         bounds.height = this.row.height;\n        //     }\n        //  }\n\n\n        this.isFinish = true; //graphics.drawString((this.remaining as string), font, textPen, textBrush, layoutRectangle.x, layoutRectangle.y, layoutRectangle.width, layoutRectangle.height, strFormat);\n      }\n\n      result = graphics.stringLayoutResult; // if(this.row.grid.isChildGrid && this.row.rowBreakHeight > 0 && result !=null) {\n      //     bounds.height -= this.row.grid.ParentCell.row.grid.style.cellPadding.bottom;\n      // }\n    } else if (this.objectValue instanceof PdfGrid) {\n      let childGrid = this.objectValue;\n      childGrid.isChildGrid = true;\n      childGrid.ParentCell = this;\n      let layoutRect;\n      layoutRect = innerLayoutArea;\n\n      if (this.gridRow.grid.style.cellSpacing != 0) {\n        bounds.width -= this.gridRow.grid.style.cellSpacing;\n      } // layoutRect = bounds;\n      // if (this.style.cellPadding != null){\n      //     layoutRect = bounds;            \n      // } else if((this.row.grid.style.cellPadding != null) && (childGrid.style.cellPadding.bottom === 0.5) && (childGrid.style.cellPadding.top === 0.5)\n      //                               && (childGrid.style.cellPadding.left === 5.76) && (childGrid.style.cellPadding.right === 5.76)\n      //                               && (this.gridRow.grid.style.cellSpacing === 0) && (childGrid.style.cellSpacing === 0)) {\n      //     layoutRect = innerLayoutArea;\n      // }\n      // if(this.objectValue.style.cellPadding != null && typeof this.objectValue.style.cellPadding !== 'undefined'){\n      //     layoutRect = bounds;\n      // }           \n\n\n      let layouter = new PdfGridLayouter(childGrid);\n      let format = new PdfGridLayoutFormat();\n      if (this.row.grid.LayoutFormat != null) format = this.row.grid.LayoutFormat;else format.layout = PdfLayoutType.Paginate;\n      let param = new PdfLayoutParams();\n\n      if (graphics.layer != null) {\n        // Define layout parameters.\n        param.page = graphics.page;\n        param.bounds = layoutRect;\n        param.format = format; //Set the span \n\n        childGrid.setSpan();\n        childGrid.checkSpan(); // Draw the child grid.\n\n        let childGridResult = layouter.Layouter(param); //let childGridResult : PdfLayoutResult = layouter.innerLayout(param);\n\n        this.value = childGrid;\n\n        if (this.row.grid.splitChildRowIndex !== -1) {\n          this.height = this.row.rowBreakHeightValue;\n        }\n\n        if (param.page != childGridResult.page) //&& (isWidthGreaterthanParent != true))\n          {\n            childGridResult.bounds.height = this.row.rowBreakHeightValue;\n            if (this.row.rowBreakHeight == 0) this.row.NestedGridLayoutResult = childGridResult;else this.row.rowBreakHeight = this.row.rowBreakHeightValue; //bounds.height = this.row.rowBreakHeight;\n            //After drawing paginated nested grid, the bounds of the parent grid in start page should be corrected for borders.\n            //bounds.height = graphics.clientSize.height - bounds.y;\n          }\n      }\n    } else if (this.objectValue instanceof PdfImage || this.objectValue instanceof PdfBitmap) {\n      let imageBounds;\n\n      if (this.objectValue.width <= innerLayoutArea.width) {\n        imageBounds = new RectangleF(innerLayoutArea.x, innerLayoutArea.y, this.objectValue.width, innerLayoutArea.height);\n      } else {\n        imageBounds = innerLayoutArea;\n      }\n\n      graphics.drawImage(this.objectValue, imageBounds.x, imageBounds.y, imageBounds.width, imageBounds.height);\n    } else if (this.objectValue instanceof PdfTextWebLink) {\n      this.objectValue.draw(graphics.currentPage, innerLayoutArea);\n    } else if (typeof this.objectValue === 'undefined') {\n      this.objectValue = \"\";\n      graphics.drawString(this.objectValue, font, textPen, textBrush, innerLayoutArea.x, innerLayoutArea.y, innerLayoutArea.width, innerLayoutArea.height, strFormat);\n\n      if (this.style.cellPadding != null && this.style.cellPadding.bottom == 0 && this.style.cellPadding.left == 0 && this.style.cellPadding.right == 0 && this.style.cellPadding.top == 0) {\n        bounds.width -= this.style.borders.left.width + this.style.borders.right.width;\n      }\n\n      if (this.gridRow.grid.style.cellSpacing != 0) {\n        bounds.width -= this.gridRow.grid.style.cellSpacing;\n      }\n    }\n\n    if (this.style.borders != null) {\n      if (!this.fontSpilt) this.drawCellBorders(graphics, bounds);else {\n        if (this.row.grid.ParentCell.row.grid.splitChildRowIndex != -1) {\n          this.row.rowFontSplit = false;\n          this.drawCellBorders(graphics, bounds);\n        }\n      }\n    }\n\n    return result;\n  }\n  /* tslint:enable */\n\n  /**\n   * Draws the `cell border` constructed by drawing lines.\n   * @private\n   */\n\n\n  drawCellBorders(graphics, bounds) {\n    if (this.row.grid.style.borderOverlapStyle === PdfBorderOverlapStyle.Inside) {\n      bounds.x += this.style.borders.left.width;\n      bounds.y += this.style.borders.top.width;\n      bounds.width -= this.style.borders.right.width;\n      bounds.height -= this.style.borders.bottom.width;\n    }\n\n    let p1 = new PointF(bounds.x, bounds.y + bounds.height);\n    let p2 = new PointF(bounds.x, bounds.y);\n    let pen = this.cellStyle.borders.left;\n\n    if (this.cellStyle.borders.left.dashStyle === PdfDashStyle.Solid) {\n      pen.lineCap = PdfLineCap.Square;\n    } // SetTransparency(ref graphics, pen);\n\n\n    if (pen.width !== 0) {\n      graphics.drawLine(pen, p1, p2);\n    }\n\n    p1 = new PointF(bounds.x + bounds.width, bounds.y);\n    p2 = new PointF(bounds.x + bounds.width, bounds.y + bounds.height);\n    pen = this.cellStyle.borders.right;\n\n    if (bounds.x + bounds.width > graphics.clientSize.width - pen.width / 2) {\n      p1 = new PointF(graphics.clientSize.width - pen.width / 2, bounds.y);\n      p2 = new PointF(graphics.clientSize.width - pen.width / 2, bounds.y + bounds.height);\n    }\n\n    if (this.cellStyle.borders.right.dashStyle === PdfDashStyle.Solid) {\n      pen.lineCap = PdfLineCap.Square;\n    }\n\n    if (pen.width !== 0) {\n      graphics.drawLine(pen, p1, p2);\n    }\n\n    p1 = new PointF(bounds.x, bounds.y);\n    p2 = new PointF(bounds.x + bounds.width, bounds.y);\n    pen = this.cellStyle.borders.top;\n\n    if (this.cellStyle.borders.top.dashStyle === PdfDashStyle.Solid) {\n      pen.lineCap = PdfLineCap.Square;\n    }\n\n    if (pen.width !== 0) {\n      graphics.drawLine(pen, p1, p2);\n    }\n\n    p1 = new PointF(bounds.x + bounds.width, bounds.y + bounds.height);\n    p2 = new PointF(bounds.x, bounds.y + bounds.height);\n    pen = this.cellStyle.borders.bottom;\n\n    if (bounds.y + bounds.height > graphics.clientSize.height - pen.width / 2) {\n      p1 = new PointF(bounds.x + bounds.width, graphics.clientSize.height - pen.width / 2);\n      p2 = new PointF(bounds.x, graphics.clientSize.height - pen.width / 2);\n    }\n\n    if (this.cellStyle.borders.bottom.dashStyle === PdfDashStyle.Solid) {\n      pen.lineCap = PdfLineCap.Square;\n    }\n\n    if (pen.width !== 0) {\n      graphics.drawLine(pen, p1, p2);\n    }\n  } // private setTransparency(graphics : PdfGraphics, pen : PdfPen) : void {\n  //     let alpha : number = (pen.color.a / 255) as number;\n  //     graphics.save();\n  //     graphics.setTransparency(alpha);\n  // }\n\n  /**\n   * `Adjusts the outer layout area`.\n   * @private\n   */\n\n  /* tslint:disable */\n\n\n  adjustOuterLayoutArea(bounds, g) {\n    let isHeader = false;\n    let cellSpacing = this.row.grid.style.cellSpacing;\n\n    if (cellSpacing > 0) {\n      bounds = new RectangleF(bounds.x + cellSpacing, bounds.y + cellSpacing, bounds.width - cellSpacing, bounds.height - cellSpacing);\n    }\n\n    let currentColIndex = this.row.cells.indexOf(this);\n\n    if (this.columnSpan > 1 || this.row.rowOverflowIndex > 0 && currentColIndex == this.row.rowOverflowIndex + 1 && this.isCellMergeContinue) {\n      let span = this.columnSpan;\n\n      if (span == 1 && this.isCellMergeContinue) {\n        for (let j = currentColIndex + 1; j < this.row.grid.columns.count; j++) {\n          if (this.row.cells.getCell(j).isCellMergeContinue) span++;else break;\n        }\n      }\n\n      let totalWidth = 0;\n\n      for (let i = currentColIndex; i < currentColIndex + span; i++) {\n        if (this.row.grid.style.allowHorizontalOverflow) {\n          let width;\n          let compWidth = this.row.grid.size.width < g.clientSize.width ? this.row.grid.size.width : g.clientSize.width;\n\n          if (this.row.grid.size.width > g.clientSize.width) {\n            width = bounds.x + totalWidth + this.row.grid.columns.getColumn(i).width;\n          } else {\n            width = totalWidth + this.row.grid.columns.getColumn(i).width;\n          }\n\n          if (width > compWidth) {\n            break;\n          }\n        }\n\n        totalWidth += this.row.grid.columns.getColumn(i).width;\n      }\n\n      totalWidth -= this.row.grid.style.cellSpacing;\n      bounds.width = totalWidth;\n    }\n\n    if (this.rowSpan > 1 || this.row.rowSpanExists) {\n      let span = this.rowSpan;\n      let currentRowIndex = this.row.grid.rows.rowCollection.indexOf(this.row);\n\n      if (currentRowIndex == -1) {\n        currentRowIndex = this.row.grid.headers.indexOf(this.row);\n\n        if (currentRowIndex != -1) {\n          isHeader = true;\n        }\n      } // if (span == 1 && this.isCellMergeContinue) {\n      //         for (let j : number = currentRowIndex + 1; j < this.row.grid.rows.count; j++)\n      //         {\n      //             let flag : boolean = (isHeader ? this.row.grid.headers.getHeader(j).cells.getCell(currentColIndex).isCellMergeContinue : this.row.grid.rows.getRow(j).cells.getCell(currentColIndex).isCellMergeContinue);\n      //             if (flag)\n      //                 span++;\n      //             else\n      //                 break;\n      //         }\n      // }\n\n\n      let totalHeight = 0;\n\n      for (let i = currentRowIndex; i < currentRowIndex + span; i++) {\n        totalHeight += isHeader ? this.row.grid.headers.getHeader(i).height : this.row.grid.rows.getRow(i).height;\n        let row = this.row.grid.rows.getRow(i);\n        let rowIndex = this.row.grid.rows.rowCollection.indexOf(row);\n        /*if (this.rowSpan > 1)\n            {\n                for (let k : number = 0; k < this.row.cells.count; k++) {\n                    let cell : PdfGridCell = this.row.cells.getCell(k);\n                    if(cell.rowSpan>1)\n                    {\n                        let tempHeight : number =0;\n                        \n                        for (let j :number = i; j < i +cell.rowSpan; j++)\n                        {\n                            if (!this.row.grid.rows.getRow(j).isRowSpanRowHeightSet)\n                                this.row.grid.rows.getRow(j).isRowHeightSet = false;\n                            tempHeight += this.row.grid.rows.getRow(j).height;\n                            if (!this.row.grid.rows.getRow(j).isRowSpanRowHeightSet)\n                                this.row.grid.rows.getRow(j).isRowHeightSet = true;\n                        }\n                        //To check the Row spanned cell height is greater than the total spanned row height.\n                        if(cell.height>tempHeight)\n                        {\n                            if (max < (cell.height - tempHeight))\n                            {\n                                max = cell.height - tempHeight;\n                                if (this.rowSpanRemainingHeight != 0 && max > this.rowSpanRemainingHeight)\n                                {\n                                    max += this.rowSpanRemainingHeight;\n                                }\n                                let index :number = row.cells.indexOf(cell);\n                                //set the m_rowspanRemainingHeight to last rowspanned row.\n                                this.row.grid.rows.getRow((rowIndex +cell.rowSpan) - 1).cells.getCell(index).rowSpanRemainingHeight = max;\n                                this.rowSpanRemainingHeight = this.row.grid.rows.getRow((rowIndex + cell.rowSpan) - 1).cells.getCell(index).rowSpanRemainingHeight;\n                            }\n                        }\n                    }\n                }\n            }\n            if (!this.row.grid.rows.getRow(i).isRowSpanRowHeightSet)\n            this.row.grid.rows.getRow(i).isRowHeightSet = true;*/\n      }\n\n      let cellIndex = this.row.cells.indexOf(this);\n      totalHeight -= this.row.grid.style.cellSpacing; // if (this.row.cells.getCell(cellIndex).height > totalHeight && (!this.row.grid.rows.getRow((currentRowIndex + span) - 1).isRowHeightSet)) {\n      //      this.row.grid.rows.getRow((currentRowIndex + span) - 1).cells.getCell(cellIndex).rowSpanRemainingHeight = this.row.cells.getCell(cellIndex).height - totalHeight;\n      //      totalHeight = this.row.cells.getCell(cellIndex).height;\n      //      bounds.height = totalHeight;\n      // } else {\n\n      bounds.height = totalHeight; //  }\n\n      if (!this.row.rowMergeComplete) {\n        bounds.height = totalHeight;\n      }\n    }\n\n    return bounds;\n  }\n  /* tslint:enable */\n\n  /**\n   * Gets the `text font`.\n   * @private\n   */\n\n\n  getTextFont() {\n    if (typeof this.style.font !== 'undefined' && this.style.font != null) {\n      return this.style.font;\n    } else if (typeof this.row.style.font !== 'undefined' && this.row.style.font != null) {\n      return this.row.style.font;\n    } else if (typeof this.row.grid.style.font !== 'undefined' && this.row.grid.style.font != null) {\n      return this.row.grid.style.font;\n    } else {\n      return PdfDocument.defaultFont;\n    }\n  }\n  /**\n   * Gets the `text brush`.\n   * @private\n   */\n\n\n  getTextBrush() {\n    if (typeof this.style.textBrush !== 'undefined' && this.style.textBrush != null) {\n      return this.style.textBrush;\n    } else if (typeof this.row.style.textBrush !== 'undefined' && this.row.style.textBrush != null) {\n      return this.row.style.textBrush;\n    } else {\n      return this.row.grid.style.textBrush;\n    }\n  }\n  /**\n   * Gets the `text pen`.\n   * @private\n   */\n\n\n  getTextPen() {\n    if (typeof this.style.textPen !== 'undefined' && this.style.textPen != null) {\n      return this.style.textPen;\n    } else if (typeof this.row.style.textPen !== 'undefined' && this.row.style.textPen != null) {\n      return this.row.style.textPen;\n    } else {\n      return this.row.grid.style.textPen;\n    }\n  }\n  /**\n   * Gets the `background brush`.\n   * @private\n   */\n\n\n  getBackgroundBrush() {\n    if (typeof this.style.backgroundBrush !== 'undefined' && this.style.backgroundBrush != null) {\n      return this.style.backgroundBrush;\n    } else if (typeof this.row.style.backgroundBrush !== 'undefined' && this.row.style.backgroundBrush != null) {\n      return this.row.style.backgroundBrush;\n    } else {\n      return this.row.grid.style.backgroundBrush;\n    }\n  }\n  /**\n   * Gets the `background image`.\n   * @private\n   */\n\n\n  getBackgroundImage() {\n    if (typeof this.style.backgroundImage !== 'undefined' && this.style.backgroundImage != null) {\n      return this.style.backgroundImage;\n    } else if (typeof this.row.style.backgroundImage !== 'undefined' && this.row.style.backgroundImage != null) {\n      return this.row.style.backgroundImage;\n    } else {\n      return this.row.grid.style.backgroundImage;\n    }\n  }\n  /**\n   * Gets the current `StringFormat`.\n   * @private\n   */\n\n\n  getStringFormat() {\n    if (typeof this.style.stringFormat !== 'undefined' && this.style.stringFormat != null) {\n      return this.style.stringFormat;\n    } else {\n      return this.stringFormat;\n    }\n  }\n  /**\n   * Calculates the `height`.\n   * @private\n   */\n\n\n  measureHeight() {\n    // .. Calculate the cell text height.\n    // .....Add border widths, cell spacings and paddings to the height.\n    let width = this.calculateWidth(); // //check whether the Current PdfGridCell has padding\n\n    if (this.style.cellPadding == null || typeof this.style.cellPadding === 'undefined') {\n      width -= this.gridRow.grid.style.cellPadding.right + this.gridRow.grid.style.cellPadding.left; //width -= (this.style.borders.left.width + this.style.borders.right.width);\n    } else {\n      width -= this.style.cellPadding.right + this.style.cellPadding.left;\n      width -= this.style.borders.left.width + this.style.borders.right.width;\n    }\n\n    let height = 0;\n    let layouter = new PdfStringLayouter();\n\n    if (typeof this.objectValue === 'string' || typeof this.remaining === 'string') {\n      let currentValue = this.objectValue;\n      /* tslint:disable */\n\n      if (!this.isFinish) currentValue = !(this.remaining === null || this.remaining === '' || typeof this.remaining === 'undefined') ? this.remaining : this.objectValue;\n      let slr = null;\n      let cellIndex = this.row.cells.indexOf(this);\n\n      if (this.gridRow.grid.style.cellSpacing != 0) {\n        width -= this.gridRow.grid.style.cellSpacing * 2;\n      }\n\n      if (!this.row.cells.getCell(cellIndex).hasColSpan && !this.row.cells.getCell(cellIndex).hasRowSpan) {\n        if (this.gridRow.grid.isChildGrid) {\n          if (width < 0) {\n            this.tempval = width;\n\n            if (this.style.cellPadding == null || typeof this.style.cellPadding === 'undefined') {\n              this.tempval += this.gridRow.grid.style.cellPadding.right + this.gridRow.grid.style.cellPadding.left;\n            } else {\n              this.tempval += this.style.cellPadding.right + this.style.cellPadding.left;\n              this.tempval += this.style.borders.left.width + this.style.borders.right.width;\n            }\n          } else {\n            this.tempval = width;\n          }\n\n          slr = layouter.layout(currentValue, this.getTextFont(), this.stringFormat, new SizeF(this.tempval, 0), false, new SizeF(0, 0));\n          height += slr.actualSize.height;\n        } else {\n          slr = layouter.layout(currentValue, this.getTextFont(), this.stringFormat, new SizeF(width, 0), false, new SizeF(0, 0));\n          height += slr.actualSize.height;\n        }\n      }\n      /* tslint:enable */\n\n\n      height += (this.style.borders.top.width + this.style.borders.bottom.width) * 2;\n    } else if (this.objectValue instanceof PdfGrid) {\n      let cellIndex = this.row.cells.indexOf(this);\n      let internalWidth = 0;\n\n      if (this.style.cellPadding != null || typeof this.style.cellPadding !== 'undefined') {\n        internalWidth = this.calculateWidth();\n\n        if (typeof this.style.cellPadding.left !== 'undefined' && this.style.cellPadding.hasLeftPad) {\n          internalWidth -= this.style.cellPadding.left;\n        }\n\n        if (typeof this.style.cellPadding.right !== 'undefined' && this.style.cellPadding.hasRightPad) {\n          internalWidth -= this.style.cellPadding.right;\n        }\n      } else if (this.row.grid.style.cellPadding != null || typeof this.row.grid.style.cellPadding !== 'undefined') {\n        internalWidth = this.calculateWidth();\n\n        if (typeof this.row.grid.style.cellPadding.left !== 'undefined' && this.row.grid.style.cellPadding.hasLeftPad) {\n          internalWidth -= this.row.grid.style.cellPadding.left;\n        }\n\n        if (typeof this.row.grid.style.cellPadding.right !== 'undefined' && this.row.grid.style.cellPadding.hasRightPad) {\n          internalWidth -= this.row.grid.style.cellPadding.right;\n        }\n      } else {\n        internalWidth = this.calculateWidth();\n      }\n\n      this.objectValue.tempWidth = internalWidth;\n\n      if (!this.row.cells.getCell(cellIndex).hasColSpan && !this.row.cells.getCell(cellIndex).hasRowSpan) {\n        height = this.objectValue.size.height;\n      } else {\n        height += (this.style.borders.top.width + this.style.borders.bottom.width) * 2;\n      }\n\n      if (this.gridRow.grid.style.cellSpacing !== 0) {\n        width -= this.gridRow.grid.style.cellSpacing * 2; //height += (this.row.grid.style.cellPadding.top + this.row.grid.style.cellPadding.bottom);\n      }\n\n      if (this.style.cellPadding != null || typeof this.style.cellPadding !== 'undefined') {\n        if (typeof this.row.grid.style.cellPadding.top !== 'undefined' && this.row.grid.style.cellPadding.hasTopPad) {\n          height += this.row.grid.style.cellPadding.top;\n        }\n\n        if (this.row.grid.style.cellPadding.hasBottomPad && typeof this.row.grid.style.cellPadding.bottom !== 'undefined') {\n          height += this.row.grid.style.cellPadding.bottom;\n        }\n      }\n\n      height += this.objectValue.style.cellSpacing;\n    } else if (this.objectValue instanceof PdfImage || this.objectValue instanceof PdfBitmap) {\n      height += this.objectValue.height;\n    } else if (this.objectValue instanceof PdfTextWebLink) {\n      let webLink = this.objectValue;\n      /* tslint:disable */\n\n      let slr = layouter.layout(webLink.text, webLink.font, webLink.stringFormat, new SizeF(width, 0), false, new SizeF(0, 0));\n      /* tslint:enable */\n\n      height += slr.actualSize.height;\n      height += (this.style.borders.top.width + this.style.borders.bottom.width) * 2;\n    } else if (typeof this.objectValue === 'undefined') {\n      if (this.style.cellPadding == null || typeof this.style.cellPadding === 'undefined') {\n        width -= this.gridRow.grid.style.cellPadding.right + this.gridRow.grid.style.cellPadding.left;\n      } else {\n        width -= this.style.cellPadding.right + this.style.cellPadding.left;\n        width -= this.style.borders.left.width + this.style.borders.right.width;\n      }\n\n      height += (this.style.borders.top.width + this.style.borders.bottom.width) * 2;\n    } //Add padding top and bottom value to height\n\n\n    if (!(this.objectValue instanceof PdfGrid)) {\n      if (this.style.cellPadding == null || typeof this.style.cellPadding === 'undefined') {\n        height += this.row.grid.style.cellPadding.top + this.row.grid.style.cellPadding.bottom;\n      } else {\n        height += this.style.cellPadding.top + this.style.cellPadding.bottom;\n      }\n    } else {\n      if (this.style.cellPadding == null || typeof this.style.cellPadding === 'undefined') {\n        if (typeof this.row.grid.style.cellPadding.top !== 'undefined' && this.row.grid.style.cellPadding.hasTopPad) {\n          height += this.row.grid.style.cellPadding.top;\n        }\n\n        if (typeof this.row.grid.style.cellPadding.bottom !== 'undefined' && this.row.grid.style.cellPadding.hasBottomPad) {\n          height += this.row.grid.style.cellPadding.bottom;\n        }\n      } else {\n        if (typeof this.style.cellPadding.top !== 'undefined' && this.style.cellPadding.hasTopPad) {\n          height += this.style.cellPadding.top;\n        }\n\n        if (typeof this.style.cellPadding.bottom !== 'undefined' && this.style.cellPadding.hasBottomPad) {\n          height += this.style.cellPadding.bottom;\n        }\n      }\n    }\n\n    height += this.row.grid.style.cellSpacing;\n    return height;\n  }\n  /**\n   * return the calculated `width` of the cell.\n   * @private\n   */\n\n\n  calculateWidth() {\n    let cellIndex = this.row.cells.indexOf(this);\n    let rowindex = this.row.grid.rows.rowCollection.indexOf(this.row);\n    let columnSpan = this.columnSpan;\n    let width = 0;\n\n    if (columnSpan === 1) {\n      for (let i = 0; i < columnSpan; i++) {\n        width += this.row.grid.columns.getColumn(cellIndex + i).width;\n      }\n    } else if (columnSpan > 1) {\n      for (let i = 0; i < columnSpan; i++) {\n        width += this.row.grid.columns.getColumn(cellIndex + i).width;\n\n        if (i + 1 < columnSpan) {\n          this.row.cells.getCell(cellIndex + i + 1).hasColSpan = true;\n        }\n      }\n    }\n\n    if (this.parent != null && this.parent.row.width > 0) {\n      if (this.row.grid.isChildGrid && this.parent != null && this.row.width > this.parent.row.width) {\n        width = 0;\n\n        for (let j = 0; j < this.parent.columnSpan; j++) {\n          width += this.parent.row.grid.columns.getColumn(j).width;\n        }\n\n        width = width / this.row.cells.count;\n      }\n    }\n\n    return width;\n  }\n\n}\n/**\n * `PdfGridCellCollection` class provides access to an ordered,\n * strongly typed collection of 'PdfGridCell' objects.\n * @private\n */\n\n\nclass PdfGridCellCollection {\n  //Constructor\n\n  /**\n   * Initializes a new instance of the `PdfGridCellCollection` class with the row.\n   * @private\n   */\n  constructor(row) {\n    /**\n     * @hidden\n     * @private\n     */\n    this.cells = [];\n    this.gridRow = row;\n  } //Properties\n\n  /**\n   * Gets the current `cell`.\n   * @private\n   */\n\n\n  getCell(index) {\n    if (index < 0 || index >= this.count) {\n      throw new Error('IndexOutOfRangeException');\n    }\n\n    return this.cells[index];\n  }\n  /**\n   * Gets the cells `count`.[Read-Only].\n   * @private\n   */\n\n\n  get count() {\n    return this.cells.length;\n  }\n\n  add(cell) {\n    if (typeof cell === 'undefined') {\n      let tempcell = new PdfGridCell();\n      this.add(tempcell);\n      return cell;\n    } else {\n      cell.row = this.gridRow;\n      this.cells.push(cell);\n    }\n  }\n  /**\n   * Returns the `index of` a particular cell in the collection.\n   * @private\n   */\n\n\n  indexOf(cell) {\n    return this.cells.indexOf(cell);\n  }\n\n}\n/**\n * `PdfGridColumn` class represents the schema of a column in a 'PdfGrid'.\n */\n\n\nclass PdfGridColumn {\n  //Constructors\n\n  /**\n   * Initializes a new instance of the `PdfGridColumn` class with the parent grid.\n   * @private\n   */\n  constructor(grid) {\n    /**\n     * The `width` of the column.\n     * @default 0\n     * @private\n     */\n    this.columnWidth = 0;\n    this.grid = grid;\n  }\n  /**\n   * Gets or sets the `width` of the 'PdfGridColumn'.\n   * @private\n   */\n\n\n  get width() {\n    return this.columnWidth;\n  }\n\n  set width(value) {\n    this.isCustomWidth = true;\n    this.columnWidth = value;\n  }\n  /**\n   * Gets or sets the information about the text `formatting`.\n   * @private\n   */\n\n\n  get format() {\n    if (this.stringFormat == null) {\n      this.stringFormat = new PdfStringFormat(); //GetDefaultFormat();\n    }\n\n    return this.stringFormat;\n  }\n\n  set format(value) {\n    this.stringFormat = value;\n  }\n\n}\n/**\n * `PdfGridColumnCollection` class provides access to an ordered,\n * strongly typed collection of 'PdfGridColumn' objects.\n * @private\n */\n\n\nclass PdfGridColumnCollection {\n  //properties\n  //Constructors\n\n  /**\n   * Initializes a new instance of the `PdfGridColumnCollection` class with the parent grid.\n   * @private\n   */\n  constructor(grid) {\n    /**\n     * @hidden\n     * @private\n     */\n    this.internalColumns = [];\n    /**\n     * @hidden\n     * @private\n     */\n\n    this.columnWidth = 0;\n    this.grid = grid;\n    this.internalColumns = [];\n  } //Iplementation\n\n  /**\n   * `Add` a new column to the 'PdfGrid'.\n   * @private\n   */\n\n\n  add(count) {\n    // public add(column : PdfGridColumn) : void\n    // public add(arg : number|PdfGridColumn) : void {\n    // if (typeof arg === 'number') {\n    for (let i = 0; i < count; i++) {\n      this.internalColumns.push(new PdfGridColumn(this.grid));\n\n      for (let index = 0; index < this.grid.rows.count; index++) {\n        let row = this.grid.rows.getRow(index);\n        let cell = new PdfGridCell();\n        cell.value = '';\n        row.cells.add(cell);\n      }\n    } // } else {\n    //     let column : PdfGridColumn = new PdfGridColumn(this.grid);\n    //     this.columns.push(column);\n    //     return column;\n    // }\n\n  }\n  /**\n   * Gets the `number of columns` in the 'PdfGrid'.[Read-Only].\n   * @private\n   */\n\n\n  get count() {\n    return this.internalColumns.length;\n  }\n  /**\n   * Gets the `widths`.\n   * @private\n   */\n\n\n  get width() {\n    if (this.columnWidth === 0) {\n      this.columnWidth = this.measureColumnsWidth();\n    }\n\n    if (this.grid.initialWidth !== 0 && this.columnWidth !== this.grid.initialWidth && !this.grid.style.allowHorizontalOverflow) {\n      this.columnWidth = this.grid.initialWidth;\n      this.grid.isPageWidth = true;\n    }\n\n    return this.columnWidth;\n  }\n  /**\n   * Gets the `array of PdfGridColumn`.[Read-Only]\n   * @private\n   */\n\n\n  get columns() {\n    return this.internalColumns;\n  }\n  /**\n   * Gets the `PdfGridColumn` from the specified index.[Read-Only]\n   * @private\n   */\n\n\n  getColumn(index) {\n    if (index >= 0 && index <= this.columns.length) {\n      return this.columns[index];\n    } else {\n      throw Error('can not get the column from the index: ' + index);\n    }\n  } //Implementation\n\n  /**\n   * `Calculates the column widths`.\n   * @private\n   */\n\n\n  measureColumnsWidth() {\n    let totalWidth = 0;\n    this.grid.measureColumnsWidth();\n\n    for (let i = 0, count = this.internalColumns.length; i < count; i++) {\n      totalWidth += this.internalColumns[i].width;\n    }\n\n    return totalWidth;\n  }\n  /**\n   * Gets the `widths of the columns`.\n   * @private\n   */\n\n\n  getDefaultWidths(totalWidth) {\n    let widths = [];\n    let subFactor = this.count;\n\n    for (let i = 0; i < this.count; i++) {\n      if (this.grid.isPageWidth && totalWidth >= 0 && !this.internalColumns[i].isCustomWidth) {\n        this.internalColumns[i].width = 0;\n      } else {\n        widths[i] = this.internalColumns[i].width;\n\n        if (this.internalColumns[i].width > 0 && this.internalColumns[i].isCustomWidth) {\n          totalWidth -= this.internalColumns[i].width;\n          subFactor--;\n        } else {\n          widths[i] = 0;\n        }\n      }\n    }\n\n    for (let i = 0; i < this.count; i++) {\n      let width = totalWidth / subFactor;\n\n      if (widths[i] <= 0) {\n        widths[i] = width;\n      }\n    }\n\n    return widths;\n  }\n\n}\n/**\n * `PdfGridRow` class provides customization of the settings for the particular row.\n */\n\n\nclass PdfGridRow {\n  //Constructor\n\n  /**\n   * Initializes a new instance of the `PdfGridRow` class with the parent grid.\n   * @private\n   */\n  constructor(grid) {\n    /**\n     * Stores the index of the overflowing row.\n     * @private\n     */\n    this.gridRowOverflowIndex = 0;\n    /**\n     * The `height` of the row.\n     * @private\n     */\n\n    this.rowHeight = 0;\n    /**\n     * The `width` of the row.\n     * @private\n     */\n\n    this.rowWidth = 0;\n    /**\n     * The `isFinish` of the row.\n     * @private\n     */\n\n    this.isrowFinish = false;\n    /**\n     * Check whether the Row span row height `is set explicitly`.\n     * @default false\n     * @public\n     */\n\n    this.isRowSpanRowHeightSet = false;\n    /**\n     * The `page count` of the row.\n     * @public\n     */\n\n    this.noOfPageCount = 0;\n    /**\n     * Check whether the row height `is set explicitly`.\n     * @default false\n     * @private\n     */\n\n    this.isRowHeightSet = false;\n    this.isPageBreakRowSpanApplied = false;\n    /**\n     * Check weather the row merge `is completed` or not.\n     * @default true\n     * @private\n     */\n\n    this.isRowMergeComplete = true;\n    this.repeatFlag = false;\n    this.rowFontSplit = false;\n    this.pdfGrid = grid;\n  } //Properties\n\n  /**\n   * Gets or sets a value indicating [`row span exists`].\n   * @private\n   */\n\n\n  get rowSpanExists() {\n    return this.bRowSpanExists;\n  }\n\n  set rowSpanExists(value) {\n    this.bRowSpanExists = value;\n  }\n  /**\n   * Gets the `cells` from the selected row.[Read-Only].\n   * @private\n   */\n\n\n  get cells() {\n    if (this.gridCells == null) {\n      this.gridCells = new PdfGridCellCollection(this);\n    }\n\n    return this.gridCells;\n  }\n  /**\n   * Gets or sets the parent `grid`.\n   * @private\n   */\n\n\n  get grid() {\n    return this.pdfGrid;\n  }\n\n  set grid(value) {\n    this.pdfGrid = value;\n  }\n  /**\n   * Gets or sets the row `style`.\n   * @private\n   */\n\n\n  get style() {\n    if (typeof this.rowStyle === 'undefined') {\n      this.rowStyle = new PdfGridRowStyle();\n      this.rowStyle.setParent(this);\n    }\n\n    return this.rowStyle;\n  }\n\n  set style(value) {\n    this.rowStyle = value;\n\n    for (let i = 0; i < this.cells.count; i++) {\n      this.cells.getCell(i).style.borders = value.border;\n\n      if (typeof value.font !== 'undefined') {\n        this.cells.getCell(i).style.font = value.font;\n      }\n\n      if (typeof value.backgroundBrush !== 'undefined') {\n        this.cells.getCell(i).style.backgroundBrush = value.backgroundBrush;\n      }\n\n      if (typeof value.backgroundImage !== 'undefined') {\n        this.cells.getCell(i).style.backgroundImage = value.backgroundImage;\n      }\n\n      if (typeof value.textBrush !== 'undefined') {\n        this.cells.getCell(i).style.textBrush = value.textBrush;\n      }\n\n      if (typeof value.textPen !== 'undefined') {\n        this.cells.getCell(i).style.textPen = value.textPen;\n      }\n    }\n  }\n  /**\n   * `Height` of the row yet to be drawn after split.\n   * @private\n   */\n\n\n  get rowBreakHeight() {\n    if (typeof this.gridRowBreakHeight === 'undefined') {\n      this.gridRowBreakHeight = 0;\n    }\n\n    return this.gridRowBreakHeight;\n  }\n\n  set rowBreakHeight(value) {\n    this.gridRowBreakHeight = value;\n  }\n  /**\n   * `over flow index` of the row.\n   * @private\n   */\n\n\n  get rowOverflowIndex() {\n    return this.gridRowOverflowIndex;\n  }\n\n  set rowOverflowIndex(value) {\n    this.gridRowOverflowIndex = value;\n  }\n  /**\n   * Gets or sets the `height` of the row.\n   * @private\n   */\n\n\n  get height() {\n    if (!this.isRowHeightSet) {\n      this.rowHeight = this.measureHeight();\n    }\n\n    return this.rowHeight;\n  }\n\n  set height(value) {\n    this.rowHeight = value;\n    this.isRowHeightSet = true;\n  }\n  /**\n   * Gets or sets the `width` of the row.\n   * @private\n   */\n\n\n  get width() {\n    if (this.rowWidth === 0 || typeof this.rowWidth === 'undefined') {\n      this.rowWidth = this.measureWidth();\n    }\n\n    return this.rowWidth;\n  }\n  /**\n   * Gets or sets the row `Nested grid Layout Result`.\n   * @private\n   */\n\n\n  get NestedGridLayoutResult() {\n    return this.gridResult;\n  }\n\n  set NestedGridLayoutResult(value) {\n    this.gridResult = value;\n  }\n  /**\n   * Gets or sets a value indicating [`column span exists`].\n   * @private\n   */\n\n\n  get columnSpanExists() {\n    return this.bColumnSpanExists;\n  }\n\n  set columnSpanExists(value) {\n    this.bColumnSpanExists = value;\n  }\n  /**\n   * Check whether the Row `has row span or row merge continue`.\n   * @private\n   */\n\n\n  get rowMergeComplete() {\n    return this.isRowMergeComplete;\n  }\n\n  set rowMergeComplete(value) {\n    this.isRowMergeComplete = value;\n  }\n  /**\n   * Returns `index` of the row.\n   * @private\n   */\n\n\n  get rowIndex() {\n    return this.grid.rows.rowCollection.indexOf(this);\n  } //Implementation\n\n  /**\n   * `Calculates the height`.\n   * @private\n   */\n\n\n  measureHeight() {\n    let rowSpanRemainingHeight = 0;\n    let rowHeight;\n    let maxHeight = 0;\n\n    if (this.cells.getCell(0).rowSpan > 1) {\n      rowHeight = 0;\n    } else {\n      rowHeight = this.cells.getCell(0).height;\n    }\n\n    for (let i = 0; i < this.cells.count; i++) {\n      let cell = this.cells.getCell(i); //get the maximum rowspan remaining height.\n\n      if (cell.rowSpanRemainingHeight > rowSpanRemainingHeight) {\n        rowSpanRemainingHeight = cell.rowSpanRemainingHeight;\n      } //skip the cell if row spanned.\n      // if (cell.isRowMergeContinue) {\n      //     continue;\n      // }\n      // if (!cell.isRowMergeContinue) {\n      //     this.rowMergeComplete = false;\n      // }\n\n\n      this.rowMergeComplete = false;\n\n      if (cell.rowSpan > 1) {\n        let cellIn = i;\n        let rowin = this.grid.rows.rowCollection.indexOf(this);\n\n        for (let j = 0; j < cell.rowSpan; j++) {\n          if (j + 1 < cell.rowSpan) {\n            this.grid.rows.getRow(rowin + j + 1).cells.getCell(cellIn).hasRowSpan = true;\n          }\n        }\n\n        if (maxHeight < cell.height) {\n          maxHeight = cell.height;\n        }\n\n        continue;\n      }\n\n      rowHeight = Math.max(rowHeight, cell.height);\n    }\n\n    if (maxHeight > rowHeight) {\n      rowHeight = maxHeight;\n    }\n\n    if (rowHeight === 0) {\n      rowHeight = maxHeight;\n    } else if (rowSpanRemainingHeight > 0) {\n      rowHeight += rowSpanRemainingHeight;\n    }\n\n    return rowHeight;\n  }\n\n  measureWidth() {\n    let rowWid = 0;\n\n    for (let i = 0; i < this.grid.columns.count; i++) {\n      let column = this.grid.columns.getColumn(i);\n      rowWid += column.width;\n    }\n\n    return rowWid;\n  }\n\n}\n/**\n * `PdfGridRowCollection` class provides access to an ordered, strongly typed collection of 'PdfGridRow' objects.\n * @private\n */\n\n\nclass PdfGridRowCollection {\n  // Constructor\n\n  /**\n   * Initializes a new instance of the `PdfGridRowCollection` class with the parent grid.\n   * @private\n   */\n  constructor(grid) {\n    this.rows = [];\n    this.grid = grid;\n  } //Properties\n\n  /**\n   * Gets the number of header in the `PdfGrid`.[Read-Only].\n   * @private\n   */\n\n\n  get count() {\n    return this.rows.length;\n  } //Implementation\n\n  /**\n   * Return the row collection of the `grid`.\n   * @private\n   */\n\n\n  get rowCollection() {\n    return this.rows;\n  }\n\n  addRow(arg) {\n    if (typeof arg === 'undefined') {\n      let temprow = new PdfGridRow(this.grid);\n      this.addRow(temprow);\n      return temprow;\n    } else {\n      arg.style.setBackgroundBrush(this.grid.style.backgroundBrush);\n      arg.style.setFont(this.grid.style.font);\n      arg.style.setTextBrush(this.grid.style.textBrush);\n      arg.style.setTextPen(this.grid.style.textPen);\n\n      if (arg.cells.count === 0) {\n        for (let i = 0; i < this.grid.columns.count; i++) {\n          arg.cells.add(new PdfGridCell());\n        }\n      }\n\n      this.rows.push(arg);\n    }\n  }\n  /**\n   * Return the row by index.\n   * @private\n   */\n\n\n  getRow(index) {\n    return this.rows[index];\n  }\n\n}\n/**\n * `PdfGridHeaderCollection` class provides customization of the settings for the header.\n * @private\n */\n\n\nclass PdfGridHeaderCollection {\n  //constructor\n\n  /**\n   * Initializes a new instance of the `PdfGridHeaderCollection` class with the parent grid.\n   * @private\n   */\n  constructor(grid) {\n    /**\n     * The array to store the `rows` of the grid header.\n     * @private\n     */\n    this.rows = [];\n    this.grid = grid;\n    this.rows = [];\n  } //Properties\n\n  /**\n   * Gets a 'PdfGridRow' object that represents the `header` row in a 'PdfGridHeaderCollection' control.[Read-Only].\n   * @private\n   */\n\n\n  getHeader(index) {\n    // if (index < 0 || index >= Count) {\n    //     throw new IndexOutOfRangeException();\n    // }\n    return this.rows[index];\n  }\n  /**\n   * Gets the `number of header` in the 'PdfGrid'.[Read-Only]\n   * @private\n   */\n\n\n  get count() {\n    return this.rows.length;\n  }\n\n  add(arg) {\n    if (typeof arg === 'number') {\n      let row;\n\n      for (let i = 0; i < arg; i++) {\n        row = new PdfGridRow(this.grid);\n\n        for (let j = 0; j < this.grid.columns.count; j++) {\n          row.cells.add(new PdfGridCell());\n        }\n\n        this.rows.push(row);\n      }\n\n      return this.rows;\n    } else {\n      this.rows.push(arg);\n    }\n  }\n\n  indexOf(row) {\n    return this.rows.indexOf(row);\n  }\n\n}\n/**\n * PdfGrid.ts class for EJ2-PDF\n */\n\n\nclass PdfGrid extends PdfLayoutElement {\n  //constructor\n\n  /**\n   * Initialize a new instance for `PdfGrid` class.\n   * @private\n   */\n  constructor() {\n    super();\n    /**\n     * @hidden\n     * @private\n     */\n\n    this.gridSize = new SizeF(0, 0);\n    /**\n     * Check the child grid is ' split or not'\n     */\n\n    this.isGridSplit = false;\n    /**\n     * @hidden\n     * @private\n     */\n\n    this.isRearranged = false;\n    /**\n     * @hidden\n     * @private\n     */\n\n    this.pageBounds = new RectangleF();\n    /**\n     * @hidden\n     * @private\n     */\n\n    this.listOfNavigatePages = [];\n    /**\n     * @hidden\n     * @private\n     */\n\n    this.parentCellIndex = 0;\n    this.tempWidth = 0;\n    /**\n     * @hidden\n     * @private\n     */\n\n    this.breakRow = true;\n    this.splitChildRowIndex = -1;\n    /**\n     * The event raised on `begin cell lay outing`.\n     * @event\n     * @private\n     */\n    //public beginPageLayout : Function;\n\n    /**\n     * The event raised on `end cell lay outing`.\n     * @event\n     * @private\n     */\n    //public endPageLayout : Function;\n\n    this.hasRowSpanSpan = false;\n    this.hasColumnSpan = false;\n    this.isSingleGrid = true;\n  } //Properties\n\n  /**\n   * Gets a value indicating whether the `start cell layout event` should be raised.\n   * @private\n   */\n\n\n  get raiseBeginCellDraw() {\n    return typeof this.beginCellDraw !== 'undefined' && typeof this.beginCellDraw !== null;\n  }\n  /**\n   * Gets a value indicating whether the `end cell layout event` should be raised.\n   * @private\n   */\n\n\n  get raiseEndCellDraw() {\n    return typeof this.endCellDraw !== 'undefined' && typeof this.endCellDraw !== null;\n  }\n  /**\n   * Gets or sets a value indicating whether to `repeat header`.\n   * @private\n   */\n\n\n  get repeatHeader() {\n    if (this.bRepeatHeader == null || typeof this.bRepeatHeader === 'undefined') {\n      this.bRepeatHeader = false;\n    }\n\n    return this.bRepeatHeader;\n  }\n\n  set repeatHeader(value) {\n    this.bRepeatHeader = value;\n  }\n  /**\n   * Gets or sets a value indicating whether to split or cut rows that `overflow a page`.\n   * @private\n   */\n\n\n  get allowRowBreakAcrossPages() {\n    return this.breakRow;\n  }\n\n  set allowRowBreakAcrossPages(value) {\n    this.breakRow = value;\n  }\n  /**\n   * Gets the `column` collection of the PdfGrid.[Read-Only]\n   * @private\n   */\n\n\n  get columns() {\n    if (this.gridColumns == null || typeof this.gridColumns === 'undefined') {\n      this.gridColumns = new PdfGridColumnCollection(this);\n    }\n\n    return this.gridColumns;\n  }\n  /**\n   * Gets the `row` collection from the PdfGrid.[Read-Only]\n   * @private\n   */\n\n\n  get rows() {\n    if (this.gridRows == null) {\n      this.gridRows = new PdfGridRowCollection(this);\n    }\n\n    return this.gridRows;\n  }\n  /**\n   * Gets the `headers` collection from the PdfGrid.[Read-Only]\n   * @private\n   */\n\n\n  get headers() {\n    if (this.gridHeaders == null || typeof this.gridHeaders === 'undefined') {\n      this.gridHeaders = new PdfGridHeaderCollection(this);\n    }\n\n    return this.gridHeaders;\n  }\n  /**\n   * Indicating `initial width` of the page.\n   * @private\n   */\n\n\n  get initialWidth() {\n    return this.gridInitialWidth;\n  }\n\n  set initialWidth(value) {\n    this.gridInitialWidth = value;\n  }\n  /**\n   * Gets or sets the `grid style`.\n   * @private\n   */\n\n\n  get style() {\n    if (this.gridStyle == null) {\n      this.gridStyle = new PdfGridStyle();\n    }\n\n    return this.gridStyle;\n  }\n\n  set style(value) {\n    if (this.gridStyle == null) {\n      this.gridStyle = value;\n    }\n  }\n  /**\n   * Gets a value indicating whether the grid column width is considered to be `page width`.\n   * @private\n   */\n\n\n  get isPageWidth() {\n    return this.ispageWidth;\n  }\n\n  set isPageWidth(value) {\n    this.ispageWidth = value;\n  }\n  /**\n   * Gets or set if grid `is nested grid`.\n   * @private\n   */\n\n\n  get isChildGrid() {\n    return this.ischildGrid;\n  }\n\n  set isChildGrid(value) {\n    this.ischildGrid = value;\n  }\n  /**\n   * Gets or set if grid ' is split or not'\n   * @public\n   */\n  // public get isGridSplit() : boolean {\n  //     return this.isgridSplit;\n  // }\n  // public set isGridSplit(value : boolean) {\n  //     this.isgridSplit = value;\n  // }public get isGridSplit() : boolean {\n  //     return this.isgridSplit;\n  // }\n  // public set isGridSplit(value : boolean) {\n  //     this.isgridSplit = value;\n  // }\n\n  /**\n   * Gets the `size`.\n   * @private\n   */\n\n\n  get size() {\n    if ((this.gridSize.width === 0 || typeof this.gridSize.width === 'undefined') && this.gridSize.height === 0) {\n      this.gridSize = this.measure();\n    }\n\n    return this.gridSize; // } else {\n    //     return this.gridSize;\n    // }\n  }\n\n  set size(value) {\n    this.gridSize = value;\n  }\n\n  get ParentCell() {\n    return this.parentCell;\n  }\n\n  set ParentCell(value) {\n    this.parentCell = value;\n  }\n\n  get LayoutFormat() {\n    return this.layoutFormat;\n  }\n\n  draw(arg1, arg2, arg3, arg4) {\n    if (arg2 instanceof PointF && typeof arg2.width === 'undefined' && typeof arg3 === 'undefined') {\n      return this.drawHelper(arg1, arg2.x, arg2.y);\n    } else if (typeof arg2 === 'number' && typeof arg3 === 'number' && typeof arg4 === 'undefined') {\n      return this.drawHelper(arg1, arg2, arg3, null);\n    } else if (arg2 instanceof RectangleF && typeof arg2.width !== 'undefined' && typeof arg3 === 'undefined') {\n      return this.drawHelper(arg1, arg2, null);\n    } else if (arg2 instanceof PointF && typeof arg2.width === 'undefined' && arg3 instanceof PdfLayoutFormat) {\n      return this.drawHelper(arg1, arg2.x, arg2.y, arg3);\n    } else if (typeof arg2 === 'number' && typeof arg3 === 'number' && (arg4 instanceof PdfLayoutFormat || arg4 == null)) {\n      let width = arg1.graphics.clientSize.width - arg2;\n      let layoutRectangle = new RectangleF(arg2, arg3, width, 0);\n      return this.drawHelper(arg1, layoutRectangle, arg4);\n    } else if (arg2 instanceof RectangleF && typeof arg2.width !== 'undefined' && typeof arg3 === 'boolean') {\n      return this.drawHelper(arg1, arg2, null);\n    } else {\n      return this.drawHelper(arg1, arg2, arg3);\n    }\n  }\n  /**\n   * `measures` this instance.\n   * @private\n   */\n\n\n  measure() {\n    let height = 0;\n    let width = this.columns.width;\n\n    for (let i = 0; i < this.headers.count; i++) {\n      let row = this.headers.getHeader(i);\n      height += row.height;\n    }\n\n    for (let i = 0; i < this.rows.count; i++) {\n      let row = this.rows.getRow(i);\n      height += row.height;\n    }\n\n    return new SizeF(width, height);\n  }\n\n  onBeginCellDraw(args) {\n    if (this.raiseBeginCellDraw) {\n      this.beginCellDraw(this, args);\n    }\n  }\n\n  onEndCellDraw(args) {\n    if (this.raiseEndCellDraw) {\n      this.endCellDraw(this, args);\n    }\n  }\n  /**\n   * `Layouts` the specified graphics.\n   * @private\n   */\n\n\n  layout(param) {\n    if (this.rows.count !== 0) {\n      let currentRow = this.rows.getRow(0).cells.getCell(0).style;\n\n      if (currentRow.borders != null && (currentRow.borders.left != null && currentRow.borders.left.width !== 1 || currentRow.borders.top != null && currentRow.borders.top.width !== 1)) {\n        let x = currentRow.borders.left.width / 2;\n        let y = currentRow.borders.top.width / 2;\n\n        if (param.bounds.x === PdfBorders.default.right.width / 2 && param.bounds.y === PdfBorders.default.right.width / 2) {\n          let newBound = new RectangleF(x, y, this.gridSize.width, this.gridSize.height);\n          param.bounds = newBound;\n        }\n      }\n    }\n\n    this.setSpan();\n    this.checkSpan();\n    this.layoutFormat = param.format;\n    this.gridLocation = param.bounds;\n    let layouter = new PdfGridLayouter(this);\n    let result = layouter.Layouter(param);\n    return result;\n  }\n\n  setSpan() {\n    let colSpan = 1;\n    let rowSpan = 1;\n    let currentCellIndex = 0;\n    let currentRowIndex = 0;\n    let maxSpan = 0;\n    let rowCount = this.headers.count;\n\n    for (let i = 0; i < rowCount; i++) {\n      let row = this.headers.getHeader(i);\n      maxSpan = 0;\n      let colCount = row.cells.count;\n\n      for (let j = 0; j < colCount; j++) {\n        let cell = row.cells.getCell(j);\n        maxSpan = Math.max(maxSpan, cell.rowSpan); //Skip setting span map for already coverted rows/columns.\n\n        if (!cell.isCellMergeContinue && !cell.isRowMergeContinue && (cell.columnSpan > 1 || cell.rowSpan > 1)) {\n          if (cell.columnSpan + j > row.cells.count) {\n            throw new Error('Invalid span specified at row ' + j.toString() + ' column ' + i.toString());\n          }\n\n          if (cell.rowSpan + i > this.headers.count) {\n            throw new Error('Invalid span specified at Header ' + j.toString() + ' column ' + i.toString());\n          } // if (this.rows.count !== 0 && cell.rowSpan + i > this.rows.count) {\n          //     throw new Error('Invalid span specified at row ' + j.toString() + ' column ' + i.toString());\n          // }\n\n\n          if (cell.columnSpan > 1 && cell.rowSpan > 1) {\n            colSpan = cell.columnSpan;\n            rowSpan = cell.rowSpan;\n            currentCellIndex = j;\n            currentRowIndex = i;\n            cell.isCellMergeStart = true;\n            cell.isRowMergeStart = true; //Set Column merges for first row\n\n            while (colSpan > 1) {\n              currentCellIndex++;\n              row.cells.getCell(currentCellIndex).isCellMergeContinue = true;\n              row.cells.getCell(currentCellIndex).isRowMergeContinue = true;\n              row.cells.getCell(currentCellIndex).rowSpan = rowSpan;\n              colSpan--;\n            }\n\n            currentCellIndex = j;\n            colSpan = cell.columnSpan; //Set Row Merges and column merges foreach subsequent rows.\n\n            while (rowSpan > 1) {\n              currentRowIndex++;\n              this.headers.getHeader(currentRowIndex).cells.getCell(j).isRowMergeContinue = true;\n              this.headers.getHeader(currentRowIndex).cells.getCell(currentCellIndex).isRowMergeContinue = true;\n              rowSpan--;\n\n              while (colSpan > 1) {\n                currentCellIndex++;\n                this.headers.getHeader(currentRowIndex).cells.getCell(currentCellIndex).isCellMergeContinue = true;\n                this.headers.getHeader(currentRowIndex).cells.getCell(currentCellIndex).isRowMergeContinue = true;\n                colSpan--;\n              }\n\n              colSpan = cell.columnSpan;\n              currentCellIndex = j;\n            }\n          } else if (cell.columnSpan > 1 && cell.rowSpan === 1) {\n            colSpan = cell.columnSpan;\n            currentCellIndex = j;\n            cell.isCellMergeStart = true; //Set Column merges.\n\n            while (colSpan > 1) {\n              currentCellIndex++;\n              row.cells.getCell(currentCellIndex).isCellMergeContinue = true;\n              colSpan--;\n            }\n          } else if (cell.columnSpan === 1 && cell.rowSpan > 1) {\n            rowSpan = cell.rowSpan;\n            currentRowIndex = i; //Set row Merges.\n\n            while (rowSpan > 1) {\n              currentRowIndex++;\n              this.headers.getHeader(currentRowIndex).cells.getCell(j).isRowMergeContinue = true;\n              rowSpan--;\n            }\n          }\n        }\n      }\n\n      row.maximumRowSpan = maxSpan;\n    }\n  }\n\n  checkSpan() {\n    let cellcolSpan;\n    let cellrowSpan = 1;\n    let cellmaxSpan = 0;\n    let currentCellIndex;\n    let currentRowIndex = 0;\n    cellcolSpan = cellrowSpan = 1;\n    currentCellIndex = currentRowIndex = 0;\n\n    if (this.hasRowSpanSpan || this.hasColumnSpan) {\n      let rowCount = this.rows.count;\n\n      for (let i = 0; i < rowCount; i++) {\n        let row = this.rows.getRow(i);\n        cellmaxSpan = 0;\n        let colCount = row.cells.count;\n\n        for (let j = 0; j < colCount; j++) {\n          let cell = row.cells.getCell(j);\n          cellmaxSpan = Math.max(cellmaxSpan, cell.rowSpan); //Skip setting span map for already coverted rows/columns.\n\n          if (!cell.isCellMergeContinue && !cell.isRowMergeContinue && (cell.columnSpan > 1 || cell.rowSpan > 1)) {\n            if (cell.columnSpan + j > row.cells.count) {\n              throw new Error('Invalid span specified at row  ' + j.toString() + ' column ' + i.toString());\n            }\n\n            if (cell.rowSpan + i > this.rows.count) {\n              throw new Error('Invalid span specified at row  ' + j.toString() + ' column ' + i.toString());\n            }\n\n            if (cell.columnSpan > 1 && cell.rowSpan > 1) {\n              cellcolSpan = cell.columnSpan;\n              cellrowSpan = cell.rowSpan;\n              currentCellIndex = j;\n              currentRowIndex = i;\n              cell.isCellMergeStart = true;\n              cell.isRowMergeStart = true; //Set Column merges for first row\n\n              while (cellcolSpan > 1) {\n                currentCellIndex++;\n                row.cells.getCell(currentCellIndex).isCellMergeContinue = true;\n                row.cells.getCell(currentCellIndex).isRowMergeContinue = true;\n                cellcolSpan--;\n              }\n\n              currentCellIndex = j;\n              cellcolSpan = cell.columnSpan; //Set Row Merges and column merges foreach subsequent rows.\n\n              while (cellrowSpan > 1) {\n                currentRowIndex++;\n                this.rows.getRow(currentRowIndex).cells.getCell(j).isRowMergeContinue = true;\n                this.rows.getRow(currentRowIndex).cells.getCell(currentCellIndex).isRowMergeContinue = true;\n                cellrowSpan--;\n\n                while (cellcolSpan > 1) {\n                  currentCellIndex++;\n                  this.rows.getRow(currentRowIndex).cells.getCell(currentCellIndex).isCellMergeContinue = true;\n                  this.rows.getRow(currentRowIndex).cells.getCell(currentCellIndex).isRowMergeContinue = true;\n                  cellcolSpan--;\n                }\n\n                cellcolSpan = cell.columnSpan;\n                currentCellIndex = j;\n              }\n            } else if (cell.columnSpan > 1 && cell.rowSpan === 1) {\n              cellcolSpan = cell.columnSpan;\n              currentCellIndex = j;\n              cell.isCellMergeStart = true; //Set Column merges.\n\n              while (cellcolSpan > 1) {\n                currentCellIndex++;\n                row.cells.getCell(currentCellIndex).isCellMergeContinue = true;\n                cellcolSpan--;\n              }\n            } else if (cell.columnSpan === 1 && cell.rowSpan > 1) {\n              cellrowSpan = cell.rowSpan;\n              currentRowIndex = i; //Set row Merges.\n\n              while (cellrowSpan > 1) {\n                currentRowIndex++;\n                this.rows.getRow(currentRowIndex).cells.getCell(j).isRowMergeContinue = true;\n                cellrowSpan--;\n              }\n            }\n          }\n        }\n\n        row.maximumRowSpan = cellmaxSpan;\n      }\n    }\n  }\n\n  measureColumnsWidth(bounds) {\n    if (typeof bounds !== 'undefined') {\n      this.isPageWidth = false;\n      let widths = this.columns.getDefaultWidths(bounds.width - bounds.x); //let tempWidth : number = this.columns.getColumn(0).width;\n\n      for (let i = 0, count = this.columns.count; i < count; i++) {\n        // if (this.columns.getColumn(i).width < 0)\n        //     this.columns.getColumn(i).columnWidth = widths[i];\n        // else if (this.columns.getColumn(i).width > 0 && !this.columns.getColumn(i).isCustomWidth && widths[i]>0 && this.isComplete)\n        this.columns.getColumn(i).columnWidth = widths[i];\n        this.tempWidth = widths[i];\n      }\n\n      if (this.ParentCell != null && this.style.allowHorizontalOverflow == false && this.ParentCell.row.grid.style.allowHorizontalOverflow == false) {\n        let padding = 0;\n        let columnWidth = 0;\n        let columnCount = this.columns.count;\n        let childGridColumnWidth = 0;\n\n        if (this.ParentCell.style.cellPadding != null || typeof this.ParentCell.style.cellPadding !== 'undefined') {\n          if (typeof this.ParentCell.style.cellPadding.left != 'undefined' && this.ParentCell.style.cellPadding.hasLeftPad) {\n            padding += this.ParentCell.style.cellPadding.left;\n          }\n\n          if (typeof this.ParentCell.style.cellPadding.right != 'undefined' && this.ParentCell.style.cellPadding.hasRightPad) {\n            padding += this.ParentCell.style.cellPadding.right;\n          }\n        }\n\n        for (let i = 0; i < this.ParentCell.columnSpan; i++) {\n          columnWidth += this.ParentCell.row.grid.columns.getColumn(this.parentCellIndex + i).width;\n        }\n\n        for (let j = 0; j < this.columns.count; j++) {\n          if (this.gridColumns.getColumn(j).width > 0 && this.gridColumns.getColumn(j).isCustomWidth) {\n            columnWidth -= this.gridColumns.getColumn(j).width;\n            columnCount--;\n          }\n        }\n\n        if (this.ParentCell.row.grid.style.cellPadding != null || typeof this.ParentCell.row.grid.style.cellPadding != 'undefined') {\n          if (typeof this.ParentCell.row.grid.style.cellPadding.top != 'undefined' && this.ParentCell.row.grid.style.cellPadding.hasTopPad) {\n            padding += this.ParentCell.row.grid.style.cellPadding.top;\n          }\n\n          if (typeof this.ParentCell.row.grid.style.cellPadding.bottom != 'undefined' && this.ParentCell.row.grid.style.cellPadding.hasBottomPad) {\n            padding += this.ParentCell.row.grid.style.cellPadding.bottom;\n          }\n        }\n\n        if (this.ParentCell.row.grid.style.cellSpacing != 0) {\n          columnWidth -= this.ParentCell.row.grid.style.cellSpacing * 2;\n        }\n\n        if (columnWidth > padding) {\n          childGridColumnWidth = (columnWidth - padding) / columnCount;\n          this.tempWidth = childGridColumnWidth;\n\n          if (this.ParentCell != null) {\n            for (let j = 0; j < this.columns.count; j++) {\n              if (!this.columns.getColumn(j).isCustomWidth) this.columns.getColumn(j).columnWidth = childGridColumnWidth;\n            }\n          }\n        }\n      } // if (this.ParentCell != null && this.ParentCell.row.width > 0)\n      // {\n      //     if (this.isChildGrid && this.gridSize.width > this.ParentCell.row.width)\n      //     {\n      //         widths = this.columns.getDefaultWidths(bounds.width);\n      //         for (let i : number = 0; i < this.columns.count; i++)\n      //         {\n      //             this.columns.getColumn(i).width = widths[i];\n      //         }\n      //     }\n      // }\n\n    } else {\n      let widths = [this.columns.count];\n\n      for (let n = 0; n < this.columns.count; n++) {\n        widths[n] = 0;\n      }\n\n      let cellWidth = 0;\n\n      if (typeof this.isChildGrid === 'undefined' && typeof this.gridLocation !== 'undefined' || this.isChildGrid === null && typeof this.gridLocation !== 'undefined') {\n        this.initialWidth = this.gridLocation.width;\n      }\n\n      if (this.headers.count > 0) {\n        let colCount = this.headers.getHeader(0).cells.count;\n        let rowCount = this.headers.count;\n\n        for (let i = 0; i < colCount; i++) {\n          cellWidth = 0;\n\n          for (let j = 0; j < rowCount; j++) {\n            let rowWidth = Math.min(this.initialWidth, this.headers.getHeader(j).cells.getCell(i).width);\n            cellWidth = Math.max(cellWidth, rowWidth);\n          }\n\n          widths[i] = cellWidth;\n        }\n      } // else {\n      //     let colCount : number = this.rows.getRow(0).cells.count;\n      //     let rowCount : number = this.rows.count;\n      //     for (let i : number = 0; i < colCount; i++) {\n      //         cellWidth = 0;\n      //         for (let j : number = 0; j < rowCount; j++) {\n      //             let rowWidth : number = Math.min(this.initialWidth, this.rows.getRow(j).cells.getCell(i).width);\n      //             cellWidth = Math.max(cellWidth, rowWidth);\n      //         }\n      //         widths[i] = cellWidth;\n      //     }\n      // }\n\n\n      cellWidth = 0;\n\n      for (let i = 0, colCount = this.columns.count; i < colCount; i++) {\n        for (let j = 0, rowCount = this.rows.count; j < rowCount; j++) {\n          if (this.rows.getRow(j).cells.getCell(i).columnSpan == 1 && !this.rows.getRow(j).cells.getCell(i).isCellMergeContinue || this.rows.getRow(j).cells.getCell(i).value != null) {\n            if (this.rows.getRow(j).cells.getCell(i).value != null && !this.rows.getRow(j).grid.style.allowHorizontalOverflow) {\n              let value = this.rows.getRow(j).grid.style.cellPadding.right + this.rows.getRow(j).grid.style.cellPadding.left + this.rows.getRow(j).cells.getCell(i).style.borders.left.width / 2; //  if (this.initialWidth != 0 )\n              //         (this.rows.getRow(j).cells.getCell(i).value as PdfGrid).initialWidth = this.initialWidth - value;\n            }\n\n            let rowWidth = 0;\n            rowWidth = this.initialWidth > 0.0 ? Math.min(this.initialWidth, this.rows.getRow(j).cells.getCell(i).width) : this.rows.getRow(j).cells.getCell(i).width; // let internalWidth : number = this.rows.getRow(j).cells.getCell(i).width;\n            // internalWidth += this.rows.getRow(j).cells.getCell(i).style.borders.left.width;\n            // internalWidth += this.rows.getRow(j).cells.getCell(i).style.borders.right.width;\n            // let internalHeight : number = this.rows.getRow(j).cells.getCell(i).height;\n            // internalHeight += (this.rows.getRow(j).cells.getCell(i).style.borders.top.width);\n            // internalHeight += (this.rows.getRow(j).cells.getCell(i).style.borders.bottom.width);\n            // let isCorrectWidth : boolean = (internalWidth + this.gridLocation.x) > this.currentGraphics.clientSize.width;\n            // let isCorrectHeight : boolean = (internalHeight + this.gridLocation.y) > this.currentGraphics.clientSize.height;\n            // if (isCorrectWidth || isCorrectHeight) {\n            //     throw Error('Image size exceeds client size of the page. Can not insert this image');\n            // }\n            // rowWidth = Math.min(this.initialWidth, this.rows.getRow(j).cells.getCell(i).width);\n\n            cellWidth = Math.max(widths[i], Math.max(cellWidth, rowWidth));\n            cellWidth = Math.max(this.columns.getColumn(i).width, cellWidth);\n          }\n        }\n\n        if (this.rows.count != 0) widths[i] = cellWidth;\n        cellWidth = 0;\n      }\n\n      for (let i = 0, RowCount = this.rows.count; i < RowCount; i++) {\n        for (let j = 0, ColCount = this.columns.count; j < ColCount; j++) {\n          if (this.rows.getRow(i).cells.getCell(j).columnSpan > 1) {\n            for (let k = 1; k < this.rows.getRow(i).cells.getCell(j).columnSpan; k++) {} // if (this.rows.getRow(i).cells.getCell(j).width > total)\n            // {\n            //     let extendedWidth : number = this.rows.getRow(i).cells.getCell(j).width - total;\n            //     extendedWidth = extendedWidth / this.rows.getRow(i).cells.getCell(j).columnSpan;\n            //     for (let k : number = j; k < j + this.rows.getRow(i).cells.getCell(j).columnSpan; k++)\n            //         widths[k] += extendedWidth;\n            // }\n\n          }\n        }\n      } // if (this.isChildGrid && this.initialWidth != 0)\n      // {\n      //     widths = this.columns.getDefaultWidths(this.initialWidth);\n      // }\n\n\n      for (let i = 0, count = this.columns.count; i < count; i++) {\n        if (this.columns.getColumn(i).width <= 0) this.columns.getColumn(i).columnWidth = widths[i];else if (this.columns.getColumn(i).width > 0 && !this.columns.getColumn(i).isCustomWidth) this.columns.getColumn(i).columnWidth = widths[i];\n      }\n\n      let padding = 0;\n      let colWidth = 0;\n      let colCount = this.columns.count;\n      let childGridColWidth = 0;\n      colWidth = this.tempWidth;\n\n      for (let j = 0; j < this.columns.count; j++) {\n        if (this.gridColumns.getColumn(j).width > 0 && this.gridColumns.getColumn(j).isCustomWidth) {\n          colWidth -= this.gridColumns.getColumn(j).width;\n          colCount--;\n        }\n      } // if (this.style.cellSpacing != 0){\n      //     colWidth -= this.style.cellSpacing * 2;\n      // }\n\n\n      if (colWidth > 0) {\n        if (this.ParentCell.row.grid.style.cellSpacing != 0) {\n          colWidth -= this.ParentCell.row.grid.style.cellSpacing * 2;\n        }\n      }\n\n      if (colWidth > padding) {\n        childGridColWidth = colWidth / colCount;\n\n        if (this.ParentCell != null) {\n          for (let j = 0; j < this.columns.count; j++) {\n            if (!this.columns.getColumn(j).isCustomWidth) this.columns.getColumn(j).columnWidth = childGridColWidth;\n          }\n        }\n      }\n    }\n  }\n\n}\n/**\n * Class `lay outing the text`.\n *\n */\n\n\nlet PdfGridLayouter = /*#__PURE__*/(() => {\n  class PdfGridLayouter extends ElementLayouter {\n    //constructor\n\n    /**\n     * Initialize a new instance for `PdfGrid` class.\n     * @private\n     */\n    constructor(baseFormat) {\n      super(baseFormat);\n      /**\n       * @hidden\n       * @private\n       */\n\n      this.gridInitialWidth = 0;\n      /**\n       * @hidden\n       * @private\n       */\n\n      this.gridSize = new SizeF(0, 0);\n      this.parentCellIndex = 0;\n      this.tempWidth = 0;\n      this.childheight = 0;\n      /**\n       * Check weather it is `child grid or not`.\n       * @private\n       */\n\n      this.isChildGrid = false;\n      /**\n       * @hidden\n       * @private\n       */\n\n      this.hasRowSpanSpan = false;\n      /**\n       * @hidden\n       * @private\n       */\n\n      this.isRearranged = false;\n      /**\n       * @hidden\n       * @private\n       */\n\n      this.pageBounds = new RectangleF();\n      /**\n       * @hidden\n       * @private\n       */\n\n      this.listOfNavigatePages = [];\n      /**\n       * @hidden\n       * @private\n       */\n\n      this.flag = true;\n      /**\n       * @hidden\n       * @private\n       */\n\n      this.columnRanges = [];\n      /**\n       * @hidden\n       * @private\n       */\n\n      this.currentLocation = new PointF(0, 0);\n      /**\n       * @hidden\n       * @private\n       */\n\n      this.breakRow = true;\n      this.slr = null;\n      this.remainderText = null;\n      this.isPaginate = false;\n      /**\n       * Checks whether the x co-ordinate is need to set as client size or not.\n       * @hidden\n       * @private\n       */\n\n      this.isOverloadWithPosition = false;\n    } //Properties\n\n\n    get Grid() {\n      return this.elements;\n    } // Constructors\n\n    /**\n     * Initializes a new instance of the `StringLayouter` class.\n     * @private\n     */\n    //Public methods\n\n    /**\n     * `Layouts` the text.\n     * @private\n     */\n\n    /**\n     * `Layouts` the specified graphics.\n     * @private\n     */\n\n    /**\n     * `Layouts` the specified graphics.\n     * @private\n     */\n\n    /*public layout(graphics : PdfLayoutParams) : PdfLayoutResult\n    public layout(graphics : PdfGraphics, bounds : RectangleF) : void\n    public layout(graphics : PdfGraphics, bounds : PointF) : void\n    public layout(graphics ?: PdfGraphics | PdfLayoutParams, bounds ?: PointF | RectangleF) : void | PdfLayoutResult  {\n        if (graphics instanceof PdfGraphics) {\n        if (bounds instanceof PointF) {\n            if (bounds.x === 0) {\n                bounds.x = PdfBorders.default.right.width / 2;\n            }\n            if (bounds.y === 0) {\n                bounds.y = PdfBorders.default.top.width / 2;\n            }\n            let boundaries : RectangleF = new RectangleF(bounds, new SizeF(0, 0));\n            this.layout(graphics, boundaries);\n        } else {\n            let width : number = graphics.clientSize.width;\n            let parameter : PdfLayoutParams = new PdfLayoutParams();\n            parameter.bounds = bounds;\n            this.currentGraphics = graphics;\n            if (graphics.layer != null) {\n                let index : number = 0;\n                if (this.currentGraphics.page instanceof PdfPage) {\n                    index = (this.currentGraphics.page as PdfPage).section.indexOf(this.currentGraphics.page as PdfPage);\n                } else {\n                    index = (this.currentGraphics.page as PdfPageBase).defaultLayerIndex;\n                }\n            } else {\n                this.layoutInternal(parameter);\n            }\n        }\n    }\n    }*/\n\n    /**\n     * Gets the `format`.\n     * @private\n     */\n\n\n    getFormat(format) {\n      let f = format;\n      return f;\n    }\n    /**\n     * `Layouts` the element.\n     * @private\n     */\n\n\n    layoutInternal(param) {\n      let format = this.getFormat(param.format);\n      this.gridLayoutFormat = this.getFormat(param.format);\n      this.currentPage = param.page;\n\n      if (this.currentPage !== null) {\n        let pageHeight = this.currentPage.getClientSize().height;\n        let pageWidth = this.currentPage.getClientSize().width;\n        this.currentPageBounds = this.currentPage.getClientSize();\n      } else {\n        throw Error('Can not set page as null'); //this.currentPageBounds = this.currentGraphics.clientSize;\n      }\n\n      this.currentGraphics = this.currentPage.graphics; //this.currentGraphics = (this.currentPage != null ) ? this.currentPage.graphics : this.currentGraphics;\n      // if (this.currentGraphics.layer !== null) {\n      //     let index : number = 0;\n      //     if (this.currentGraphics.page instanceof PdfPage) {\n      //         index = (this.currentGraphics.page as PdfPage).section.indexOf(this.currentGraphics.page as PdfPage);\n      //     } else {\n      //         index = (this.currentGraphics.page as PdfPageBase).defaultLayerIndex;\n      //     }\n      //     this.listOfNavigatePages.push(index);\n      // }\n\n      let index = 0;\n      index = this.currentGraphics.page.section.indexOf(this.currentGraphics.page);\n      this.listOfNavigatePages.push(index);\n\n      if (format != null && format.break === PdfLayoutBreakType.FitColumnsToPage) {\n        this.currentBounds = new RectangleF(new PointF(param.bounds.x, param.bounds.y), new SizeF(this.Grid.columns.width, this.currentGraphics.clientSize.height));\n      } else {\n        this.currentBounds = new RectangleF(new PointF(param.bounds.x, param.bounds.y), this.currentGraphics.clientSize);\n      } //this.currentBounds = new RectangleF(new PointF(param.bounds.x, param.bounds.y), this.currentGraphics.clientSize);\n\n\n      if (this.Grid.rows.count !== 0) {\n        this.currentBounds.width = param.bounds.width > 0 ? param.bounds.width : this.currentBounds.width - this.Grid.rows.getRow(0).cells.getCell(0).style.borders.left.width / 2;\n      } else if (this.Grid.headers.count !== 0) {\n        // this.currentBounds.width = (param.bounds.width > 0) ? param.bounds.width : (this.currentBounds.width -\n        //                                 this.Grid.headers.getHeader(0).cells.getCell(0).style.borders.left.width / 2);\n        this.currentBounds.width = param.bounds.width;\n      } else {\n        throw Error('Please add row or header into grid');\n      }\n\n      this.startLocation = new PointF(param.bounds.x, param.bounds.y); // if (this.Grid.style.allowHorizontalOverflow && this.currentBounds.width > this.currentGraphics.clientSize.width) {\n      //     this.currentBounds.width = this.currentGraphics.clientSize.width;\n      //     this.currentBounds.width -= this.currentBounds.x;\n      // }\n      // if (this.Grid.isChildGrid) {\n      //     this.childheight = param.bounds.height;\n      // }\n      // if (param.format !== null && param.format.usePaginateBounds) {\n      //     if (param.format.paginateBounds.height > 0) {\n      //         this.currentBounds.height = param.format.paginateBounds.height;\n      //     }\n      //} else \n\n      if (param.bounds.height > 0 && !this.Grid.isChildGrid) {\n        this.currentBounds.height = param.bounds.height;\n      }\n\n      if (!this.Grid.isChildGrid) {\n        this.hType = this.Grid.style.horizontalOverflowType;\n      }\n\n      if (!this.Grid.style.allowHorizontalOverflow) {\n        this.columnRanges = [];\n        this.Grid.measureColumnsWidth(this.currentBounds);\n        this.columnRanges.push([0, this.Grid.columns.count - 1]);\n      } else {\n        this.Grid.measureColumnsWidth();\n        this.determineColumnDrawRanges();\n      }\n\n      if (this.Grid.hasRowSpanSpan) {\n        for (let i = 0; i < this.Grid.rows.count; i++) {\n          if (this.Grid.rows.getRow(i).height !== -1 && !this.Grid.rows.getRow(i).isRowHeightSet) {\n            this.Grid.rows.getRow(i).isRowHeightSet = true;\n          }\n        }\n      }\n\n      let result = this.layoutOnPage(param);\n      return result;\n    } // /* tslint:enable */\n\n    /**\n     * `Determines the column draw ranges`.\n     * @private\n     */\n\n\n    determineColumnDrawRanges() {\n      let startColumn = 0;\n      let endColumn = 0;\n      let cellWidths = 0;\n      let availableWidth = this.currentGraphics.clientSize.width - this.currentBounds.x;\n\n      for (let i = 0; i < this.Grid.columns.count; i++) {\n        cellWidths += this.Grid.columns.getColumn(i).width;\n\n        if (cellWidths >= availableWidth) {\n          let subWidths = 0;\n\n          for (let j = startColumn; j <= i; j++) {\n            subWidths += this.Grid.columns.getColumn(j).width;\n\n            if (subWidths > availableWidth) {\n              break;\n            }\n\n            endColumn = j;\n          }\n\n          this.columnRanges.push([startColumn, endColumn]);\n          startColumn = endColumn + 1;\n          endColumn = startColumn;\n          cellWidths = endColumn <= i ? this.Grid.columns.getColumn(i).width : 0;\n        }\n      } // if (startColumn !== this.columns.Count) {\n\n\n      this.columnRanges.push([startColumn, this.Grid.columns.count - 1]); // }\n    }\n    /**\n     * `Layouts the on page`.\n     * @private\n     */\n\n\n    layoutOnPage(param) {\n      /* tslint:disable */\n      this.pageBounds.x = param.bounds.x;\n      this.pageBounds.y = param.bounds.y;\n      this.pageBounds.height = param.bounds.height;\n      let format = this.getFormat(param.format);\n      let endArgs = null;\n      let result = null;\n      let layoutedPages = new TemporaryDictionary();\n      let startPage = param.page;\n      let isParentCell = false;\n      let cellBounds = [];\n\n      for (let index = 0; index < this.columnRanges.length; index++) {\n        let range = this.columnRanges[index];\n        this.cellStartIndex = range[0];\n        this.cellEndIndex = range[1];\n        let returnObject = this.raiseBeforePageLayout(this.currentPage, this.currentBounds, this.currentRowIndex);\n        this.currentBounds = returnObject.currentBounds;\n        this.currentRowIndex = returnObject.currentRowIndex; // if (returnObject.returnValue) {\n        //     result = new PdfGridLayoutResult(this.currentPage, this.currentBounds);\n        //     break;\n        // }\n        //Draw Headers.\n\n        let drawHeader;\n\n        for (let i = 0; i < this.Grid.headers.count; i++) {\n          let row = this.Grid.headers.getHeader(i);\n          let headerHeight = this.currentBounds.y;\n          this.isHeader = true;\n\n          if (startPage != this.currentPage) {\n            for (let k = this.cellStartIndex; k <= this.cellEndIndex; k++) {\n              if (row.cells.getCell(k).isCellMergeContinue) {\n                row.cells.getCell(k).isCellMergeContinue = false;\n                row.cells.getCell(k).value = \"\";\n              }\n            }\n          } // RowLayoutResult\n\n\n          let headerResult = this.drawRow(row);\n\n          if (headerHeight === this.currentBounds.y) {\n            drawHeader = true;\n\n            if (PdfGridLayouter.repeatRowIndex === -1) {\n              PdfGridLayouter.repeatRowIndex = i;\n            }\n          } else {\n            drawHeader = false;\n          }\n\n          if (!headerResult.isFinish && startPage !== null && format.layout !== PdfLayoutType.OnePage && drawHeader) {\n            this.startLocation.x = this.currentBounds.x;\n            this.currentPage = this.getNextPageformat(format);\n            this.startLocation.y = this.currentBounds.y;\n            if (typeof format.paginateBounds !== 'undefined' && format.paginateBounds.x === 0 && format.paginateBounds.y === 0 && format.paginateBounds.width === 0 && format.paginateBounds.height === 0) this.currentBounds.x += this.startLocation.x;\n            this.drawRow(row);\n          }\n\n          this.isHeader = false;\n        }\n\n        let i = 0;\n        let length = this.Grid.rows.count;\n        let repeatRow;\n        let flag = true; //Here is to draw parent Grid and Cells\n\n        cellBounds = []; //Draw row by row with the specified cell range.\n\n        for (let j = 0; j < this.Grid.rows.count; j++) {\n          let row = this.Grid.rows.getRow(j);\n          i++;\n          this.currentRowIndex = i - 1;\n          let originalHeight = this.currentBounds.y;\n          startPage = this.currentPage;\n          PdfGridLayouter.repeatRowIndex = -1;\n\n          if (flag && row.grid.isChildGrid) {\n            flag = false;\n          }\n\n          let rowResult = null; ///rowResult = this.drawRow(row);\n\n          /*if(!row.isrowFinish) {\n              if(!row.grid.isgridSplit){\n                  rowResult = this.drawRow(row);\n                  row.isrowFinish = true;\n                  row.isrowDraw = true;\n              } else {\n                  if(!row.isrowDraw){\n                      rowResult = this.drawRow(row);\n                      row.isrowFinish = true;\n                      row.isrowDraw = true;\n                      row.grid.isgridSplit = false;\n                  } else {\n                      rowResult =  null;\n                      break;\n                  }\n              }\n          }\n          else {\n              //row.isrowFinish = false;\n              //rowResult = this.drawRow(row);\n              rowResult = null;\n              break;\n              \n          }             */\n\n          if (this.Grid.splitChildRowIndex == -1) {\n            rowResult = this.drawRow(row);\n            row.isrowFinish = true;\n          } else {\n            if (row.grid.ParentCell.row.grid.isGridSplit && this.Grid.splitChildRowIndex <= row.rowIndex) {\n              rowResult = this.drawRow(row);\n              row.isrowFinish = true;\n            } else if (row.isrowFinish) {\n              continue;\n            } else {\n              break;\n            }\n          } //rowResult = this.drawRow(row);\n\n\n          cellBounds.push(rowResult.bounds.width);\n          /*if (row.isRowBreaksNextPage)\n              {\n                  let x : number  = 0;\n                  for (let l : number = 0; l < row.cells.count; l++)\n                  {\n                      let isNestedRowBreak : boolean = false;\n                      if (row.height == row.cells.getCell(l).height)\n                      {\n                          let n : number;\n                          let grid : PdfGrid = row.cells.getCell(l).value as PdfGrid;\n                          for (let m : number = grid.rows.count; 0 < m; m--)\n                          {\n                              if ((grid.rows.getRow(m - 1).rowBreakHeight > 0))\n                              {\n                                  isNestedRowBreak = true;\n                                  break;\n                              }\n                              if (grid.rows.getRow(m - 1).isRowBreaksNextPage)\n                              {\n                                  row.rowBreakHeightValue = grid.rows.getRow(m - 1).rowBreakHeightValue;\n                                  break;\n                              }\n                              row.rowBreakHeightValue += grid.rows.getRow(m - 1).height;\n                          }\n                      }\n                      if (isNestedRowBreak)\n                          break;\n                  }\n                  for (let j : number = 0; j < row.cells.count; j++)\n                  {\n                       if (row.height > row.cells.getCell(j).height)\n                      {\n                          row.cells.getCell(j).value = \" \";\n                          let rect : RectangleF ;\n                          let page : PdfPage = this.getNextPage(this.currentPage);\n                          let section : PdfSection = this.currentPage.section;\n                          let index : number = section.indexOf(page);\n                          for (let k : number = 0; k < (section.count - 1) - index; k++)\n                          {\n                              rect = new RectangleF(x, 0, row.grid.columns.getColumn(j).width, page.getClientSize().height);\n                              PdfGridLayouter.repeatRowIndex = -1;\n                              row.cells.getCell(j).draw(page.graphics, rect, false);\n                              page = this.getNextPage(page);\n                          }\n                          rect = new RectangleF(x, 0, row.grid.columns.getColumn(j).width, row.rowBreakHeightValue);\n                           row.cells.getCell(j).draw(page.graphics, rect, false);\n                      }\n                      x += row.grid.columns.getColumn(j).width;\n                  }\n              }*/\n          //if height remains same, it is understood that row is not drawn in the page\n\n          if (originalHeight === this.currentBounds.y) {\n            repeatRow = true;\n            PdfGridLayouter.repeatRowIndex = this.Grid.rows.rowCollection.indexOf(row);\n          } else {\n            repeatRow = false;\n            PdfGridLayouter.repeatRowIndex = -1;\n          }\n\n          while (!rowResult.isFinish && startPage != null) {\n            let tempResult = this.getLayoutResult();\n            /*if (startPage != this.currentPage)\n                {\n                    if (row.grid.isChildGrid && row.grid.ParentCell != null)\n                    {\n                        let bounds : RectangleF= new RectangleF(new PointF(format.paginateBounds.x,format.paginateBounds.y), new SizeF(param.bounds.width, tempResult.bounds.height));\n                        bounds.x += param.bounds.x;\n                        if (row.grid.ParentCell.row.grid.style.cellPadding != null)\n                        {\n                            bounds.y += row.grid.ParentCell.row.grid.style.cellPadding.top;\n                            if (bounds.height > this.currentPageBounds.height)\n                            {\n                                bounds.height = this.currentPageBounds.height - bounds.y;\n                                bounds.height -= (row.grid.ParentCell.row.grid.style.cellPadding.bottom);\n                            }\n                        }\n                        // Draw border for cells in the nested grid cell's row.\n                        for (let c : number = 0; c < row.cells.count; c++)\n                        {\n                            let cell : PdfGridCell = row.cells.getCell(c);\n                            let cellWidth :  number= 0;\n                            if (cell.columnSpan > 1)\n                            {\n                                for (; c < cell.columnSpan; c++)\n                                    cellWidth += row.grid.columns.getColumn(c).width;\n                            }\n                            else\n                                cellWidth = Math.max(cell.width, row.grid.columns.getColumn(c).width);\n                            cell.drawCellBorders(this.currentGraphics, new RectangleF(new PointF(bounds.x,bounds.y), new SizeF(cellWidth, bounds.height)));\n                            bounds.x += cellWidth;\n                            c += (cell.columnSpan - 1);\n                        }\n                    }\n                }\n                */\n\n            endArgs = this.raisePageLayouted(tempResult);\n            if (endArgs.cancel || repeatRow) break;else if (this.Grid.allowRowBreakAcrossPages) {\n              //If there is no space in the current page, add new page and then draw the remaining row.\n              this.currentPage = this.getNextPageformat(format);\n              originalHeight = this.currentBounds.y;\n              let location = new PointF(PdfBorders.default.right.width / 2, PdfBorders.default.top.width / 2);\n\n              if (format.paginateBounds.x === 0 && format.paginateBounds.y === 0 && format.paginateBounds.width === 0 && format.paginateBounds.height === 0 && this.startLocation.x === location.x && this.startLocation.y === location.y) {\n                this.currentBounds.x += this.startLocation.x;\n                this.currentBounds.y += this.startLocation.y;\n              }\n\n              if (this.isPaginate) {\n                this.startLocation.y = this.currentBounds.y;\n                this.isPaginate = false;\n              }\n\n              if (this.Grid.isChildGrid && row.grid.ParentCell != null) {\n                if (this.Grid.ParentCell.row.grid.style.cellPadding != null) {\n                  if (row.rowBreakHeight + this.Grid.ParentCell.row.grid.style.cellPadding.top < this.currentBounds.height) {\n                    this.currentBounds.y = this.Grid.ParentCell.row.grid.style.cellPadding.top;\n                  }\n                }\n              }\n\n              if (row.grid.ParentCell != null) {\n                row.grid.ParentCell.row.isRowBreaksNextPage = true;\n                row.grid.ParentCell.row.rowBreakHeightValue = row.rowBreakHeight + this.Grid.ParentCell.row.grid.style.cellPadding.top + this.Grid.ParentCell.row.grid.style.cellPadding.bottom;\n\n                for (let i = row.rowIndex + 1; i < row.grid.rows.count; i++) {\n                  row.grid.ParentCell.row.rowBreakHeightValue += row.grid.rows.getRow(i).height;\n                } //row.rowBreakHeight = row.grid.ParentCell.row.rowBreakHeightValue;\n\n              }\n              /*if (row.noOfPageCount > 1)\n              {\n                  let temp : number = row.rowBreakHeightValue;\n                  for (let j : number = 1; j < row.noOfPageCount; j++)\n                  {\n                      row.rowBreakHeightValue = 0;\n                      row.height = ((row.noOfPageCount - 1) * this.currentPage.getClientSize().height);\n                      this.drawRow(row);\n                      this.currentPage = this.getNextPageformat(format);\n                      startPage = this.currentPage;\n                  }\n                  row.rowBreakHeightValue = temp;\n                  row.noOfPageCount = 1;\n                  rowResult = this.drawRow(row);\n              } else {\n                  rowResult = this.drawRow(row);\n              }\n              /*if(row.grid.isChildGrid){\n                  row.isrowFinish = false;\n                  row.isrowDraw = false;\n                  row.grid.isgridSplit = true;\n                  row.grid.ParentCell.row.grid.isgridSplit = true;\n                  //rowResult.isFinish = false;\n                  break;\n              }*/\n\n\n              if (row.grid.isChildGrid) {\n                //row.grid.isgridSplit = true;\n                row.isrowFinish = false; //row.grid.ParentCell.row.grid.isgridSplit = true;\n\n                row.grid.splitChildRowIndex = row.rowIndex;\n                row.grid.ParentCell.row.grid.splitChildRowIndex = row.grid.ParentCell.row.rowIndex;\n\n                if (row.grid.ParentCell.row.grid.isGridSplit) {\n                  row.grid.ParentCell.row.noOfPageCount += 1;\n                  row.grid.ParentCell.row.grid.isGridSplit = false;\n                }\n\n                break;\n              }\n\n              if (row.noOfPageCount < 1) {\n                if (row.grid.splitChildRowIndex != -1) {\n                  row.grid.isGridSplit = true;\n                }\n\n                if (row.style.border != null && (row.style.border.left != null && row.style.border.left.width !== 1 || row.style.border.top != null && row.style.border.top.width !== 1)) {\n                  let x = row.style.border.left.width / 2;\n                  let y = row.style.border.top.width / 2;\n\n                  if (this.currentBounds.x === PdfBorders.default.right.width / 2 && this.currentBounds.y === PdfBorders.default.right.width / 2) {\n                    let newBound = new RectangleF(x, y, this.currentBounds.width, this.currentBounds.height);\n                    this.currentBounds = newBound;\n                  }\n                }\n\n                if (this.Grid.repeatHeader) {\n                  for (let j = 0; j < this.Grid.headers.count; j++) {\n                    let headerRepeat = this.Grid.headers.getHeader(j);\n                    this.drawRow(headerRepeat);\n                  }\n                }\n\n                rowResult = this.drawRow(row);\n\n                if (row.noOfPageCount >= 1) {\n                  let temp = row.rowBreakHeightValue;\n\n                  for (let j = 0; j < row.noOfPageCount; j++) {\n                    //this.currentPage.section.add();\n                    let tempResult1 = this.getLayoutResult();\n                    endArgs = this.raisePageLayouted(tempResult1);\n                    this.currentPage = this.getNextPageformat(format);\n                    originalHeight = this.currentBounds.y; //row.rowBreakHeightValue = 0;\n\n                    if (row.grid.splitChildRowIndex != -1) {\n                      row.grid.isGridSplit = true;\n                    }\n\n                    this.currentBounds.y = 0.5;\n\n                    if (this.Grid.repeatHeader) {\n                      for (let i = 0; i < this.Grid.headers.count; i++) {\n                        let header = this.Grid.headers.getHeader(i);\n                        this.drawRow(header);\n                      }\n                    } //row.height = ((row.noOfPageCount - 1) * this.currentPage.getClientSize().height);\n\n\n                    this.drawRow(row);\n                  } // row.rowBreakHeight = temp;\n                  // row.noOfPageCount = 1;\n                  // rowResult = this.drawRow(row);\n\n                }\n\n                row.grid.splitChildRowIndex = -1;\n                row.grid.isGridSplit = false;\n                rowResult.isFinish = true; //row.NestedGridLayoutResult.bounds.height = row.rowBreakHeightValue;\n                //this.currentBounds.y = rowResult.bounds.y;\n\n                for (let i = 0; i < row.cells.count; i++) {\n                  if (row.cells.getCell(i).value instanceof PdfGrid) {\n                    row.cells.getCell(i).value.splitChildRowIndex = -1;\n                  }\n                }\n              }\n            } // else if (!this.Grid.allowRowBreakAcrossPages && i < length)\n            // {\n            //     this.currentPage = this.getNextPageformat(format);\n            //     break;\n            // }\n            // else if (i >= length)\n            //     break;\n          }\n\n          if (!rowResult.isFinish && startPage !== null && format.layout !== PdfLayoutType.OnePage && repeatRow) {\n            // During pagination, cell position is maintained here.\n            this.startLocation.x = this.currentBounds.x;\n            this.currentPage = this.getNextPageformat(format);\n            /*if (!this.Grid.isSingleGrid)\n            {\n                for ( let j : number= 0; j < this.Grid.rows.count; j++)\n                {\n                    let isWidthGreaterthanParent : boolean = false;\n                    for (let k : number = 0; k < this.Grid.rows.getRow(j).cells.count; k++)\n                    {\n                        if (this.Grid.rows.getRow(j).cells.getCell(k).width > this.currentPageBounds.width)\n                            isWidthGreaterthanParent = true;\n                    }\n                    if (isWidthGreaterthanParent && this.Grid.rows.getRow(j).cells.getCell(this.rowBreakPageHeightCellIndex).pageCount > 0)\n                    {\n                        isAddNextPage = true;\n                    }\n                }\n            }\n            if (!this.Grid.isRearranged && isAddNextPage)\n                 {\n                     let section : PdfSection = this.currentPage.section;\n                     \n                     //this.currentPage = section.add();\n                 \n                     this.currentGraphics = this.currentPage.graphics;\n                     this.currentBounds = new RectangleF(new PointF(0,0), this.currentPage.getClientSize());\n                  \n                     let pageindex  : number = (this.currentGraphics.page as PdfPage).section.indexOf(this.currentGraphics.page as PdfPage);\n                 }\n                 else\n                 {\n                     this.currentPage = this.getNextPageformat(format);\n                 }\n                 if (format.paginateBounds.y == 0)\n                     this.currentBounds.y = PdfBorders.default.top.width/2;\n                 else\n                 {\n                     this.currentBounds.y = format == null ? 0 : format.paginateBounds.y;\n                     \n                 }\n                 if (this.raiseBeforePageLayout(this.currentPage, this.currentBounds, this.currentRowIndex))\n                     break;*/\n\n            if (param.format !== null && !param.format.usePaginateBounds && param.bounds !== null && param.bounds.height > 0 && !this.Grid.isChildGrid) {\n              this.currentBounds.height = param.bounds.height;\n            }\n\n            if (typeof param.format !== 'undefined' && param.format != null && typeof param.format.usePaginateBounds !== 'undefined' && !param.format.usePaginateBounds && !(param.format.paginateBounds.x === 0 && param.format.paginateBounds.y === 0 && param.format.paginateBounds.width === 0 && param.format.paginateBounds.height === 0) && param.format.paginateBounds.y === 0) {\n              this.currentBounds.y = PdfBorders.default.top.width / 2;\n            } else {\n              this.currentBounds.y = format == null ? 0 : format.paginateBounds.y;\n            }\n\n            if (typeof param.format !== 'undefined' && param.format !== null && typeof param.format.usePaginateBounds !== 'undefined' && !param.format.usePaginateBounds && param.bounds !== null && param.bounds.y > 0 && !this.Grid.isChildGrid) {\n              this.currentBounds.y = param.bounds.y;\n            }\n\n            this.startLocation.y = this.currentBounds.y;\n\n            if (format.paginateBounds.x === format.paginateBounds.y && format.paginateBounds.y === format.paginateBounds.height && format.paginateBounds.height === format.paginateBounds.width && format.paginateBounds.width === 0) {\n              this.currentBounds.x += this.startLocation.x;\n            }\n\n            if (this.currentBounds.x === PdfBorders.default.left.width / 2) {\n              this.currentBounds.y += this.startLocation.x;\n            }\n\n            if (this.Grid.repeatHeader) {\n              for (let i = 0; i < this.Grid.headers.count; i++) {\n                let header = this.Grid.headers.getHeader(i);\n                this.drawRow(header);\n              }\n            }\n\n            this.drawRow(row);\n\n            if (this.currentPage !== null && !layoutedPages.containsKey(this.currentPage)) {\n              layoutedPages.add(this.currentPage, range);\n            }\n          }\n\n          if (row.NestedGridLayoutResult != null) {\n            // Position for next row in the grid.\n            this.currentPage = row.NestedGridLayoutResult.page;\n            this.currentGraphics = this.currentPage.graphics; //If not, next row will not be drawn in the layouted page.\n\n            this.startLocation = new PointF(row.NestedGridLayoutResult.bounds.x, row.NestedGridLayoutResult.bounds.y);\n            let recalHeight = this.ReCalculateHeight(row, row.NestedGridLayoutResult.bounds.height);\n            this.currentBounds.y = recalHeight; //this.currentBounds.y = row.NestedGridLayoutResult.bounds.height;\n\n            if (startPage != this.currentPage) {\n              let secion = this.currentPage.section;\n              let startIndex = secion.indexOf(startPage) + 1;\n              let endIndex = secion.indexOf(this.currentPage);\n\n              for (let page = startIndex; page < endIndex + 1; page++) {\n                let pageGraphics = this.currentPage.graphics;\n                let location = new PointF(format.paginateBounds.x, format.paginateBounds.y);\n                let height = page == endIndex ? row.NestedGridLayoutResult.bounds.height - param.bounds.y : this.currentBounds.height - location.y;\n                if (height <= pageGraphics.clientSize.height) height += param.bounds.y; // if (row.grid.isChildGrid && row.grid.ParentCell != null)\n                //     location.x += param.bounds.x;\n\n                location.y = format == null ? 0.5 : format.paginateBounds.y; // Draw border for last paginated row containing nested grid.\n\n                for (let c = 0; c < row.cells.count; c++) {\n                  let cell = row.cells.getCell(c);\n                  let cellWidth = 0;\n                  let totalwidth = 0;\n\n                  if (cell.value instanceof PdfGrid) {\n                    for (let i = 0; i < cell.value.columns.count; i++) {\n                      totalwidth += cell.value.columns.getColumn(i).columnWidth;\n                    }\n                  } else {\n                    totalwidth = cell.width;\n                  } // if (cell.columnSpan > 1)\n                  // {\n                  //     for (; c < cell.columnSpan; c++)\n                  //         cellWidth += row.grid.columns.getColumn(c).width;\n                  // }\n                  // else\n\n\n                  cellWidth = Math.max(totalwidth, row.grid.columns.getColumn(c).width);\n                  cell.drawCellBorders(pageGraphics, new RectangleF(location, new SizeF(cellWidth, height)));\n                  location.x += cellWidth;\n                  c += cell.columnSpan - 1;\n                }\n              } // So, nested grid drawing is completed for the current row. Update page.\n              // Otherwise, the next nested grid of the parent will draw borders from start.\n\n\n              startPage = this.currentPage;\n            }\n          }\n        }\n\n        let isPdfGrid = false;\n        let maximumCellBoundsWidth = 0;\n\n        if (cellBounds.length > 0) {\n          maximumCellBoundsWidth = cellBounds[0];\n        }\n\n        let largeNavigatePage = [[1, 2]];\n\n        for (let c = 0; c < this.Grid.rows.count; c++) {\n          if (this.cellEndIndex != -1 && this.Grid.rows.getRow(c).cells.getCell(this.cellEndIndex).value instanceof PdfGrid) {\n            let grid = this.Grid.rows.getRow(c).cells.getCell(this.cellEndIndex).value;\n            this.rowLayoutBoundsWidth = grid.rowLayoutBoundsWidth;\n            isPdfGrid = true; // if (largeNavigatePage[0][0] < grid.listOfNavigatePages.length)\n            // {\n            //     largeNavigatePage[0][0] = grid.listOfNavigatePages.length;\n            //     largeNavigatePage[0][1] = cellBounds[c];\n            // }\n            // else if ((largeNavigatePage[0][0] == grid.listOfNavigatePages.length) && (largeNavigatePage[0][1] < cellBounds[c]))\n            // {\n            //     largeNavigatePage[0][1] = cellBounds[c];\n            // }\n          }\n        }\n\n        if (!isPdfGrid && cellBounds.length > 0) {\n          for (let c = 0; c < i - 1; c++) {\n            if (maximumCellBoundsWidth < cellBounds[c]) {\n              maximumCellBoundsWidth = cellBounds[c];\n            }\n          }\n\n          this.rowLayoutBoundsWidth = maximumCellBoundsWidth;\n        } else {\n          this.rowLayoutBoundsWidth = largeNavigatePage[0][1];\n        }\n\n        if (this.columnRanges.indexOf(range) < this.columnRanges.length - 1 && startPage != null && format.layout != PdfLayoutType.OnePage) {\n          isParentCell = this.Grid.isChildGrid;\n\n          if (largeNavigatePage[0][0] != 0) {\n            let section = this.currentPage.section;\n            let pageIndex = section.indexOf(this.currentPage);\n            this.currentGraphics = this.currentPage.graphics;\n            this.currentBounds = new RectangleF(new PointF(0, 0), this.currentPage.getClientSize());\n            let pageindex = this.currentGraphics.page.section.indexOf(this.currentGraphics.page);\n          } else {\n            this.currentPage = this.getNextPageformat(format);\n          } // let locationGrid : PointF= new PointF(PdfBorders.default.right.width / 2, PdfBorders.default.top.width / 2);\n          // if (format.paginateBounds == new RectangleF(0,0,0,0) && this.startLocation == locationGrid)\n          // {\n          //     this.currentBounds.x += this.startLocation.x;\n          //     this.currentBounds.y += this.startLocation.y;\n          // }\n\n        }\n\n        if (this.columnRanges.length - 1 !== index && this.columnRanges.length > 1 && format.layout !== PdfLayoutType.OnePage) {\n          this.currentPage = this.getNextPageformat(format);\n\n          if (format.paginateBounds.x === format.paginateBounds.y && format.paginateBounds.y === format.paginateBounds.height && format.paginateBounds.height === format.paginateBounds.width && format.paginateBounds.width === 0) {\n            this.currentBounds.x += this.startLocation.x;\n            this.currentBounds.y += this.startLocation.y; //this.currentBounds.height = this.pageBounds.height;\n          }\n        }\n      }\n\n      result = this.getLayoutResult();\n\n      if (this.Grid.style.allowHorizontalOverflow && this.Grid.style.horizontalOverflowType == PdfHorizontalOverflowType.NextPage) {\n        this.reArrangePages(layoutedPages);\n      }\n\n      this.raisePageLayouted(result);\n      return result;\n    }\n    /* tslint:enable */\n\n    /**\n     * Gets the `next page`.\n     * @private\n     */\n\n\n    getNextPageformat(format) {\n      let section = this.currentPage.section;\n      let nextPage = null;\n      let index = section.indexOf(this.currentPage);\n      this.flag = false;\n\n      if (index === section.count - 1) {\n        nextPage = section.add();\n      } else {\n        nextPage = section.getPages()[index + 1];\n      }\n\n      this.currentGraphics = nextPage.graphics;\n      let pageindex = this.currentGraphics.page.section.indexOf(this.currentGraphics.page);\n\n      if (!(this.listOfNavigatePages.indexOf(pageindex) !== -1)) {\n        this.listOfNavigatePages.push(pageindex);\n      }\n\n      this.currentBounds = new RectangleF(new PointF(0, 0), nextPage.getClientSize());\n\n      if (typeof format !== 'undefined' && format != null && format.usePaginateBounds && typeof format.paginateBounds !== 'undefined' && format.paginateBounds != null && format.paginateBounds.x !== format.paginateBounds.y && format.paginateBounds.y !== format.paginateBounds.height && format.paginateBounds.height !== format.paginateBounds.width && format.paginateBounds.width !== 0) {\n        this.currentBounds.x = format.paginateBounds.x;\n        this.currentBounds.y = format.paginateBounds.y;\n        this.currentBounds.height = format.paginateBounds.height;\n      }\n\n      return nextPage;\n    }\n\n    CheckIfDefaultFormat(format) {\n      let defaultFormat = new PdfStringFormat();\n      return format.alignment === defaultFormat.alignment && format.characterSpacing === defaultFormat.characterSpacing && format.clipPath === defaultFormat.clipPath && format.firstLineIndent === defaultFormat.firstLineIndent && format.horizontalScalingFactor === defaultFormat.horizontalScalingFactor && format.lineAlignment === defaultFormat.lineAlignment && format.lineLimit === defaultFormat.lineLimit && format.lineSpacing === defaultFormat.lineSpacing && format.measureTrailingSpaces === defaultFormat.measureTrailingSpaces && format.noClip === defaultFormat.noClip && format.paragraphIndent === defaultFormat.paragraphIndent && format.rightToLeft === defaultFormat.rightToLeft && format.subSuperScript === defaultFormat.subSuperScript && format.wordSpacing === defaultFormat.wordSpacing && format.wordWrap === defaultFormat.wordWrap;\n    }\n    /**\n     * `Raises BeforeCellDraw event`.\n     * @private\n     */\n\n\n    RaiseBeforeCellDraw(graphics, rowIndex, cellIndex, bounds, value, style) {\n      let args = null;\n\n      if (this.Grid.raiseBeginCellDraw) {\n        args = new PdfGridBeginCellDrawEventArgs(graphics, rowIndex, cellIndex, bounds, value, style);\n        this.Grid.onBeginCellDraw(args);\n        style = args.style;\n      }\n\n      return style;\n    }\n    /**\n     * `Raises AfterCellDraw event`.\n     * @private\n     */\n\n\n    raiseAfterCellDraw(graphics, rowIndex, cellIndex, bounds, value, cellstyle) {\n      let args = null;\n\n      if (this.Grid.raiseEndCellDraw) {\n        args = new PdfGridEndCellDrawEventArgs(graphics, rowIndex, cellIndex, bounds, value, cellstyle);\n        this.Grid.onEndCellDraw(args);\n      }\n    }\n\n    reArrangePages(layoutedPages) {\n      let document = this.currentPage.document;\n      let pages = [];\n      let keys = layoutedPages.keys();\n      let values = layoutedPages.values();\n\n      for (let i = 0; i < keys.length; i++) {\n        let page = keys[i];\n        page.section = null;\n        pages.push(page);\n        document.pages.remove(page);\n      }\n      /* tslint:disable */\n\n\n      for (let i = 0; i < layoutedPages.size(); i++) {\n        for (let j = i, count = layoutedPages.size() / this.columnRanges.length; j < layoutedPages.size(); j += count) {\n          let page = pages[j];\n\n          if (document.pages.indexOf(page) === -1) {\n            document.pages.add(page);\n          }\n        }\n      }\n      /* tslint:enable */\n\n    }\n    /**\n     * Gets the `layout result`.\n     * @private\n     */\n\n\n    getLayoutResult() {\n      if (this.Grid.isChildGrid && this.Grid.allowRowBreakAcrossPages) {\n        for (let i = 0; i < this.Grid.rows.count; i++) {\n          let row = this.Grid.rows.getRow(i);\n\n          if (row.rowBreakHeight > 0 && row.repeatFlag) {\n            this.startLocation.y = this.currentPage.origin.y;\n          }\n        }\n      }\n\n      let bounds;\n\n      if (!this.isChanged) {\n        bounds = new RectangleF(this.startLocation, new SizeF(this.currentBounds.width, this.currentBounds.y - this.startLocation.y));\n      } // else {\n      //     bounds = new RectangleF(this.currentLocation, new SizeF(this.currentBounds.width, this.currentBounds.y -\n      //                              this.currentLocation.y));\n      // }\n\n      /* tslint:enable */\n\n\n      return new PdfGridLayoutResult(this.currentPage, bounds);\n    }\n    /**\n     * `Recalculate row height` for the split cell to be drawn.\n     * @private\n     */\n\n\n    ReCalculateHeight(row, height) {\n      let newHeight = 0.0;\n\n      for (let i = this.cellStartIndex; i <= this.cellEndIndex; i++) {\n        if (!(row.cells.getCell(i).remainingString === null || row.cells.getCell(i).remainingString === '' || typeof row.cells.getCell(i).remainingString === 'undefined')) {\n          newHeight = Math.max(newHeight, row.cells.getCell(i).measureHeight());\n        }\n      }\n\n      return Math.max(height, newHeight);\n    }\n    /**\n     * `Raises BeforePageLayout event`.\n     * @private\n     */\n\n\n    raiseBeforePageLayout(currentPage, currentBounds, currentRow) {\n      let cancel = false;\n\n      if (this.Grid.raiseBeginPageLayout) {\n        let args = new PdfGridBeginPageLayoutEventArgs(currentBounds, currentPage, currentRow);\n        this.Grid.onBeginPageLayout(args); // if (currentBounds !== args.Bounds) {\n        //     this.isChanged = true;\n        //     this.currentLocation = new PointF(args.Bounds.x, args.Bounds.y);\n        //     this.measureColumnsWidth(new RectangleF(new PointF(args.Bounds.x, args.Bounds.y) ,\n        //                                                  new SizeF(args.Bounds.width + args.Bounds.x ,\n        //                                                                 args.Bounds.height)));\n        // }\n\n        cancel = args.cancel;\n        currentBounds = args.bounds;\n        currentRow = args.startRowIndex;\n      }\n\n      return {\n        returnValue: cancel,\n        currentBounds: currentBounds,\n        currentRowIndex: currentRow\n      };\n    }\n    /**\n     * `Raises PageLayout event` if needed.\n     * @private\n     */\n\n\n    raisePageLayouted(result) {\n      let args = new PdfGridEndPageLayoutEventArgs(result);\n\n      if (this.Grid.raiseEndPageLayout) {\n        this.Grid.onEndPageLayout(args);\n      }\n\n      return args;\n    }\n\n    drawRow(row, result, height) {\n      if (typeof result === 'undefined') {\n        //.. Check if required space available.\n        //.....If the row conains spans which  falls through more than one page, then draw the row to next page.                        \n        let result = new RowLayoutResult();\n        let rowHeightWithSpan = 0;\n        let isHeader = false;\n\n        if (row.rowSpanExists) {\n          let maxSpan = 0;\n          let currRowIndex = this.Grid.rows.rowCollection.indexOf(row);\n\n          if (currRowIndex === -1) {\n            currRowIndex = this.Grid.headers.indexOf(row);\n\n            if (currRowIndex !== -1) {\n              isHeader = true;\n            }\n          }\n\n          for (let i = 0; i < row.cells.count; i++) {\n            let cell = row.cells.getCell(i);\n            maxSpan = Math.max(maxSpan, cell.rowSpan);\n          }\n\n          for (let i = currRowIndex; i < currRowIndex + maxSpan; i++) {\n            rowHeightWithSpan += isHeader ? this.Grid.headers.getHeader(i).height : this.Grid.rows.getRow(i).height;\n          } // let rowMaxHeight : number = rowHeightWithSpan;\n          // for (let i : number = 0; i < row.cells.count; i++ ) {\n          //     rowMaxHeight = rowMaxHeight > row.cells.getCell(i).height ? rowMaxHeight : row.cells.getCell(i).height;\n          // }\n          // let flag : boolean = true;\n          // let nextRow : PdfGridRow = this.Grid.headers.getHeader(this.Grid.headers.indexOf(row) + 1);\n          // for (let i : number = 0; i < nextRow.cells.count; i++ ) {\n          //     if (nextRow.cells.getCell(i).value !== '' && nextRow.cells.getCell(i).value !== undefined) {\n          //         flag = false;\n          //         break;\n          //     }\n          // }\n          // if ((rowMaxHeight > rowHeightWithSpan) && flag) {\n          //     row.height += (rowMaxHeight - rowHeightWithSpan);\n          // }                \n\n        }\n\n        let calculatedHeight = row.rowBreakHeight > 0.0 ? row.rowBreakHeight : row.height;\n\n        if (this.Grid.isChildGrid && this.Grid.ParentCell != null) {\n          //Split row only if row height exceeds page height and AllowRowBreakAcrossPages is true.\n          // if (calculatedHeight + this.Grid.ParentCell.row.grid.style.cellPadding.bottom +\n          //             this.Grid.ParentCell.row.grid.style.cellPadding.top > this.currentPageBounds.height) {\n          //     if (this.Grid.allowRowBreakAcrossPages) {\n          //         result.isFinish = true;\n          //         if ( this.Grid.isChildGrid && row.rowBreakHeight > 0 ) {\n          //             if (this.Grid.ParentCell.row.grid.style.cellPadding !== null) {\n          //                 this.currentBounds.y += this.Grid.ParentCell.row.grid.style.cellPadding.top;\n          //             }\n          //             this.currentBounds.x = this.startLocation.x;\n          //         }\n          //         result.bounds = this.currentBounds ;\n          //         this.drawRowWithBreak(result, row, calculatedHeight);\n          //     } else {\n          //         //If AllowRowBreakAcrossPages is not true, draw the row till it fits the page.                       \n          //         if (this.Grid.ParentCell.row.grid.style.cellPadding != null) {\n          //             this.currentBounds.y += this.Grid.ParentCell.row.grid.style.cellPadding.top;\n          //             calculatedHeight = this.currentBounds.height - this.currentBounds.y -\n          //                     this.Grid.ParentCell.row.grid.style.cellPadding.bottom;\n          //         }\n          //         result.isFinish = false;\n          //         this.drawRow( row, result, calculatedHeight);\n          //     }\n          // } else\n          if (this.currentBounds.y + this.Grid.ParentCell.row.grid.style.cellPadding.bottom + calculatedHeight > this.currentPageBounds.height || this.currentBounds.y + this.Grid.ParentCell.row.grid.style.cellPadding.bottom + calculatedHeight > this.currentBounds.height || this.currentBounds.y + this.Grid.ParentCell.row.grid.style.cellPadding.bottom + rowHeightWithSpan > this.currentPageBounds.height) {\n            //If a row is repeated and still cannot fit in page, proceed draw.\n            if (this.Grid.ParentCell.row.grid.LayoutFormat.break === PdfLayoutBreakType.FitPage) {\n              PdfGridLayouter.repeatRowIndex = this.Grid.rows.rowCollection.indexOf(row);\n              this.Grid.splitChildRowIndex = this.Grid.rows.rowCollection.indexOf(row);\n            }\n\n            if (PdfGridLayouter.repeatRowIndex > -1 && PdfGridLayouter.repeatRowIndex === row.rowIndex) {\n              if (this.Grid.allowRowBreakAcrossPages) {\n                result.isFinish = true; // if (this.Grid.isChildGrid && row.rowBreakHeightValue > 0) {\n                //     // if (this.Grid.ParentCell.row.grid.style.cellPadding != null) {\n                //     //     this.currentBounds.y += this.Grid.ParentCell.row.grid.style.cellPadding.top;\n                //     // }\n                //     this.currentBounds.x = this.startLocation.x;\n                // }\n\n                result.bounds = this.currentBounds;\n                this.drawRowWithBreak(result, row, calculatedHeight);\n                row.repeatFlag = true;\n                row.repeatRowNumber = PdfGridLayouter.repeatRowIndex;\n              } // else {\n              //     result.isFinish = false;\n              //     row.repeatFlag = false;\n              //     this.drawRow( row, result, calculatedHeight);\n              // }\n\n            } // else {\n            //     result.isFinish = false;\n            // }\n\n          } else {\n            result.isFinish = true;\n\n            if (row.grid.ParentCell.row.rowBreakHeightValue > 0) {\n              row.repeatFlag = true;\n            } else {\n              row.repeatFlag = false;\n              calculatedHeight = row.height;\n            }\n\n            if (this.Grid.isChildGrid && row.rowBreakHeight > 0) {\n              if (this.Grid.ParentCell.row.grid.style.cellPadding != null) {\n                calculatedHeight += this.Grid.ParentCell.row.grid.style.cellPadding.bottom;\n              }\n            }\n\n            this.drawRow(row, result, calculatedHeight);\n          }\n        } else {\n          //Split row only if row height exceeds page height and AllowRowBreakAcrossPages is true.\n          if (calculatedHeight > this.currentPageBounds.height) {\n            if (this.Grid.allowRowBreakAcrossPages) {\n              result.isFinish = true; //result.bounds = this.currentBounds;\n\n              this.drawRowWithBreak(result, row, calculatedHeight);\n              row.isrowFinish = true;\n              row.repeatFlag = true;\n\n              if (row.grid.splitChildRowIndex !== -1) {\n                result.isFinish = false;\n              }\n            } // else {\n            //     //If AllowRowBreakAcrossPages is not true, draw the row till it fits the page.\n            //     result.isFinish = false;\n            //     this.drawRow( row, result, calculatedHeight);\n            // }\n\n          } else if (this.currentBounds.y + calculatedHeight > this.currentPageBounds.height || this.currentBounds.y + calculatedHeight > this.currentBounds.height + this.startLocation.y || this.currentBounds.y + rowHeightWithSpan > this.currentPageBounds.height) {\n            // If a row is repeated and still cannot fit in page, proceed draw.\n            let isFit = false;\n\n            if (this.Grid.allowRowBreakAcrossPages && !this.Grid.repeatHeader && !row.isRowHeightSet && !row.rowMergeComplete) {\n              if (this.Grid.LayoutFormat !== null && this.Grid.LayoutFormat.paginateBounds.height > 0 && typeof this.Grid.ParentCell !== 'undefined' && this.Grid.ParentCell !== null && this.currentBounds.y + this.Grid.ParentCell.row.grid.style.cellPadding.bottom + calculatedHeight > this.currentBounds.height) {\n                isFit = this.isFitToCell(this.currentBounds.height + this.startLocation.y - this.currentBounds.y, this.Grid, row);\n              } else isFit = this.isFitToCell(this.currentPageBounds.height - this.currentBounds.y, this.Grid, row);\n\n              if (isFit) {\n                this.isPaginate = true;\n              }\n            } else if (this.Grid.allowRowBreakAcrossPages && this.Grid.LayoutFormat != null && this.Grid.LayoutFormat.layout == PdfLayoutType.Paginate && this.Grid.LayoutFormat.break != PdfLayoutBreakType.FitElement && row.isRowHeightSet && this.currentBounds.y + height > this.currentPageBounds.height) {\n              isFit = this.isFitToCell(this.currentPageBounds.height - this.currentBounds.y, this.Grid, row);\n              if (!isFit) isFit = !(this.slr !== null && this.slr.actualSize.height == 0 && this.slr.remainder != null && this.slr.remainder.length > 0 && this.remainderText == this.slr.remainder);\n\n              if (isFit && this.slr != null && this.slr.lineCount > 1) {\n                //It may text cutoff issue\n                isFit = false;\n              }\n\n              this.remainderText = null;\n            }\n\n            if (PdfGridLayouter.repeatRowIndex > -1 && PdfGridLayouter.repeatRowIndex === row.rowIndex || isFit) {\n              if (this.Grid.allowRowBreakAcrossPages) {\n                result.isFinish = true;\n                this.drawRowWithBreak(result, row, calculatedHeight);\n                row.repeatFlag = true;\n                row.repeatRowNumber = PdfGridLayouter.repeatRowIndex;\n\n                if (row.grid.splitChildRowIndex !== -1) {\n                  result.isFinish = false;\n                }\n              } else {\n                result.isFinish = false;\n                this.drawRow(row, result, calculatedHeight);\n              }\n            } else {\n              result.isFinish = false;\n            }\n          } else {\n            result.isFinish = true;\n            this.drawRow(row, result, calculatedHeight);\n            row.repeatFlag = false;\n          }\n        }\n\n        return result;\n      } else {\n        let skipcell = false;\n        let location = new PointF(this.currentBounds.x, this.currentBounds.y); // if (row.grid.isChildGrid && row.grid.allowRowBreakAcrossPages && this.startLocation.x !== this.currentBounds.x && row.width <\n        //                 this.currentPage.getClientSize().width) {\n        //     location.x = this.startLocation.x;\n        // }\n\n        result.bounds = new RectangleF(location, new SizeF(0, 0));\n        height = this.ReCalculateHeight(row, height);\n\n        for (let i = this.cellStartIndex; i <= this.cellEndIndex; i++) {\n          let cancelSpans = i > this.cellEndIndex + 1 && row.cells.getCell(i).columnSpan > 1; // let cancelSpans : boolean = false;\n\n          if (!cancelSpans) {\n            for (let j = 1; j < row.cells.getCell(i).columnSpan; j++) {\n              row.cells.getCell(i + j).isCellMergeContinue = true;\n            }\n          }\n\n          let size = new SizeF(this.Grid.columns.getColumn(i).width, height); // if (size.width > this.currentGraphics.clientSize.width) {\n          //     size.width = this.currentGraphics.clientSize.width;\n          // }\n          // if (this.Grid.isChildGrid && this.Grid.style.allowHorizontalOverflow) {\n          //     if (size.width >= this.currentGraphics.clientSize.width) {\n          //         size.width -= 2 * this.currentBounds.x;\n          //     }\n          // }\n\n          /* tslint:disable */\n\n          if (!this.CheckIfDefaultFormat(this.Grid.columns.getColumn(i).format) && this.CheckIfDefaultFormat(row.cells.getCell(i).stringFormat)) {\n            row.cells.getCell(i).stringFormat = this.Grid.columns.getColumn(i).format;\n          }\n\n          let cellstyle = row.cells.getCell(i).style;\n          let tempValue = typeof row.cells.getCell(i).value === 'string' && row.cells.getCell(i).value !== null ? row.cells.getCell(i).value : '';\n          row.cells.getCell(i).style = this.RaiseBeforeCellDraw(this.currentGraphics, this.currentRowIndex, i, new RectangleF(location, size), tempValue, cellstyle); //row.cells.getCell(i).style = cellstyle;\n\n          if (!skipcell) {\n            if (row.cells.getCell(i).value instanceof PdfGrid) {\n              let grid = row.cells.getCell(i).value;\n              grid.parentCellIndex = i;\n            }\n\n            let stringResult = row.cells.getCell(i).draw(this.currentGraphics, new RectangleF(location, size), cancelSpans);\n\n            if (row.grid.style.allowHorizontalOverflow && (row.cells.getCell(i).columnSpan > this.cellEndIndex || i + row.cells.getCell(i).columnSpan > this.cellEndIndex + 1) && this.cellEndIndex < row.cells.count - 1) {\n              row.rowOverflowIndex = this.cellEndIndex;\n            }\n\n            if (row.grid.style.allowHorizontalOverflow && row.rowOverflowIndex > 0 && (row.cells.getCell(i).columnSpan > this.cellEndIndex || i + row.cells.getCell(i).columnSpan > this.cellEndIndex + 1) && row.cells.getCell(i).columnSpan - this.cellEndIndex + i - 1 > 0) {\n              row.cells.getCell(row.rowOverflowIndex + 1).value = stringResult !== null ? stringResult.remainder !== undefined ? stringResult.remainder : '' : '';\n              row.cells.getCell(row.rowOverflowIndex + 1).stringFormat = row.cells.getCell(i).stringFormat;\n              row.cells.getCell(row.rowOverflowIndex + 1).style = row.cells.getCell(i).style;\n              row.cells.getCell(row.rowOverflowIndex + 1).columnSpan = row.cells.getCell(i).columnSpan - this.cellEndIndex + i - 1;\n            }\n          }\n          /* tslint:enable */\n\n\n          tempValue = typeof row.cells.getCell(i).value === 'string' && row.cells.getCell(i).value !== null ? row.cells.getCell(i).value : '';\n\n          if (!cancelSpans) {\n            this.raiseAfterCellDraw(this.currentGraphics, this.currentRowIndex, i, new RectangleF(location, size), tempValue, row.cells.getCell(i).style);\n          }\n\n          if (row.cells.getCell(i).value instanceof PdfGrid) {\n            let grid = row.cells.getCell(i).value;\n\n            if (this.Grid.columns.getColumn(i).width >= this.currentGraphics.clientSize.width) {\n              location.x = grid.rowLayoutBoundsWidth;\n              location.x += grid.style.cellSpacing;\n            } else {\n              location.x += this.Grid.columns.getColumn(i).width;\n            }\n          } else {\n            location.x += this.Grid.columns.getColumn(i).width;\n          }\n        }\n\n        if (!row.rowMergeComplete || row.isRowHeightSet) {\n          this.currentBounds.y += height;\n        }\n\n        result.bounds = new RectangleF(new PointF(result.bounds.x, result.bounds.y), new SizeF(location.x, location.y));\n      }\n    }\n\n    isFitToCell(currentHeight, grid, gridRow) {\n      let isFit = false;\n      let layouter = new PdfStringLayouter();\n\n      for (let i = 0; i < gridRow.cells.count; i++) {\n        let cell = gridRow.cells.getCell(i);\n\n        if (typeof cell.value !== 'undefined' && cell.value !== null && typeof cell.value === 'string') {\n          let font = null;\n\n          if (typeof cell.style.font !== 'undefined' && cell.style.font != null) {\n            font = cell.style.font;\n          } else if (typeof cell.row.style.font !== 'undefined' && cell.row.style.font != null) {\n            font = cell.row.style.font;\n          } else if (typeof cell.row.grid.style.font !== 'undefined' && cell.row.grid.style.font != null) {\n            font = cell.row.grid.style.font;\n          } else {\n            font = PdfDocument.defaultFont;\n          }\n\n          this.remainderText = gridRow.cells.getCell(i).value;\n          let width = gridRow.cells.getCell(i).width;\n\n          if (grid.columns.getColumn(i).isCustomWidth && gridRow.cells.getCell(i).width > grid.columns.getColumn(i).width) {\n            width = grid.columns.getColumn(i).width;\n          }\n\n          this.slr = layouter.layout(gridRow.cells.getCell(i).value, font, gridRow.cells.getCell(i).stringFormat, new SizeF(width, currentHeight), false, this.currentPageBounds);\n          let height = this.slr.actualSize.height;\n\n          if (height == 0) {\n            isFit = false;\n            break;\n          } else if (currentHeight > height || typeof this.slr.remainder !== 'undefined' && this.slr.remainder !== null) {\n            isFit = true;\n            break;\n          }\n        }\n      }\n\n      return isFit;\n    }\n\n    drawRowWithBreak(result, row, calculateHeight) {\n      let location = new PointF(this.currentBounds.x, this.currentBounds.y);\n\n      if (row.grid.isChildGrid && row.grid.allowRowBreakAcrossPages && this.startLocation.x !== this.currentBounds.x) {\n        location.x = this.startLocation.x;\n      }\n\n      result.bounds = new RectangleF(location, new SizeF(0, 0));\n      this.gridHeight = row.rowBreakHeight > 0 ? this.currentPageBounds.height : 0; // Calculate the remaining height.\n\n      if (row.grid.style.cellPadding.top + this.currentBounds.y + row.grid.style.cellPadding.bottom < this.currentPageBounds.height) {\n        row.rowBreakHeight = this.currentBounds.y + calculateHeight - this.currentPageBounds.height;\n      } // else {\n      //     row.rowBreakHeight = calculateHeight;\n      //     result.isFinish = false;\n      //     return;\n      // }\n      // No need to explicit break if the row height is equal to grid height.\n\n\n      for (let i = 0; i < row.cells.count; i++) {\n        let cell = row.cells.getCell(i);\n        let cellHeight = cell.measureHeight();\n\n        if (cellHeight === calculateHeight && cell.value instanceof PdfGrid) {\n          row.rowBreakHeight = 0;\n        } // else if (cellHeight === calculateHeight && (cell.value as PdfGrid) === null) {\n        //     row.rowBreakHeight = this.currentBounds.y + calculateHeight - this.currentPageBounds.height;\n        // }\n\n      }\n\n      for (let i = this.cellStartIndex; i <= this.cellEndIndex; i++) {\n        let cancelSpans = row.cells.getCell(i).columnSpan + i > this.cellEndIndex + 1 && row.cells.getCell(i).columnSpan > 1; // if (!cancelSpans) {\n        //     for (let k : number = 1; k < row.cells.getCell(i).columnSpan; k++) {\n        //         row.cells.getCell(i + k).isCellMergeContinue = true;\n        //     }\n        //}\n\n        let size = new SizeF(this.Grid.columns.getColumn(i).width, this.gridHeight > 0.0 ? this.gridHeight : this.currentPageBounds.height); // if (size.width === 0) {\n        //     size = new SizeF(row.cells.getCell(i).width, size.height);\n        // }\n        // if (!this.CheckIfDefaultFormat(this.Grid.columns.getColumn(i).format) &&\n        //         this.CheckIfDefaultFormat((row.cells.getCell(i).stringFormat))) {\n        //     row.cells.getCell(i).stringFormat = this.Grid.columns.getColumn(i).format;\n        // }\n\n        let cellstyle1 = row.cells.getCell(i).style;\n        row.cells.getCell(i).style = cellstyle1;\n        let skipcell = false;\n        let stringResult = null;\n\n        if (!skipcell) {\n          stringResult = row.cells.getCell(i).draw(this.currentGraphics, new RectangleF(location, size), cancelSpans);\n        } //If still row is to be drawn, set cell finished drawing cell as false and update the text to be drawn.\n\n\n        if (row.rowBreakHeight > 0.0) {\n          if (stringResult != null && typeof stringResult.remainder !== 'undefined') {\n            row.cells.getCell(i).FinishedDrawingCell = false;\n            row.cells.getCell(i).remainingString = stringResult.remainder == null ? ' ' : stringResult.remainder;\n\n            if (row.grid.isChildGrid) {\n              row.rowBreakHeight = calculateHeight - stringResult.actualSize.height;\n            }\n          }\n        }\n\n        result.isFinish = !result.isFinish ? result.isFinish : row.cells.getCell(i).FinishedDrawingCell; // let tempValue : string = ((typeof row.cells.getCell(i).value === 'string' &&\n        //row.cells.getCell(i).value !== null) ? row.cells.getCell(i).value : '') as string;\n        // if (!cancelSpans) {\n        //     // this.raiseAfterCellDraw(this.currentGraphics, this.currentRowIndex, i,\n        //     //           new RectangleF(location, size), tempValue, row.cells.getCell(i).style);            \n        //     this.raiseAfterCellDraw(this.currentGraphics, this.currentRowIndex, i, new RectangleF(location, size),\n        //                             (row.cells.getCell(i).value as string) ? row.cells.getCell(i).value.toString() : ' ',\n        //                             row.cells.getCell(i).style);\n        //     }                \n\n        if (row.cells.getCell(i).value instanceof PdfGrid) {\n          let grid = row.cells.getCell(i).value;\n          this.rowBreakPageHeightCellIndex = i; // row.cells.getCell(i).pageCount = grid.listOfNavigatePages.length;\n          // for (let j : number = 0;j<grid.listOfNavigatePages.length;j++){\n          //     let pageIndex : number =grid.listOfNavigatePages.indexOf(j);\n          //             this.Grid.listOfNavigatePages.push(pageIndex);\n          //     }\n\n          if (this.Grid.columns.getColumn(i).width >= this.currentGraphics.clientSize.width) {\n            location.x = this.rowLayoutBoundsWidth;\n            location.x += grid.style.cellSpacing;\n          } else {\n            location.x += this.Grid.columns.getColumn(i).width;\n          }\n        } else {\n          location.x += this.Grid.columns.getColumn(i).width;\n        }\n      }\n\n      this.currentBounds.y += this.gridHeight > 0.0 ? this.gridHeight : calculateHeight;\n      result.bounds = new RectangleF(new PointF(result.bounds.x, result.bounds.y), new SizeF(location.x, location.y));\n    }\n\n  }\n\n  /**\n   * @hidden\n   * @private\n   */\n  PdfGridLayouter.repeatRowIndex = -1; // recalculateBounds : boolean, clientSize : SizeF\n  //Implementation\n\n  /**\n   * `Initializes` internal data.\n   * @private\n   */\n  //Internal declaration\n\n  return PdfGridLayouter;\n})();\n\nclass PdfGridLayoutResult extends PdfLayoutResult {\n  /**\n   * Constructor\n   * @private\n   */\n  constructor(page, bounds) {\n    super(page, bounds);\n  }\n\n}\n/**\n * `PdfGridLayoutFormat` class represents a flexible grid that consists of columns and rows.\n */\n\n\nclass PdfGridLayoutFormat extends PdfLayoutFormat {\n  /**\n   * Initializes a new instance of the `PdfGridLayoutFormat` class.\n   * @private\n   */\n  constructor(baseFormat) {\n    super(baseFormat);\n  }\n\n}\n\nclass GridCellEventArgs {\n  // Properties\n\n  /**\n   * Gets the value of current `row index`.\n   * @private\n   */\n  get rowIndex() {\n    return this.gridRowIndex;\n  }\n  /**\n   * Gets the value of current `cell index`.\n   * @private\n   */\n\n\n  get cellIndex() {\n    return this.gridCellIndex;\n  }\n  /**\n   * Gets the actual `value` of current cell.\n   * @private\n   */\n\n\n  get value() {\n    return this.internalValue;\n  }\n  /**\n   * Gets the `bounds` of current cell.\n   * @private\n   */\n\n\n  get bounds() {\n    return this.gridBounds;\n  }\n  /**\n   * Gets the instance of `current graphics`.\n   * @private\n   */\n\n\n  get graphics() {\n    return this.pdfGraphics;\n  } // Constructors\n\n  /**\n   * Initialize a new instance for `GridCellEventArgs` class.\n   * @private\n   */\n\n\n  constructor(graphics, rowIndex, cellIndex, bounds, value) {\n    this.gridRowIndex = rowIndex;\n    this.gridCellIndex = cellIndex;\n    this.internalValue = value;\n    this.gridBounds = bounds;\n    this.pdfGraphics = graphics;\n  }\n\n}\n\nclass PdfGridBeginCellDrawEventArgs extends GridCellEventArgs {\n  // Properties\n\n  /**\n   * Gets or sets a value indicating whether the value of this cell should be `skipped`.\n   * @private\n   */\n  get skip() {\n    return this.bSkip;\n  }\n\n  set skip(value) {\n    this.bSkip = value;\n  }\n  /**\n   * Gets or sets a `style` value of the cell.\n   * @private\n   */\n\n\n  get style() {\n    return this.cellStyle;\n  }\n\n  set style(value) {\n    this.cellStyle = value;\n  } // Constructors\n\n  /**\n   * Initializes a new instance of the `StartCellLayoutEventArgs` class.\n   * @private\n   */\n\n\n  constructor(graphics, rowIndex, cellIndex, bounds, value, style) {\n    super(graphics, rowIndex, cellIndex, bounds, value);\n    this.style = style;\n  }\n\n}\n\nclass PdfGridEndCellDrawEventArgs extends GridCellEventArgs {\n  // Propertise\n\n  /**\n   * Get the `PdfGridCellStyle`.\n   * @private\n   */\n  get style() {\n    return this.cellStyle;\n  } // Constructors\n\n  /**\n   * Initializes a new instance of the `PdfGridEndCellLayoutEventArgs` class.\n   * @private\n   */\n\n\n  constructor(graphics, rowIndex, cellIndex, bounds, value, style) {\n    super(graphics, rowIndex, cellIndex, bounds, value);\n    this.cellStyle = style;\n  }\n\n}\n\nclass PdfCancelEventArgs {\n  // Properties\n\n  /**\n   * Gets and Sets the value of `cancel`.\n   * @private\n   */\n  get cancel() {\n    return this.isCancel;\n  }\n\n  set cancel(value) {\n    this.isCancel = value;\n  }\n\n}\n\nclass BeginPageLayoutEventArgs extends PdfCancelEventArgs {\n  // Properties\n\n  /**\n   * Gets or sets value that indicates the lay outing `bounds` on the page.\n   * @private\n   */\n  get bounds() {\n    return this.cellBounds;\n  }\n\n  set bounds(value) {\n    this.cellBounds = value;\n  }\n  /**\n   * Gets the `page` where the lay outing should start.\n   * @private\n   */\n\n\n  get page() {\n    return this.pdfPage;\n  } // Constructors\n\n  /**\n   * Initializes a new instance of the `BeginPageLayoutEventArgs` class with the specified rectangle and page.\n   * @private\n   */\n\n\n  constructor(bounds, page) {\n    super();\n    this.bounds = bounds;\n    this.pdfPage = page;\n  }\n\n}\n/**\n * `EndPageLayoutEventArgs` class is alternate for end page layout events.\n */\n\n\nclass EndPageLayoutEventArgs extends PdfCancelEventArgs {\n  // Properties\n\n  /**\n   * Gets the lay outing `result` of the page.\n   * @private\n   */\n  get result() {\n    return this.layoutResult;\n  }\n  /**\n   * Gets or sets a value indicating the `next page` where the element should be layout.\n   * @private\n   */\n\n\n  get nextPage() {\n    return this.nextPdfPage;\n  }\n\n  set nextPage(value) {\n    this.nextPdfPage = value;\n  } // Constructors\n\n  /**\n   * Initializes a new instance of the `EndPageLayoutEventArgs` class. with the specified 'PdfLayoutResult'.\n   * @private\n   */\n\n\n  constructor(result) {\n    super();\n    this.layoutResult = result;\n  }\n\n}\n/**\n * `PdfGridBeginPageLayoutEventArgs` class is alternate for begin page layout events.\n */\n\n\nclass PdfGridBeginPageLayoutEventArgs extends BeginPageLayoutEventArgs {\n  // Properties\n\n  /**\n   * Gets the `start row index`.\n   * @private\n   */\n  get startRowIndex() {\n    return this.startRow;\n  } // Constructors\n\n  /**\n   * Initialize a new instance of `PdfGridBeginPageLayoutEventArgs` class.\n   * @private\n   */\n\n\n  constructor(bounds, page, startRow) {\n    super(bounds, page);\n    this.startRow = startRow;\n  }\n\n}\n/**\n * `PdfGridEndPageLayoutEventArgs` class is alternate for begin page layout events.\n */\n\n\nclass PdfGridEndPageLayoutEventArgs extends EndPageLayoutEventArgs {\n  // Constructors\n\n  /**\n   * Initialize a new instance of `PdfGridEndPageLayoutEventArgs` class.\n   * @private\n   */\n  constructor(result) {\n    super(result);\n  }\n\n}\n\nclass RowLayoutResult {\n  /**\n   * Gets or sets a value indicating whether this instance `is finish`.\n   * @private\n   */\n  get isFinish() {\n    return this.bIsFinished;\n  }\n\n  set isFinish(value) {\n    this.bIsFinished = value;\n  }\n  /**\n   * Gets or sets the `bounds`.\n   * @private\n   */\n\n\n  get bounds() {\n    return this.layoutedBounds;\n  }\n\n  set bounds(value) {\n    this.layoutedBounds = value;\n  } //Constructors\n\n  /**\n   * Initializes a new instance of the `RowLayoutResult` class.\n   * @private\n   */\n\n\n  constructor() {\n    this.layoutedBounds = new RectangleF(0, 0, 0, 0);\n  }\n\n}\n/**\n * ShapeLayouter.ts class for EJ2-PDF\n * @private\n */\n\n/**\n * ShapeLayouter class.\n * @private\n */\n\n\nlet ShapeLayouter = /*#__PURE__*/(() => {\n  class ShapeLayouter extends ElementLayouter {\n    // Constructors\n\n    /**\n     * Initializes a new instance of the `ShapeLayouter` class.\n     * @private\n     */\n    constructor(element) {\n      super(element); // Fields\n\n      /**\n       * Initializes the object to store `older form elements` of previous page.\n       * @default 0\n       * @private\n       */\n\n      this.olderPdfForm = 0;\n      /**\n       * The `bounds` of the shape element.\n       * * @default new RectangleF()\n       * @private\n       */\n\n      this.shapeBounds = new RectangleF();\n      /**\n       * Total Page size of the web page.\n       * * @default 0\n       * @private\n       */\n\n      this.totalPageSize = 0;\n    } // Properties\n\n    /**\n     * Gets shape element.\n     * @private\n     */\n\n\n    get element() {\n      return this.elements;\n    } // Implementation\n\n    /**\n     * Layouts the element.\n     * @private\n     */\n\n\n    layoutInternal(param) {\n      let currentPage = param.page;\n      let currentBounds = param.bounds;\n      let shapeLayoutBounds = this.element.getBounds();\n      shapeLayoutBounds.x = 0;\n      shapeLayoutBounds.y = 0;\n      /* tslint:disable */\n\n      let isEmpty = this.shapeBounds.x === this.shapeBounds.y && this.shapeBounds.y === this.shapeBounds.width && this.shapeBounds.width === this.shapeBounds.height && this.shapeBounds.height === 0 ? true : false;\n      /* tslint:enable */\n\n      if (this.isPdfGrid && !isEmpty) {\n        shapeLayoutBounds = this.shapeBounds;\n      }\n\n      let result = null;\n      let pageResult = new ShapeLayoutResult();\n      pageResult.page = currentPage;\n      /*tslint:disable:no-constant-condition */\n\n      while (true) {\n        // Raise event.\n        let result1 = this.raiseBeforePageLayout(currentPage, currentBounds);\n        currentBounds = result1.currentBounds;\n        let endArgs = null;\n\n        if (!result1.cancel) {\n          pageResult = this.layoutOnPage(currentPage, currentBounds, shapeLayoutBounds, param); // Raise event.\n\n          endArgs = this.raiseEndPageLayout(pageResult);\n          result1.cancel = endArgs === null ? false : endArgs.cancel;\n        }\n\n        if (!pageResult.end && !result1.cancel) {\n          currentBounds = this.getPaginateBounds(param);\n          shapeLayoutBounds = this.getNextShapeBounds(shapeLayoutBounds, pageResult);\n          currentPage = endArgs === null || endArgs.nextPage === null ? this.getNextPage(currentPage) : endArgs.nextPage;\n\n          if (this.isPdfGrid) {\n            result = this.getLayoutResult(pageResult);\n            break;\n          }\n        } else {\n          result = this.getLayoutResult(pageResult);\n          break;\n        }\n      }\n\n      return result;\n    }\n    /**\n     * Raises BeforePageLayout event.\n     * @private\n     */\n\n\n    raiseBeforePageLayout(currentPage, currentBounds) {\n      let cancel = false;\n\n      if (this.element.raiseBeginPageLayout) {\n        let args = new BeginPageLayoutEventArgs(currentBounds, currentPage);\n        this.element.onBeginPageLayout(args);\n        cancel = args.cancel;\n        currentBounds = args.bounds;\n      }\n\n      return {\n        currentBounds: currentBounds,\n        cancel: cancel\n      };\n    }\n    /**\n     * Raises PageLayout event if needed.\n     * @private\n     */\n\n\n    raiseEndPageLayout(pageResult) {\n      let args = null;\n\n      if (this.element.raiseEndPageLayout) {\n        let res = this.getLayoutResult(pageResult);\n        args = new EndPageLayoutEventArgs(res);\n        this.element.onEndPageLayout(args);\n      }\n\n      return args;\n    }\n    /**\n     * Creates layout result.\n     * @private\n     */\n\n\n    getLayoutResult(pageResult) {\n      let result = new PdfLayoutResult(pageResult.page, pageResult.bounds);\n      return result;\n    }\n    /**\n     * Calculates the next active shape bounds.\n     * @private\n     */\n\n\n    getNextShapeBounds(shapeLayoutBounds, pageResult) {\n      let layoutedBounds = pageResult.bounds;\n      shapeLayoutBounds.y = shapeLayoutBounds.y + layoutedBounds.height;\n      shapeLayoutBounds.height = shapeLayoutBounds.height - layoutedBounds.height;\n      return shapeLayoutBounds;\n    }\n    /**\n     * Layouts the element on the current page.\n     * @private\n     */\n\n\n    layoutOnPage(currentPage, curBounds, sBounds, param) {\n      let result = new ShapeLayoutResult();\n      curBounds = this.checkCorrectCurrentBounds(currentPage, curBounds, param);\n      let fitToPage = this.fitsToBounds(curBounds, sBounds);\n      let canDraw = !(param.format.break === PdfLayoutBreakType.FitElement && !fitToPage && currentPage === param.page);\n      let shapeFinished = false;\n\n      if (canDraw) {\n        let drawRectangle = this.getDrawBounds(curBounds, sBounds);\n        this.drawShape(currentPage.graphics, curBounds, drawRectangle);\n        result.bounds = this.getPageResultBounds(curBounds, sBounds);\n        shapeFinished = curBounds.height >= sBounds.height;\n      }\n\n      result.end = shapeFinished || param.format.layout === PdfLayoutType.OnePage;\n      result.page = currentPage;\n      return result;\n    }\n    /**\n     * Returns Rectangle for element drawing on the page.\n     * @private\n     */\n\n\n    getDrawBounds(currentBounds, shapeLayoutBounds) {\n      let result = currentBounds;\n      result.y = result.y - shapeLayoutBounds.y;\n      result.height = result.height + shapeLayoutBounds.y;\n      return result;\n    }\n    /**\n     * Draws the shape.\n     * @private\n     */\n\n\n    drawShape(g, currentBounds, drawRectangle) {\n      let gState = g.save();\n\n      try {\n        g.setClip(currentBounds);\n        this.element.drawGraphicsHelper(g, new PointF(drawRectangle.x, drawRectangle.y));\n      } finally {\n        g.restore(gState);\n      }\n    }\n    /**\n     * Corrects current bounds on the page.\n     * @protected\n     */\n\n\n    checkCorrectCurrentBounds(currentPage, curBounds, param) {\n      let pageSize = currentPage.graphics.clientSize;\n      curBounds.width = curBounds.width > 0 ? curBounds.width : pageSize.width - curBounds.x;\n      curBounds.height = curBounds.height > 0 ? curBounds.height : pageSize.height - curBounds.y;\n\n      if (this.isPdfGrid) {\n        curBounds.height = curBounds.height - this.bottomCellPadding;\n      }\n\n      return curBounds;\n    }\n    /**\n     * Calculates bounds where the shape was layout on the page.\n     * @private\n     */\n\n\n    getPageResultBounds(currentBounds, shapeLayoutBounds) {\n      let result = currentBounds;\n      result.height = Math.min(result.height, shapeLayoutBounds.height);\n      return result;\n    }\n    /**\n     * Checks whether shape rectangle fits to the lay outing bounds.\n     * @private\n     */\n\n\n    fitsToBounds(currentBounds, shapeLayoutBounds) {\n      let fits = shapeLayoutBounds.height <= currentBounds.height;\n      return fits;\n    }\n\n  }\n\n  /**\n   * Initializes the offset `index`.\n   * * @default 0\n   * @private\n   */\n  ShapeLayouter.index = 0;\n  /**\n   * Initializes the `difference in page height`.\n   * * @default 0\n   * @private\n   */\n\n  ShapeLayouter.splitDiff = 0;\n  /**\n   * Determines the `end of Vertical offset` values.\n   * * @default false\n   * @private\n   */\n\n  ShapeLayouter.last = false;\n  /**\n   * Determines the document link annotation `border width`.\n   * * @default 0\n   * @private\n   */\n\n  ShapeLayouter.borderWidth = 0;\n  /**\n   * Contains lay outing result settings.\n   * @private\n   */\n\n  return ShapeLayouter;\n})();\n\nclass ShapeLayoutResult {}\n/**\n * Base class for the main shapes.\n * @private\n */\n\n\nclass PdfShapeElement extends PdfLayoutElement {\n  // methods\n\n  /**\n   * Gets the bounds.\n   * @private\n   */\n  getBounds() {\n    let rect = this.getBoundsInternal();\n    return rect;\n  }\n  /**\n   * `drawGraphicsHelper` the graphics.\n   * @public\n   */\n\n\n  drawGraphicsHelper(graphics, location) {\n    if (graphics == null) {\n      throw new Error('ArgumentNullException :graphics');\n    }\n\n    this.drawShapeHelper(graphics, location.x, location.y);\n  }\n  /**\n   * `drawShapeHelper` the graphics.\n   * @private\n   */\n\n\n  drawShapeHelper(graphics, x, y) {\n    let bNeedSave = x !== 0.5 || y !== 0.5;\n    let gState = null; // Translate co-ordinates.\n\n    if (bNeedSave) {\n      // Save state.\n      gState = graphics.save();\n      graphics.translateTransform(x, y);\n    }\n\n    this.drawInternal(graphics);\n\n    if (bNeedSave) {\n      // Restore state.\n      graphics.restore(gState);\n    }\n  }\n  /**\n   * Layouts the element.\n   * @private\n   */\n\n\n  layout(param) {\n    let layouter = new ShapeLayouter(this);\n    let result = layouter.layout(param);\n    return result;\n  }\n\n}\n/**\n * PdfDrawElement.ts class for EJ2-PDF\n */\n\n/**\n * Represents a base class for all page graphics elements.\n */\n\n\nclass PdfDrawElement extends PdfShapeElement {\n  /**\n   * Initializes a new instance of the `PdfDrawElement` class.\n   * @protected\n   */\n  constructor(pen) {\n    super();\n\n    if (typeof pen !== 'undefined') {\n      this.mpen = pen;\n    }\n  } // Properties\n\n  /**\n   * Gets or sets a pen that will be used to draw the element.\n   * @public\n   */\n\n\n  get pen() {\n    return this.mpen;\n  }\n\n  set pen(value) {\n    this.mpen = value;\n  }\n\n}\n/**\n * PdfFillElement.ts class for EJ2-PDF\n */\n\n/**\n * Represents a base class for all page graphics elements.\n */\n\n\nclass PdfFillElement extends PdfDrawElement {\n  /**\n   * Initializes a new instance of the `PdfFillElement` class.\n   * @protected\n   */\n  constructor(arg1, arg2) {\n    super(); // Fields\n\n    /**\n     * Internal variable to store pen.\n     * @private\n     */\n\n    this.mbrush = null;\n\n    if (typeof arg1 === 'undefined') {//\n    } else if (arg1 instanceof PdfPen) {\n      super(arg1);\n    } else {\n      this.mbrush = arg2;\n    }\n  } // Properties\n\n  /**\n   * Gets or sets a brush of the element.\n   * @public\n   */\n\n\n  get brush() {\n    return this.mbrush;\n  }\n\n  set brush(value) {\n    this.mbrush = value;\n  } // Implementation\n\n  /**\n   * Gets the pen. If both pen and brush are not explicitly defined, default pen will be used.\n   * @protected\n   */\n\n\n  obtainPen() {\n    return this.mbrush == null && this.pen == null ? new PdfPen(new PdfColor(0, 0, 0)) : this.pen;\n  }\n\n}\n/**\n * Path.ts class for EJ2-PDF\n */\n\n/**\n * `PdfPath` class Implements graphics path, which is a sequence of primitive graphics elements.\n * @private\n */\n\n\nclass PdfPath extends PdfFillElement {\n  /**\n   * Initializes a new instance of the `PdfPath` class.\n   * @public\n   */\n\n  /* tslint:disable-next-line:max-line-length */\n  constructor(arg1, arg2, arg3, arg4) {\n    super(); // Fields\n\n    /**\n     * Local variable to store the points.\n     * @private\n     */\n\n    this.mpoints = null;\n    /**\n     * Local variable to store the path Types.\n     * @private\n     */\n\n    this.mpathTypes = null;\n    /**\n     * Local variable to store the Start Figure.\n     * @private\n     */\n\n    this.mStartFigure = true;\n    /**\n     * Local variable to store the fill Mode.\n     * @private\n     */\n\n    this.mfillMode = PdfFillMode.Alternate;\n    /**\n     * Local variable to store the Beziers.\n     * @private\n     */\n\n    this.isBeziers3 = false;\n    /**\n     * Local variable to store the xps.\n     * @private\n     */\n\n    this.isXps = false;\n\n    if (typeof arg1 === 'undefined') {//\n    } else if (arg1 instanceof PdfPen) {\n      super(arg1);\n\n      if (arg2 instanceof PdfBrush) {\n        super(arg1, arg2);\n        this.fillMode = arg3;\n      } else if (arg2 !== null && typeof arg2 !== 'undefined' && arg3 !== null && typeof arg3 !== 'undefined') {\n        this.addPath(arg2, arg3);\n      }\n    } else if (arg1 instanceof PdfBrush) {\n      super(arg1);\n\n      if (arg2 !== null && typeof arg2 !== 'undefined') {\n        this.fillMode = arg2;\n      }\n\n      if (arg3 !== null && typeof arg3 !== 'undefined' && arg4 !== null && typeof arg4 !== 'undefined') {\n        this.addPath(arg3, arg4);\n      }\n    } else {\n      this.addPath(arg1, arg2);\n    }\n  } // Properties\n\n  /**\n   * Gets or sets the fill mode.\n   * @public\n   */\n\n\n  get fillMode() {\n    return this.mfillMode;\n  }\n\n  set fillMode(value) {\n    this.mfillMode = value;\n  }\n  /**\n   * Gets the path points.\n   * @public\n   */\n\n\n  get pathPoints() {\n    return this.points;\n  }\n  /**\n   * Gets the path point types.\n   * @public\n   */\n\n\n  get pathTypes() {\n    return this.types;\n  }\n  /**\n   * Gets the point count.\n   * @public\n   */\n\n\n  get pointCount() {\n    let count = 0;\n\n    if (this.mpoints != null) {\n      count = this.mpoints.length;\n    }\n\n    return count;\n  }\n  /**\n   * Gets the last points.\n   * @public\n   */\n\n\n  get lastPoint() {\n    return this.getLastPoint();\n  }\n  /**\n   * Gets the points list.\n   * @private\n   */\n\n\n  get points() {\n    if (this.mpoints == null) {\n      this.mpoints = [];\n    }\n\n    return this.mpoints;\n  }\n  /**\n   * Gets the types.\n   * @private\n   */\n\n\n  get types() {\n    if (this.mpathTypes == null) {\n      this.mpathTypes = [];\n    }\n\n    return this.mpathTypes;\n  }\n\n  draw(arg1, arg2, arg3, arg4) {\n    if (arg2 instanceof PointF && typeof arg2.width === 'undefined' && typeof arg3 === 'undefined') {\n      return this.drawHelper(arg1, arg2.x, arg2.y);\n    } else if (arg2 instanceof RectangleF && typeof arg2.width !== 'undefined' && typeof arg3 === 'undefined') {\n      return this.drawHelper(arg1, arg2, null);\n    } else if (typeof arg2 === 'number' && typeof arg3 === 'number' && typeof arg4 === 'undefined') {\n      return this.drawHelper(arg1, arg2, arg3, null);\n    } else if (arg2 instanceof PointF && arg3 instanceof PdfLayoutFormat) {\n      return this.drawHelper(arg1, arg2.x, arg2.y, arg3);\n    } else if (typeof arg2 === 'number' && (arg4 instanceof PdfLayoutFormat || arg4 == null) && typeof arg3 === 'number') {\n      let widthValue = arg1.graphics.clientSize.width - arg2;\n      let layoutRect = new RectangleF(arg2, arg3, widthValue, 0);\n      return this.drawHelper(arg1, layoutRect, arg4);\n    } else if (arg2 instanceof RectangleF && arg3 instanceof PdfLayoutFormat) {\n      return this.drawHelper(arg1, arg2, arg3);\n    } else {\n      return this.drawHelper(arg1, arg2, arg3);\n    }\n  }\n\n  addArc(arg1, arg2, arg3, arg4, arg5, arg6) {\n    if (arg1 instanceof RectangleF) {\n      this.addArc(arg1.x, arg1.y, arg1.width, arg1.height, arg2, arg3);\n    } else {\n      let points = this.getBezierArcPoints(arg1, arg2, arg2 + arg3, arg2 + arg4, arg5, arg6);\n\n      for (let i = 0; i < points.length; i = i + 8) {\n        /* tslint:disable-next-line:max-line-length */\n        let point = [points[i], points[i + 1], points[i + 2], points[i + 3], points[i + 4], points[i + 5], points[i + 6], points[i + 7]];\n        this.addPoints(point, PathPointType.Bezier3);\n      }\n    }\n  }\n  /* tslint:disable-next-line:max-line-length */\n\n\n  addBezier(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8) {\n    if (arg1 instanceof PointF && arg2 instanceof PointF && arg3 instanceof PointF && arg4 instanceof PointF) {\n      this.addBezier(arg1.x, arg1.y, arg2.x, arg2.y, arg3.x, arg3.y, arg4.x, arg4.y);\n    } else {\n      let points = [];\n      points.push(arg1);\n      points.push(arg2);\n      points.push(arg3);\n      points.push(arg4);\n      points.push(arg5);\n      points.push(arg6);\n      points.push(arg7);\n      points.push(arg8);\n      this.addPoints(points, PathPointType.Bezier3);\n    }\n  }\n\n  addEllipse(arg1, arg2, arg3, arg4) {\n    if (arg1 instanceof RectangleF) {\n      this.addEllipse(arg1.x, arg1.y, arg1.width, arg1.height);\n    } else {\n      this.startFigure();\n      this.addArc(arg1, arg2, arg3, arg4, 0, 360);\n      this.closeFigure();\n    }\n  }\n\n  addLine(arg1, arg2, arg3, arg4) {\n    if (arg1 instanceof PointF && arg2 instanceof PointF) {\n      this.addLine(arg1.x, arg1.y, arg2.x, arg2.y);\n    } else {\n      let points = [];\n      points.push(arg1);\n      points.push(arg2);\n      points.push(arg3);\n      points.push(arg4);\n      this.addPoints(points, PathPointType.Line);\n    }\n  }\n\n  addPath(arg1, arg2) {\n    if (arg1 instanceof PdfPath) {\n      this.addPath(arg1.pathPoints, arg1.pathTypes);\n    } else {\n      if (arg1 == null) {\n        throw new Error('ArgumentNullException:pathPoints');\n      }\n\n      if (arg2 == null) {\n        throw new Error('ArgumentNullException:pathTypes');\n      }\n\n      let count = arg1.length;\n\n      if (count !== arg2.length) {\n        throw new Error('The argument arrays should be of equal length.');\n      }\n    }\n  }\n\n  addPie(arg1, arg2, arg3, arg4, arg5, arg6) {\n    if (arg1 instanceof RectangleF) {\n      this.addPie(arg1.x, arg1.y, arg1.width, arg1.height, arg2, arg3);\n    } else {\n      this.startFigure();\n      this.addArc(arg1, arg2, arg3, arg4, arg5, arg6);\n      this.addPoint(new PointF(arg1 + arg3 / 2, arg2 + arg4 / 2), PathPointType.Line);\n      this.closeFigure();\n    }\n  }\n  /**\n   * `add a polygon` specified by points.\n   * @param points The points of the polygon\n   */\n\n\n  addPolygon(points) {\n    let count = points.length * 2;\n    let p = [];\n    this.startFigure();\n\n    for (let i = 0; i < points.length; i++) {\n      p.push(points[i].x);\n      p.push(points[i].y);\n    }\n\n    this.addPoints(p, PathPointType.Line);\n    this.closeFigure();\n  }\n\n  addRectangle(arg1, y, width, height) {\n    if (arg1 instanceof RectangleF) {\n      this.addRectangle(arg1.x, arg1.y, arg1.width, arg1.height);\n    } else {\n      let points = [];\n      this.startFigure();\n      points.push(arg1);\n      points.push(y);\n      points.push(arg1 + width);\n      points.push(y);\n      points.push(arg1 + width);\n      points.push(y + height);\n      points.push(arg1);\n      points.push(y + height);\n      this.addPoints(points, PathPointType.Line);\n      this.closeFigure();\n    }\n  }\n  /**\n   * Starts a new figure.\n   * @public\n   */\n\n\n  startFigure() {\n    this.mStartFigure = true;\n  }\n  /**\n   * Closed all non-closed figures.\n   * @public\n   */\n\n\n  closeAllFigures() {\n    let startPath = this.pathPoints[0];\n\n    for (let i = 0; i < this.mpathTypes.length; i++) {\n      let pt = this.types[i];\n      let flag = false;\n\n      if (i !== 0 && pt === PathPointType.Start) {\n        this.closeFigure(i - 1);\n        flag = true;\n      } else if (i === this.mpathTypes.length - 1 && !flag && this.isXps) {\n        if (startPath.x === this.pathPoints[i].y) {\n          this.closeFigure(i);\n        }\n      }\n    }\n  }\n  /**\n   * Gets the last point.\n   * @public\n   */\n\n\n  getLastPoint() {\n    let lastPoint = new PointF(0, 0);\n    let count = this.pointCount;\n\n    if (count > 0 && this.mpoints != null) {\n      lastPoint.x = this.mpoints[count - 1].x;\n      lastPoint.y = this.mpoints[count - 1].y;\n    }\n\n    return lastPoint;\n  }\n  /**\n   * Gets the bezier points for arc constructing.\n   * @public\n   */\n\n\n  getBezierArcPoints(x1, y1, x2, y2, s1, e1) {\n    if (x1 > x2) {\n      let tmp;\n      tmp = x1;\n      x1 = x2;\n      x2 = tmp;\n    }\n\n    if (y2 > y1) {\n      let tmp;\n      tmp = y1;\n      y1 = y2;\n      y2 = tmp;\n    }\n\n    let fragAngle;\n    let numFragments;\n\n    if (Math.abs(e1) <= 90) {\n      fragAngle = e1;\n      numFragments = 1;\n    } else {\n      numFragments = Math.ceil(Math.abs(e1) / 90);\n      fragAngle = e1 / numFragments;\n    }\n\n    let xcen = (x1 + x2) / 2;\n    let ycen = (y1 + y2) / 2;\n    let rx = (x2 - x1) / 2;\n    let ry = (y2 - y1) / 2;\n    let halfAng = fragAngle * (Math.PI / 360);\n    let kappa = Math.abs(4.0 / 3.0 * (1.0 - Math.cos(halfAng)) / Math.sin(halfAng));\n    let pointList = [];\n\n    for (let i = 0; i < numFragments; i++) {\n      let theta0 = (s1 + i * fragAngle) * (Math.PI / 180);\n      let theta1 = (s1 + (i + 1) * fragAngle) * (Math.PI / 180);\n      let cos0 = Math.cos(theta0);\n      let cos1 = Math.cos(theta1);\n      let sin0 = Math.sin(theta0);\n      let sin1 = Math.sin(theta1);\n\n      if (fragAngle > 0) {\n        /* tslint:disable-next-line:max-line-length */\n        pointList.push(xcen + rx * cos0, ycen - ry * sin0, xcen + rx * (cos0 - kappa * sin0), ycen - ry * (sin0 + kappa * cos0), xcen + rx * (cos1 + kappa * sin1), ycen - ry * (sin1 - kappa * cos1), xcen + rx * cos1, ycen - ry * sin1);\n      } else {\n        /* tslint:disable-next-line:max-line-length */\n        pointList.push(xcen + rx * cos0, ycen - ry * sin0, xcen + rx * (cos0 + kappa * sin0), ycen - ry * (sin0 - kappa * cos0), xcen + rx * (cos1 - kappa * sin1), ycen - ry * (sin1 + kappa * cos1), xcen + rx * cos1, ycen - ry * sin1);\n      }\n    }\n\n    return pointList;\n  }\n  /**\n   * `getBoundsInternal` Returns a rectangle that bounds this element.\n   * @public\n   */\n\n\n  getBoundsInternal() {\n    let points = this.pathPoints;\n    let bounds = new RectangleF(0, 0, 0, 0);\n\n    if (points.length > 0) {\n      let xmin = points[0].x;\n      let xmax = points[0].x;\n      let ymin = points[0].y;\n      let ymax = points[0].y;\n\n      for (let i = 1; i < points.length; i++) {\n        let point = points[i];\n        xmin = Math.min(point.x, xmin);\n        xmax = Math.max(point.x, xmax);\n        ymin = Math.min(point.y, ymin);\n        ymax = Math.max(point.y, ymax);\n      }\n\n      bounds = new RectangleF(xmin, ymin, xmax - xmin, ymax - ymin);\n    }\n\n    return bounds;\n  }\n  /**\n   * `drawInternal` Draws an element on the Graphics.\n   * @param graphics Graphics context where the element should be printed.\n   * @public\n   */\n\n\n  drawInternal(graphics) {\n    if (graphics == null) {\n      throw new Error('ArgumentNullException :graphics');\n    }\n\n    graphics.drawPath(this.obtainPen(), this.brush, this);\n  }\n\n  addPoints(points, pointType, startIndex, endIndex) {\n    if (typeof startIndex === 'undefined' && typeof endIndex === 'undefined') {\n      this.addPoints(points, pointType, 0, points.length);\n    } else {\n      for (let i = startIndex; i < endIndex; i++) {\n        let point = new PointF(points[i], points[i + 1]);\n\n        if (i === startIndex) {\n          if (this.pointCount <= 0 || this.mStartFigure) {\n            this.addPoint(point, PathPointType.Start);\n            this.mStartFigure = false;\n          } else if (point.x !== this.lastPoint.x && point.y !== this.lastPoint.y && !this.isBeziers3) {\n            this.addPoint(point, PathPointType.Line);\n          } else if (point.x !== this.lastPoint.x && point.y !== this.lastPoint.y) {\n            this.addPoint(point, PathPointType.Bezier3);\n          }\n        } else {\n          this.addPoint(point, pointType);\n        }\n\n        i++;\n      }\n    }\n  }\n  /**\n   * `add a point` Adds the point and its type\n   * @param points The points.\n   * @param pointType Type of the points.\n   * @private\n   */\n\n\n  addPoint(point, pointType) {\n    this.points.push(point);\n    this.types.push(pointType);\n  }\n\n  closeFigure(index) {\n    if (typeof index === 'undefined') {\n      if (this.pointCount > 0) {\n        this.closeFigure(this.pointCount - 1);\n      }\n\n      this.startFigure();\n    } else {\n      if (index < 0) {\n        throw new Error('IndexOutOfRangeException()');\n      }\n\n      let pt = this.types[index];\n      pt = pt | PathPointType.CloseSubpath;\n      this.types[index] = pt;\n    }\n  }\n\n}\n/**\n * `PdfRectangleArea` class Implements graphics rectangle area, which is a sequence of primitive graphics elements.\n * @private\n */\n\n\nclass PdfRectangleArea extends PdfFillElement {\n  /* tslint:disable-next-line:max-line-length */\n  constructor(arg1, arg2, arg3, arg4, arg5, arg6) {\n    super(); //Fields\n\n    /**\n     * public variable to store the rectangle.\n     * @public\n     */\n\n    this.bounds = new RectangleF(0, 0, 0, 0);\n\n    if (typeof arg1 === 'undefined') {//\n    } else if (arg1 instanceof PdfPen) {\n      super(arg1, arg2);\n\n      if (arg3 instanceof RectangleF) {\n        this.bounds = arg3;\n      } else {\n        this.bounds = new RectangleF(arg3, arg4, arg5, arg6);\n      }\n    } else if (arg1 instanceof RectangleF) {\n      this.bounds = arg1;\n    } else {\n      this.bounds = new RectangleF(arg1, arg2, arg3, arg4);\n    }\n  } //Properties\n\n  /**\n   * Gets or sets the X co-ordinate of the upper-left corner of this the element.\n   * @public\n   */\n\n\n  get x() {\n    return this.bounds.x;\n  }\n\n  set x(value) {\n    this.bounds.x = value;\n  }\n  /**\n   * Gets or sets the Y co-ordinate of the upper-left corner of this the element.\n   * @public\n   */\n\n\n  get y() {\n    return this.bounds.y;\n  }\n\n  set y(value) {\n    this.bounds.y = value;\n  }\n  /**\n   * Gets or sets the width of this element.\n   * @public\n   */\n\n\n  get width() {\n    return this.bounds.width;\n  }\n\n  set width(value) {\n    this.bounds.width = value;\n  }\n  /**\n   * Gets or sets the height of this element.\n   * @public\n   */\n\n\n  get height() {\n    return this.bounds.height;\n  }\n\n  set height(value) {\n    this.bounds.height = value;\n  } //Implementation\n\n\n  getBoundsInternal() {\n    return this.bounds;\n  }\n\n}\n/**\n * `PdfEllipsePart` class Implements graphics ellipse part, which is a sequence of primitive graphics elements.\n * @private\n */\n\n\nclass PdfEllipsePart extends PdfRectangleArea {\n  /* tslint:disable-next-line:max-line-length */\n  constructor(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8) {\n    super(); // Fields\n\n    /**\n     * public variable to store the start angle.\n     * @public\n     */\n\n    this.startAngle = 0;\n    /**\n     * public variable to store the sweep angle.\n     * @public\n     */\n\n    this.sweepAngle = 0;\n\n    if (typeof arg1 === 'undefined') {//\n    } else if (arg1 instanceof RectangleF && typeof arg2 !== 'undefined' && typeof arg3 !== 'undefined') {\n      super(arg1);\n      this.startAngle = arg2;\n      this.sweepAngle = arg3;\n    } else if (arg1 instanceof PdfPen) {\n      if (arg3 instanceof RectangleF) {\n        super(arg1, arg2, arg3);\n        this.startAngle = arg4;\n        this.sweepAngle = arg5;\n      } else {\n        super(arg1, arg2, arg3, arg4, arg5, arg6);\n        this.startAngle = arg7;\n        this.sweepAngle = arg8;\n      }\n    } else {\n      super(arg1, arg2, arg3, arg4);\n      this.startAngle = arg5;\n      this.sweepAngle = arg6;\n    }\n  }\n\n}\n/**\n * arc.ts class for EJ2-PDF\n */\n\n/**\n * `PdfArc` class Implements graphics arc, which is a sequence of primitive graphics elements.\n * @private\n */\n\n\nclass PdfArc extends PdfEllipsePart {\n  /* tslint:disable-next-line:max-line-length */\n  constructor(arg1, arg2, arg3, arg4, arg5, arg6, arg7) {\n    if (typeof arg1 === 'undefined') {\n      super();\n    } else if (arg1 instanceof RectangleF) {\n      super(arg1, arg2, arg3);\n    } else if (arg1 instanceof PdfPen) {\n      if (arg2 instanceof RectangleF) {\n        super(arg1, null, arg2, arg3, arg4);\n      } else if (typeof arg6 === 'undefined' && typeof arg7 === 'undefined') {\n        super(arg1, null, 0, 0, arg2, arg3, arg4, arg5);\n      } else if (typeof arg6 !== 'undefined' && typeof arg7 !== 'undefined') {\n        super(arg1, null, arg2, arg3, arg4, arg5, arg6, arg7);\n      }\n    } else if (typeof arg1 !== 'undefined' && typeof arg5 === 'undefined' && typeof arg6 === 'undefined') {\n      super(0, 0, arg1, arg2, arg3, arg4);\n    } else if (typeof arg1 !== 'undefined' && typeof arg5 !== 'undefined' && typeof arg6 !== 'undefined') {\n      super(arg1, arg2, arg3, arg4, arg5, arg6);\n    }\n  }\n\n  draw(argu1, arg2, arg3, arg4) {\n    if (arg2 instanceof PointF && typeof arg2.width === 'undefined' && typeof arg3 === 'undefined') {\n      return this.drawHelper(argu1, arg2.x, arg2.y);\n    } else if (arg2 instanceof RectangleF && typeof arg2.width !== 'undefined' && typeof arg3 === 'undefined') {\n      return this.drawHelper(argu1, arg2, null);\n    } else if (typeof arg2 === 'number' && typeof arg3 === 'number' && typeof arg4 === 'undefined') {\n      return this.drawHelper(argu1, arg2, arg3, null);\n    } else if (arg2 instanceof PointF && arg3 instanceof PdfLayoutFormat) {\n      return this.drawHelper(argu1, arg2.x, arg2.y, arg3);\n    } else if (typeof arg2 === 'number' && (arg4 instanceof PdfLayoutFormat || arg4 == null) && typeof arg3 === 'number') {\n      let widthValue = argu1.graphics.clientSize.width - arg2;\n      let layoutRect = new RectangleF(arg2, arg3, widthValue, 0);\n      return this.drawHelper(argu1, layoutRect, arg4);\n    } else {\n      return this.drawHelper(argu1, arg2, arg3);\n    }\n  } // Implementation\n\n  /**\n   * `drawInternal` Draws an element on the Graphics.\n   * @param graphics Graphics context where the element should be printed.\n   *\n   */\n\n\n  drawInternal(graphics) {\n    if (graphics == null) {\n      throw new Error('ArgumentNullException : graphics');\n    }\n\n    graphics.drawArc(this.obtainPen(), this.bounds, this.startAngle, this.sweepAngle);\n  }\n\n}\n/**\n * PdfTrueTypeFont.ts class for EJ2-PDF\n */\n//https://www.giftofspeed.com/base64-encoder/\n\n\nclass PdfTrueTypeFont extends PdfFont {\n  constructor(base64String, size, style) {\n    super(size);\n    /**\n     * Indicates whether the font is embedded or not.\n     * @private\n     */\n\n    this.isEmbedFont = false;\n    /**\n     * Indicates whether the font is unicoded or not.\n     * @private\n     */\n\n    this.isUnicode = true;\n\n    if (style !== undefined) {\n      this.createFontInternal(base64String, style);\n    } else {\n      this.createFontInternal(base64String, PdfFontStyle.Regular);\n    }\n  }\n\n  equalsToFont(font) {\n    let result = false; //let result : boolean = this.fontInternal.equalsToFont(font);\n\n    return result;\n  }\n\n  getLineWidth(line, format) {\n    let width = 0;\n\n    if (format !== null && typeof format !== 'undefined' && format.textDirection !== PdfTextDirection.None) {\n      let returnValue = this.getUnicodeLineWidth(line,\n      /*out*/\n      width, format);\n      width = returnValue.width;\n    } else {\n      width = this.fontInternal.getLineWidth(line);\n    }\n\n    let size = this.metrics.getSize(format);\n    width *= PdfFont.charSizeMultiplier * size;\n    width = this.applyFormatSettings(line, format, width);\n    return width;\n  }\n  /**\n   * Returns width of the char.\n   */\n\n\n  getCharWidth(charCode, format) {\n    let codeWidth = this.fontInternal.getCharWidth(charCode);\n    let size = this.metrics.getSize(format);\n    codeWidth *= 0.001 * size;\n    return codeWidth;\n  } //Implementation\n\n\n  createFontInternal(base64String, style) {\n    this.fontInternal = new UnicodeTrueTypeFont(base64String, this.size);\n    this.calculateStyle(style);\n    this.initializeInternals();\n  }\n\n  calculateStyle(style) {\n    let iStyle = this.fontInternal.ttfMetrics.macStyle;\n\n    if ((style & PdfFontStyle.Underline) !== 0) {\n      iStyle |= PdfFontStyle.Underline;\n    }\n\n    if ((style & PdfFontStyle.Strikeout) !== 0) {\n      iStyle |= PdfFontStyle.Strikeout;\n    }\n\n    this.setStyle(iStyle);\n  }\n\n  initializeInternals() {\n    let equalFont = null;\n\n    if (PdfDocument.enableCache) {\n      // Search for the similar fonts.\n      equalFont = PdfDocument.cache.search(this);\n    }\n\n    let internals = null; // There is not equal font in the cache.\n\n    if (equalFont !== null && equalFont !== undefined) {\n      // Get the settings from the cached font.\n      internals = equalFont.getInternals();\n      let metrics = equalFont.metrics;\n      metrics = metrics.clone();\n      metrics.size = this.size;\n      this.metrics = metrics;\n      this.fontInternal = equalFont.fontInternal;\n    } else {\n      if (equalFont == null) {\n        if (this.fontInternal instanceof UnicodeTrueTypeFont) {\n          this.fontInternal.isEmbed = this.isEmbedFont;\n        }\n\n        this.fontInternal.createInternals();\n        internals = this.fontInternal.getInternals();\n        this.metrics = this.fontInternal.metrics;\n      }\n    }\n\n    this.metrics.isUnicodeFont = true;\n    this.setInternals(internals); //this.ttfReader = (this.fontInternal as UnicodeTrueTypeFont).ttfReader;\n  }\n  /**\n   * Stores used symbols.\n   */\n\n\n  setSymbols(text) {\n    let internalFont = this.fontInternal;\n\n    if (internalFont != null) {\n      internalFont.setSymbols(text);\n    }\n  }\n  /**\n   * Property\n   *\n   */\n\n\n  get Unicode() {\n    return this.isUnicode;\n  } // public get Font() : UnicodeTrueTypeFont {\n  //     return this.fontInternal as UnicodeTrueTypeFont;\n  // }\n\n\n  getUnicodeLineWidth(line,\n  /*out*/\n  width, format) {\n    // if (line == null) {\n    //     throw new Error('ArgumentNullException : line');\n    // }\n    width = 0;\n    let glyphIndices = null;\n    let rtlRender = new RtlRenderer();\n    /* tslint:disable-next-line:max-line-length */\n\n    let result = rtlRender.getGlyphIndex(line, this, format.textDirection === PdfTextDirection.RightToLeft ? true : false,\n    /*out*/\n    glyphIndices, true);\n    let resultGlyph = result.success;\n    glyphIndices = result.glyphs;\n\n    if (resultGlyph && glyphIndices !== null) {\n      let ttfReader = this.fontInternal.ttfReader;\n\n      for (let i = 0, len = glyphIndices.length; i < len; i++) {\n        let glyphIndex = glyphIndices[i];\n        let glyph = ttfReader.getGlyph(glyphIndex);\n\n        if (glyph !== null && typeof glyph !== 'undefined') {\n          width += glyph.width;\n        }\n      }\n    }\n\n    return {\n      success: resultGlyph,\n      width: width\n    };\n  }\n\n}\n/**\n * PdfPageTemplateElement.ts class for EJ2-Pdf\n */\n\n/**\n * Describes a `page template` object that can be used as header/footer, watermark or stamp.\n */\n\n\nclass PdfPageTemplateElement {\n  // Properties\n\n  /**\n   * Gets or sets the `dock style` of the page template element.\n   * @private\n   */\n  get dock() {\n    return this.dockStyle;\n  }\n\n  set dock(value) {\n    // if (this.dockStyle !== value && this.Type === TemplateType.None) {\n    this.dockStyle = value; // Reset alignment.\n\n    this.resetAlignment(); // }\n  }\n  /**\n   * Gets or sets `alignment` of the page template element.\n   * @private\n   */\n\n\n  get alignment() {\n    return this.alignmentStyle;\n  }\n\n  set alignment(value) {\n    // if (this.alignmentStyle !== value) {\n    this.setAlignment(value); // }\n  }\n  /**\n   * Indicates whether the page template is located `in front of the page layers or behind of it`.\n   * @private\n   */\n\n\n  get foreground() {\n    return this.isForeground;\n  }\n\n  set foreground(value) {\n    // if (this.foreground !== value) {\n    this.isForeground = value; // }\n  }\n  /**\n   * Indicates whether the page template is located `behind of the page layers or in front of it`.\n   * @private\n   */\n\n\n  get background() {\n    return !this.isForeground;\n  }\n\n  set background(value) {\n    this.isForeground = !value;\n  }\n  /**\n   * Gets or sets `location` of the page template element.\n   * @private\n   */\n\n\n  get location() {\n    return this.currentLocation;\n  }\n\n  set location(value) {\n    if (this.type === TemplateType.None) {\n      this.currentLocation = value;\n    } else {//\n    }\n  }\n  /**\n   * Gets or sets `X` co-ordinate of the template element on the page.\n   * @private\n   */\n\n\n  get x() {\n    let value = typeof this.currentLocation !== 'undefined' ? this.currentLocation.x : 0;\n    return value;\n  }\n\n  set x(value) {\n    if (this.type === TemplateType.None) {\n      this.currentLocation.x = value;\n    } else {//\n    }\n  }\n  /**\n   * Gets or sets `Y` co-ordinate of the template element on the page.\n   * @private\n   */\n\n\n  get y() {\n    let value = typeof this.currentLocation !== 'undefined' ? this.currentLocation.y : 0;\n    return value;\n  }\n\n  set y(value) {\n    if (this.type === TemplateType.None) {\n      this.currentLocation.y = value;\n    } else {//\n    }\n  }\n  /**\n   * Gets or sets `size` of the page template element.\n   * @private\n   */\n\n\n  get size() {\n    return this.template.size;\n  }\n\n  set size(value) {\n    if (this.type === TemplateType.None) {\n      this.template.reset(value);\n    }\n  }\n  /**\n   * Gets or sets `width` of the page template element.\n   * @private\n   */\n\n\n  get width() {\n    return this.template.width;\n  }\n\n  set width(value) {\n    if (this.template.width !== value && this.type === TemplateType.None) {\n      let size = this.template.size;\n      size.width = value;\n      this.template.reset(size);\n    }\n  }\n  /**\n   * Gets or sets `height` of the page template element.\n   * @private\n   */\n\n\n  get height() {\n    return this.template.height;\n  }\n\n  set height(value) {\n    if (this.template.height !== value && this.type === TemplateType.None) {\n      let size = this.template.size;\n      size.height = value;\n      this.template.reset(size);\n    }\n  }\n  /**\n   * Gets `graphics` context of the page template element.\n   * @private\n   */\n\n\n  get graphics() {\n    return this.template.graphics;\n  }\n  /**\n   * Gets Pdf `template` object.\n   * @private\n   */\n\n\n  get template() {\n    // if (typeof this.pdfTemplate === 'undefined' || this.pdfTemplate == null) {\n    //     this.pdfTemplate = new PdfTemplate(this.size);\n    // }\n    return this.pdfTemplate;\n  }\n  /**\n   * Gets or sets `type` of the usage of this page template.\n   * @private\n   */\n\n\n  get type() {\n    return this.templateType;\n  }\n\n  set type(value) {\n    this.updateDocking(value);\n    this.templateType = value;\n  }\n  /**\n   * Gets or sets `bounds` of the page template.\n   * @public\n   */\n\n\n  get bounds() {\n    return new RectangleF(new PointF(this.x, this.y), this.size);\n  }\n\n  set bounds(value) {\n    if (this.type === TemplateType.None) {\n      this.location = new PointF(value.x, value.y);\n      this.size = new SizeF(value.width, value.height);\n    }\n  }\n  /* tslint:disable */\n\n\n  constructor(arg1, arg2, arg3, arg4, arg5) {\n    if (arg1 instanceof RectangleF && typeof arg2 === 'undefined') {\n      this.InitiateBounds(arg1.x, arg1.y, arg1.width, arg1.height, null);\n    } else if (arg1 instanceof RectangleF && arg2 instanceof PdfPage && typeof arg3 === 'undefined') {\n      this.InitiateBounds(arg1.x, arg1.y, arg1.width, arg1.height, arg2);\n    } else if (arg1 instanceof PointF && arg2 instanceof SizeF && typeof arg3 === 'undefined') {\n      this.InitiateBounds(arg1.x, arg1.y, arg2.width, arg2.height, null);\n    } else if (arg1 instanceof PointF && arg2 instanceof SizeF && arg3 instanceof PdfPage && typeof arg4 === 'undefined') {\n      this.InitiateBounds(arg1.x, arg1.y, arg2.width, arg2.height, arg3);\n    } else if (arg1 instanceof SizeF && typeof arg2 === 'undefined') {\n      this.InitiateBounds(0, 0, arg1.width, arg1.height, null);\n    } else if (typeof arg1 === 'number' && typeof arg2 === 'number' && typeof arg3 === 'undefined') {\n      this.InitiateBounds(0, 0, arg1, arg2, null);\n    } else if (typeof arg1 === 'number' && typeof arg2 === 'number' && arg3 instanceof PdfPage && typeof arg4 === 'undefined') {\n      this.InitiateBounds(0, 0, arg1, arg2, arg3);\n    } else if (typeof arg1 === 'number' && typeof arg2 === 'number' && typeof arg3 === 'number' && typeof arg4 === 'number' && typeof arg5 === 'undefined') {\n      this.InitiateBounds(arg1, arg2, arg3, arg4, null);\n    } else {\n      this.InitiateBounds(arg1, arg2, arg3, arg4, null); // this.graphics.colorSpace = this.page.document.colorSpace;\n    }\n    /* tslint:enable */\n\n  }\n  /**\n   * `Initialize Bounds` Initialize the bounds value of the template.\n   * @private\n   */\n\n\n  InitiateBounds(arg1, arg2, arg3, arg4, arg5) {\n    this.x = arg1;\n    this.y = arg2;\n    this.pdfTemplate = new PdfTemplate(arg3, arg4); // this.graphics.colorSpace = this.page.document.colorSpace;\n  }\n  /**\n   * `Updates Dock` property if template is used as header/footer.\n   * @private\n   */\n\n\n  updateDocking(type) {\n    if (type !== TemplateType.None) {\n      switch (type) {\n        case TemplateType.Top:\n          this.dock = PdfDockStyle.Top;\n          break;\n\n        case TemplateType.Bottom:\n          this.dock = PdfDockStyle.Bottom;\n          break;\n\n        case TemplateType.Left:\n          this.dock = PdfDockStyle.Left;\n          break;\n\n        case TemplateType.Right:\n          this.dock = PdfDockStyle.Right;\n          break;\n      }\n\n      this.resetAlignment();\n    }\n  }\n  /**\n   * `Resets alignment` of the template.\n   * @private\n   */\n\n\n  resetAlignment() {\n    this.alignment = PdfAlignmentStyle.None;\n  }\n  /**\n   * `Sets alignment` of the template.\n   * @private\n   */\n\n\n  setAlignment(alignment) {\n    if (this.dock === PdfDockStyle.None) {\n      this.alignmentStyle = alignment;\n    } else {\n      // Template is docked and alignment has been changed.\n      let canBeSet = false;\n\n      switch (this.dock) {\n        case PdfDockStyle.Left:\n          canBeSet = alignment === PdfAlignmentStyle.TopLeft || alignment === PdfAlignmentStyle.MiddleLeft || alignment === PdfAlignmentStyle.BottomLeft || alignment === PdfAlignmentStyle.None;\n          break;\n\n        case PdfDockStyle.Top:\n          canBeSet = alignment === PdfAlignmentStyle.TopLeft || alignment === PdfAlignmentStyle.TopCenter || alignment === PdfAlignmentStyle.TopRight || alignment === PdfAlignmentStyle.None;\n          break;\n\n        case PdfDockStyle.Right:\n          canBeSet = alignment === PdfAlignmentStyle.TopRight || alignment === PdfAlignmentStyle.MiddleRight || alignment === PdfAlignmentStyle.BottomRight || alignment === PdfAlignmentStyle.None;\n          break;\n\n        case PdfDockStyle.Bottom:\n          canBeSet = alignment === PdfAlignmentStyle.BottomLeft || alignment === PdfAlignmentStyle.BottomCenter || alignment === PdfAlignmentStyle.BottomRight || alignment === PdfAlignmentStyle.None;\n          break;\n\n        case PdfDockStyle.Fill:\n          canBeSet = alignment === PdfAlignmentStyle.MiddleCenter || alignment === PdfAlignmentStyle.None;\n          break;\n      }\n\n      if (canBeSet) {\n        this.alignmentStyle = alignment;\n      }\n    }\n  }\n  /**\n   * Draws the template.\n   * @private\n   */\n\n\n  draw(layer, document) {\n    let page = layer.page;\n    let bounds = this.calculateBounds(page, document);\n\n    if (bounds.x === -0) {\n      bounds.x = 0;\n    }\n\n    layer.graphics.drawPdfTemplate(this.template, new PointF(bounds.x, bounds.y), new SizeF(bounds.width, bounds.height));\n  }\n  /**\n   * Calculates bounds of the page template.\n   * @private\n   */\n\n\n  calculateBounds(page, document) {\n    let result = this.bounds;\n\n    if (this.alignmentStyle !== PdfAlignmentStyle.None) {\n      result = this.getAlignmentBounds(page, document);\n    } else if (this.dockStyle !== PdfDockStyle.None) {\n      result = this.getDockBounds(page, document);\n    }\n\n    return result;\n  }\n  /**\n   * Calculates bounds according to the alignment.\n   * @private\n   */\n\n\n  getAlignmentBounds(page, document) {\n    let result = this.bounds;\n\n    if (this.type === TemplateType.None) {\n      result = this.getSimpleAlignmentBounds(page, document);\n    } else {\n      result = this.getTemplateAlignmentBounds(page, document);\n    }\n\n    return result;\n  }\n  /**\n   * Calculates bounds according to the alignment.\n   * @private\n   */\n\n\n  getSimpleAlignmentBounds(page, document) {\n    let bounds = this.bounds;\n    let pdfSection = page.section;\n    let actualBounds = pdfSection.getActualBounds(document, page, false);\n    let x = this.x;\n    let y = this.y;\n\n    switch (this.alignmentStyle) {\n      case PdfAlignmentStyle.TopLeft:\n        x = 0;\n        y = 0;\n        break;\n\n      case PdfAlignmentStyle.TopCenter:\n        x = (actualBounds.width - this.width) / 2;\n        y = 0;\n        break;\n\n      case PdfAlignmentStyle.TopRight:\n        x = actualBounds.width - this.width;\n        y = 0;\n        break;\n\n      case PdfAlignmentStyle.MiddleLeft:\n        x = 0;\n        y = (actualBounds.height - this.height) / 2;\n        break;\n\n      case PdfAlignmentStyle.MiddleCenter:\n        x = (actualBounds.width - this.width) / 2;\n        y = (actualBounds.height - this.height) / 2;\n        break;\n\n      case PdfAlignmentStyle.MiddleRight:\n        x = actualBounds.width - this.width;\n        y = (actualBounds.height - this.height) / 2;\n        break;\n\n      case PdfAlignmentStyle.BottomLeft:\n        x = 0;\n        y = actualBounds.height - this.height;\n        break;\n\n      case PdfAlignmentStyle.BottomCenter:\n        x = (actualBounds.width - this.width) / 2;\n        y = actualBounds.height - this.height;\n        break;\n\n      case PdfAlignmentStyle.BottomRight:\n        x = actualBounds.width - this.width;\n        y = actualBounds.height - this.height;\n        break;\n    }\n\n    bounds.x = x;\n    bounds.y = y;\n    return bounds;\n  }\n  /**\n   * Calculates bounds according to the alignment.\n   * @private\n   */\n\n\n  getTemplateAlignmentBounds(page, document) {\n    let result = this.bounds;\n    let section = page.section;\n    let actualBounds = section.getActualBounds(document, page, false);\n    let x = this.x;\n    let y = this.y;\n\n    switch (this.alignmentStyle) {\n      case PdfAlignmentStyle.TopLeft:\n        if (this.type === TemplateType.Left) {\n          x = -actualBounds.x;\n          y = 0;\n        } else if (this.type === TemplateType.Top) {\n          x = -actualBounds.x;\n          y = -actualBounds.y;\n        }\n\n        break;\n\n      case PdfAlignmentStyle.TopCenter:\n        x = (actualBounds.width - this.width) / 2;\n        y = -actualBounds.y;\n        break;\n\n      case PdfAlignmentStyle.TopRight:\n        if (this.type === TemplateType.Right) {\n          x = actualBounds.width + section.getRightIndentWidth(document, page, false) - this.width;\n          y = 0;\n        } else if (this.type === TemplateType.Top) {\n          x = actualBounds.width + section.getRightIndentWidth(document, page, false) - this.width;\n          y = -actualBounds.y;\n        }\n\n        break;\n\n      case PdfAlignmentStyle.MiddleLeft:\n        x = -actualBounds.x;\n        y = (actualBounds.height - this.height) / 2;\n        break;\n\n      case PdfAlignmentStyle.MiddleCenter:\n        x = (actualBounds.width - this.width) / 2;\n        y = (actualBounds.height - this.height) / 2;\n        break;\n\n      case PdfAlignmentStyle.MiddleRight:\n        x = actualBounds.width + section.getRightIndentWidth(document, page, false) - this.width;\n        y = (actualBounds.height - this.height) / 2;\n        break;\n\n      case PdfAlignmentStyle.BottomLeft:\n        if (this.type === TemplateType.Left) {\n          x = -actualBounds.x;\n          y = actualBounds.height - this.height;\n        } else if (this.type === TemplateType.Bottom) {\n          x = -actualBounds.x;\n          y = actualBounds.height + section.getBottomIndentHeight(document, page, false) - this.height;\n        }\n\n        break;\n\n      case PdfAlignmentStyle.BottomCenter:\n        x = (actualBounds.width - this.width) / 2;\n        y = actualBounds.height + section.getBottomIndentHeight(document, page, false) - this.height;\n        break;\n\n      case PdfAlignmentStyle.BottomRight:\n        if (this.type === TemplateType.Right) {\n          x = actualBounds.width + section.getRightIndentWidth(document, page, false) - this.width;\n          y = actualBounds.height - this.height;\n        } else if (this.type === TemplateType.Bottom) {\n          x = actualBounds.width + section.getRightIndentWidth(document, page, false) - this.width;\n          y = actualBounds.height + section.getBottomIndentHeight(document, page, false) - this.height;\n        }\n\n        break;\n    }\n\n    result.x = x;\n    result.y = y;\n    return result;\n  }\n  /**\n   * Calculates bounds according to the docking.\n   * @private\n   */\n\n\n  getDockBounds(page, document) {\n    let result = this.bounds;\n\n    if (this.type === TemplateType.None) {\n      result = this.getSimpleDockBounds(page, document);\n    } else {\n      result = this.getTemplateDockBounds(page, document);\n    }\n\n    return result;\n  }\n  /**\n   * Calculates bounds according to the docking.\n   * @private\n   */\n\n\n  getSimpleDockBounds(page, document) {\n    let result = this.bounds;\n    let section = page.section;\n    let actualBounds = section.getActualBounds(document, page, false);\n    let x = this.x;\n    let y = this.y;\n    let width = this.width;\n    let height = this.height;\n\n    switch (this.dockStyle) {\n      case PdfDockStyle.Left:\n        x = 0;\n        y = 0;\n        width = this.width;\n        height = actualBounds.height;\n        break;\n\n      case PdfDockStyle.Top:\n        x = 0;\n        y = 0;\n        width = actualBounds.width;\n        height = this.height;\n        break;\n\n      case PdfDockStyle.Right:\n        x = actualBounds.width - this.width;\n        y = 0;\n        width = this.width;\n        height = actualBounds.height;\n        break;\n\n      case PdfDockStyle.Bottom:\n        x = 0;\n        y = actualBounds.height - this.height;\n        width = actualBounds.width;\n        height = this.height;\n        break;\n\n      case PdfDockStyle.Fill:\n        x = 0;\n        x = 0;\n        width = actualBounds.width;\n        height = actualBounds.height;\n        break;\n    }\n\n    result = new RectangleF(x, y, width, height);\n    return result;\n  }\n  /**\n   * Calculates template bounds basing on docking if template is a page template.\n   * @private\n   */\n\n\n  getTemplateDockBounds(page, document) {\n    let result = this.bounds;\n    let section = page.section;\n    let actualBounds = section.getActualBounds(document, page, false);\n    let actualSize = section.pageSettings.getActualSize();\n    let x = this.x;\n    let y = this.y;\n    let width = this.width;\n    let height = this.height;\n\n    switch (this.dockStyle) {\n      case PdfDockStyle.Left:\n        x = -actualBounds.x;\n        y = 0;\n        width = this.width;\n        height = actualBounds.height;\n        break;\n\n      case PdfDockStyle.Top:\n        x = -actualBounds.x;\n        y = -actualBounds.y;\n        width = actualSize.width;\n        height = this.height;\n\n        if (actualBounds.height < 0) {\n          y = -actualBounds.y + actualSize.height;\n        }\n\n        break;\n\n      case PdfDockStyle.Right:\n        x = actualBounds.width + section.getRightIndentWidth(document, page, false) - this.width;\n        y = 0;\n        width = this.width;\n        height = actualBounds.height;\n        break;\n\n      case PdfDockStyle.Bottom:\n        x = -actualBounds.x;\n        y = actualBounds.height + section.getBottomIndentHeight(document, page, false) - this.height;\n        width = actualSize.width;\n        height = this.height;\n\n        if (actualBounds.height < 0) {\n          y -= actualSize.height;\n        }\n\n        break;\n\n      case PdfDockStyle.Fill:\n        x = 0;\n        x = 0;\n        width = actualBounds.width;\n        height = actualBounds.height;\n        break;\n    }\n\n    result = new RectangleF(x, y, width, height);\n    return result;\n  }\n\n}\n/**\n * Pdf all modules\n * @hidden\n */\n\n\nexport { PdfAction, PdfUriAction, PdfActionLinkAnnotation, PdfAnnotation, PdfAnnotationCollection, PdfDocumentLinkAnnotation, PdfLinkAnnotation, PdfTextWebLink, PdfUriAnnotation, Dictionary, defaultToString, PdfCatalog, PdfDocument, PdfDocumentBase, PdfDocumentTemplate, PdfPageNumberField, PdfCompositeField, PdfPageCountField, PointF, SizeF, RectangleF, Rectangle, PdfCacheCollection, PdfCollection, PdfDestination, PdfFunction, PdfSampledFunction, PdfDestinationMode, ProcedureSets, PdfHorizontalAlignment, PdfVerticalAlignment, PdfTextAlignment, TextRenderingMode, PdfLineJoin, PdfLineCap, PdfDashStyle, PdfFillMode, PdfColorSpace, PdfBlendMode, PdfGraphicsUnit, PdfGridImagePosition, PdfTextDirection, PdfColor, PdfGraphics, GetResourceEventHandler, PdfGraphicsState, PdfMargins, PdfPen, PdfResources, Guid, PdfTransformationMatrix, Matrix, PdfBrush, PdfBrushes, PdfSolidBrush, PdfLinearGradientBrush, PdfRadialGradientBrush, PdfTilingBrush, PdfGradientBrush, PdfColorBlend, PdfBlend, PdfTemplate, PdfLayoutElement, PdfPath, PdfArc, PdfTextElement, ElementLayouter, PdfLayoutFormat, PdfLayoutParams, PdfLayoutResult, TextLayouter, TextPageLayoutResult, PdfTextLayoutResult, PdfLayoutType, PdfLayoutBreakType, PathPointType, PdfFontStyle, PdfFontFamily, PdfFontType, PdfWordWrapType, PdfSubSuperScript, FontEncoding, TtfCmapFormat, TtfCmapEncoding, TtfPlatformID, TtfMicrosoftEncodingID, TtfMacintoshEncodingID, FontDescriptorFlags, TtfCompositeGlyphFlags, PdfFont, PdfFontMetrics, WidthTable, StandardWidthTable, PdfStandardFont, PdfStandardFontMetricsFactory, PdfStringFormat, PdfStringLayouter, PdfStringLayoutResult, LineInfo, LineType, StringTokenizer, PdfTrueTypeFont, RtlRenderer, ArabicShapeRenderer, ArabicShape, Bidi, RtlCharacters, ByteArray, ImageFormat, ImageDecoder, PdfBitmap, PdfImage, PdfTransparency, ObjectStatus, ObjectType, PdfCrossTable, RegisteredObject, DictionaryProperties, PdfMainObjectCollection, ObjectInfo, Operators, PdfStreamWriter, PdfWriter, PdfPageOrientation, PdfPageRotateAngle, PdfNumberStyle, PdfDockStyle, PdfAlignmentStyle, TemplateType, PageAddedEventArgs, PdfDocumentPageCollection, PdfPage, PdfPageBase, PdfPageLayer, PdfPageLayerCollection, PdfPageSettings, PdfPageSize, PdfPageTemplateElement, PdfSection, PageSettingsState, PdfSectionCollection, PdfSectionPageCollection, PdfSectionTemplate, PdfArray, PdfDictionary, SaveSectionCollectionEventHandler, SaveDescendantFontEventHandler, SaveFontDictionaryEventHandler, SaveAnnotationEventHandler, SaveSectionEventHandler, SaveTemplateEventHandler, PdfName, PdfNumber, PdfReference, PdfReferenceHolder, PdfStream, SaveCmapEventHandler, SaveFontProgramEventHandler, InternalEnum, PdfString, PdfGridStyleBase, PdfGridStyle, PdfGridCellStyle, PdfGridRowStyle, PdfHorizontalOverflowType, PdfBorders, PdfPaddings, PdfBorderOverlapStyle, PdfGridLayouter, PdfGridLayoutResult, PdfGridLayoutFormat, GridCellEventArgs, PdfGridBeginCellDrawEventArgs, PdfGridEndCellDrawEventArgs, PdfCancelEventArgs, BeginPageLayoutEventArgs, EndPageLayoutEventArgs, PdfGridBeginPageLayoutEventArgs, PdfGridEndPageLayoutEventArgs, RowLayoutResult, PdfGrid, PdfGridColumn, PdfGridColumnCollection, PdfGridRow, PdfGridRowCollection, PdfGridHeaderCollection, PdfGridCell, PdfGridCellCollection }; //# sourceMappingURL=ej2-pdf-export.es2015.js.map","map":null,"metadata":{},"sourceType":"module"}