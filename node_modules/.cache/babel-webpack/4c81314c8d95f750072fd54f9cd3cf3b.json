{"ast":null,"code":"import { Browser, ChildProperty, Collection, Complex, Component, Draggable, Droppable, Event, EventHandler, Internationalization, KeyboardEvents, L10n, NotifyPropertyChanges, Property, addClass, append, attributes, blazorTemplates, classList, closest, compile, createElement, debounce, detach, extend, formatUnit, getEnumValue, getValue, isNullOrUndefined, isObject, isUndefined, matches, merge, print, remove, removeClass, resetBlazorTemplate, select, selectAll, setCulture, setStyleAttribute, setValue, updateBlazorTemplate } from '@syncfusion/ej2-base';\nimport { DataManager, DataUtil, Deferred, Predicate, Query, UrlAdaptor } from '@syncfusion/ej2-data';\nimport { Dialog, Tooltip, calculatePosition, calculateRelativeBasedPosition, createSpinner, hideSpinner, showSpinner } from '@syncfusion/ej2-popups';\nimport { Button, CheckBox, RadioButton, Switch, createCheckBox } from '@syncfusion/ej2-buttons';\nimport { FormValidator, Input, MaskedTextBox, NumericTextBox, TextBox } from '@syncfusion/ej2-inputs';\nimport { AutoComplete, ComboBox, DropDownList, MultiSelect } from '@syncfusion/ej2-dropdowns';\nimport { DatePicker, DateTimePicker, TimePicker } from '@syncfusion/ej2-calendars';\nimport { ContextMenu, Toolbar } from '@syncfusion/ej2-navigations';\nimport { Workbook } from '@syncfusion/ej2-excel-export';\nimport { PdfBitmap, PdfBorders, PdfColor, PdfCompositeField, PdfDocument, PdfFontFamily, PdfFontStyle, PdfGrid, PdfPaddings, PdfPageCountField, PdfPageNumberField, PdfPageOrientation, PdfPageSettings, PdfPageTemplateElement, PdfPen, PdfSolidBrush, PdfStandardFont, PdfStringFormat, PdfTextAlignment, PdfTextWebLink, PdfTrueTypeFont, PdfVerticalAlignment, PointF, RectangleF, SizeF } from '@syncfusion/ej2-pdf-export';\n/**\n * ValueFormatter class to globalize the value.\n *\n * @hidden\n */\n\nclass ValueFormatter {\n  constructor(cultureName) {\n    this.intl = new Internationalization();\n\n    if (!isNullOrUndefined(cultureName)) {\n      this.intl.culture = cultureName;\n    }\n  }\n\n  getFormatFunction(format) {\n    if (format.type) {\n      return this.intl.getDateFormat(format);\n    } else {\n      return this.intl.getNumberFormat(format);\n    }\n  }\n\n  getParserFunction(format) {\n    if (format.type) {\n      return this.intl.getDateParser(format);\n    } else {\n      return this.intl.getNumberParser(format);\n    }\n  }\n\n  fromView(value, format, type) {\n    if ((type === 'date' || type === 'datetime' || type === 'number') && !isNullOrUndefined(format)) {\n      return format(value);\n    } else {\n      return value;\n    }\n  }\n\n  toView(value, format) {\n    let result = value;\n\n    if (!isNullOrUndefined(format) && !isNullOrUndefined(value)) {\n      result = format(value);\n    }\n\n    return result;\n  }\n\n  setCulture(cultureName) {\n    if (!isNullOrUndefined(cultureName)) {\n      setCulture(cultureName);\n    }\n  }\n\n}\n\nvar __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n/**\n * Represents Grid `Column` model class.\n */\n\n\nclass Column {\n  constructor(options, parent) {\n    /**\n     * If `disableHtmlEncode` is set to true, it encodes the HTML of the header and content cells.\n     *\n     * @default true\n     */\n    this.disableHtmlEncode = true;\n    /**\n     * If `allowSorting` set to false, then it disables sorting option of a particular column.\n     * By default all columns are sortable.\n     *\n     * @default true\n     */\n\n    this.allowSorting = true;\n    /**\n     * If `allowResizing` is set to false, it disables resize option of a particular column.\n     * By default all the columns can be resized.\n     *\n     * @default true\n     */\n\n    this.allowResizing = true;\n    /**\n     * If `allowFiltering` set to false, then it disables filtering option and filter bar element of a particular column.\n     * By default all columns are filterable.\n     *\n     * @default true\n     */\n\n    this.allowFiltering = true;\n    /**\n     * If `allowGrouping` set to false, then it disables grouping of a particular column.\n     * By default all columns are groupable.\n     *\n     * @default true\n     */\n\n    this.allowGrouping = true;\n    /**\n     * If `allowReordering` set to false, then it disables reorder of a particular column.\n     * By default all columns can be reorder.\n     *\n     * @default true\n     */\n\n    this.allowReordering = true;\n    /**\n     * If `showColumnMenu` set to false, then it disable the column menu of a particular column.\n     * By default column menu will show for all columns\n     *\n     * @default true\n     */\n\n    this.showColumnMenu = true;\n    /**\n     * If `enableGroupByFormat` set to true, then it groups the particular column by formatted values.\n     *\n     * @default true\n     */\n\n    this.enableGroupByFormat = false;\n    /**\n     * If `allowEditing` set to false, then it disables editing of a particular column.\n     * By default all columns are editable.\n     *\n     * @default true\n     */\n\n    this.allowEditing = true;\n    /**\n     *  It is used to customize the default filter options for a specific columns.\n     * * type -  Specifies the filter type as menu or checkbox.\n     * * ui - to render custom component for specific column it has following functions.\n     * * ui.create â€“ It is used for creating custom components.\n     * * ui.read -  It is used for read the value from the component.\n     * * ui.write - It is used to apply component model as dynamically.\n     * {% codeBlock src=\"grid/filter-menu-api/index.ts\" %}{% endcodeBlock %}\n     *\n     * > Check the [`Filter UI`](../../grid/filtering/#custom-component-in-filter-menu) for its customization.\n     *\n     *  @default {}\n     */\n\n    this.filter = {};\n    /**\n     * If `showInColumnChooser` set to false, then hide the particular column in column chooser.\n     *  By default all columns are displayed in column Chooser.\n     *\n     * @default true\n     */\n\n    this.showInColumnChooser = true;\n    /**\n     * Defines the `IEditCell` object to customize default edit cell.\n     *\n     * @default {}\n     */\n\n    this.edit = {};\n    /**\n     * If `allowSearching` set to false, then it disables Searching of a particular column.\n     * By default all columns allow Searching.\n     *\n     * @default true\n     */\n\n    this.allowSearching = true;\n    /**\n     * If `autoFit` set to true, then the particular column content width will be\n     * adjusted based on its content in the initial rendering itself.\n     * Setting this property as true is equivalent to calling `autoFitColumns` method in the `dataBound` event.\n     *\n     * @default false\n     */\n\n    this.autoFit = false;\n    this.sortDirection = 'Descending';\n    /**\n     * @returns {Function} returns the edit template\n     * @hidden */\n\n    this.getEditTemplate = () => this.editTemplateFn;\n    /**\n     * @returns {Function} returns the filter template\n     * @hidden */\n\n\n    this.getFilterTemplate = () => this.filterTemplateFn;\n\n    merge(this, options);\n    this.parent = parent;\n\n    if (this.type === 'none') {\n      this.type = null;\n    } else if (this.type) {\n      this.type = typeof this.type === 'string' ? this.type.toLowerCase() : undefined;\n    }\n\n    if (this.editType) {\n      this.editType = this.editType.toLowerCase();\n    }\n\n    if (isNullOrUndefined(this.uid)) {\n      this.uid = getUid('grid-column');\n    }\n\n    const valueFormatter = new ValueFormatter();\n\n    if (options.format && (options.format.skeleton || options.format.format && typeof options.format.format === 'string')) {\n      this.setFormatter(valueFormatter.getFormatFunction(extend({}, options.format)));\n      this.setParser(valueFormatter.getParserFunction(options.format));\n    }\n\n    this.toJSON = () => {\n      const col = {};\n      const skip = ['filter', 'dataSource', 'headerText', 'template', 'headerTemplate', 'edit', 'editTemplate', 'filterTemplate', 'commandsTemplate', 'parent'];\n      const keys = Object.keys(this);\n\n      for (let i = 0; i < keys.length; i++) {\n        if (keys[i] === 'columns') {\n          col[keys[i]] = [];\n\n          for (let j = 0; j < this[keys[i]].length; j++) {\n            col[keys[i]].push(this[keys[i]][j].toJSON());\n          }\n        } else if (skip.indexOf(keys[i]) < 0) {\n          col[keys[i]] = this[keys[i]];\n        }\n      }\n\n      return col;\n    };\n\n    if (!this.field) {\n      this.allowFiltering = false;\n      this.allowGrouping = false;\n      this.allowSorting = false;\n\n      if (this.columns) {\n        this.allowResizing = this.columns.some(col => {\n          return col.allowResizing;\n        });\n      }\n    }\n\n    if (this.commands && !this.textAlign) {\n      this.textAlign = 'Right';\n    }\n\n    if (this.template || this.commandsTemplate) {\n      this.templateFn = templateCompiler(this.template || this.commandsTemplate);\n    }\n\n    if (this.headerTemplate) {\n      this.headerTemplateFn = templateCompiler(this.headerTemplate);\n    }\n\n    if (!isNullOrUndefined(this.filter) && this.filter.itemTemplate) {\n      this.fltrTemplateFn = templateCompiler(this.filter.itemTemplate);\n    }\n\n    if (this.editTemplate) {\n      this.editTemplateFn = templateCompiler(this.editTemplate);\n    }\n\n    if (this.filterTemplate) {\n      this.filterTemplateFn = templateCompiler(this.filterTemplate);\n    }\n\n    if (this.isForeignColumn() && (isNullOrUndefined(this.editType) || this.editType === 'dropdownedit' || this.editType === 'defaultedit')) {\n      this.editType = 'dropdownedit';\n      this.edit.params = extend({\n        dataSource: this.dataSource,\n        query: new Query(),\n        fields: {\n          value: this.foreignKeyField || this.field,\n          text: this.foreignKeyValue\n        }\n      }, this.edit.params);\n    }\n\n    if (this.sortComparer) {\n      let a = this.sortComparer;\n\n      this.sortComparer = function comparer(x, y, xObj, yObj) {\n        if (typeof a === 'string') {\n          a = getObject(a, window);\n        }\n\n        if (this.sortDirection === 'Descending') {\n          const z = x;\n          x = y;\n          y = z;\n          const obj = xObj;\n          xObj = yObj;\n          yObj = obj;\n        }\n\n        return a(x, y, xObj, yObj);\n      };\n    }\n\n    if (!this.sortComparer && this.isForeignColumn()) {\n      this.sortComparer = (x, y) => {\n        x = getObject(this.foreignKeyValue, getForeignData(this, {}, x)[0]);\n        y = getObject(this.foreignKeyValue, getForeignData(this, {}, y)[0]);\n        return this.sortDirection === 'Descending' ? DataUtil.fnDescending(x, y) : DataUtil.fnAscending(x, y);\n      };\n    }\n  }\n  /**\n   * @returns {string} returns the sort direction\n   * @hidden */\n\n\n  getSortDirection() {\n    return this.sortDirection;\n  }\n  /**\n   * @param {string} direction - specifies the direction\n   * @returns {void}\n   * @hidden\n   */\n\n\n  setSortDirection(direction) {\n    this.sortDirection = direction;\n  }\n  /**\n   * @returns {freezeTable} returns the FreezeTable\n   * @hidden */\n\n\n  getFreezeTableName() {\n    return this.freezeTable;\n  }\n  /**\n   * @param {Column} column - specifies the column\n   * @returns {void}\n   * @hidden\n   */\n\n\n  setProperties(column) {\n    //Angular two way binding\n    const keys = Object.keys(column);\n\n    for (let i = 0; i < keys.length; i++) {\n      this[keys[i]] = column[keys[i]]; //Refresh the react columnTemplates on state change\n\n      if (this.parent && this.parent.isReact) {\n        if (keys[i] === 'template') {\n          this.parent.refreshReactColumnTemplateByUid(this.uid);\n        } else if (keys[i] === 'headerTemplate') {\n          this.headerTemplateFn = templateCompiler(column[keys[i]]);\n          this.parent.refreshReactHeaderTemplateByUid(this.uid);\n        }\n      }\n    }\n  }\n  /**\n   * @returns {boolean} returns true for foreign column\n   * @hidden\n   * It defines the column is foreign key column or not.\n   */\n\n\n  isForeignColumn() {\n    return !!(this.dataSource && this.foreignKeyValue);\n  }\n  /**\n   * @returns {Function} returns the function\n   * @hidden\n   */\n\n\n  getFormatter() {\n    return this.formatFn;\n  }\n  /**\n   * @param {Function} value - specifies the value\n   * @returns {void}\n   * @hidden\n   */\n\n\n  setFormatter(value) {\n    this.formatFn = value;\n  }\n  /**\n   * @returns {Function} returns the function\n   * @hidden */\n\n\n  getParser() {\n    return this.parserFn;\n  }\n  /**\n   * @param {Function} value - specifies the value\n   * @returns {void}\n   * @hidden\n   */\n\n\n  setParser(value) {\n    this.parserFn = value;\n  }\n  /**\n   * @returns {Function} returns the function\n   * @hidden */\n\n\n  getColumnTemplate() {\n    return this.templateFn;\n  }\n  /**\n   * @returns {Function} returns the function\n   * @hidden */\n\n\n  getHeaderTemplate() {\n    return this.headerTemplateFn;\n  }\n  /**\n   * @returns {Function} returns the function\n   * @hidden */\n\n\n  getFilterItemTemplate() {\n    return this.fltrTemplateFn;\n  }\n  /**\n   * @returns {string} returns the string\n   * @hidden */\n\n\n  getDomSetter() {\n    return this.disableHtmlEncode ? 'textContent' : 'innerHTML';\n  }\n\n}\n/**\n * Define options for custom command buttons.\n */\n\n\nlet CommandColumnModel = /*#__PURE__*/(() => {\n  class CommandColumnModel {}\n\n  __decorate([Property()], CommandColumnModel.prototype, \"title\", void 0);\n\n  __decorate([Property()], CommandColumnModel.prototype, \"type\", void 0);\n\n  __decorate([Property()], CommandColumnModel.prototype, \"buttonOption\", void 0);\n  /**\n   * Defines Grid column\n   */\n\n\n  return CommandColumnModel;\n})();\nlet GridColumn = /*#__PURE__*/(() => {\n  class GridColumn extends Column {}\n\n  __decorate([Property(null)], GridColumn.prototype, \"columns\", void 0);\n  /**\n   * Defines stacked grid column\n   */\n\n\n  return GridColumn;\n})();\n\nclass StackedColumn extends GridColumn {}\n/** @hidden */\n\n\nconst created = 'create';\n/** @hidden */\n\nconst destroyed = 'destroy';\n/** @hidden */\n\nconst load = 'load';\n/** @hidden */\n\nconst rowDataBound = 'rowDataBound';\n/** @hidden */\n\nconst queryCellInfo = 'queryCellInfo';\n/** @hidden */\n\nconst headerCellInfo = 'headerCellInfo';\n/** @hidden */\n\nconst actionBegin = 'actionBegin';\n/** @hidden */\n\nconst actionComplete = 'actionComplete';\n/** @hidden */\n\nconst actionFailure = 'actionFailure';\n/** @hidden */\n\nconst dataBound = 'dataBound';\n/** @hidden */\n\nconst rowSelecting = 'rowSelecting';\n/** @hidden */\n\nconst rowSelected = 'rowSelected';\n/** @hidden */\n\nconst rowDeselecting = 'rowDeselecting';\n/** @hidden */\n\nconst rowDeselected = 'rowDeselected';\n/** @hidden */\n\nconst cellSelecting = 'cellSelecting';\n/** @hidden */\n\nconst cellSelected = 'cellSelected';\n/** @hidden */\n\nconst cellDeselecting = 'cellDeselecting';\n/** @hidden */\n\nconst cellDeselected = 'cellDeselected';\n/** @hidden */\n\nconst columnSelecting = 'columnSelecting';\n/** @hidden */\n\nconst columnSelected = 'columnSelected';\n/** @hidden */\n\nconst columnDeselecting = 'columnDeselecting';\n/** @hidden */\n\nconst columnDeselected = 'columnDeselected';\n/** @hidden */\n\nconst columnDragStart = 'columnDragStart';\n/** @hidden */\n\nconst columnDrag = 'columnDrag';\n/** @hidden */\n\nconst columnDrop = 'columnDrop';\n/** @hidden */\n\nconst rowDragStartHelper = 'rowDragStartHelper';\n/** @hidden */\n\nconst rowDragStart = 'rowDragStart';\n/** @hidden */\n\nconst rowDrag = 'rowDrag';\n/** @hidden */\n\nconst rowDrop = 'rowDrop';\n/** @hidden */\n\nconst beforePrint = 'beforePrint';\n/** @hidden */\n\nconst printComplete = 'printComplete';\n/** @hidden */\n\nconst detailDataBound = 'detailDataBound';\n/** @hidden */\n\nconst toolbarClick = 'toolbarClick';\n/** @hidden */\n\nconst batchAdd = 'batchAdd';\n/** @hidden */\n\nconst batchCancel = 'batchCancel';\n/** @hidden */\n\nconst batchDelete = 'batchDelete';\n/** @hidden */\n\nconst beforeBatchAdd = 'beforeBatchAdd';\n/** @hidden */\n\nconst beforeBatchDelete = 'beforeBatchDelete';\n/** @hidden */\n\nconst beforeBatchSave = 'beforeBatchSave';\n/** @hidden */\n\nconst beginEdit = 'beginEdit';\n/** @hidden */\n\nconst cellEdit = 'cellEdit';\n/** @hidden */\n\nconst cellSave = 'cellSave';\n/** @hidden */\n\nconst cellSaved = 'cellSaved';\n/** @hidden */\n\nconst endAdd = 'endAdd';\n/** @hidden */\n\nconst endDelete = 'endDelete';\n/** @hidden */\n\nconst endEdit = 'endEdit';\n/** @hidden */\n\nconst recordDoubleClick = 'recordDoubleClick';\n/** @hidden */\n\nconst recordClick = 'recordClick';\n/** @hidden */\n\nconst beforeDataBound = 'beforeDataBound';\n/** @hidden */\n\nconst beforeOpenColumnChooser = 'beforeOpenColumnChooser';\n/** @hidden */\n\nconst beforeOpenAdaptiveDialog = 'beforeOpenAdaptiveDialog';\n/** @hidden */\n\nconst resizeStart = 'resizeStart';\n/** @hidden */\n\nconst onResize = 'resizing';\n/** @hidden */\n\nconst resizeStop = 'resizeStop';\n/** @hidden */\n\nconst checkBoxChange = 'checkBoxChange';\n/** @hidden */\n\nconst beforeCopy = 'beforeCopy';\n/** @hidden */\n\nconst beforePaste = 'beforePaste';\n/** @hidden */\n\nconst beforeAutoFill = 'beforeAutoFill';\n/** @hidden */\n\nconst filterChoiceRequest = 'filterchoicerequest';\n/** @hidden */\n\nconst filterAfterOpen = 'filterafteropen';\n/** @hidden */\n\nconst filterBeforeOpen = 'filterbeforeopen';\n/** @hidden */\n\nconst filterSearchBegin = 'filtersearchbegin';\n/** @hidden */\n\nconst commandClick = 'commandClick';\n/** @hidden */\n\nconst exportGroupCaption = 'exportGroupCaption';\n/** @hidden */\n\nconst lazyLoadGroupExpand = 'lazyLoadGroupExpand';\n/** @hidden */\n\nconst lazyLoadGroupCollapse = 'lazyLoadGroupCollapse';\n/**\n * Specifies grid internal events\n */\n\n/** @hidden */\n\nconst initialLoad = 'initial-load';\n/** @hidden */\n\nconst initialEnd = 'initial-end';\n/** @hidden */\n\nconst dataReady = 'data-ready';\n/** @hidden */\n\nconst contentReady = 'content-ready';\n/** @hidden */\n\nconst uiUpdate = 'ui-update';\n/** @hidden */\n\nconst onEmpty = 'on-empty';\n/** @hidden */\n\nconst inBoundModelChanged = 'inbound-model-changed';\n/** @hidden */\n\nconst modelChanged = 'model-changed';\n/** @hidden */\n\nconst colGroupRefresh = 'colgroup-refresh';\n/** @hidden */\n\nconst headerRefreshed = 'header-refreshed';\n/** @hidden */\n\nconst pageBegin = 'paging-begin';\n/** @hidden */\n\nconst pageComplete = 'paging-complete';\n/** @hidden */\n\nconst sortBegin = 'sorting-begin';\n/** @hidden */\n\nconst sortComplete = 'sorting-complete';\n/** @hidden */\n\nconst filterBegin = 'filtering-begin';\n/** @hidden */\n\nconst filterComplete = 'filtering-complete';\n/** @hidden */\n\nconst searchBegin = 'searching-begin';\n/** @hidden */\n\nconst searchComplete = 'searching-complete';\n/** @hidden */\n\nconst reorderBegin = 'reorder-begin';\n/** @hidden */\n\nconst reorderComplete = 'reorder-complete';\n/** @hidden */\n\nconst rowDragAndDropBegin = 'rowdraganddrop-begin';\n/** @hidden */\n\nconst rowDragAndDropComplete = 'rowdraganddrop-complete';\n/** @hidden */\n\nconst groupBegin = 'grouping-begin';\n/** @hidden */\n\nconst groupComplete = 'grouping-complete';\n/** @hidden */\n\nconst ungroupBegin = 'ungrouping-begin';\n/** @hidden */\n\nconst ungroupComplete = 'ungrouping-complete';\n/** @hidden */\n\nconst groupAggregates = 'group-aggregates';\n/** @hidden */\n\nconst refreshFooterRenderer = 'refresh-footer-rendered';\n/** @hidden */\n\nconst refreshAggregateCell = 'refresh-aggregate-cell';\n/** @hidden */\n\nconst refreshAggregates = 'refresh-aggregates';\n/** @hidden */\n\nconst rowSelectionBegin = 'rowselecting';\n/** @hidden */\n\nconst rowSelectionComplete = 'rowselected';\n/** @hidden */\n\nconst columnSelectionBegin = 'columnselecting';\n/** @hidden */\n\nconst columnSelectionComplete = 'columnselected';\n/** @hidden */\n\nconst cellSelectionBegin = 'cellselecting';\n/** @hidden */\n\nconst cellSelectionComplete = 'cellselected';\n/** @hidden */\n\nconst beforeCellFocused = 'beforecellfocused';\n/** @hidden */\n\nconst cellFocused = 'cellfocused';\n/** @hidden */\n\nconst keyPressed = 'key-pressed';\n/** @hidden */\n\nconst click = 'click';\n/** @hidden */\n\nconst destroy = 'destroy';\n/** @hidden */\n\nconst columnVisibilityChanged = 'column-visible-changed';\n/** @hidden */\n\nconst scroll = 'scroll';\n/** @hidden */\n\nconst columnWidthChanged = 'column-width-changed';\n/** @hidden */\n\nconst columnPositionChanged = 'column-position-changed';\n/** @hidden */\n\nconst rowDragAndDrop = 'row-drag-and-drop';\n/** @hidden */\n\nconst rowsAdded = 'rows-added';\n/** @hidden */\n\nconst rowsRemoved = 'rows-removed';\n/** @hidden */\n\nconst columnDragStop = 'column-drag-stop';\n/** @hidden */\n\nconst headerDrop = 'header-drop';\n/** @hidden */\n\nconst dataSourceModified = 'datasource-modified';\n/** @hidden */\n\nconst refreshComplete = 'refresh-complete';\n/** @hidden */\n\nconst refreshVirtualBlock = 'refresh-virtual-block';\n/** @hidden */\n\nconst dblclick = 'dblclick';\n/** @hidden */\n\nconst toolbarRefresh = 'toolbar-refresh';\n/** @hidden */\n\nconst bulkSave = 'bulk-save';\n/** @hidden */\n\nconst autoCol = 'auto-col';\n/** @hidden */\n\nconst tooltipDestroy = 'tooltip-destroy';\n/** @hidden */\n\nconst updateData = 'update-data';\n/** @hidden */\n\nconst editBegin = 'edit-begin';\n/** @hidden */\n\nconst editComplete = 'edit-complete';\n/** @hidden */\n\nconst addBegin = 'add-begin';\n/** @hidden */\n\nconst addComplete = 'add-complete';\n/** @hidden */\n\nconst saveComplete = 'save-complete';\n/** @hidden */\n\nconst deleteBegin = 'delete-begin';\n/** @hidden */\n\nconst deleteComplete = 'delete-complete';\n/** @hidden */\n\nconst preventBatch = 'prevent-batch';\n/** @hidden */\n\nconst dialogDestroy = 'dialog-destroy';\n/** @hidden */\n\nconst crudAction = 'crud-Action';\n/** @hidden */\n\nconst addDeleteAction = 'add-delete-Action';\n/** @hidden */\n\nconst destroyForm = 'destroy-form';\n/** @hidden */\n\nconst doubleTap = 'double-tap';\n/** @hidden */\n\nconst beforeExcelExport = 'beforeExcelExport';\n/** @hidden */\n\nconst excelExportComplete = 'excelExportComplete';\n/** @hidden */\n\nconst excelQueryCellInfo = 'excelQueryCellInfo';\n/** @hidden */\n\nconst excelHeaderQueryCellInfo = 'excelHeaderQueryCellInfo';\n/** @hidden */\n\nconst exportDetailDataBound = 'exportDetailDataBound';\n/** @hidden */\n\nconst beforePdfExport = 'beforePdfExport';\n/** @hidden */\n\nconst pdfExportComplete = 'pdfExportComplete';\n/** @hidden */\n\nconst pdfQueryCellInfo = 'pdfQueryCellInfo';\n/** @hidden */\n\nconst pdfHeaderQueryCellInfo = 'pdfHeaderQueryCellInfo';\n/** @hidden */\n\nconst accessPredicate = 'access-predicate';\n/** @hidden */\n\nconst contextMenuClick = 'contextMenuClick';\n/** @hidden */\n\nconst freezeRender = 'freezerender';\n/** @hidden */\n\nconst freezeRefresh = 'freezerefresh';\n/** @hidden */\n\nconst contextMenuOpen = 'contextMenuOpen';\n/** @hidden */\n\nconst columnMenuClick = 'columnMenuClick';\n/** @hidden */\n\nconst columnMenuOpen = 'columnMenuOpen';\n/** @hidden */\n\nconst filterOpen = 'filterOpen';\n/** @hidden */\n\nconst filterDialogCreated = 'filterDialogCreated';\n/** @hidden */\n\nconst filterMenuClose = 'filter-menu-close';\n/** @hidden */\n\nconst initForeignKeyColumn = 'initForeignKeyColumn';\n/** @hidden */\n\nconst getForeignKeyData = 'getForeignKeyData';\n/** @hidden */\n\nconst generateQuery = 'generateQuery';\n/** @hidden */\n\nconst showEmptyGrid = 'showEmptyGrid';\n/** @hidden */\n\nconst foreignKeyData = 'foreignKeyData';\n/** @hidden */\n\nconst columnDataStateChange = 'columnDataStateChange';\n/** @hidden */\n\nconst dataStateChange = 'dataStateChange';\n/** @hidden */\n\nconst dataSourceChanged = 'dataSourceChanged';\n/** @hidden */\n\nconst rtlUpdated = 'rtl-updated';\n/** @hidden */\n\nconst beforeFragAppend = 'beforeFragAppend';\n/** @hidden */\n\nconst frozenHeight = 'frozenHeight';\n/** @hidden */\n\nconst textWrapRefresh = 'textWrapRefresh';\n/** @hidden */\n\nconst recordAdded = 'recordAdded';\n/** @hidden */\n\nconst cancelBegin = 'cancel-Begin';\n/** @hidden */\n\nconst editNextValCell = 'editNextValCell';\n/** @hidden */\n\nconst hierarchyPrint = 'hierarchyprint';\n/** @hidden */\n\nconst expandChildGrid = 'expandchildgrid';\n/** @hidden */\n\nconst printGridInit = 'printGrid-Init';\n/** @hidden */\n\nconst exportRowDataBound = 'export-RowDataBound';\n/** @hidden */\n\nconst exportDataBound = 'export-DataBound';\n/** @hidden */\n\nconst rowPositionChanged = 'row-position-changed';\n/** @hidden */\n\nconst columnChooserOpened = 'columnChooserOpened';\n/** @hidden */\n\nconst batchForm = 'batchedit-form';\n/** @hidden */\n\nconst beforeStartEdit = 'edit-form';\n/** @hidden */\n\nconst beforeBatchCancel = 'before-batch-cancel';\n/** @hidden */\n\nconst batchEditFormRendered = 'batcheditform-rendered';\n/** @hidden */\n\nconst partialRefresh = 'partial-refresh';\n/** @hidden */\n\nconst beforeCustomFilterOpen = 'beforeCustomFilterOpen';\n/** @hidden */\n\nconst selectVirtualRow = 'select-virtual-Row';\n/** @hidden */\n\nconst columnsPrepared = 'columns-prepared';\n/** @hidden */\n\nconst cBoxFltrBegin = 'cbox-filter-begin';\n/** @hidden */\n\nconst cBoxFltrComplete = 'cbox-filter-complete';\n/** @hidden */\n\nconst fltrPrevent = 'filter-Prevent';\n/** @hidden */\n\nconst beforeFltrcMenuOpen = 'before-filter-cmenu-open';\n/** @hidden */\n\nconst valCustomPlacement = 'validation-custom-placement';\n/** @hidden */\n\nconst filterCboxValue = 'filter-cbox-value';\n/** @hidden */\n\nconst componentRendered = 'component-rendered';\n/** @hidden */\n\nconst restoreFocus = 'restore-Focus';\n/** @hidden */\n\nconst detailStateChange = 'detail-state-change';\n/** @hidden */\n\nconst detailIndentCellInfo = 'detail-indentcell-info';\n/** @hidden */\n\nconst virtaulKeyHandler = 'virtaul-key-handler';\n/** @hidden */\n\nconst virtaulCellFocus = 'virtaul-cell-focus';\n/** @hidden */\n\nconst virtualScrollEditActionBegin = 'virtual-scroll-edit-action-begin';\n/** @hidden */\n\nconst virtualScrollEditSuccess = 'virtual-scroll-edit-success';\n/** @hidden */\n\nconst virtualScrollEditCancel = 'virtual-scroll-edit-cancel';\n/** @hidden */\n\nconst virtualScrollEdit = 'virtual-scroll-edit';\n/** @hidden */\n\nconst refreshVirtualCache = 'refresh-virtual-cache';\n/** @hidden */\n\nconst editReset = 'edit-reset';\n/** @hidden */\n\nconst virtualScrollAddActionBegin = 'virtual-scroll-add-action-begin';\n/** @hidden */\n\nconst getVirtualData = 'get-virtual-data';\n/** @hidden */\n\nconst refreshInfiniteModeBlocks = 'refresh-infinite-mode-blocks';\n/** @hidden */\n\nconst resetInfiniteBlocks = 'reset-infinite-blocks';\n/** @hidden */\n\nconst infiniteScrollHandler = 'infinite-scroll-handler';\n/** @hidden */\n\nconst infinitePageQuery = 'infinite-page-query';\n/** @hidden */\n\nconst infiniteShowHide = 'infinite-show-hide';\n/** @hidden */\n\nconst appendInfiniteContent = 'append-infinite-content';\n/** @hidden */\n\nconst removeInfiniteRows = 'remove-infinite-rows';\n/** @hidden */\n\nconst setInfiniteCache = 'set-infinite-cache';\n/** @hidden */\n\nconst infiniteEditHandler = 'infinite-edit-handler';\n/** @hidden */\n\nconst initialCollapse = 'initial-collapse';\n/** @hidden */\n\nconst getAggregateQuery = 'get-aggregate-query';\n/** @hidden */\n\nconst closeFilterDialog = 'close-filter-dialog';\n/** @hidden */\n\nconst columnChooserCancelBtnClick = 'columnChooserCancelBtnClick';\n/** @hidden */\n\nconst getFilterBarOperator = 'get-filterbar-operator';\n/** @hidden */\n\nconst resetColumns = 'reset-columns';\n/** @hidden */\n\nconst pdfAggregateQueryCellInfo = 'pdfAggregateQueryCellInfo';\n/** @hidden */\n\nconst excelAggregateQueryCellInfo = 'excelAggregateQueryCellInfo';\n/** @hidden */\n\nconst setGroupCache = 'group-cache';\n/** @hidden */\n\nconst lazyLoadScrollHandler = 'lazy-load-scroll-handler';\n/** @hidden */\n\nconst groupCollapse = 'group-collapse';\n/** @hidden */\n\nconst beforeCheckboxRenderer = 'beforeCheckboxRenderer';\n/** @hidden */\n\nconst refreshHandlers = 'refreshResizeHandlers';\n/** @hidden */\n\nconst refreshFrozenColumns = 'refresh-frozen-columns';\n/** @hidden */\n\nconst setReorderDestinationElement = 'set-reorder-destination-element';\n/** @hidden */\n\nconst refreshVirtualFrozenHeight = 'refresh-virtual-frozen-height';\n/** @hidden */\n\nconst setFreezeSelection = 'set-freeze-selection';\n/** @hidden */\n\nconst setInfiniteFrozenHeight = 'set-infinite-frozen-height';\n/** @hidden */\n\nconst setInfiniteColFrozenHeight = 'set-infinite-col-frozen-height';\n/** @hidden */\n\nconst beforeRefreshOnDataChange = 'before-refresh-on-data-change';\n/** @hidden */\n\nconst immutableBatchCancel = 'immutable-batch-cancel';\n/** @hidden */\n\nconst refreshVirtualFrozenRows = 'refresh-virtual-frozenrows';\n/** @hidden */\n\nconst checkScrollReset = 'check-scroll-reset';\n/** @hidden */\n\nconst refreshFrozenHeight = 'refresh-frozen-height';\n/** @hidden */\n\nconst setHeightToFrozenElement = 'set-height-to-frozen-element';\n/** @hidden */\n\nconst preventFrozenScrollRefresh = 'prevent-frozen-scroll-refresh';\n/** @hidden */\n\nconst nextCellIndex = 'next-cell-index';\n/** @hidden */\n\nconst refreshInfiniteCurrentViewData = 'refresh-infinite-current-view-data';\n/** @hidden */\n\nconst infiniteCrudCancel = 'infinite-crud-cancel';\n/** @hidden */\n\nconst filterDialogClose = 'filter-dialog-close';\n/** @hidden */\n\nconst refreshCustomFilterOkBtn = 'refresh-cutsom-filter-ok-button';\n/** @hidden */\n\nconst refreshCustomFilterClearBtn = 'refresh-cutsom-filter-clear-button';\n/** @hidden */\n\nconst renderResponsiveCmenu = 'render-responsive-cmenu';\n/** @hidden */\n\nconst filterCmenuSelect = 'filter-cmenu-select';\n/** @hidden */\n\nconst customFilterClose = 'custom-filter-close';\n/** @hidden */\n\nconst setFullScreenDialog = 'set-fullscreen-dialog';\n/** @hidden */\n\nconst refreshExpandandCollapse = 'refresh-Expand-and-Collapse';\n/** @hidden */\n\nconst rowModeChange = 'row-mode-change';\n/** @hidden */\n\nconst enterKeyHandler = 'enter-key-handler';\n/** @hidden */\n\nconst refreshVirtualMaxPage = 'refresh-virtual-max-page';\n/** @hidden */\n\nconst setVirtualPageQuery = 'set-virtual-page-query';\n/** @hidden */\n\nconst selectRowOnContextOpen = 'select-row-on-context-open';\n/** @hidden */\n\nconst pagerRefresh = 'pager-refresh';\n/** @hidden */\n\nconst closeInline = 'closeinline';\n/** @hidden */\n\nconst closeBatch = 'closebatch';\n/** @hidden */\n\nconst closeEdit = 'close-edit';\n/** @hidden */\n\nconst resetVirtualFocus = 'reset-virtual-focus';\n/** @hidden */\n\nconst afterContentRender = 'after-content-renderer';\n/** @hidden */\n\nconst refreshVirtualEditFormCells = 'refresh-virtual-editform-cells';\n/** @hidden */\n\nconst scrollToEdit = 'scroll-to-edit';\n/** @hidden */\n\nconst beforeCheckboxRendererQuery = 'before-checkbox-renderer-query';\n/** @hidden */\n\nconst createVirtualValidationForm = 'create-virtual-validation-form';\n/** @hidden */\n\nconst validateVirtualForm = 'validate-virtual-form';\n/** @hidden */\n\nconst destroyChildGrid = 'destroy-child-grid';\n/** @hidden */\n\nconst stickyScrollComplete = 'sticky-scroll-complete';\n/** @hidden */\n\nconst captionActionComplete = 'infinite-group-collapse';\n/** @hidden */\n\nconst refreshInfinitePersistSelection = 'refresh-infinite-persist-selection';\n/**\n * Defines types of Cell\n *\n * @hidden\n */\n\nvar CellType = /*#__PURE__*/(() => {\n  (function (CellType) {\n    /**  Defines CellType as Data */\n    CellType[CellType[\"Data\"] = 0] = \"Data\";\n    /**  Defines CellType as Header */\n\n    CellType[CellType[\"Header\"] = 1] = \"Header\";\n    /**  Defines CellType as Summary */\n\n    CellType[CellType[\"Summary\"] = 2] = \"Summary\";\n    /**  Defines CellType as GroupSummary */\n\n    CellType[CellType[\"GroupSummary\"] = 3] = \"GroupSummary\";\n    /**  Defines CellType as CaptionSummary */\n\n    CellType[CellType[\"CaptionSummary\"] = 4] = \"CaptionSummary\";\n    /**  Defines CellType as Filter */\n\n    CellType[CellType[\"Filter\"] = 5] = \"Filter\";\n    /**  Defines CellType as Indent */\n\n    CellType[CellType[\"Indent\"] = 6] = \"Indent\";\n    /**  Defines CellType as GroupCaption */\n\n    CellType[CellType[\"GroupCaption\"] = 7] = \"GroupCaption\";\n    /**  Defines CellType as GroupCaptionEmpty */\n\n    CellType[CellType[\"GroupCaptionEmpty\"] = 8] = \"GroupCaptionEmpty\";\n    /**  Defines CellType as Expand */\n\n    CellType[CellType[\"Expand\"] = 9] = \"Expand\";\n    /**  Defines CellType as HeaderIndent */\n\n    CellType[CellType[\"HeaderIndent\"] = 10] = \"HeaderIndent\";\n    /**  Defines CellType as StackedHeader */\n\n    CellType[CellType[\"StackedHeader\"] = 11] = \"StackedHeader\";\n    /**  Defines CellType as DetailHeader */\n\n    CellType[CellType[\"DetailHeader\"] = 12] = \"DetailHeader\";\n    /**  Defines CellType as DetailExpand */\n\n    CellType[CellType[\"DetailExpand\"] = 13] = \"DetailExpand\";\n    /**  Defines CellType as CommandColumn */\n\n    CellType[CellType[\"CommandColumn\"] = 14] = \"CommandColumn\";\n    /**  Defines CellType as DetailFooterIntent */\n\n    CellType[CellType[\"DetailFooterIntent\"] = 15] = \"DetailFooterIntent\";\n    /**  Defines CellType as RowDrag */\n\n    CellType[CellType[\"RowDragIcon\"] = 16] = \"RowDragIcon\";\n    /**  Defines CellType as RowDragHeader */\n\n    CellType[CellType[\"RowDragHIcon\"] = 17] = \"RowDragHIcon\";\n  })(CellType || (CellType = {}));\n\n  return CellType;\n})();\n\n/**\n * Defines types of Render\n *\n * @hidden\n */\nvar RenderType = /*#__PURE__*/(() => {\n  (function (RenderType) {\n    /**  Defines RenderType as Header */\n    RenderType[RenderType[\"Header\"] = 0] = \"Header\";\n    /**  Defines RenderType as Content */\n\n    RenderType[RenderType[\"Content\"] = 1] = \"Content\";\n    /**  Defines RenderType as Summary */\n\n    RenderType[RenderType[\"Summary\"] = 2] = \"Summary\";\n  })(RenderType || (RenderType = {}));\n\n  return RenderType;\n})();\n\n/**\n * Defines Predefined toolbar items.\n *\n * @hidden\n */\nvar ToolbarItem = /*#__PURE__*/(() => {\n  (function (ToolbarItem) {\n    ToolbarItem[ToolbarItem[\"Add\"] = 0] = \"Add\";\n    ToolbarItem[ToolbarItem[\"Edit\"] = 1] = \"Edit\";\n    ToolbarItem[ToolbarItem[\"Update\"] = 2] = \"Update\";\n    ToolbarItem[ToolbarItem[\"Delete\"] = 3] = \"Delete\";\n    ToolbarItem[ToolbarItem[\"Cancel\"] = 4] = \"Cancel\";\n    ToolbarItem[ToolbarItem[\"Print\"] = 5] = \"Print\";\n    ToolbarItem[ToolbarItem[\"Search\"] = 6] = \"Search\";\n    ToolbarItem[ToolbarItem[\"ColumnChooser\"] = 7] = \"ColumnChooser\";\n    ToolbarItem[ToolbarItem[\"PdfExport\"] = 8] = \"PdfExport\";\n    ToolbarItem[ToolbarItem[\"ExcelExport\"] = 9] = \"ExcelExport\";\n    ToolbarItem[ToolbarItem[\"CsvExport\"] = 10] = \"CsvExport\";\n    ToolbarItem[ToolbarItem[\"WordExport\"] = 11] = \"WordExport\";\n  })(ToolbarItem || (ToolbarItem = {}));\n\n  return ToolbarItem;\n})();\n\n/**\n * Defines types of responsive dialogs\n *\n * @hidden\n */\nvar ResponsiveDialogAction = /*#__PURE__*/(() => {\n  (function (ResponsiveDialogAction) {\n    /**  Defines dialog type as Edit */\n    ResponsiveDialogAction[ResponsiveDialogAction[\"isEdit\"] = 0] = \"isEdit\";\n    /**  Defines dialog type as Add */\n\n    ResponsiveDialogAction[ResponsiveDialogAction[\"isAdd\"] = 1] = \"isAdd\";\n    /**  Defines dialog type as Sort */\n\n    ResponsiveDialogAction[ResponsiveDialogAction[\"isSort\"] = 2] = \"isSort\";\n    /**  Defines dialog type as Filter */\n\n    ResponsiveDialogAction[ResponsiveDialogAction[\"isFilter\"] = 3] = \"isFilter\";\n  })(ResponsiveDialogAction || (ResponsiveDialogAction = {}));\n\n  return ResponsiveDialogAction;\n})();\n\n/**\n * Defines responsive toolbar actions\n *\n * @hidden\n */\nvar ResponsiveToolbarAction = /*#__PURE__*/(() => {\n  (function (ResponsiveToolbarAction) {\n    /**  Defines initial responsive toolbar buttons */\n    ResponsiveToolbarAction[ResponsiveToolbarAction[\"isInitial\"] = 0] = \"isInitial\";\n    /**  Defines responsive toolbar search */\n\n    ResponsiveToolbarAction[ResponsiveToolbarAction[\"isSearch\"] = 1] = \"isSearch\";\n  })(ResponsiveToolbarAction || (ResponsiveToolbarAction = {}));\n\n  return ResponsiveToolbarAction;\n})();\n\n/**\n * Grid data module is used to generate query and data source.\n *\n * @hidden\n */\nclass Data {\n  /**\n   * Constructor for data module.\n   *\n   * @param {IGrid} parent - specifies the IGrid\n   * @param {ServiceLocator} serviceLocator - specifies the service locator\n   * @hidden\n   */\n  constructor(parent, serviceLocator) {\n    this.dataState = {\n      isPending: false,\n      resolver: null,\n      group: []\n    };\n    this.foreignKeyDataState = {\n      isPending: false,\n      resolver: null\n    };\n    this.parent = parent;\n    this.serviceLocator = serviceLocator;\n    this.initDataManager();\n\n    if (this.parent.isDestroyed || this.getModuleName() === 'foreignKey') {\n      return;\n    }\n\n    this.parent.on(rowsAdded, this.addRows, this);\n    this.parent.on(rowPositionChanged, this.reorderRows, this);\n    this.parent.on(rowsRemoved, this.removeRows, this);\n    this.parent.on(dataSourceModified, this.initDataManager, this);\n    this.parent.on(destroy, this.destroy, this);\n    this.parent.on(updateData, this.crudActions, this);\n    this.parent.on(addDeleteAction, this.getData, this);\n    this.parent.on(autoCol, this.refreshFilteredCols, this);\n    this.parent.on(columnsPrepared, this.refreshFilteredCols, this);\n  }\n\n  reorderRows(e) {\n    this.dataManager.dataSource.json.splice(e.toIndex, 0, this.dataManager.dataSource.json.splice(e.fromIndex, 1)[0]);\n  }\n\n  getModuleName() {\n    return 'data';\n  }\n  /**\n   * The function used to initialize dataManager and external query\n   *\n   * @returns {void}\n   */\n\n\n  initDataManager() {\n    const gObj = this.parent;\n    this.dataManager = gObj.dataSource instanceof DataManager ? gObj.dataSource : isNullOrUndefined(gObj.dataSource) ? new DataManager() : new DataManager(gObj.dataSource);\n\n    if (gObj.isAngular && !(gObj.query instanceof Query)) {\n      gObj.setProperties({\n        query: new Query()\n      }, true);\n    } else {\n      this.isQueryInvokedFromData = true;\n      gObj.query = gObj.query instanceof Query ? gObj.query : new Query();\n    }\n  }\n  /**\n   * The function is used to generate updated Query from Grid model.\n   *\n   * @param {boolean} skipPage - specifies the boolean to skip the page\n   * @returns {Query} returns the Query\n   * @hidden\n   */\n\n\n  generateQuery(skipPage) {\n    const gObj = this.parent;\n    const query = gObj.getQuery().clone();\n\n    if (this.parent.columnQueryMode === 'ExcludeHidden') {\n      query.select(this.parent.getColumns().filter(column => !(column.isPrimaryKey !== true && column.visible === false || column.field === undefined)).map(column => column.field));\n    } else if (this.parent.columnQueryMode === 'Schema') {\n      const selectQueryFields = [];\n      const columns = this.parent.columns;\n\n      for (let i = 0; i < columns.length; i++) {\n        selectQueryFields.push(columns[i].field);\n      }\n\n      query.select(selectQueryFields);\n    }\n\n    this.filterQuery(query);\n    this.searchQuery(query);\n    this.aggregateQuery(query);\n    this.sortQuery(query);\n\n    if (isGroupAdaptive(this.parent)) {\n      this.virtualGroupPageQuery(query);\n    } else {\n      this.pageQuery(query, skipPage);\n    }\n\n    this.groupQuery(query);\n    return query;\n  }\n  /**\n   * @param {Query} query - specifies the query\n   * @returns {Query} - returns the query\n   * @hidden\n   */\n\n\n  aggregateQuery(query) {\n    const rows = this.parent.aggregates;\n\n    for (let i = 0; i < rows.length; i++) {\n      const row = rows[i];\n\n      for (let j = 0; j < row.columns.length; j++) {\n        const cols = row.columns[j];\n        const types = cols.type instanceof Array ? cols.type : [cols.type];\n\n        for (let k = 0; k < types.length; k++) {\n          query.aggregate(types[k].toLowerCase(), cols.field);\n        }\n      }\n    }\n\n    return query;\n  }\n\n  virtualGroupPageQuery(query) {\n    const fName = 'fn';\n\n    if (query.queries.length) {\n      for (let i = 0; i < query.queries.length; i++) {\n        if (query.queries[i][fName] === 'onPage') {\n          query.queries.splice(i, 1);\n        }\n      }\n    }\n\n    return query;\n  }\n\n  pageQuery(query, skipPage) {\n    const gObj = this.parent;\n    const fName = 'fn';\n    const args = {\n      query: query,\n      skipPage: false\n    };\n    gObj.notify(setVirtualPageQuery, args);\n\n    if (args.skipPage) {\n      return query;\n    }\n\n    if ((gObj.allowPaging || gObj.enableVirtualization || gObj.enableInfiniteScrolling) && skipPage !== true) {\n      gObj.pageSettings.currentPage = Math.max(1, gObj.pageSettings.currentPage);\n\n      if (gObj.pageSettings.pageCount <= 0) {\n        gObj.pageSettings.pageCount = 8;\n      }\n\n      if (gObj.pageSettings.pageSize <= 0) {\n        gObj.pageSettings.pageSize = 12;\n      }\n\n      if (query.queries.length) {\n        for (let i = 0; i < query.queries.length; i++) {\n          if (query.queries[i][fName] === 'onPage') {\n            query.queries.splice(i, 1);\n          }\n        }\n      }\n\n      if (!isNullOrUndefined(gObj.infiniteScrollModule) && gObj.enableInfiniteScrolling) {\n        this.parent.notify(infinitePageQuery, query);\n      } else {\n        query.page(gObj.pageSettings.currentPage, gObj.pageSettings.pageSize);\n      }\n    }\n\n    return query;\n  }\n\n  groupQuery(query) {\n    const gObj = this.parent;\n\n    if (gObj.allowGrouping && gObj.groupSettings.columns.length) {\n      if (this.parent.groupSettings.enableLazyLoading) {\n        query.lazyLoad.push({\n          key: 'isLazyLoad',\n          value: this.parent.groupSettings.enableLazyLoading\n        });\n      }\n\n      const columns = gObj.groupSettings.columns;\n\n      for (let i = 0, len = columns.length; i < len; i++) {\n        const column = this.getColumnByField(columns[i]);\n\n        if (!column) {\n          this.parent.log('initial_action', {\n            moduleName: 'group',\n            columnName: columns[i]\n          });\n        }\n\n        const isGrpFmt = column.enableGroupByFormat;\n        const format = column.format;\n\n        if (isGrpFmt) {\n          query.group(columns[i], this.formatGroupColumn.bind(this), format);\n        } else {\n          query.group(columns[i], null);\n        }\n      }\n    }\n\n    return query;\n  }\n\n  sortQuery(query) {\n    const gObj = this.parent;\n\n    if ((gObj.allowSorting || gObj.allowGrouping) && gObj.sortSettings.columns.length) {\n      const columns = gObj.sortSettings.columns;\n      const sortGrp = [];\n\n      for (let i = columns.length - 1; i > -1; i--) {\n        const col = this.getColumnByField(columns[i].field);\n\n        if (col) {\n          col.setSortDirection(columns[i].direction);\n        } else {\n          this.parent.log('initial_action', {\n            moduleName: 'sort',\n            columnName: columns[i].field\n          });\n          return query;\n        }\n\n        let fn = columns[i].direction;\n\n        if (col.sortComparer) {\n          this.parent.log('grid_sort_comparer');\n          fn = !this.isRemote() ? col.sortComparer.bind(col) : columns[i].direction;\n        }\n\n        if (gObj.groupSettings.columns.indexOf(columns[i].field) === -1) {\n          if (col.isForeignColumn() || col.sortComparer) {\n            query.sortByForeignKey(col.field, fn, undefined, columns[i].direction.toLowerCase());\n          } else {\n            query.sortBy(col.field, fn);\n          }\n        } else {\n          sortGrp.push({\n            direction: fn,\n            field: col.field\n          });\n        }\n      }\n\n      for (let i = 0, len = sortGrp.length; i < len; i++) {\n        if (typeof sortGrp[i].direction === 'string') {\n          query.sortBy(sortGrp[i].field, sortGrp[i].direction);\n        } else {\n          const col = this.getColumnByField(sortGrp[i].field);\n          query.sortByForeignKey(sortGrp[i].field, sortGrp[i].direction, undefined, col.getSortDirection().toLowerCase());\n        }\n      }\n    }\n\n    return query;\n  }\n\n  searchQuery(query, fcolumn, isForeignKey) {\n    const sSettings = this.parent.searchSettings;\n    let fields = sSettings.fields.length ? sSettings.fields : this.getSearchColumnFieldNames();\n    let predicateList = [];\n    let needForeignKeySearch = false;\n\n    if (this.parent.searchSettings.key.length) {\n      needForeignKeySearch = this.parent.getForeignKeyColumns().some(col => fields.indexOf(col.field) > -1);\n      const adaptor = !isForeignKey ? this.dataManager.adaptor : fcolumn.dataSource.adaptor;\n\n      if (needForeignKeySearch || adaptor.getModuleName && adaptor.getModuleName() === 'ODataV4Adaptor') {\n        fields = isForeignKey ? [fcolumn.foreignKeyValue] : fields;\n\n        for (let i = 0; i < fields.length; i++) {\n          const column = isForeignKey ? fcolumn : this.getColumnByField(fields[i]);\n\n          if (column.isForeignColumn() && !isForeignKey) {\n            predicateList = this.fGeneratePredicate(column, predicateList);\n          } else {\n            predicateList.push(new Predicate(fields[i], sSettings.operator, sSettings.key, sSettings.ignoreCase, sSettings.ignoreAccent));\n          }\n        }\n\n        const predList = Predicate.or(predicateList);\n        predList.key = sSettings.key;\n        query.where(predList);\n      } else {\n        query.search(sSettings.key, fields, sSettings.operator, sSettings.ignoreCase, sSettings.ignoreAccent);\n      }\n    }\n\n    return query;\n  }\n\n  filterQuery(query, column, skipFoerign) {\n    const gObj = this.parent;\n    let predicateList = [];\n    const actualFilter = [];\n    const foreignColumn = this.parent.getForeignKeyColumns();\n    let foreignColEmpty;\n\n    if (gObj.allowFiltering && gObj.filterSettings.columns.length) {\n      const columns = column ? column : gObj.filterSettings.columns;\n      const colType = {};\n\n      for (const col of gObj.getColumns()) {\n        colType[col.field] = col.filter.type ? col.filter.type : gObj.filterSettings.type;\n      }\n\n      const foreignCols = [];\n      const defaultFltrCols = [];\n\n      for (const col of columns) {\n        const gridColumn = gObj.getColumnByField(col.field);\n\n        if (isNullOrUndefined(col.type) && gridColumn && (gridColumn.type === 'date' || gridColumn.type === 'datetime')) {\n          col.type = gObj.getColumnByField(col.field).type;\n        }\n\n        if (col.isForeignKey) {\n          foreignCols.push(col);\n        } else {\n          defaultFltrCols.push(col);\n        }\n      }\n\n      if (defaultFltrCols.length) {\n        for (let i = 0, len = defaultFltrCols.length; i < len; i++) {\n          defaultFltrCols[i].uid = defaultFltrCols[i].uid || this.parent.grabColumnByFieldFromAllCols(defaultFltrCols[i].field).uid;\n        }\n\n        const excelPredicate = CheckBoxFilterBase.getPredicate(defaultFltrCols);\n\n        for (const prop of Object.keys(excelPredicate)) {\n          predicateList.push(excelPredicate[prop]);\n        }\n      }\n\n      if (foreignCols.length) {\n        for (const col of foreignCols) {\n          col.uid = col.uid || this.parent.grabColumnByFieldFromAllCols(col.field).uid;\n          const column = this.parent.grabColumnByUidFromAllCols(col.uid);\n\n          if (!column) {\n            this.parent.log('initial_action', {\n              moduleName: 'filter',\n              columnName: col.field\n            });\n          }\n\n          if (column.isForeignColumn() && getColumnByForeignKeyValue(col.field, foreignColumn) && !skipFoerign) {\n            actualFilter.push(col);\n\n            if (!column.columnData.length) {\n              foreignColEmpty = true;\n            }\n\n            predicateList = this.fGeneratePredicate(column, predicateList);\n          } else {\n            const excelPredicate = CheckBoxFilterBase.getPredicate(columns);\n\n            for (const prop of Object.keys(excelPredicate)) {\n              predicateList.push(excelPredicate[prop]);\n            }\n          }\n        }\n      }\n\n      if (predicateList.length && !foreignColEmpty) {\n        query.where(Predicate.and(predicateList));\n      } else {\n        this.parent.notify(showEmptyGrid, {});\n      }\n    }\n\n    return query;\n  }\n\n  fGeneratePredicate(col, predicateList) {\n    const fPredicate = {};\n\n    if (col) {\n      this.parent.notify(generateQuery, {\n        predicate: fPredicate,\n        column: col\n      });\n\n      if (fPredicate.predicate.predicates.length) {\n        predicateList.push(fPredicate.predicate);\n      }\n    }\n\n    return predicateList;\n  }\n  /**\n   * The function is used to get dataManager promise by executing given Query.\n   *\n   * @param {object} args - specifies the object\n   * @param {string} args.requestType - Defines the request type\n   * @param {string[]} args.foreignKeyData - Defines the foreignKeyData.string\n   * @param {Object} args.data - Defines the data.\n   * @param {number} args.index - Defines the index .\n   * @param {Query} query - Defines the query which will execute along with data processing.\n   * @returns {Promise<Object>} - returns the object\n   * @hidden\n   */\n\n\n  getData(args = {\n    requestType: ''\n  }, query) {\n    const key = this.getKey(args.foreignKeyData && Object.keys(args.foreignKeyData).length ? args.foreignKeyData : this.parent.getPrimaryKeyFieldNames());\n    this.parent.log('datasource_syntax_mismatch', {\n      dataState: this.parent\n    });\n\n    if (this.parent.dataSource && 'result' in this.parent.dataSource) {\n      const def = this.eventPromise(args, query, key);\n      return def.promise;\n    } else {\n      let crud;\n\n      switch (args.requestType) {\n        case 'delete':\n          query = query ? query : this.generateQuery(); // eslint-disable-next-line no-case-declarations\n\n          const len = Object.keys(args.data).length;\n\n          if (len === 1) {\n            crud = this.dataManager.remove(key, args.data[0], query.fromTable, query);\n          } else {\n            const changes = {\n              addedRecords: [],\n              deletedRecords: [],\n              changedRecords: []\n            };\n            changes.deletedRecords = args.data;\n            crud = this.dataManager.saveChanges(changes, key, query.fromTable, query.requiresCount());\n          }\n\n          break;\n\n        case 'save':\n          query = query ? query : this.generateQuery();\n          args.index = isNullOrUndefined(args.index) ? 0 : args.index;\n          crud = this.dataManager.insert(args.data, query.fromTable, query, args.index);\n          break;\n      }\n\n      const promise = 'promise';\n      args[promise] = crud; // eslint-disable-next-line no-prototype-builtins\n\n      if (crud && !Array.isArray(crud) && !crud.hasOwnProperty('deletedRecords')) {\n        return crud.then(() => {\n          return this.insert(query, args);\n        });\n      } else {\n        return this.insert(query, args);\n      }\n    }\n  }\n\n  insert(query, args) {\n    if (args.requestType === 'save') {\n      this.parent.notify(recordAdded, args);\n    }\n\n    return this.executeQuery(query);\n  }\n\n  executeQuery(query) {\n    if (this.dataManager.ready) {\n      const deferred = new Deferred();\n      const ready = this.dataManager.ready;\n      ready.then(() => {\n        this.dataManager.executeQuery(query).then(result => {\n          deferred.resolve(result);\n        });\n      }).catch(e => {\n        deferred.reject(e);\n      });\n      return deferred.promise;\n    } else {\n      return this.dataManager.executeQuery(query);\n    }\n  }\n\n  formatGroupColumn(value, field) {\n    const serviceLocator = this.serviceLocator;\n    const column = this.getColumnByField(field);\n    const date = value;\n\n    if (!column.type) {\n      column.type = date.getDay ? date.getHours() > 0 || date.getMinutes() > 0 || date.getSeconds() > 0 || date.getMilliseconds() > 0 ? 'datetime' : 'date' : typeof value;\n    }\n\n    if (isNullOrUndefined(column.getFormatter())) {\n      setFormatter(serviceLocator, column);\n    }\n\n    const formatVal = ValueFormatter.prototype.toView(value, column.getFormatter());\n    return formatVal;\n  }\n\n  crudActions(args) {\n    const query = this.generateQuery();\n    let promise = null;\n    const pr = 'promise';\n    const key = this.getKey(args.foreignKeyData && Object.keys(args.foreignKeyData).length ? args.foreignKeyData : this.parent.getPrimaryKeyFieldNames());\n\n    if (this.parent.dataSource && 'result' in this.parent.dataSource) {\n      this.eventPromise(args, query, key);\n    }\n\n    switch (args.requestType) {\n      case 'save':\n        promise = this.dataManager.update(key, args.data, query.fromTable, query, args.previousData);\n        break;\n    }\n\n    args[pr] = promise ? promise : args[pr];\n    this.parent.notify(crudAction, args);\n  }\n  /**\n   * @param {object} changes - specifies the changes\n   * @param {string} key - specifies the key\n   * @param {object} original - specifies the original data\n   * @param {Query} query - specifies the query\n   * @returns {Promise<Object>} returns the object\n   * @hidden\n   */\n\n\n  saveChanges(changes, key, original, query = this.generateQuery()) {\n    query.requiresCount();\n\n    if ('result' in this.parent.dataSource) {\n      const deff = new Deferred();\n      const args = {\n        requestType: 'batchsave',\n        changes: changes,\n        key: key,\n        query: query,\n        endEdit: deff.resolve\n      };\n      this.setState({\n        isPending: true,\n        resolver: deff.resolve\n      });\n      this.parent.trigger(dataSourceChanged, args);\n      return deff.promise;\n    } else {\n      const promise = this.dataManager.saveChanges(changes, key, query.fromTable, query, original);\n      return promise;\n    }\n  }\n\n  getKey(keys) {\n    if (keys && keys.length) {\n      return keys[0];\n    }\n\n    return undefined;\n  }\n  /**\n   * @returns {boolean} returns whether its remote data\n   * @hidden\n   */\n\n\n  isRemote() {\n    return this.dataManager.dataSource.offline !== true && this.dataManager.dataSource.url !== undefined && this.dataManager.dataSource.url !== '';\n  }\n\n  addRows(e) {\n    for (let i = e.records.length; i > 0; i--) {\n      this.dataManager.dataSource.json.splice(e.toIndex, 0, e.records[i - 1]);\n    }\n  }\n\n  removeRows(e) {\n    const json = this.dataManager.dataSource.json;\n    this.dataManager.dataSource.json = json.filter(value => e.records.indexOf(value) === -1);\n  }\n\n  getColumnByField(field) {\n    let col;\n    return this.parent.columnModel.some(column => {\n      col = column;\n      return column.field === field;\n    }) && col;\n  }\n\n  destroy() {\n    if (this.parent.isDestroyed) {\n      return;\n    }\n\n    this.parent.off(rowsAdded, this.addRows);\n    this.parent.off(rowsRemoved, this.removeRows);\n    this.parent.off(dataSourceModified, this.initDataManager);\n    this.parent.off(destroy, this.destroy);\n    this.parent.off(updateData, this.crudActions);\n    this.parent.off(addDeleteAction, this.getData);\n    this.parent.off(autoCol, this.refreshFilteredCols);\n    this.parent.off(columnsPrepared, this.refreshFilteredCols);\n  }\n\n  getState() {\n    return this.dataState;\n  }\n\n  setState(state) {\n    return this.dataState = state;\n  }\n\n  getForeignKeyDataState() {\n    return this.foreignKeyDataState;\n  }\n\n  setForeignKeyDataState(state) {\n    this.foreignKeyDataState = state;\n  }\n\n  getStateEventArgument(query) {\n    const adaptr = new UrlAdaptor();\n    const dm = new DataManager({\n      url: '',\n      adaptor: new UrlAdaptor()\n    });\n    const state = adaptr.processQuery(dm, query);\n    const data = JSON.parse(state.data);\n    return extend(data, state.pvtData);\n  }\n\n  eventPromise(args, query, key) {\n    const dataArgs = args;\n    const state = this.getStateEventArgument(query);\n    const def = new Deferred();\n    const deff = new Deferred();\n\n    if (args.requestType !== undefined && this.dataState.isDataChanged !== false) {\n      state.action = args;\n\n      if (args.requestType === 'save' || args.requestType === 'delete') {\n        const editArgs = args;\n        editArgs.key = key;\n        const promise = 'promise';\n        editArgs[promise] = deff.promise;\n        editArgs.state = state;\n        this.setState({\n          isPending: true,\n          resolver: deff.resolve\n        });\n        dataArgs.endEdit = deff.resolve;\n        dataArgs.cancelEdit = deff.reject;\n        this.parent.trigger(dataSourceChanged, editArgs);\n        deff.promise.then(() => {\n          this.setState({\n            isPending: true,\n            resolver: def.resolve,\n            group: state.group,\n            aggregates: state.aggregates\n          });\n\n          if (editArgs.requestType === 'save') {\n            this.parent.notify(recordAdded, editArgs);\n          }\n\n          this.parent.trigger(dataStateChange, state);\n        }).catch(() => void 0);\n      } else {\n        this.setState({\n          isPending: true,\n          resolver: def.resolve,\n          group: state.group,\n          aggregates: state.aggregates\n        });\n        this.parent.trigger(dataStateChange, state);\n      }\n    } else {\n      this.setState({});\n      def.resolve(this.parent.dataSource);\n    }\n\n    return def;\n  }\n  /**\n   * Gets the columns where searching needs to be performed from the Grid.\n   *\n   * @returns {string[]} returns the searched column field names\n   */\n\n\n  getSearchColumnFieldNames() {\n    const colFieldNames = [];\n    const columns = this.parent.getColumns();\n\n    for (const col of columns) {\n      if (col.allowSearching && !isNullOrUndefined(col.field)) {\n        colFieldNames.push(col.field);\n      }\n    }\n\n    return colFieldNames;\n  }\n\n  refreshFilteredCols() {\n    if (this.parent.allowFiltering && this.parent.filterSettings.columns.length) {\n      refreshFilteredColsUid(this.parent, this.parent.filterSettings.columns);\n    }\n  }\n\n}\n/**\n * Row\n *\n * @hidden\n */\n\n\nclass Row {\n  constructor(options, parent) {\n    merge(this, options);\n    this.parent = parent;\n  }\n\n  clone() {\n    const row = new Row({});\n    merge(row, this);\n    row.cells = this.cells.map(cell => cell.clone());\n    return row;\n  }\n  /**\n   * Replaces the row data and grid refresh the particular row element only.\n   *\n   * @param  {Object} data - To update new data for the particular row.\n   * @returns {void}\n   */\n\n\n  setRowValue(data) {\n    if (!this.parent) {\n      return;\n    }\n\n    const key = this.data[this.parent.getPrimaryKeyFieldNames()[0]];\n    this.parent.setRowData(key, data);\n  }\n  /**\n   * Replaces the given field value and refresh the particular cell element only.\n   *\n   * @param {string} field - Specifies the field name which you want to update.\n   * @param {string | number | boolean | Date} value - To update new value for the particular cell.\n   * @returns {void}\n   */\n\n\n  setCellValue(field, value) {\n    if (!this.parent) {\n      return;\n    }\n\n    const isValDiff = !(this.data[field].toString() === value.toString());\n\n    if (isValDiff) {\n      const pKeyField = this.parent.getPrimaryKeyFieldNames()[0];\n      const key = this.data[pKeyField];\n      this.parent.setCellValue(key, field, value);\n      this.makechanges(pKeyField, this.data);\n    } else {\n      return;\n    }\n  }\n\n  makechanges(key, data) {\n    if (!this.parent) {\n      return;\n    }\n\n    const gObj = this.parent;\n    const dataManager = gObj.getDataModule().dataManager;\n    dataManager.update(key, data);\n  }\n\n}\n/**\n * Cell\n *\n * @hidden\n */\n\n\nclass Cell {\n  constructor(options) {\n    this.isSpanned = false;\n    this.isRowSpanned = false;\n    merge(this, options);\n  }\n\n  clone() {\n    const cell = new Cell({});\n    merge(cell, this);\n    return cell;\n  }\n\n}\n/**\n * `CellMergeRender` module.\n *\n * @hidden\n */\n\n\nclass CellMergeRender {\n  constructor(serviceLocator, parent) {\n    this.serviceLocator = serviceLocator;\n    this.parent = parent;\n  }\n\n  render(cellArgs, row, i, td) {\n    const cellRendererFact = this.serviceLocator.getService('cellRendererFactory');\n    const cellRenderer = cellRendererFact.getCellRenderer(row.cells[i].cellType || CellType.Data);\n    let colSpan = row.cells[i].cellSpan ? row.cells[i].cellSpan : cellArgs.colSpan + i <= row.cells.length ? cellArgs.colSpan : row.cells.length - i;\n    const rowSpan = cellArgs.rowSpan;\n    let visible = 0;\n    let spannedCell;\n\n    if (row.index > 0) {\n      const cells = this.parent.groupSettings.columns.length > 0 && !this.parent.getRowsObject()[row.index - 1].isDataRow ? this.parent.getRowsObject()[row.index].cells : this.parent.getRowsObject()[row.index - 1].cells;\n      const targetCell = row.cells[i];\n      const uid = 'uid';\n      spannedCell = cells.filter(cell => cell.column.uid === targetCell.column[uid])[0];\n    }\n\n    const colSpanLen = spannedCell && spannedCell.colSpanRange > 1 && spannedCell.rowSpanRange > 1 ? spannedCell.colSpanRange : colSpan;\n\n    for (let j = i + 1; j < i + colSpanLen && j < row.cells.length; j++) {\n      if (row.cells[j].visible === false) {\n        visible++;\n      } else {\n        row.cells[j].isSpanned = true;\n      }\n    }\n\n    if (visible > 0) {\n      for (let j = i + colSpan; j < i + colSpan + visible && j < row.cells.length; j++) {\n        row.cells[j].isSpanned = true;\n      }\n\n      if (i + colSpan + visible >= row.cells.length) {\n        colSpan -= i + colSpan + visible - row.cells.length;\n      }\n    }\n\n    if (row.cells[i].cellSpan) {\n      row.data[cellArgs.column.field] = row.cells[i].spanText;\n      td = cellRenderer.render(row.cells[i], row.data, {\n        'index': !isNullOrUndefined(row.index) ? row.index.toString() : ''\n      });\n    }\n\n    if (colSpan > 1) {\n      attributes(td, {\n        'colSpan': colSpan.toString(),\n        'aria-colSpan': colSpan.toString()\n      });\n    }\n\n    if (rowSpan > 1) {\n      attributes(td, {\n        'rowspan': rowSpan.toString(),\n        'aria-rowspan': rowSpan.toString()\n      });\n      row.cells[i].isRowSpanned = true;\n      row.cells[i].rowSpanRange = Number(rowSpan);\n\n      if (colSpan > 1) {\n        row.cells[i].colSpanRange = Number(colSpan);\n      }\n    }\n\n    if (row.index > 0 && spannedCell.rowSpanRange > 1) {\n      row.cells[i].isSpanned = true;\n      row.cells[i].rowSpanRange = Number(spannedCell.rowSpanRange - 1);\n      row.cells[i].colSpanRange = spannedCell.rowSpanRange > 0 ? spannedCell.colSpanRange : 1;\n    }\n\n    if (this.parent.enableColumnVirtualization && !row.cells[i].cellSpan && !this.containsKey(cellArgs.column.field, cellArgs.data[cellArgs.column.field])) {\n      this.backupMergeCells(cellArgs.column.field, cellArgs.data[cellArgs.column.field], cellArgs.colSpan);\n    }\n\n    return td;\n  }\n\n  backupMergeCells(fName, data, span) {\n    this.setMergeCells(this.generteKey(fName, data), span);\n  }\n\n  generteKey(fname, data) {\n    return fname + '__' + data.toString();\n  }\n\n  splitKey(key) {\n    return key.split('__');\n  }\n\n  containsKey(fname, data) {\n    // eslint-disable-next-line no-prototype-builtins\n    return this.getMergeCells().hasOwnProperty(this.generteKey(fname, data));\n  }\n\n  getMergeCells() {\n    return this.parent.mergeCells;\n  }\n\n  setMergeCells(key, span) {\n    this.parent.mergeCells[key] = span;\n  }\n\n  updateVirtualCells(rows) {\n    const mCells = this.getMergeCells();\n\n    for (const key of Object.keys(mCells)) {\n      const value = mCells[key];\n      const merge$$1 = this.splitKey(key);\n      const columnIndex = this.getIndexFromAllColumns(merge$$1[0]);\n      const vColumnIndices = this.parent.getColumnIndexesInView();\n      const span = value - (vColumnIndices[0] - columnIndex);\n\n      if (columnIndex < vColumnIndices[0] && span > 1) {\n        for (const row of rows) {\n          if (row.data[merge$$1[0]].toString() === merge$$1[1].toString()) {\n            row.cells[0].cellSpan = span;\n            row.cells[0].spanText = merge$$1[1];\n            break;\n          }\n        }\n      }\n    }\n\n    return rows;\n  }\n\n  getIndexFromAllColumns(field) {\n    const index = iterateArrayOrObject(this.parent.getVisibleColumns(), (item, index) => {\n      if (item.field === field) {\n        return index;\n      }\n\n      return undefined;\n    })[0];\n    return index;\n  }\n\n}\n/**\n * Specifies class names\n */\n\n/** @hidden */\n\n\nconst rowCell = 'e-rowcell';\n/** @hidden */\n\nconst gridHeader = 'e-gridheader';\n/** @hidden */\n\nconst gridContent = 'e-gridcontent';\n/** @hidden */\n\nconst gridFooter = 'e-gridfooter';\n/** @hidden */\n\nconst headerContent = 'e-headercontent';\n/** @hidden */\n\nconst movableContent = 'e-movablecontent';\n/** @hidden */\n\nconst movableHeader = 'e-movableheader';\n/** @hidden */\n\nconst frozenContent = 'e-frozencontent';\n/** @hidden */\n\nconst frozenHeader = 'e-frozenheader';\n/** @hidden */\n\nconst content = 'e-content';\n/** @hidden */\n\nconst table = 'e-table';\n/** @hidden */\n\nconst row = 'e-row';\n/** @hidden */\n\nconst gridChkBox = 'e-gridchkbox';\n/** @hidden */\n\nconst editedRow = 'e-editedrow';\n/** @hidden */\n\nconst addedRow = 'e-addedrow';\n/**\n * Specifies repeated strings\n */\n\n/** @hidden */\n\nconst changedRecords = 'changedRecords';\n/** @hidden */\n\nconst addedRecords = 'addedRecords';\n/** @hidden */\n\nconst deletedRecords = 'deletedRecords';\n/** @hidden */\n\nconst leftRight = 'Left-Right';\n/** @hidden */\n\nconst frozenRight = 'frozen-right';\n/** @hidden */\n\nconst frozenLeft = 'frozen-left';\n/** @hidden */\n\nconst ariaColIndex = 'aria-colindex';\n/** @hidden */\n\nconst ariaRowIndex = 'aria-rowindex';\n/** @hidden */\n\nconst tbody = 'tbody';\n/** @hidden */\n\nconst colGroup = 'colgroup';\n/** @hidden */\n\nconst open = 'open';\n/** @hidden */\n\nconst change = 'change';\n/** @hidden */\n\nconst focus = 'focus';\n/** @hidden */\n\nconst create = 'created';\n/** @hidden */\n\nconst beforeOpen = 'beforeOpen';\n/** @hidden */\n\nconst downArrow = 'downArrow';\n/** @hidden */\n\nconst upArrow = 'upArrow';\n/** @hidden */\n\nconst pageUp = 'PageUp';\n/** @hidden */\n\nconst pageDown = 'PageDown';\n/** @hidden */\n\nconst enter = 'enter';\n/** @hidden */\n\nconst shiftEnter = 'shiftEnter';\n/** @hidden */\n\nconst tab = 'tab';\n/** @hidden */\n\nconst shiftTab = 'shiftTab';\n/**\n * RowRenderer class which responsible for building row content.\n *\n * @hidden\n */\n\nclass RowRenderer {\n  constructor(serviceLocator, cellType, parent) {\n    this.isSpan = false;\n    this.cellType = cellType;\n    this.serviceLocator = serviceLocator;\n    this.parent = parent;\n    this.element = this.parent.createElement('tr', {\n      attrs: {\n        role: 'row'\n      }\n    });\n  }\n  /* eslint-disable */\n\n  /**\n   * Function to render the row content based on Column[] and data.\n   *\n   * @param {Row<T>} row - specifies the row\n   * @param {Column[]} columns - specifies the columns\n   * @param {Object} attributes - specifies the attributes\n   * @param {string} rowTemplate - specifies the rowTemplate\n   * @param {Element} cloneNode - specifies the cloneNode\n   * @returns {Element} returns the element\n   */\n\n  /* eslint-enable */\n\n\n  render(row$$1, columns, attributes$$1, rowTemplate, cloneNode) {\n    return this.refreshRow(row$$1, columns, attributes$$1, rowTemplate, cloneNode);\n  }\n  /* eslint-disable */\n\n  /**\n   * Function to refresh the row content based on Column[] and data.\n   *\n   * @param {Row<T>} row - specifies the row\n   * @param {Column[]} columns - specifies the column\n   * @param {boolean} isChanged - specifies isChanged\n   * @param {Object} attributes - specifies the attributes\n   * @param {string} rowTemplate - specifies the rowTemplate\n   * @returns {void}\n   */\n\n  /* eslint-enable */\n\n\n  refresh(row$$1, columns, isChanged, attributes$$1, rowTemplate) {\n    if (isChanged) {\n      row$$1.data = extendObjWithFn({}, row$$1.changes);\n      this.refreshMergeCells(row$$1);\n    }\n\n    const node = this.parent.element.querySelector('[data-uid=' + row$$1.uid + ']');\n    const tr = this.refreshRow(row$$1, columns, attributes$$1, rowTemplate, null, isChanged);\n    const cells = [].slice.call(tr.cells);\n    node.innerHTML = '';\n\n    for (const cell of cells) {\n      node.appendChild(cell);\n    }\n  } // tslint:disable-next-line:max-func-body-length\n\n\n  refreshRow(row$$1, columns, attributes$$1, rowTemplate, cloneNode, isEdit) {\n    const tr = !isNullOrUndefined(cloneNode) ? cloneNode : this.element.cloneNode();\n    const rowArgs = {\n      data: row$$1.data\n    };\n    const cellArgs = {\n      data: row$$1.data\n    };\n    const chekBoxEnable = this.parent.getColumns().filter(col => col.type === 'checkbox' && col.field)[0];\n    let value = false;\n\n    if (chekBoxEnable) {\n      value = getObject(chekBoxEnable.field, rowArgs.data);\n    }\n\n    const selIndex = this.parent.getSelectedRowIndexes();\n\n    if (row$$1.isDataRow) {\n      row$$1.isSelected = selIndex.indexOf(row$$1.index) > -1 || value;\n    }\n\n    if (row$$1.isDataRow && this.parent.isCheckBoxSelection && this.parent.checkAllRows === 'Check' && this.parent.enableVirtualization) {\n      row$$1.isSelected = true;\n\n      if (selIndex.indexOf(row$$1.index) === -1) {\n        selIndex.push(row$$1.index);\n      }\n    }\n\n    this.buildAttributeFromRow(tr, row$$1);\n    attributes(tr, extend({}, attributes$$1, {}));\n    setStyleAndAttributes(tr, row$$1.attributes);\n    const cellRendererFact = this.serviceLocator.getService('cellRendererFactory');\n\n    for (let i = 0, len = row$$1.cells.length; i < len; i++) {\n      const cell = row$$1.cells[i];\n      cell.isSelected = row$$1.isSelected;\n      cell.isColumnSelected = cell.column.isSelected;\n      const cellRenderer = cellRendererFact.getCellRenderer(row$$1.cells[i].cellType || CellType.Data);\n      const attrs = {\n        'index': !isNullOrUndefined(row$$1.index) ? row$$1.index.toString() : ''\n      };\n\n      if (row$$1.isExpand && row$$1.cells[i].cellType === CellType.DetailExpand) {\n        attrs['class'] = this.parent.isPrinting ? 'e-detailrowcollapse' : 'e-detailrowexpand';\n      }\n\n      let td = cellRenderer.render(row$$1.cells[i], row$$1.data, attrs, row$$1.isExpand, isEdit);\n\n      if (row$$1.cells[i].cellType !== CellType.Filter) {\n        if (row$$1.cells[i].cellType === CellType.Data || row$$1.cells[i].cellType === CellType.CommandColumn) {\n          this.parent.trigger(queryCellInfo, extend(cellArgs, {\n            cell: td,\n            column: cell.column,\n            colSpan: 1,\n            rowSpan: 1,\n            foreignKeyData: row$$1.cells[i].foreignKeyData,\n            requestType: this.parent.requestTypeAction\n          }));\n          let isRowSpanned = false;\n\n          if (row$$1.index > 0 && this.isSpan) {\n            const prevRowCells = this.parent.groupSettings.columns.length > 0 && !this.parent.getRowsObject()[row$$1.index - 1].isDataRow ? this.parent.getRowsObject()[row$$1.index].cells : this.parent.getRowsObject()[row$$1.index - 1].cells;\n            const uid = 'uid';\n            const prevRowCell = prevRowCells.filter(cell => cell.column.uid === row$$1.cells[i].column[uid])[0];\n            isRowSpanned = prevRowCell.isRowSpanned ? prevRowCell.isRowSpanned : prevRowCell.rowSpanRange > 1;\n          }\n\n          if (cellArgs.colSpan > 1 || row$$1.cells[i].cellSpan > 1 || cellArgs.rowSpan > 1 || isRowSpanned) {\n            this.isSpan = true;\n            const cellMerge = new CellMergeRender(this.serviceLocator, this.parent);\n            td = cellMerge.render(cellArgs, row$$1, i, td);\n          }\n        }\n\n        if (!row$$1.cells[i].isSpanned) {\n          tr.appendChild(td);\n        }\n      }\n    }\n\n    const args = {\n      row: tr,\n      rowHeight: this.parent.rowHeight\n    };\n\n    if (row$$1.isDataRow) {\n      this.parent.trigger(rowDataBound, extend(rowArgs, args));\n\n      if (this.parent.childGrid || this.parent.isRowDragable() || this.parent.detailTemplate) {\n        const td = tr.querySelectorAll('.e-rowcell:not(.e-hide)')[0];\n\n        if (td) {\n          td.classList.add('e-detailrowvisible');\n        }\n      }\n    }\n\n    if (this.parent.enableVirtualization) {\n      rowArgs.rowHeight = this.parent.rowHeight;\n    }\n\n    if (rowArgs.rowHeight) {\n      tr.style.height = rowArgs.rowHeight + 'px';\n    } else if (this.parent.rowHeight && (tr.querySelector('.e-headercell') || tr.querySelector('.e-groupcaption'))) {\n      tr.style.height = this.parent.rowHeight + 'px';\n    }\n\n    if (row$$1.cssClass) {\n      tr.classList.add(row$$1.cssClass);\n    }\n\n    if (row$$1.lazyLoadCssClass) {\n      tr.classList.add(row$$1.lazyLoadCssClass);\n    }\n\n    const vFTable = this.parent.enableColumnVirtualization && this.parent.frozenColumns !== 0;\n\n    if (!vFTable && this.parent.aggregates.length && this.parent.element.scrollHeight > this.parent.height) {\n      for (let i = 0; i < this.parent.aggregates.length; i++) {\n        const property = 'properties';\n        const column = 'columns';\n\n        if (this.parent.aggregates[i][property][column][0].footerTemplate) {\n          const summarycell = [].slice.call(tr.getElementsByClassName('e-summarycell'));\n\n          if (summarycell.length) {\n            const lastSummaryCell = summarycell[summarycell.length - 1];\n            addClass([lastSummaryCell], ['e-lastsummarycell']);\n            const firstSummaryCell = summarycell[0];\n            addClass([firstSummaryCell], ['e-firstsummarycell']);\n          }\n        }\n      }\n    }\n\n    return tr;\n  }\n\n  refreshMergeCells(row$$1) {\n    for (const cell of row$$1.cells) {\n      cell.isSpanned = false;\n    }\n\n    return row$$1;\n  }\n  /* eslint-disable */\n\n  /**\n   * Function to check and add alternative row css class.\n   *\n   * @param {Element} tr - specifies the tr element\n   * @param {Row<T>} row - specifies the row\n   * @returns {void}\n   */\n\n  /* eslint-enable */\n\n\n  buildAttributeFromRow(tr, row$$1) {\n    const attr = {};\n    const prop = {\n      'rowindex': ariaRowIndex,\n      'dataUID': 'data-uid',\n      'ariaSelected': 'aria-selected'\n    };\n    const classes = [];\n\n    if (row$$1.isDataRow) {\n      classes.push(row);\n    }\n\n    if (row$$1.isAltRow) {\n      classes.push('e-altrow');\n    }\n\n    if (!isNullOrUndefined(row$$1.index)) {\n      attr[prop.rowindex] = row$$1.index;\n    }\n\n    if (row$$1.rowSpan) {\n      attr.rowSpan = row$$1.rowSpan;\n    }\n\n    if (row$$1.uid) {\n      attr[prop.dataUID] = row$$1.uid;\n    }\n\n    if (row$$1.isSelected) {\n      attr[prop.ariaSelected] = true;\n    }\n\n    if (row$$1.visible === false) {\n      classes.push('e-hide');\n    }\n\n    attr.class = classes;\n    setStyleAndAttributes(tr, attr);\n  }\n\n}\n/**\n * RowModelGenerator is used to generate grid data rows.\n *\n * @hidden\n */\n\n\nclass RowModelGenerator {\n  /**\n   * Constructor for header renderer module\n   *\n   * @param {IGrid} parent - specifies the IGrid\n   */\n  constructor(parent) {\n    this.parent = parent;\n  }\n\n  generateRows(data, args) {\n    const rows = [];\n    let startIndex = this.parent.enableVirtualization && args ? args.startIndex : 0;\n    startIndex = this.parent.enableInfiniteScrolling && args ? this.getInfiniteIndex(args) : startIndex;\n\n    for (let i = 0, len = Object.keys(data).length; i < len; i++, startIndex++) {\n      rows[i] = this.generateRow(data[i], startIndex);\n    }\n\n    return rows;\n  }\n\n  ensureColumns() {\n    //TODO: generate dummy column for group, detail here;\n    const cols = [];\n\n    if (this.parent.detailTemplate || this.parent.childGrid) {\n      const args = {};\n      this.parent.notify(detailIndentCellInfo, args);\n      cols.push(this.generateCell(args, null, CellType.DetailExpand));\n    }\n\n    if (this.parent.isRowDragable()) {\n      cols.push(this.generateCell({}, null, CellType.RowDragIcon));\n    }\n\n    return cols;\n  }\n\n  generateRow(data, index, cssClass, indent, pid, tIndex, parentUid) {\n    const options = {};\n    options.foreignKeyData = {};\n    options.uid = getUid('grid-row');\n    options.data = data;\n    options.index = index;\n    options.indent = indent;\n    options.tIndex = tIndex;\n    options.isDataRow = true;\n    options.parentGid = pid;\n    options.parentUid = parentUid;\n\n    if (this.parent.isPrinting) {\n      if (this.parent.hierarchyPrintMode === 'All') {\n        options.isExpand = true;\n      } else if (this.parent.hierarchyPrintMode === 'Expanded' && this.parent.expandedRows && this.parent.expandedRows[index]) {\n        options.isExpand = this.parent.expandedRows[index].isExpand;\n      }\n    }\n\n    options.cssClass = cssClass;\n    options.isAltRow = this.parent.enableAltRow ? index % 2 !== 0 : false;\n    options.isAltRow = this.parent.enableAltRow ? index % 2 !== 0 : false;\n    options.isSelected = this.parent.getSelectedRowIndexes().indexOf(index) > -1;\n    this.refreshForeignKeyRow(options);\n    const cells = this.ensureColumns();\n    const row = new Row(options, this.parent);\n    row.cells = this.parent.getFrozenMode() === 'Right' ? this.generateCells(options).concat(cells) : cells.concat(this.generateCells(options));\n    return row;\n  }\n\n  refreshForeignKeyRow(options) {\n    const foreignKeyColumns = this.parent.getForeignKeyColumns();\n\n    for (let i = 0; i < foreignKeyColumns.length; i++) {\n      setValue(foreignKeyColumns[i].field, getForeignData(foreignKeyColumns[i], options.data), options.foreignKeyData);\n    }\n  }\n\n  generateCells(options) {\n    const dummies = this.parent.getColumns();\n    const tmp = [];\n\n    for (let i = 0; i < dummies.length; i++) {\n      tmp.push(this.generateCell(dummies[i], options.uid, isNullOrUndefined(dummies[i].commands) ? undefined : CellType.CommandColumn, null, i, options.foreignKeyData));\n    }\n\n    return tmp;\n  }\n  /**\n   *\n   * @param {Column} column - Defines column details\n   * @param {string} rowId - Defines row id\n   * @param {CellType} cellType  - Defines cell type\n   * @param {number} colSpan - Defines colSpan\n   * @param {number} oIndex - Defines index\n   * @param {Object} foreignKeyData - Defines foreign key data\n   * @returns {Cell<Column>} returns cell model\n   * @hidden\n   */\n\n\n  generateCell(column, rowId, cellType, colSpan, oIndex, foreignKeyData$$1) {\n    const opt = {\n      'visible': column.visible,\n      'isDataCell': !isNullOrUndefined(column.field || column.template),\n      'isTemplate': !isNullOrUndefined(column.template),\n      'rowID': rowId,\n      'column': column,\n      'cellType': !isNullOrUndefined(cellType) ? cellType : CellType.Data,\n      'colSpan': colSpan,\n      'commands': column.commands,\n      'isForeignKey': column.isForeignColumn && column.isForeignColumn(),\n      'foreignKeyData': column.isForeignColumn && column.isForeignColumn() && getValue(column.field, foreignKeyData$$1)\n    };\n\n    if (opt.isDataCell || opt.column.type === 'checkbox' || opt.commands) {\n      opt.index = oIndex;\n    }\n\n    return new Cell(opt);\n  }\n\n  refreshRows(input) {\n    for (let i = 0; i < input.length; i++) {\n      this.refreshForeignKeyRow(input[i]);\n      input[i].cells = this.generateCells(input[i]);\n    }\n\n    return input;\n  }\n\n  getInfiniteIndex(args) {\n    return args.requestType === 'infiniteScroll' || args.requestType === 'delete' || args.action === 'add' ? args.startIndex : 0;\n  }\n\n}\n/**\n * Summary row model generator\n *\n * @hidden\n */\n\n\nclass SummaryModelGenerator {\n  /**\n   * Constructor for Summary row model generator\n   *\n   * @param {IGrid} parent - specifies the IGrid\n   */\n  constructor(parent) {\n    this.parent = parent;\n  }\n\n  getData() {\n    const rows = [];\n    const row = this.parent.aggregates.slice();\n\n    for (let i = 0; i < row.length; i++) {\n      const columns = row[i].columns.filter(column => {\n        return !(column.footerTemplate || column.groupFooterTemplate || column.groupCaptionTemplate) || this.columnSelector(column);\n      });\n\n      if (columns.length) {\n        rows.push({\n          columns: columns\n        });\n      }\n    }\n\n    return rows;\n  }\n\n  columnSelector(column) {\n    return column.footerTemplate !== undefined;\n  }\n\n  getColumns(start, end) {\n    const columns = [];\n\n    if (this.parent.allowGrouping) {\n      for (let i = 0; i < this.parent.groupSettings.columns.length; i++) {\n        columns.push(new Column({}));\n      }\n    }\n\n    if (this.parent.detailTemplate || !isNullOrUndefined(this.parent.childGrid)) {\n      columns.push(new Column({}));\n    }\n\n    if (this.parent.isRowDragable() && !start) {\n      columns.push(new Column({}));\n    }\n\n    columns.push(...this.parent.getColumns());\n    end = end && !start ? end + this.parent.getIndentCount() : end;\n    return isNullOrUndefined(start) ? columns : columns.slice(start, end);\n  }\n\n  generateRows(input, args, start, end, columns) {\n    if (input.length === 0) {\n      if (args === undefined || !args.count) {\n        return [];\n      }\n    }\n\n    const data = this.buildSummaryData(input, args);\n    const rows = [];\n    const row = this.getData();\n\n    for (let i = 0; i < row.length; i++) {\n      rows.push(this.getGeneratedRow(row[i], data[i], args ? args.level : undefined, start, end, args ? args.parentUid : undefined, columns));\n    }\n\n    return rows;\n  }\n\n  getGeneratedRow(summaryRow, data, raw, start, end, parentUid, columns) {\n    const tmp = [];\n    let indents = this.getIndentByLevel();\n    const isDetailGridAlone = !isNullOrUndefined(this.parent.childGrid);\n    const indentLength = !start ? this.parent.getIndentCount() : 0;\n\n    if (this.parent.isRowDragable() && !start) {\n      indents = ['e-indentcelltop'];\n    }\n\n    const values = columns ? columns : this.getColumns(start, end);\n\n    for (let i = 0; i < values.length; i++) {\n      tmp.push(this.getGeneratedCell(values[i], summaryRow, i >= indentLength ? this.getCellType() : i < this.parent.groupSettings.columns.length ? CellType.Indent : CellType.DetailFooterIntent, indents[i], isDetailGridAlone));\n    }\n\n    const row = new Row({\n      data: data,\n      attributes: {\n        class: 'e-summaryrow'\n      }\n    });\n    row.cells = tmp;\n    row.uid = getUid('grid-row');\n    row.parentUid = parentUid;\n    row.visible = tmp.some(cell => cell.isDataCell && cell.visible);\n    return row;\n  }\n\n  getGeneratedCell(column, summaryRow, cellType, indent, isDetailGridAlone) {\n    //Get the summary column by display\n    const sColumn = summaryRow.columns.filter(scolumn => scolumn.columnName === column.field)[0];\n    const attrs = {\n      'style': {\n        'textAlign': column.textAlign\n      },\n      'e-mappinguid': column.uid,\n      index: column.index\n    };\n\n    if (indent) {\n      attrs.class = indent;\n    }\n\n    if (isNullOrUndefined(indent) && isDetailGridAlone) {\n      attrs.class = 'e-detailindentcelltop';\n    }\n\n    const opt = {\n      'visible': column.visible,\n      'isDataCell': !isNullOrUndefined(sColumn),\n      'isTemplate': sColumn && !isNullOrUndefined(sColumn.footerTemplate || sColumn.groupFooterTemplate || sColumn.groupCaptionTemplate),\n      'column': sColumn || {},\n      'attributes': attrs,\n      'cellType': cellType\n    };\n    opt.column.headerText = column.headerText;\n    return new Cell(opt);\n  }\n\n  buildSummaryData(data, args) {\n    const dummy = [];\n    const summaryRows = this.getData();\n    let single = {};\n\n    for (let i = 0; i < summaryRows.length; i++) {\n      single = {};\n      const column = summaryRows[i].columns;\n\n      for (let j = 0; j < column.length; j++) {\n        single = this.setTemplate(column[j], args && args.aggregates ? args : data, single);\n      }\n\n      dummy.push(single);\n    }\n\n    return dummy;\n  }\n\n  getIndentByLevel() {\n    return this.parent.groupSettings.columns.map(() => 'e-indentcelltop');\n  }\n\n  setTemplate(column, data, single) {\n    let types = column.type;\n    const helper = {};\n\n    const formatFn = column.getFormatter() || (() => a => a)();\n\n    const group = data;\n\n    if (!(types instanceof Array)) {\n      types = [column.type];\n    }\n\n    for (let i = 0; i < types.length; i++) {\n      const key = column.field + ' - ' + types[i].toLowerCase();\n      const disp = column.columnName;\n      const val = types[i] !== 'Custom' && group.aggregates && key in group.aggregates ? group.aggregates[key] : calculateAggregate(types[i], group.aggregates ? group : data, column, this.parent);\n      single[disp] = single[disp] || {};\n      single[disp][key] = val;\n      single[disp][types[i]] = !isNullOrUndefined(val) ? formatFn(val) : ' ';\n\n      if (group.field) {\n        single[disp].field = group.field;\n        single[disp].key = group.key;\n      }\n    }\n\n    helper.format = column.getFormatter();\n    column.setTemplate(helper);\n    return single;\n  }\n\n  getCellType() {\n    return CellType.Summary;\n  }\n\n}\n\nclass GroupSummaryModelGenerator extends SummaryModelGenerator {\n  columnSelector(column) {\n    return column.groupFooterTemplate !== undefined;\n  }\n\n  getIndentByLevel(level = this.parent.groupSettings.columns.length) {\n    return this.parent.groupSettings.columns.map((v, indx) => indx <= level - 1 ? '' : 'e-indentcelltop');\n  }\n\n  getCellType() {\n    return CellType.GroupSummary;\n  }\n\n}\n\nclass CaptionSummaryModelGenerator extends SummaryModelGenerator {\n  columnSelector(column) {\n    return column.groupCaptionTemplate !== undefined;\n  }\n\n  getData() {\n    const initVal = {\n      columns: []\n    };\n    return [super.getData().reduce((prev, cur) => {\n      prev.columns = [...prev.columns, ...cur.columns];\n      return prev;\n    }, initVal)];\n  }\n\n  isEmpty() {\n    return (this.getData()[0].columns || []).length === 0;\n  }\n\n  getCellType() {\n    return CellType.CaptionSummary;\n  }\n\n}\n/**\n * GroupModelGenerator is used to generate group caption rows and data rows.\n *\n * @hidden\n */\n\n\nclass GroupModelGenerator extends RowModelGenerator {\n  constructor(parent) {\n    super(parent);\n    this.rows = [];\n    /** @hidden */\n\n    this.index = 0;\n    this.infiniteChildCount = 0;\n    this.renderInfiniteAgg = true;\n    this.parent = parent;\n    this.summaryModelGen = new GroupSummaryModelGenerator(parent);\n    this.captionModelGen = new CaptionSummaryModelGenerator(parent);\n  }\n\n  generateRows(data, args) {\n    if (this.parent.groupSettings.columns.length === 0) {\n      return super.generateRows(data, args);\n    }\n\n    this.isInfiniteScroll = args.requestType === 'infiniteScroll';\n    this.rows = [];\n    this.index = this.parent.enableVirtualization || this.isInfiniteScroll ? args.startIndex : 0;\n\n    for (let i = 0, len = data.length; i < len; i++) {\n      this.infiniteChildCount = 0;\n      this.renderInfiniteAgg = true;\n      this.getGroupedRecords(0, data[i], data.level, i, undefined, this.rows.length);\n    }\n\n    this.index = 0;\n\n    if (this.parent.isCollapseStateEnabled()) {\n      this.ensureRowVisibility();\n    }\n\n    return this.rows;\n  }\n\n  getGroupedRecords(index, data, raw, parentid, childId, tIndex, parentUid) {\n    const level = raw;\n\n    if (isNullOrUndefined(data.items)) {\n      if (isNullOrUndefined(data.GroupGuid)) {\n        this.rows = this.rows.concat(this.generateDataRows(data, index, parentid, this.rows.length, parentUid));\n      } else {\n        for (let j = 0, len = data.length; j < len; j++) {\n          this.getGroupedRecords(index, data[j], data.level, parentid, index, this.rows.length, parentUid);\n        }\n      }\n    } else {\n      let preCaption;\n      const captionRow = this.generateCaptionRow(data, index, parentid, childId, tIndex, parentUid);\n\n      if (this.isInfiniteScroll) {\n        preCaption = this.getPreCaption(index, captionRow.data.key);\n      }\n\n      if (!preCaption) {\n        this.rows = this.rows.concat(captionRow);\n      } else {\n        captionRow.uid = preCaption.uid;\n      }\n\n      if (data.items && data.items.length) {\n        this.getGroupedRecords(index + 1, data.items, data.items.level, parentid, index + 1, this.rows.length, captionRow.uid);\n      }\n\n      if (this.parent.aggregates.length && this.isRenderAggregate(captionRow)) {\n        const rowCnt = this.rows.length;\n        this.rows.push(...this.summaryModelGen.generateRows(data, {\n          level: level,\n          parentUid: captionRow.uid\n        }));\n\n        for (let i = rowCnt - 1; i >= 0; i--) {\n          if (this.rows[i].isCaptionRow) {\n            this.rows[i].aggregatesCount = this.rows.length - rowCnt;\n          } else if (!this.rows[i].isCaptionRow && !this.rows[i].isDataRow) {\n            break;\n          }\n        }\n      }\n\n      if (preCaption) {\n        this.setInfiniteRowVisibility(preCaption);\n      }\n    }\n  }\n\n  isRenderAggregate(data) {\n    if (this.parent.enableInfiniteScrolling) {\n      if (!this.renderInfiniteAgg) {\n        return false;\n      }\n\n      this.getPreCaption(data.indent, data.data.key);\n      this.renderInfiniteAgg = data.data.count === this.infiniteChildCount;\n      return this.renderInfiniteAgg;\n    }\n\n    return !this.parent.enableInfiniteScrolling;\n  }\n\n  getPreCaption(indent, key) {\n    const rowObj = [...this.parent.getRowsObject(), ...this.rows];\n    let preCap;\n    this.infiniteChildCount = 0;\n    let i = rowObj.length;\n\n    while (i--) {\n      if (rowObj[i].isCaptionRow && rowObj[i].indent === indent && rowObj[i].data.key === key) {\n        preCap = rowObj[i];\n      }\n\n      if (rowObj[i].indent === indent || rowObj[i].indent < indent) {\n        break;\n      }\n\n      if (rowObj[i].indent === indent + 1) {\n        this.infiniteChildCount++;\n      }\n    }\n\n    return preCap;\n  }\n\n  getCaptionRowCells(field, indent, data) {\n    const cells = [];\n    let visibles = [];\n    let column = this.parent.getColumnByField(field);\n    const indexes = this.parent.getColumnIndexesInView();\n\n    if (this.parent.enableColumnVirtualization) {\n      column = this.parent.columns.filter(c => c.field === field)[0];\n    }\n\n    const groupedLen = this.parent.groupSettings.columns.length;\n    const gObj = this.parent;\n\n    if (!this.parent.enableColumnVirtualization || indexes.indexOf(indent) !== -1) {\n      for (let i = 0; i < indent; i++) {\n        cells.push(this.generateIndentCell());\n      }\n\n      cells.push(this.generateCell({}, null, CellType.Expand));\n    }\n\n    indent = this.parent.enableColumnVirtualization ? 1 : this.parent.getVisibleColumns().length + groupedLen + (gObj.detailTemplate || gObj.childGrid ? 1 : 0) - indent + (this.parent.getVisibleColumns().length ? -1 : 0); //Captionsummary cells will be added here.\n\n    if (this.parent.aggregates.length && !this.captionModelGen.isEmpty()) {\n      const captionCells = this.captionModelGen.generateRows(data)[0];\n      extend(data, captionCells.data);\n      let cIndex = 0;\n      captionCells.cells.some((cell, index) => {\n        cIndex = index;\n        return cell.visible && cell.isDataCell;\n      });\n      visibles = captionCells.cells.slice(cIndex).filter(cell => cell.visible);\n\n      if (captionCells.visible && visibles[0].column.field === this.parent.getVisibleColumns()[0].field) {\n        visibles = visibles.slice(1);\n      }\n\n      if (this.parent.getVisibleColumns().length === 1) {\n        visibles = [];\n      }\n\n      indent = indent - visibles.length;\n    }\n\n    const cols = !this.parent.enableColumnVirtualization ? [column] : this.parent.getColumns();\n    let wFlag = true;\n\n    for (let j = 0; j < cols.length; j++) {\n      const tmpFlag = wFlag && indexes.indexOf(indent) !== -1;\n\n      if (tmpFlag) {\n        wFlag = false;\n      }\n\n      const cellType = !this.parent.enableColumnVirtualization || tmpFlag ? CellType.GroupCaption : CellType.GroupCaptionEmpty;\n      indent = this.parent.enableColumnVirtualization && cellType === CellType.GroupCaption ? indent + groupedLen : indent;\n\n      if (gObj.isRowDragable()) {\n        indent++;\n      }\n\n      cells.push(this.generateCell(column, null, cellType, indent));\n    }\n\n    cells.push(...visibles);\n    return cells;\n  }\n  /**\n   * @param {GroupedData} data - specifies the data\n   * @param {number} indent - specifies the indent\n   * @param {number} parentID - specifies the parentID\n   * @param {number} childID - specifies the childID\n   * @param {number} tIndex - specifies the TIndex\n   * @param {string} parentUid - specifies the ParentUid\n   * @returns {Row<Column>} returns the Row object\n   * @hidden\n   */\n\n\n  generateCaptionRow(data, indent, parentID, childID, tIndex, parentUid) {\n    const options = {};\n    const records = 'records';\n    const col = this.parent.getColumnByField(data.field);\n    options.data = extend({}, data);\n\n    if (col) {\n      options.data.field = data.field;\n    }\n\n    options.isDataRow = false;\n    options.isExpand = !this.parent.groupSettings.enableLazyLoading && !this.parent.isCollapseStateEnabled();\n    options.parentGid = parentID;\n    options.childGid = childID;\n    options.tIndex = tIndex;\n    options.isCaptionRow = true;\n    options.parentUid = parentUid;\n    options.gSummary = !isNullOrUndefined(data.items[records]) ? data.items[records].length : data.items.length;\n    options.uid = getUid('grid-row');\n    const row = new Row(options);\n    row.indent = indent;\n    this.getForeignKeyData(row);\n    row.cells = this.getCaptionRowCells(data.field, indent, row.data);\n    return row;\n  }\n\n  getForeignKeyData(row) {\n    const data = row.data;\n    const col = this.parent.getColumnByField(data.field);\n\n    if (col && col.isForeignColumn && col.isForeignColumn()) {\n      const fkValue = isNullOrUndefined(data.key) ? '' : col.valueAccessor(col.foreignKeyValue, getForeignData(col, {}, data.key)[0], col);\n      setValue('foreignKey', fkValue, row.data);\n    }\n  }\n  /**\n   * @param {Object[]} data - specifies the data\n   * @param {number} indent - specifies the indent\n   * @param {number} childID - specifies the childID\n   * @param {number} tIndex - specifies the tIndex\n   * @param {string} parentUid - specifies the ParentUid\n   * @returns {Row<Column>[]} returns the row object\n   * @hidden\n   */\n\n\n  generateDataRows(data, indent, childID, tIndex, parentUid) {\n    const rows = [];\n    const indexes = this.parent.getColumnIndexesInView();\n\n    for (let i = 0, len = data.length; i < len; i++, tIndex++) {\n      rows[i] = this.generateRow(data[i], this.index, i ? undefined : 'e-firstchildrow', indent, childID, tIndex, parentUid);\n\n      for (let j = 0; j < indent; j++) {\n        if (this.parent.enableColumnVirtualization && indexes.indexOf(indent) === -1) {\n          continue;\n        }\n\n        rows[i].cells.unshift(this.generateIndentCell());\n      }\n\n      this.index++;\n    }\n\n    return rows;\n  }\n\n  generateIndentCell() {\n    return this.generateCell({}, null, CellType.Indent);\n  }\n\n  refreshRows(input) {\n    const indexes = this.parent.getColumnIndexesInView();\n\n    for (let i = 0; i < input.length; i++) {\n      if (input[i].isDataRow) {\n        input[i].cells = this.generateCells(input[i]);\n\n        for (let j = 0; j < input[i].indent; j++) {\n          if (this.parent.enableColumnVirtualization && indexes.indexOf(input[i].indent) === -1) {\n            continue;\n          }\n\n          input[i].cells.unshift(this.generateIndentCell());\n        }\n      } else {\n        const cRow = this.generateCaptionRow(input[i].data, input[i].indent);\n        input[i].cells = cRow.cells;\n      }\n    }\n\n    return input;\n  }\n\n  setInfiniteRowVisibility(caption) {\n    if (!caption.isExpand || caption.visible === false) {\n      for (const row of this.rows) {\n        if (row.parentUid === caption.uid) {\n          row.visible = false;\n\n          if (row.isCaptionRow) {\n            this.setInfiniteRowVisibility(row);\n          }\n        }\n      }\n    }\n  }\n\n  ensureRowVisibility() {\n    for (let i = 0; i < this.rows.length; i++) {\n      const row = this.rows[i];\n\n      if (!row.isCaptionRow) {\n        continue;\n      }\n\n      for (let j = i + 1; j < this.rows.length; j++) {\n        const childRow = this.rows[j];\n\n        if (row.uid === childRow.parentUid) {\n          this.rows[j].visible = row.isExpand;\n        }\n      }\n    }\n  }\n\n} // eslint-disable-next-line valid-jsdoc\n\n/**\n * Content module is used to render grid content\n *\n * @hidden\n */\n\n\nclass ContentRender {\n  /**\n   * Constructor for content renderer module\n   *\n   * @param {IGrid} parent - specifies the Igrid\n   * @param {ServiceLocator} serviceLocator - specifies the service locator\n   */\n  constructor(parent, serviceLocator) {\n    this.rows = [];\n    this.freezeRows = [];\n    this.movableRows = [];\n    this.freezeRowElements = [];\n    /** @hidden */\n\n    this.currentInfo = {};\n    /** @hidden */\n\n    this.prevCurrentView = [];\n    this.isLoaded = true;\n    this.viewColIndexes = [];\n\n    this.drop = e => {\n      this.parent.notify(columnDrop, {\n        target: e.target,\n        droppedElement: e.droppedElement\n      });\n      remove(e.droppedElement);\n    };\n\n    this.infiniteCache = {};\n    this.isRemove = false;\n    this.visibleRows = [];\n    this.visibleFrozenRows = [];\n    this.rightFreezeRows = [];\n    this.isAddRows = false;\n    this.isInfiniteFreeze = false;\n    this.useGroupCache = false;\n\n    this.rafCallback = args => {\n      const arg = args;\n      return () => {\n        if (this.parent.isFrozenGrid() && this.parent.enableVirtualization) {\n          const tableName = args.tableName;\n          this.isLoaded = this.parent.getFrozenMode() === leftRight ? tableName === 'frozen-right' : tableName === 'movable';\n\n          if (this.parent.enableColumnVirtualization && args.requestType === 'virtualscroll' && this.isLoaded) {\n            const mHdr = [].slice.call(this.parent.getMovableVirtualHeader().getElementsByClassName(row));\n            const fHdr = [].slice.call(this.parent.getFrozenVirtualHeader().getElementsByClassName(row));\n            this.isLoaded = mHdr.length === fHdr.length;\n          }\n        }\n\n        this.ariaService.setBusy(this.getPanel().querySelector('.' + content), false);\n\n        if (this.parent.isDestroyed) {\n          return;\n        }\n\n        let rows = this.rows.slice(0);\n\n        if (this.parent.enableInfiniteScrolling) {\n          rows = this.parent.getRowsObject();\n          const prevPage = arg.prevPage;\n\n          if (this.parent.infiniteScrollSettings.enableCache && prevPage) {\n            const maxBlock = this.parent.infiniteScrollSettings.maxBlocks;\n            rows = [];\n            const rowIdx = parseInt(this.rowElements[0].getAttribute('aria-rowindex'), 10) + 1;\n            const startIdx = Math.ceil(rowIdx / this.parent.pageSettings.pageSize);\n\n            for (let i = 0, count = startIdx; i < maxBlock; i++, count++) {\n              if (this.infiniteCache[count]) {\n                rows = [...rows, ...this.infiniteCache[count]];\n              }\n            }\n          }\n        }\n\n        if (this.parent.isFrozenGrid()) {\n          rows = args.isFrozen ? this.freezeRows : args.renderFrozenRightContent ? this.parent.getFrozenRightRowsObject() : this.movableRows;\n        }\n\n        this.parent.notify(contentReady, {\n          rows: rows,\n          args: arg\n        });\n\n        if (this.isLoaded) {\n          this.parent.isManualRefresh = false;\n          this.parent.trigger(dataBound, {}, () => {\n            if (this.parent.allowTextWrap) {\n              this.parent.notify(freezeRender, {\n                case: 'textwrap'\n              });\n            }\n          });\n        }\n\n        if (arg) {\n          const action = (arg.requestType || '').toLowerCase() + '-complete';\n          this.parent.notify(action, arg);\n\n          if (args.requestType === 'batchsave') {\n            args.cancel = false;\n            this.parent.trigger(actionComplete, args);\n          }\n        }\n\n        if (this.isLoaded) {\n          this.parent.hideSpinner();\n        }\n      };\n    };\n\n    this.parent = parent;\n    this.serviceLocator = serviceLocator;\n    this.ariaService = this.serviceLocator.getService('ariaService');\n    this.parent.enableDeepCompare = this.parent.getDataModule().isRemote();\n    this.generator = this.getModelGenerator();\n\n    if (this.parent.isDestroyed) {\n      return;\n    }\n\n    if (!this.parent.enableColumnVirtualization && !this.parent.enableVirtualization && !this.parent.groupSettings.enableLazyLoading) {\n      this.parent.on(columnVisibilityChanged, this.setVisible, this);\n    }\n\n    this.parent.on(colGroupRefresh, this.colGroupRefresh, this);\n    this.parent.on(uiUpdate, this.enableAfterRender, this);\n    this.parent.on(refreshInfiniteModeBlocks, this.refreshContentRows, this);\n    this.parent.on(beforeCellFocused, this.beforeCellFocused, this);\n    this.parent.on(destroy, this.droppableDestroy, this);\n  }\n\n  beforeCellFocused(e) {\n    if (e.byKey && (e.keyArgs.action === 'upArrow' || e.keyArgs.action === 'downArrow')) {\n      this.pressedKey = e.keyArgs.action;\n    } else {\n      this.pressedKey = undefined;\n    }\n  }\n  /**\n   * The function is used to render grid content div\n   *\n   * @returns {void}\n   */\n\n\n  renderPanel() {\n    const gObj = this.parent;\n    let div = this.parent.element.querySelector('.' + gridContent);\n\n    if (div) {\n      this.ariaService.setOptions(this.parent.element.querySelector('.' + content), {\n        busy: false\n      });\n      this.setPanel(div);\n      return;\n    }\n\n    div = this.parent.createElement('div', {\n      className: gridContent\n    });\n    const innerDiv = this.parent.createElement('div', {\n      className: content\n    });\n    this.ariaService.setOptions(innerDiv, {\n      busy: false\n    });\n    div.appendChild(innerDiv);\n    this.setPanel(div);\n    gObj.element.appendChild(div);\n  }\n  /**\n   * The function is used to render grid content table\n   *\n   * @returns {void}\n   */\n\n\n  renderTable() {\n    const contentDiv = this.getPanel();\n    const virtualTable = contentDiv.querySelector('.e-virtualtable');\n    const virtualTrack = contentDiv.querySelector('.e-virtualtrack');\n\n    if (this.parent.enableVirtualization && !isNullOrUndefined(virtualTable) && !isNullOrUndefined(virtualTrack)) {\n      remove(virtualTable);\n      remove(virtualTrack);\n    }\n\n    contentDiv.appendChild(this.createContentTable('_content_table'));\n    this.setTable(contentDiv.querySelector('.' + table));\n    this.ariaService.setOptions(this.getTable(), {\n      multiselectable: this.parent.selectionSettings.type === 'Multiple'\n    });\n    this.initializeContentDrop();\n\n    if (this.parent.frozenRows) {\n      this.parent.getHeaderContent().classList.add('e-frozenhdrcont');\n    }\n  }\n  /**\n   * The function is used to create content table elements\n   *\n   * @param {string} id - specifies the id\n   * @returns {Element} returns the element\n   * @hidden\n   */\n\n\n  createContentTable(id) {\n    const innerDiv = this.getPanel().firstElementChild;\n\n    if (this.getTable()) {\n      remove(this.getTable());\n    }\n\n    const table$$1 = innerDiv.querySelector('.' + table) ? innerDiv.querySelector('.' + table) : this.parent.createElement('table', {\n      className: table,\n      attrs: {\n        cellspacing: '0.25px',\n        role: 'grid',\n        id: this.parent.element.id + id\n      }\n    });\n    this.setColGroup(this.parent.getHeaderTable().querySelector(colGroup).cloneNode(true));\n    table$$1.appendChild(this.getColGroup());\n    table$$1.appendChild(this.parent.createElement(tbody));\n    innerDiv.appendChild(table$$1);\n    return innerDiv;\n  }\n  /**\n   * Refresh the content of the Grid.\n   *\n   * @param {NotifyArgs} args - specifies the args\n   * @returns {void}\n   */\n  // tslint:disable-next-line:max-func-body-length\n\n\n  refreshContentRows(args = {}) {\n    const gObj = this.parent;\n\n    if (gObj.currentViewData.length === 0) {\n      return;\n    }\n\n    const dataSource = this.currentMovableRows || gObj.currentViewData;\n    const contentModule = this.parent.contentModule;\n    const isReact = gObj.isReact && !isNullOrUndefined(gObj.rowTemplate);\n    let frag = isReact ? gObj.createElement(tbody) : document.createDocumentFragment();\n\n    if (!this.initialPageRecords) {\n      this.initialPageRecords = extend([], dataSource);\n    }\n\n    const hdrfrag = isReact ? gObj.createElement(tbody) : document.createDocumentFragment();\n    const columns = gObj.getColumns();\n    let tr;\n    let hdrTbody;\n    const frzCols = gObj.getFrozenColumns();\n    const isFrozenGrid = this.parent.isFrozenGrid();\n    let trElement;\n    const row$$1 = new RowRenderer(this.serviceLocator, null, this.parent);\n    const isInfiniteScroll = this.parent.enableInfiniteScrolling && args.requestType === 'infiniteScroll';\n    gObj.notify(destroyChildGrid, {});\n    this.rowElements = [];\n    this.rows = [];\n    const fCont = this.getPanel().querySelector('.' + frozenContent);\n    const mCont = this.getPanel().querySelector('.' + movableContent);\n    const cont = this.getPanel().querySelector('.' + content);\n    let tbdy;\n    let tableName;\n\n    if (isGroupAdaptive(gObj)) {\n      if (['sorting', 'filtering', 'searching', 'grouping', 'ungrouping', 'reorder'].some(value => {\n        return args.requestType === value;\n      })) {\n        this.emptyVcRows();\n      }\n    }\n\n    let modelData;\n\n    if (this.parent.enableVirtualization && this.parent.isFrozenGrid()) {\n      if (this.parent.enableColumnVirtualization && args.requestType === 'virtualscroll' && args.virtualInfo.sentinelInfo.axis === 'X') {\n        modelData = this.parent.contentModule.generateRows(dataSource, args);\n        args.renderMovableContent = true;\n      }\n\n      modelData = this.parent.contentModule.generateRows(dataSource, args);\n    } else {\n      modelData = this.checkCache(modelData, args);\n\n      if (!this.isAddRows && !this.useGroupCache) {\n        modelData = this.generator.generateRows(dataSource, args);\n      }\n    }\n\n    this.setGroupCache(modelData, args);\n    this.parent.notify(setInfiniteCache, {\n      isInfiniteScroll: isInfiniteScroll,\n      modelData: modelData,\n      args: args\n    });\n    const idx = modelData[0].cells[0].index;\n\n    if (isFrozenGrid) {\n      tableName = contentModule.setTbody(modelData, args);\n      tbdy = contentModule.getTbody(tableName);\n    }\n\n    const isFrozenLeft = this.parent.getFrozenMode() === leftRight && tableName === frozenRight;\n    /* eslint-disable */\n\n    if (args.requestType !== 'infiniteScroll' && this.parent.registeredTemplate && this.parent.registeredTemplate.template && !args.isFrozen && !isFrozenLeft) {\n      const templatetoclear = [];\n\n      for (let i = 0; i < this.parent.registeredTemplate.template.length; i++) {\n        for (let j = 0; j < this.parent.registeredTemplate.template[i].rootNodes.length; j++) {\n          if (isNullOrUndefined(this.parent.registeredTemplate.template[i].rootNodes[j].parentNode)) {\n            templatetoclear.push(this.parent.registeredTemplate.template[i]);\n            /* eslint-enable */\n          }\n        }\n      }\n\n      this.parent.destroyTemplate(['template'], templatetoclear);\n    }\n\n    if ((this.parent.isReact || this.parent.isVue) && args.requestType !== 'infiniteScroll' && !args.isFrozen) {\n      const templates = [this.parent.isVue ? 'template' : 'columnTemplate', 'rowTemplate', 'detailTemplate', 'captionTemplate', 'commandsTemplate', 'groupFooterTemplate', 'groupCaptionTemplate'];\n      clearReactVueTemplates(this.parent, templates);\n    }\n\n    if (this.parent.enableColumnVirtualization) {\n      const cellMerge = new CellMergeRender(this.serviceLocator, this.parent);\n      cellMerge.updateVirtualCells(modelData);\n    }\n\n    if (!isFrozenGrid) {\n      this.tbody = this.getTable().querySelector(tbody);\n    }\n\n    let startIndex = 0;\n    let blockLoad = true;\n\n    if (isGroupAdaptive(gObj) && gObj.vcRows.length) {\n      const top = 'top';\n      const scrollTop = !isNullOrUndefined(args.virtualInfo.offsets) ? args.virtualInfo.offsets.top : !isNullOrUndefined(args.scrollTop) ? args.scrollTop[top] : 0;\n\n      if (scrollTop !== 0) {\n        const offsets = gObj.vGroupOffsets;\n        const bSize = gObj.pageSettings.pageSize / 2;\n        const values = Object.keys(offsets).map(key => offsets[key]);\n\n        for (let m = 0; m < values.length; m++) {\n          if (scrollTop < values[m]) {\n            if (!isNullOrUndefined(args.virtualInfo) && args.virtualInfo.direction === 'up') {\n              startIndex = m > 0 ? (m - 1) * bSize : m * bSize;\n              break;\n            } else {\n              startIndex = m * bSize;\n\n              if (this.parent.contentModule.isEndBlock(m) || this.parent.contentModule.isEndBlock(m + 1)) {\n                args.virtualInfo.blockIndexes = [m, m + 1];\n              }\n\n              break;\n            }\n          }\n        }\n\n        if (Math.round(scrollTop + this.contentPanel.firstElementChild.offsetHeight) >= this.contentPanel.firstElementChild.scrollHeight && !args.rowObject) {\n          blockLoad = false;\n        }\n      }\n    }\n\n    const isVFFrozenOnly = gObj.frozenRows && !gObj.isFrozenGrid() && this.parent.enableVirtualization && args.requestType === 'reorder';\n\n    if (gObj.frozenRows && args.requestType === 'virtualscroll' && args.virtualInfo.sentinelInfo.axis === 'X' || isVFFrozenOnly) {\n      const bIndex = args.virtualInfo.blockIndexes;\n      const page = args.virtualInfo.page;\n      args.virtualInfo.blockIndexes = [1, 2];\n\n      if (isVFFrozenOnly) {\n        args.virtualInfo.page = 1;\n      }\n\n      const data = isVFFrozenOnly ? this.initialPageRecords : dataSource;\n      const mhdrData = this.vgenerator.generateRows(data, args);\n      mhdrData.splice(this.parent.frozenRows);\n\n      for (let i = 0; i < this.parent.frozenRows; i++) {\n        mhdrData[i].cells.splice(0, this.parent.getFrozenColumns());\n        tr = row$$1.render(mhdrData[i], columns);\n        hdrfrag.appendChild(tr);\n      }\n\n      args.virtualInfo.blockIndexes = bIndex;\n      args.virtualInfo.page = page;\n\n      if (isVFFrozenOnly && args.virtualInfo.page === 1) {\n        modelData.splice(0, this.parent.frozenRows);\n      }\n    }\n\n    this.virtualFrozenHdrRefresh(hdrfrag, modelData, row$$1, args, dataSource, columns);\n\n    for (let i = startIndex, len = modelData.length; i < len; i++) {\n      this.rows.push(modelData[i]);\n\n      if (this.parent.groupSettings.enableLazyLoading && !this.useGroupCache && this.parent.groupSettings.columns.length) {\n        this.setRowsInLazyGroup(modelData[i], i);\n\n        if (isNullOrUndefined(modelData[i].indent)) {\n          continue;\n        }\n      }\n\n      this.setInfiniteVisibleRows(args, modelData[i], tableName);\n\n      if (isGroupAdaptive(gObj) && args.virtualInfo && args.virtualInfo.blockIndexes && this.rowElements.length >= args.virtualInfo.blockIndexes.length * this.parent.contentModule.getBlockSize() && blockLoad) {\n        this.parent.currentViewData['records'] = this.rows.map(m => m.data);\n        break;\n      }\n\n      if (!gObj.rowTemplate) {\n        tr = row$$1.render(modelData[i], columns);\n        const isVFreorder = this.ensureFrozenHeaderRender(args);\n\n        if (gObj.frozenRows && i < gObj.frozenRows && !isInfiniteScroll && args.requestType !== 'virtualscroll' && isVFreorder && this.ensureVirtualFrozenHeaderRender(args)) {\n          hdrfrag.appendChild(tr);\n        } else {\n          frag.appendChild(tr);\n        }\n\n        if (modelData[i].isExpand) {\n          gObj.notify(expandChildGrid, tr.cells[gObj.groupSettings.columns.length]);\n        }\n      } else {\n        const rowTemplateID = gObj.element.id + 'rowTemplate';\n        let elements;\n\n        if (gObj.isReact) {\n          const isHeader = gObj.frozenRows && i < gObj.frozenRows;\n          const copied = extend({\n            index: i\n          }, dataSource[i]);\n          gObj.getRowTemplate()(copied, gObj, 'rowTemplate', rowTemplateID, null, null, isHeader ? hdrfrag : frag);\n          gObj.renderTemplates();\n        } else {\n          elements = gObj.getRowTemplate()(extend({\n            index: i\n          }, dataSource[i]), gObj, 'rowTemplate', rowTemplateID);\n        }\n\n        if (!gObj.isReact && elements[0].tagName === 'TBODY') {\n          for (let j = 0; j < elements.length; j++) {\n            const isTR = elements[j].nodeName.toLowerCase() === 'tr';\n\n            if (isTR || elements[j].querySelectorAll && elements[j].querySelectorAll('tr').length) {\n              tr = isTR ? elements[j] : elements[j].querySelector('tr');\n            }\n          }\n\n          if (gObj.frozenRows && i < gObj.frozenRows) {\n            hdrfrag.appendChild(tr);\n          } else {\n            frag.appendChild(tr);\n          }\n        } else {\n          if (gObj.frozenRows && i < gObj.frozenRows) {\n            tr = !gObj.isReact ? appendChildren(hdrfrag, elements) : hdrfrag.lastElementChild;\n          } else {\n            // frag.appendChild(tr);\n            if (!gObj.isReact) {\n              tr = appendChildren(frag, elements);\n            }\n\n            trElement = gObj.isReact ? frag.lastElementChild : tr.lastElementChild;\n          }\n        }\n\n        const arg = {\n          data: modelData[i].data,\n          row: trElement ? trElement : tr\n        };\n        this.parent.trigger(rowDataBound, arg);\n      }\n\n      if (modelData[i].isDataRow) {\n        this.rowElements.push(tr);\n      }\n\n      this.ariaService.setOptions(this.getTable(), {\n        colcount: gObj.getColumns().length.toString()\n      });\n    }\n\n    if (isFrozenGrid) {\n      contentModule.splitRows(tableName);\n    }\n\n    if (gObj.frozenRows && args.requestType !== 'virtualscroll' && !isInfiniteScroll && this.ensureVirtualFrozenHeaderRender(args) || args.requestType === 'virtualscroll' && args.virtualInfo.sentinelInfo && args.virtualInfo.sentinelInfo.axis === 'X') {\n      hdrTbody = isFrozenGrid ? contentModule.getFrozenHeader(tableName) : gObj.getHeaderTable().querySelector(tbody);\n\n      if (isReact) {\n        const parentTable = hdrTbody.parentElement;\n        remove(hdrTbody);\n        parentTable.appendChild(hdrfrag);\n      } else {\n        hdrTbody.innerHTML = '';\n        hdrTbody.appendChild(hdrfrag);\n      }\n    }\n\n    if (!gObj.enableVirtualization && gObj.frozenRows && idx === 0 && cont.offsetHeight === Number(gObj.height)) {\n      cont.style.height = cont.offsetHeight - hdrTbody.offsetHeight + 'px';\n    }\n\n    args.rows = this.rows.slice(0);\n\n    if (isFrozenGrid) {\n      contentModule.setIsFrozen(args, tableName);\n    }\n\n    this.index = idx;\n    getUpdateUsingRaf(() => {\n      this.parent.notify(beforeFragAppend, args);\n      const isVFTable = this.parent.enableVirtualization && this.parent.isFrozenGrid();\n\n      if (!this.parent.enableVirtualization && !isInfiniteScroll) {\n        if (this.parent.isFrozenGrid()) {\n          remove(contentModule.getTbody(tableName));\n          tbdy = this.parent.createElement(tbody);\n        } else {\n          this.tbody.innerHTML = '';\n          remove(this.tbody);\n          this.tbody = this.parent.createElement(tbody);\n        }\n      }\n\n      if (isFrozenGrid && !isVFTable && !this.parent.enableInfiniteScrolling) {\n        this.appendContent(tbdy, frag, args, tableName);\n      } else {\n        if (gObj.rowTemplate) {\n          updateBlazorTemplate(gObj.element.id + 'rowTemplate', 'RowTemplate', gObj);\n        }\n\n        if (isVFTable) {\n          if (args.renderFrozenRightContent) {\n            const frCont = gObj.getContent().querySelector('.e-frozen-right-content').querySelector(tbody);\n            this.appendContent(frCont, frag, args);\n          } else if (!args.renderMovableContent) {\n            this.appendContent(fCont.querySelector(tbody), frag, args);\n          } else {\n            this.appendContent(mCont.querySelector(tbody), frag, args);\n            args.renderMovableContent = false;\n          }\n\n          if (!this.parent.getFrozenColumns()) {\n            contentModule.renderNextFrozentPart(args, tableName);\n          }\n        } else {\n          if (!isNullOrUndefined(this.parent.infiniteScrollModule) && this.parent.enableInfiniteScrolling) {\n            this.isAddRows = false;\n            this.parent.notify(removeInfiniteRows, {\n              args: args\n            });\n            this.parent.notify(appendInfiniteContent, {\n              tbody: tbdy ? tbdy : this.tbody,\n              frag: frag,\n              args: args,\n              rows: this.rows,\n              rowElements: this.rowElements,\n              visibleRows: this.visibleRows,\n              tableName: tableName\n            });\n\n            if (!frzCols && isFrozenGrid) {\n              if (gObj.getFrozenMode() !== leftRight && (tableName === frozenLeft || tableName === frozenRight) || gObj.getFrozenMode() === leftRight && (tableName === frozenLeft || tableName === 'movable')) {\n                this.refreshContentRows(extend({}, args));\n              }\n            }\n          } else {\n            this.useGroupCache = false;\n            this.appendContent(this.tbody, frag, args);\n          }\n        }\n      }\n\n      if (frzCols) {\n        contentModule.renderNextFrozentPart(args, tableName);\n      }\n\n      frag = null;\n    }, this.rafCallback(extend({}, args)));\n  }\n\n  emptyVcRows() {\n    this.parent.vcRows = [];\n    this.parent.vRows = [];\n  } // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  appendContent(tbody$$1, frag, args, tableName) {\n    const isReact = this.parent.isReact && !isNullOrUndefined(this.parent.rowTemplate);\n\n    if (isReact) {\n      this.getTable().appendChild(frag);\n    } else {\n      tbody$$1.appendChild(frag);\n      this.getTable().appendChild(tbody$$1);\n    }\n  }\n\n  setRowsInLazyGroup(row$$1, index) {\n    if (this.parent.groupSettings.enableLazyLoading && !this.useGroupCache && this.parent.groupSettings.columns.length) {\n      this.parent.contentModule.maintainRows(row$$1, index);\n    }\n  }\n\n  setGroupCache(data, args) {\n    if (!this.useGroupCache && this.parent.groupSettings.enableLazyLoading) {\n      this.parent.notify(setGroupCache, {\n        args: args,\n        data: data\n      });\n    }\n  }\n\n  ensureFrozenHeaderRender(args) {\n    return !(this.parent.enableVirtualization && (args.requestType === 'reorder' || args.requestType === 'refresh') || this.parent.infiniteScrollSettings.enableCache && this.parent.frozenRows && this.parent.infiniteScrollModule.requestType === 'delete' && this.parent.pageSettings.currentPage !== 1);\n  }\n\n  ensureVirtualFrozenHeaderRender(args) {\n    return !(this.parent.enableVirtualization && args.requestType === 'delete');\n  }\n\n  checkCache(modelData, args) {\n    if (this.parent.infiniteScrollSettings.enableCache && args.requestType === 'infiniteScroll') {\n      const index = args.isFrozen ? 1 : 0;\n      const frozenCols = this.parent.isFrozenGrid();\n      this.isAddRows = !isNullOrUndefined(this.infiniteCache[this.parent.pageSettings.currentPage]);\n\n      if (frozenCols && !isNullOrUndefined(this.infiniteCache[this.parent.pageSettings.currentPage])) {\n        this.isAddRows = this.infiniteCache[this.parent.pageSettings.currentPage][index].length !== 0;\n      }\n\n      if (this.isAddRows) {\n        const data = !frozenCols ? this.infiniteCache[this.parent.pageSettings.currentPage] : this.infiniteCache[this.parent.pageSettings.currentPage][index];\n        modelData = this.parent.pageSettings.currentPage === 1 ? data.slice(this.parent.frozenRows) : data;\n      }\n\n      return modelData;\n    }\n\n    if (this.parent.groupSettings.enableLazyLoading && this.parent.groupSettings.columns.length && (args.requestType === 'paging' || args.requestType === 'columnstate' || args.requestType === 'reorder') && this.parent.contentModule.getGroupCache()[this.parent.pageSettings.currentPage]) {\n      this.useGroupCache = true;\n      return this.parent.contentModule.initialGroupRows(args.requestType === 'reorder');\n    }\n\n    return null;\n  }\n\n  setInfiniteVisibleRows(args, data, tableName) {\n    const frozenCols = this.parent.isFrozenGrid();\n\n    if (this.parent.enableInfiniteScrolling && !this.parent.infiniteScrollSettings.enableCache) {\n      if (frozenCols) {\n        if (tableName === frozenLeft || this.parent.getFrozenMode() === 'Right' && tableName === frozenRight) {\n          this.visibleFrozenRows.push(data);\n        } else if (tableName === 'movable') {\n          this.visibleRows.push(data);\n        } else {\n          this.rightFreezeRows.push(data);\n        }\n      } else if (!this.parent.infiniteScrollSettings.enableCache) {\n        this.visibleRows.push(data);\n      }\n    }\n  }\n\n  getCurrentBlockInfiniteRecords(isFreeze) {\n    let data = [];\n\n    if (this.parent.infiniteScrollSettings.enableCache) {\n      if (!Object.keys(this.infiniteCache).length) {\n        return [];\n      }\n\n      const frozenCols = this.parent.isFrozenGrid();\n      const rows = this.parent.getRows();\n      let index = parseInt(rows[this.parent.frozenRows].getAttribute(ariaRowIndex), 10);\n      const first = Math.ceil((index + 1) / this.parent.pageSettings.pageSize);\n      index = parseInt(rows[rows.length - 1].getAttribute(ariaRowIndex), 10);\n      const last = Math.ceil(index / this.parent.pageSettings.pageSize);\n\n      if (frozenCols) {\n        const idx = isFreeze ? 0 : 1;\n\n        for (let i = first; i <= last; i++) {\n          data = !data.length ? this.infiniteCache[i][idx] : data.concat(this.infiniteCache[i][idx]);\n        }\n\n        if (this.parent.frozenRows && this.parent.pageSettings.currentPage > 1) {\n          data = this.infiniteCache[1][idx].slice(0, this.parent.frozenRows).concat(data);\n        }\n      } else {\n        for (let i = first; i <= last; i++) {\n          data = !data.length ? this.infiniteCache[i] : data.concat(this.infiniteCache[i]);\n        }\n\n        if (this.parent.frozenRows && this.parent.pageSettings.currentPage > 1) {\n          data = this.infiniteCache[1].slice(0, this.parent.frozenRows).concat(data);\n        }\n      }\n    }\n\n    return data;\n  }\n\n  getReorderedVFRows(args) {\n    return this.parent.contentModule.getReorderedFrozenRows(args);\n  }\n\n  getReorderedRows(args) {\n    return this.parent.contentModule.getReorderedFrozenRows(args);\n  }\n\n  virtualFrozenHdrRefresh(hdrfrag, modelData, row$$1, args, dataSource, columns) {\n    if (this.parent.frozenRows && this.parent.enableVirtualization && (args.requestType === 'reorder' || args.requestType === 'refresh')) {\n      let tr;\n      let fhdrData = [];\n\n      if (this.parent.isFrozenGrid()) {\n        this.currentMovableRows = dataSource;\n        fhdrData = this.getReorderedVFRows(args);\n      } else {\n        fhdrData = this.getReorderedRows(args);\n      }\n\n      for (let i = 0; i < fhdrData.length; i++) {\n        tr = row$$1.render(fhdrData[i], columns);\n        hdrfrag.appendChild(tr);\n      }\n\n      if (args.virtualInfo.page === 1) {\n        modelData.splice(0, this.parent.frozenRows);\n      }\n\n      if (args.renderMovableContent) {\n        this.parent.currentViewData = this.currentMovableRows;\n        this.currentMovableRows = null;\n      }\n    }\n  }\n\n  getInfiniteRows() {\n    let rows = [];\n    const frozenCols = this.parent.isFrozenGrid();\n\n    if (this.parent.enableInfiniteScrolling) {\n      if (this.parent.infiniteScrollSettings.enableCache) {\n        const keys = Object.keys(this.infiniteCache);\n\n        for (let i = 0; i < keys.length; i++) {\n          rows = !frozenCols ? [...rows, ...this.infiniteCache[keys[i]]] : [...rows, ...this.infiniteCache[keys[i]][0]];\n        }\n      } else {\n        rows = frozenCols ? this.visibleFrozenRows : this.visibleRows;\n      }\n    }\n\n    return rows;\n  }\n\n  getInfiniteMovableRows() {\n    const infiniteCacheRows = this.getCurrentBlockInfiniteRecords();\n    const infiniteRows = this.parent.enableInfiniteScrolling ? infiniteCacheRows.length ? infiniteCacheRows : this.visibleRows : [];\n    return infiniteRows;\n  }\n  /**\n   * Get the content div element of grid\n   *\n   * @returns {Element} returns the element\n   */\n\n\n  getPanel() {\n    return this.contentPanel;\n  }\n  /**\n   * Set the content div element of grid\n   *\n   * @param  {Element} panel - specifies the panel\n   * @returns {void}\n   */\n\n\n  setPanel(panel) {\n    this.contentPanel = panel;\n  }\n  /**\n   * Get the content table element of grid\n   *\n   * @returns {Element} returns the element\n   */\n\n\n  getTable() {\n    return this.contentTable;\n  }\n  /**\n   * Set the content table element of grid\n   *\n   * @param  {Element} table - specifies the table\n   * @returns {void}\n   */\n\n\n  setTable(table$$1) {\n    this.contentTable = table$$1;\n  }\n  /**\n   * Get the Movable Row collection in the Freeze pane Grid.\n   *\n   * @returns {Row[] | HTMLCollectionOf<HTMLTableRowElement>} returns the row\n   */\n\n\n  getRows() {\n    const infiniteRows = this.getInfiniteRows();\n    return infiniteRows.length ? infiniteRows : this.parent.getFrozenColumns() ? this.freezeRows : this.rows;\n  }\n  /**\n   * Get the Movable Row collection in the Freeze pane Grid.\n   *\n   * @returns {Row[] | HTMLCollectionOf<HTMLTableRowElement>} returns the row\n   */\n\n\n  getMovableRows() {\n    const infiniteRows = this.getInfiniteMovableRows();\n    return infiniteRows.length ? infiniteRows : this.movableRows;\n  }\n  /**\n   * Get the content table data row elements\n   *\n   * @returns {Element} returns the element\n   */\n\n\n  getRowElements() {\n    return this.parent.getFrozenColumns() ? this.freezeRowElements : this.rowElements;\n  }\n  /**\n   * Get the Freeze pane movable content table data row elements\n   *\n   * @returns {Element} returns the element\n   */\n\n\n  getMovableRowElements() {\n    return this.rowElements;\n  }\n  /**\n   * Get the content table data row elements\n   *\n   * @param {Element[]} elements - specifies the elements\n   * @returns {void}\n   */\n\n\n  setRowElements(elements) {\n    this.rowElements = elements;\n  }\n  /**\n   * Get the header colgroup element\n   *\n   * @returns {Element} returns the element\n   */\n\n\n  getColGroup() {\n    return this.colgroup;\n  }\n  /**\n   * Set the header colgroup element\n   *\n   * @param {Element} colGroup - specifies the colgroup\n   * @returns {Element} returns the element\n   */\n\n\n  setColGroup(colGroup$$1) {\n    if (!isNullOrUndefined(colGroup$$1)) {\n      colGroup$$1.id = 'content-' + colGroup$$1.id;\n    }\n\n    return this.colgroup = colGroup$$1;\n  }\n  /**\n   * Function to hide content table column based on visible property\n   *\n   * @param {Column[]} columns - specifies the column\n   * @returns {void}\n   */\n\n\n  setVisible(columns) {\n    const gObj = this.parent;\n    const isFrozenGrid = this.parent.isFrozenGrid();\n    const frzCols = gObj.getFrozenColumns();\n    let rows = [];\n\n    if (isFrozenGrid) {\n      const fRows = this.freezeRows;\n      const mRows = this.movableRows;\n      const rowLen = fRows.length;\n      let cellLen;\n      let rightRows = [];\n\n      if (gObj.getFrozenMode() === leftRight) {\n        rightRows = gObj.getFrozenRightRowsObject();\n      }\n\n      for (let i = 0, row$$1; i < rowLen; i++) {\n        cellLen = mRows[i].cells.length;\n        const rightLen = rightRows.length ? rightRows[i].cells.length : 0;\n        row$$1 = fRows[i].clone();\n\n        for (let j = 0; j < cellLen; j++) {\n          row$$1.cells.push(mRows[i].cells[j]);\n        }\n\n        for (let k = 0; k < rightLen; k++) {\n          row$$1.cells.push(rightRows[i].cells[k]);\n        }\n\n        rows.push(row$$1);\n      }\n    } else {\n      rows = this.getRows();\n    }\n\n    let testRow;\n    rows.some(r => {\n      if (r.isDataRow) {\n        testRow = r;\n      }\n\n      return r.isDataRow;\n    });\n    let needFullRefresh = true;\n\n    if (!gObj.groupSettings.columns.length && testRow) {\n      needFullRefresh = false;\n    }\n\n    let tr = gObj.getDataRows();\n    const args = {};\n    const infiniteData = this.infiniteRowVisibility();\n    let contentrows = infiniteData ? infiniteData : this.rows.filter(row$$1 => !row$$1.isDetailRow);\n\n    for (let c = 0, clen = columns.length; c < clen; c++) {\n      const column = columns[c];\n      let idx = this.parent.getNormalizedColumnIndex(column.uid);\n      let colIdx = this.parent.getColumnIndexByUid(column.uid);\n      const displayVal = column.visible === true ? '' : 'none';\n\n      if (idx !== -1 && testRow && idx < testRow.cells.length) {\n        if (isFrozenGrid) {\n          if (column.getFreezeTableName() !== 'movable') {\n            if (column.getFreezeTableName() === frozenRight) {\n              const left = this.parent.getFrozenLeftColumnsCount();\n              const movable = this.parent.getMovableColumnsCount();\n              colIdx = idx = idx - (left + movable);\n              const colG = this.parent.getContent().querySelector('.e-frozen-right-content').querySelector(colGroup);\n              setStyleAttribute(colG.childNodes[idx], {\n                'display': displayVal\n              });\n              contentrows = gObj.getFrozenRightRowsObject();\n              tr = gObj.getFrozenRightDataRows();\n            } else {\n              setStyleAttribute(this.getColGroup().childNodes[idx], {\n                'display': displayVal\n              });\n              const infiniteFreezeData = this.infiniteRowVisibility(true);\n              contentrows = infiniteFreezeData ? infiniteFreezeData : this.freezeRows;\n              tr = gObj.getDataRows();\n            }\n          } else {\n            const mTable = gObj.getContent().querySelector('.' + movableContent).querySelector(colGroup);\n            colIdx = idx = idx - frzCols - this.parent.getFrozenLeftColumnsCount();\n            setStyleAttribute(mTable.childNodes[idx], {\n              'display': displayVal\n            });\n            tr = gObj.getMovableDataRows();\n            const infiniteMovableData = this.infiniteRowVisibility();\n            contentrows = infiniteMovableData ? infiniteMovableData : this.movableRows;\n          }\n        } else {\n          setStyleAttribute(this.getColGroup().childNodes[idx], {\n            'display': displayVal\n          });\n        }\n      }\n\n      if (!needFullRefresh) {\n        this.setDisplayNone(tr, colIdx, displayVal, contentrows);\n      }\n\n      if (!this.parent.invokedFromMedia && column.hideAtMedia) {\n        this.parent.updateMediaColumns(column);\n      }\n\n      this.parent.invokedFromMedia = false;\n    }\n\n    if (needFullRefresh) {\n      this.refreshContentRows({\n        requestType: 'refresh'\n      });\n    } else {\n      if (!this.parent.getFrozenColumns()) {\n        this.parent.notify(partialRefresh, {\n          rows: contentrows,\n          args: args\n        });\n      } else {\n        this.parent.notify(partialRefresh, {\n          rows: this.freezeRows,\n          args: {\n            isFrozen: true,\n            rows: this.freezeRows\n          }\n        });\n        this.parent.notify(partialRefresh, {\n          rows: this.movableRows,\n          args: {\n            isFrozen: false,\n            rows: this.movableRows\n          }\n        });\n      }\n    }\n  }\n  /**\n   * @param {Object} tr - specifies the trr\n   * @param {number} idx - specifies the idx\n   * @param {string} displayVal - specifies the displayval\n   * @param {Row<Column>} rows - specifies the rows\n   * @returns {void}\n   * @hidden\n   */\n\n\n  setDisplayNone(tr, idx, displayVal, rows) {\n    setDisplayValue(tr, idx, displayVal, rows, this.parent, this.parent.isRowDragable());\n    this.parent.notify(infiniteShowHide, {\n      visible: displayVal,\n      index: idx,\n      isFreeze: this.isInfiniteFreeze\n    });\n  }\n\n  infiniteRowVisibility(isFreeze) {\n    let infiniteData;\n\n    if (this.parent.enableInfiniteScrolling) {\n      this.isInfiniteFreeze = isFreeze;\n\n      if (this.parent.infiniteScrollSettings.enableCache) {\n        infiniteData = isFreeze ? this.getCurrentBlockInfiniteRecords(true) : this.getCurrentBlockInfiniteRecords();\n      } else {\n        infiniteData = isFreeze ? this.visibleFrozenRows : this.visibleRows;\n      }\n    }\n\n    return infiniteData;\n  }\n\n  colGroupRefresh() {\n    if (this.getColGroup()) {\n      let colGroup$$1;\n\n      if (this.parent.enableColumnVirtualization && this.parent.getFrozenColumns() && this.parent.contentModule.isXaxis()) {\n        colGroup$$1 = this.parent.getMovableVirtualHeader().querySelector(colGroup).cloneNode(true);\n      } else {\n        colGroup$$1 = this.getHeaderColGroup();\n      }\n\n      this.getTable().replaceChild(colGroup$$1, this.getColGroup());\n      this.setColGroup(colGroup$$1);\n    }\n  }\n\n  getHeaderColGroup() {\n    return this.parent.element.querySelector('.' + gridHeader).querySelector(colGroup).cloneNode(true);\n  }\n\n  initializeContentDrop() {\n    const gObj = this.parent;\n    this.droppable = new Droppable(gObj.element, {\n      accept: '.e-dragclone',\n      drop: this.drop\n    });\n  }\n\n  droppableDestroy() {\n    if (this.droppable && !this.droppable.isDestroyed) {\n      this.droppable.destroy();\n    }\n  }\n\n  canSkip(column, row$$1, index) {\n    /**\n     * Skip the toggle visiblity operation when one of the following success\n     * 1. Grid has empty records\n     * 2. column visible property is unchanged\n     * 3. cell`s isVisible property is same as column`s visible property.\n     */\n    return isNullOrUndefined(row$$1) || //(1)\n    isNullOrUndefined(column.visible) || //(2)\n    row$$1.cells[index].visible === column.visible; //(3)\n  }\n\n  getModelGenerator() {\n    return this.generator = this.parent.allowGrouping ? new GroupModelGenerator(this.parent) : new RowModelGenerator(this.parent);\n  }\n\n  renderEmpty(tbody$$1) {\n    this.getTable().appendChild(tbody$$1);\n\n    if (this.parent.frozenRows) {\n      this.parent.getHeaderContent().querySelector(tbody).innerHTML = '';\n    }\n  }\n\n  setSelection(uid, set, clearAll) {\n    this.parent.notify(setFreezeSelection, {\n      uid: uid,\n      set: set,\n      clearAll: clearAll\n    });\n    const isFrozen = this.parent.isFrozenGrid();\n\n    if (isFrozen && this.parent.enableVirtualization) {\n      return;\n    }\n\n    if (isFrozen) {\n      const rows = this.getMovableRows().filter(row$$1 => clearAll || uid === row$$1.uid);\n\n      for (let i = 0; i < rows.length; i++) {\n        rows[i].isSelected = set;\n      }\n    }\n\n    const row$$1 = this.getRows().filter(row$$1 => clearAll || uid === row$$1.uid);\n\n    for (let j = 0; j < row$$1.length; j++) {\n      row$$1[j].isSelected = set;\n      const cells = row$$1[j].cells;\n\n      for (let k = 0; k < cells.length; k++) {\n        cells[k].isSelected = set;\n      }\n    }\n  }\n\n  getRowByIndex(index) {\n    index = this.getInfiniteRowIndex(index);\n    return this.parent.getDataRows()[index];\n  }\n\n  getInfiniteRowIndex(index) {\n    if (this.parent.infiniteScrollSettings.enableCache) {\n      const fRows = this.parent.frozenRows;\n      const idx = fRows > index ? 0 : fRows;\n      const firstRowIndex = parseInt(this.parent.getRows()[idx].getAttribute(ariaRowIndex), 10);\n      index = fRows > index ? index : index - firstRowIndex + fRows;\n    }\n\n    return index;\n  }\n\n  getVirtualRowIndex(index) {\n    return index;\n  }\n\n  getMovableRowByIndex(index) {\n    index = this.getInfiniteRowIndex(index);\n    return this.parent.getMovableDataRows()[index];\n  }\n\n  enableAfterRender(e) {\n    if (e.module === 'group' && e.enable) {\n      this.generator = this.getModelGenerator();\n    }\n  }\n\n  setRowObjects(rows) {\n    this.rows = rows;\n  }\n  /**\n   * @param {NotifyArgs} args - specifies the args\n   * @returns {void}\n   * @hidden\n   */\n\n\n  immutableModeRendering(args = {}) {\n    const gObj = this.parent;\n    gObj.hideSpinner();\n    const key = gObj.getPrimaryKeyFieldNames()[0];\n    const oldKeys = {};\n    const newKeys = {};\n    const newRowObjs = [];\n    const oldIndexes = {};\n    const oldRowObjs = gObj.getRowsObject().slice();\n    const batchChangeKeys = this.getBatchEditedRecords(key, oldRowObjs);\n    const newIndexes = {};\n    const hasBatch = Object.keys(batchChangeKeys).length !== 0;\n\n    if (gObj.getContent().querySelector('.e-emptyrow') || args.requestType === 'reorder' || this.parent.groupSettings.columns.length) {\n      this.refreshContentRows(args);\n    } else {\n      if (gObj.currentViewData.length === 0) {\n        return;\n      }\n\n      const oldRowElements = {};\n      const tbody$$1 = gObj.createElement(tbody);\n      const dataSource = gObj.currentViewData;\n      const trs = [].slice.call(this.getTable().querySelector(tbody).children);\n\n      if (this.prevCurrentView.length) {\n        const prevLen = this.prevCurrentView.length;\n        const currentLen = dataSource.length;\n\n        if (prevLen === currentLen) {\n          for (let i = 0; i < currentLen; i++) {\n            if (this.parent.editSettings.mode === 'Batch' && trs[i].classList.contains('e-insertedrow')) {\n              trs.splice(i, 1);\n              --i;\n              continue;\n            }\n\n            newKeys[dataSource[i][key]] = oldKeys[this.prevCurrentView[i][key]] = i;\n            newIndexes[i] = dataSource[i][key];\n            oldRowElements[oldRowObjs[i].uid] = trs[i];\n            oldIndexes[i] = this.prevCurrentView[i][key];\n          }\n        } else {\n          for (let i = 0; i < currentLen; i++) {\n            newKeys[dataSource[i][key]] = i;\n            newIndexes[i] = dataSource[i][key];\n          }\n\n          for (let i = 0; i < prevLen; i++) {\n            if (this.parent.editSettings.mode === 'Batch' && trs[i].classList.contains('e-insertedrow')) {\n              trs.splice(i, 1);\n              --i;\n              continue;\n            }\n\n            oldRowElements[oldRowObjs[i].uid] = trs[i];\n            oldKeys[this.prevCurrentView[i][key]] = i;\n            oldIndexes[i] = this.prevCurrentView[i][key];\n          }\n        }\n      }\n\n      for (let i = 0; i < dataSource.length; i++) {\n        const oldIndex = oldKeys[dataSource[i][key]];\n\n        if (!isNullOrUndefined(oldIndex)) {\n          let isEqual = false;\n\n          if (this.parent.enableDeepCompare) {\n            isEqual = this.objectEqualityChecker(this.prevCurrentView[oldIndex], dataSource[i]);\n          }\n\n          const tr = oldRowElements[oldRowObjs[oldIndex].uid];\n          newRowObjs.push(oldRowObjs[oldIndex]);\n\n          if (this.rowElements[oldIndex] && this.rowElements[oldIndex].getAttribute('data-uid') === newRowObjs[i].uid && (hasBatch && isNullOrUndefined(batchChangeKeys[newIndexes[i]]) || !hasBatch && (isEqual || this.prevCurrentView[oldIndex] === dataSource[i]))) {\n            if (oldIndex !== i) {\n              this.refreshImmutableContent(i, tr, newRowObjs[i]);\n            }\n\n            tbody$$1.appendChild(tr);\n            continue;\n          }\n\n          if (hasBatch && !isNullOrUndefined(batchChangeKeys[newIndexes[i]]) || !this.parent.enableDeepCompare && dataSource[i] !== this.prevCurrentView[oldIndex] || this.parent.enableDeepCompare && !isEqual) {\n            oldRowObjs[oldIndex].setRowValue(dataSource[i]);\n          }\n\n          tbody$$1.appendChild(tr);\n          this.refreshImmutableContent(i, tr, newRowObjs[i]);\n        } else {\n          const row$$1 = new RowRenderer(this.serviceLocator, null, gObj);\n          const modelData = this.generator.generateRows([dataSource[i]]);\n          newRowObjs.push(modelData[0]);\n          const tr = row$$1.render(modelData[0], gObj.getColumns());\n          tbody$$1.appendChild(tr);\n          this.refreshImmutableContent(i, tr, newRowObjs[i]);\n        }\n      }\n\n      this.rows = newRowObjs;\n      this.rowElements = [].slice.call(tbody$$1.children);\n      remove(this.getTable().querySelector(tbody));\n      this.getTable().appendChild(tbody$$1);\n      this.parent.trigger(dataBound, {}, () => {\n        if (this.parent.allowTextWrap) {\n          this.parent.notify(freezeRender, {\n            case: 'textwrap'\n          });\n        }\n      });\n\n      if (args) {\n        const action = (args.requestType || '').toLowerCase() + '-complete';\n        this.parent.notify(action, args);\n      }\n    }\n  }\n\n  objectEqualityChecker(old, next) {\n    const keys = Object.keys(old);\n    let isEqual = true;\n\n    for (let i = 0; i < keys.length; i++) {\n      if (old[keys[i]] !== next[keys[i]]) {\n        const isDate = old[keys[i]] instanceof Date && next[keys[i]] instanceof Date;\n\n        if (!isDate || old[keys[i]].getTime() !== next[keys[i]].getTime()) {\n          isEqual = false;\n          break;\n        }\n      }\n    }\n\n    return isEqual;\n  }\n\n  getBatchEditedRecords(primaryKey, rows) {\n    const keys = {};\n    const changes = this.parent.getBatchChanges();\n    let changedRecords$$1 = [];\n    let addedRecords$$1 = [];\n\n    if (Object.keys(changes).length) {\n      changedRecords$$1 = changes.changedRecords;\n      addedRecords$$1 = changes.addedRecords;\n    }\n\n    const args = {\n      cancel: false\n    };\n    this.parent.notify(immutableBatchCancel, {\n      rows: rows,\n      args: args\n    });\n\n    if (addedRecords$$1.length) {\n      if (this.parent.editSettings.newRowPosition === 'Bottom') {\n        rows.splice(rows.length - 1, addedRecords$$1.length);\n      } else {\n        if (!args.cancel) {\n          rows.splice(0, addedRecords$$1.length);\n        }\n      }\n    }\n\n    for (let i = 0; i < changedRecords$$1.length; i++) {\n      keys[changedRecords$$1[i][primaryKey]] = i;\n    }\n\n    return keys;\n  }\n\n  refreshImmutableContent(index, tr, row$$1) {\n    row$$1.isAltRow = this.parent.enableAltRow ? index % 2 !== 0 : false;\n\n    if (row$$1.isAltRow) {\n      tr.classList.add('e-altrow');\n    } else {\n      tr.classList.remove('e-altrow');\n    }\n\n    row$$1.index = index;\n    row$$1.edit = undefined;\n    row$$1.isDirty = false;\n    tr.setAttribute(ariaRowIndex, index.toString());\n    this.updateCellIndex(tr, index);\n  }\n\n  updateCellIndex(rowEle, index) {\n    for (let i = 0; i < rowEle.cells.length; i++) {\n      rowEle.cells[i].setAttribute('index', index.toString());\n    }\n  }\n\n} // eslint-disable-next-line valid-jsdoc\n\n/**\n * Content module is used to render grid content\n *\n * @hidden\n */\n\n\nclass HeaderRender {\n  /**\n   * Constructor for header renderer module\n   *\n   * @param {IGrid} parent - specifies the IGrid\n   * @param {ServiceLocator} serviceLocator - specifies the serviceLocator\n   */\n  constructor(parent, serviceLocator) {\n    this.frzIdx = 0;\n    this.notfrzIdx = 0;\n    this.isFirstCol = false;\n    this.isReplaceDragEle = true; // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n    this.helper = e => {\n      const gObj = this.parent;\n      const target = this.draggable.currentStateTarget;\n      const parentEle = parentsUntil(target, 'e-headercell');\n\n      if (!(gObj.allowReordering || gObj.allowGrouping) || !isNullOrUndefined(parentEle) && parentEle.getElementsByClassName('e-checkselectall').length > 0) {\n        return false;\n      }\n\n      const visualElement = this.parent.createElement('div', {\n        className: 'e-cloneproperties e-dragclone e-headerclone'\n      });\n      const element = target.classList.contains('e-headercell') ? target : parentEle;\n\n      if (!element || !gObj.allowReordering && element.classList.contains('e-stackedheadercell')) {\n        return false;\n      }\n\n      const height = element.offsetHeight;\n      const headercelldiv = element.querySelector('.e-headercelldiv') || element.querySelector('.e-stackedheadercelldiv');\n      let col;\n\n      if (headercelldiv) {\n        if (element.querySelector('.e-stackedheadercelldiv')) {\n          col = gObj.getStackedHeaderColumnByHeaderText(headercelldiv.innerText.trim(), gObj.columns);\n        } else {\n          col = gObj.getColumnByUid(headercelldiv.getAttribute('e-mappinguid'));\n        }\n\n        this.column = col;\n\n        if (this.column.lockColumn) {\n          return false;\n        }\n\n        visualElement.setAttribute('e-mappinguid', this.column.uid);\n      }\n\n      if (col && !isNullOrUndefined(col.headerTemplate)) {\n        if (!isNullOrUndefined(col.headerTemplate)) {\n          const colIndex = gObj.getColumnIndexByField(col.field);\n          const result = col.getHeaderTemplate()(extend({\n            'index': colIndex\n          }, col), gObj, 'headerTemplate');\n          appendChildren(visualElement, result);\n        } else {\n          visualElement.innerHTML = col.headerTemplate;\n        }\n      } else {\n        visualElement.innerHTML = headercelldiv ? col.headerText : element.firstElementChild.innerHTML;\n      }\n\n      visualElement.style.width = element.offsetWidth + 'px';\n      visualElement.style.height = element.offsetHeight + 'px';\n      visualElement.style.lineHeight = (height - 6).toString() + 'px';\n      gObj.element.appendChild(visualElement);\n      return visualElement;\n    };\n\n    this.dragStart = e => {\n      const gObj = this.parent;\n      gObj.element.querySelector('.e-gridpopup').style.display = 'none';\n      gObj.notify(columnDragStart, {\n        target: this.draggable.currentStateTarget,\n        column: this.column,\n        event: e.event\n      });\n    };\n\n    this.drag = e => {\n      const gObj = this.parent;\n      const target = e.target;\n\n      if (target) {\n        const closest$$1 = closest(target, '.e-grid');\n        const cloneElement = this.parent.element.querySelector('.e-cloneproperties');\n\n        if (!closest$$1 || closest$$1.getAttribute('id') !== gObj.element.getAttribute('id')) {\n          classList(cloneElement, ['e-notallowedcur'], ['e-defaultcur']);\n\n          if (gObj.allowReordering) {\n            gObj.element.querySelector('.e-reorderuparrow').style.display = 'none';\n            gObj.element.querySelector('.e-reorderdownarrow').style.display = 'none';\n          }\n\n          if (!gObj.groupSettings.allowReordering) {\n            return;\n          }\n        }\n\n        gObj.notify(columnDrag, {\n          target: e.target,\n          column: this.column,\n          event: e.event\n        });\n      }\n    };\n\n    this.dragStop = e => {\n      const gObj = this.parent;\n      let cancel;\n      gObj.element.querySelector('.e-gridpopup').style.display = 'none';\n\n      if (!parentsUntil(e.target, 'e-headercell') && !parentsUntil(e.target, 'e-groupdroparea') || !gObj.allowReordering && parentsUntil(e.target, 'e-headercell') || !e.helper.getAttribute('e-mappinguid') && parentsUntil(e.target, 'e-groupdroparea')) {\n        remove(e.helper);\n        cancel = true;\n      }\n\n      gObj.notify(columnDragStop, {\n        target: e.target,\n        event: e.event,\n        column: this.column,\n        cancel: cancel\n      });\n    };\n\n    this.drop = e => {\n      const gObj = this.parent;\n      const uid = e.droppedElement.getAttribute('e-mappinguid');\n      const closest$$1 = closest(e.target, '.e-grid');\n      remove(e.droppedElement);\n\n      if (closest$$1 && closest$$1.getAttribute('id') !== gObj.element.getAttribute('id') || !(gObj.allowReordering || gObj.allowGrouping)) {\n        return;\n      }\n\n      gObj.notify(headerDrop, {\n        target: e.target,\n        uid: uid,\n        droppedElement: e.droppedElement\n      });\n    };\n\n    this.parent = parent;\n    this.serviceLocator = serviceLocator;\n    this.ariaService = this.serviceLocator.getService('ariaService');\n    this.widthService = this.serviceLocator.getService('widthService');\n\n    if (this.parent.isDestroyed) {\n      return;\n    }\n\n    if (!this.parent.enableColumnVirtualization && !this.parent.getFrozenLeftColumnsCount() && !this.parent.getFrozenRightColumnsCount()) {\n      this.parent.on(columnVisibilityChanged, this.setVisible, this);\n    }\n\n    this.parent.on(columnPositionChanged, this.colPosRefresh, this);\n    this.parent.on(initialEnd, this.renderCustomToolbar, this);\n\n    if (this.parent.rowRenderingMode === 'Vertical') {\n      this.parent.on(uiUpdate, this.updateCustomResponsiveToolbar, this);\n    }\n  }\n  /**\n   * The function is used to render grid header div\n   *\n   * @returns {void}\n   */\n\n\n  renderPanel() {\n    let div = this.parent.element.querySelector('.' + gridHeader);\n    const isRendered = div != null;\n    div = isRendered ? div : this.parent.createElement('div', {\n      className: 'e-gridheader'\n    });\n    const innerDiv = isRendered ? div.querySelector('.' + headerContent) : this.parent.createElement('div', {\n      className: headerContent\n    });\n    this.toggleStackClass(div);\n    div.appendChild(innerDiv);\n    this.setPanel(div);\n\n    if (!isRendered) {\n      this.parent.element.appendChild(div);\n    }\n  }\n  /**\n   * The function is used to render grid header div\n   *\n   * @returns {void}\n   */\n\n\n  renderTable() {\n    const headerDiv = this.getPanel();\n    headerDiv.appendChild(this.createHeaderTable());\n    this.setTable(headerDiv.querySelector('.' + table));\n\n    if (!this.parent.getFrozenColumns() && !this.parent.getFrozenRightColumnsCount() && !this.parent.getFrozenLeftColumnsCount()) {\n      this.initializeHeaderDrag();\n      this.initializeHeaderDrop();\n    }\n\n    this.parent.notify(headerRefreshed, {\n      rows: this.rows,\n      args: {\n        isFrozen: this.parent.isFrozenGrid()\n      }\n    });\n  }\n  /**\n   * Get the header content div element of grid\n   *\n   * @returns {Element} returns the element\n   */\n\n\n  getPanel() {\n    return this.headerPanel;\n  }\n  /**\n   * Set the header content div element of grid\n   *\n   * @param  {Element} panel - specifies the panel element\n   * @returns {void}\n   */\n\n\n  setPanel(panel) {\n    this.headerPanel = panel;\n  }\n  /**\n   * Get the header table element of grid\n   *\n   * @returns {Element} returns the element\n   */\n\n\n  getTable() {\n    return this.headerTable;\n  }\n  /**\n   * Set the header table element of grid\n   *\n   * @param  {Element} table - specifies the table element\n   * @returns {void}\n   */\n\n\n  setTable(table$$1) {\n    this.headerTable = table$$1;\n  }\n  /**\n   * Get the header colgroup element\n   *\n   * @returns {Element} returns the element\n   */\n\n\n  getColGroup() {\n    return this.colgroup;\n  }\n  /**\n   * Set the header colgroup element\n   *\n   * @param {Element} colGroup - specifies the colgroup\n   * @returns {Element} returns the element\n   */\n\n\n  setColGroup(colGroup$$1) {\n    return this.colgroup = colGroup$$1;\n  }\n  /**\n   * Get the header row element collection.\n   *\n   * @returns {Element[]} returns the element\n   */\n\n\n  getRows() {\n    const table$$1 = this.getTable();\n    return table$$1.tHead.rows;\n  }\n  /**\n   * The function is used to create header table elements\n   *\n   * @returns {Element} returns the element\n   * @hidden\n   */\n\n\n  createHeaderTable() {\n    const table$$1 = this.createTable();\n    const innerDiv = this.getPanel().querySelector('.' + headerContent);\n    innerDiv.appendChild(table$$1);\n    return innerDiv;\n  }\n  /**\n   * The function is used to create header table elements\n   *\n   * @param {Element} tableEle - specifies the table Element\n   * @param {freezeTable} tableName - specifies the table name\n   * @returns {Element} returns the element\n   * @hidden\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  createHeader(tableEle = null, tableName) {\n    const gObj = this.parent;\n    const isFrozen = gObj.isFrozenGrid();\n\n    if (this.getTable() && !isFrozen) {\n      remove(this.getTable());\n    }\n\n    const table$$1 = this.parent.createElement('table', {\n      className: table,\n      attrs: {\n        cellspacing: '0.25px',\n        role: 'grid'\n      }\n    });\n    const tblName = tableName ? tableName : gObj.getFrozenLeftCount() ? 'frozen-left' : 'frozen-right';\n    const findHeaderRow = this.createHeaderContent(tblName);\n    const thead = findHeaderRow.thead;\n    const tbody$$1 = this.parent.createElement(tbody, {\n      className: this.parent.frozenRows ? '' : 'e-hide'\n    });\n    this.caption = this.parent.createElement('caption', {\n      innerHTML: this.parent.element.id + '_header_table',\n      className: 'e-hide'\n    });\n    const colGroup$$1 = this.parent.createElement(colGroup);\n    const rowBody = this.parent.createElement('tr');\n    let bodyCell;\n    const rows = this.rows = findHeaderRow.rows;\n\n    for (let i = 0, len = rows.length; i < len; i++) {\n      for (let j = 0, len = rows[i].cells.length; j < len; j++) {\n        bodyCell = this.parent.createElement('td');\n        rowBody.appendChild(bodyCell);\n      }\n    }\n\n    if (gObj.allowFiltering || gObj.allowSorting || gObj.allowGrouping) {\n      table$$1.classList.add('e-sortfilter');\n    }\n\n    this.updateColGroup(colGroup$$1);\n    tbody$$1.appendChild(rowBody);\n    table$$1.appendChild(this.setColGroup(colGroup$$1));\n    table$$1.appendChild(thead);\n    table$$1.appendChild(tbody$$1);\n    table$$1.appendChild(this.caption);\n    this.ariaService.setOptions(table$$1, {\n      colcount: gObj.getColumns().length.toString()\n    });\n    return table$$1;\n  }\n  /**\n   * @param {Element} tableEle - specifies the column\n   * @returns {Element} returns the element\n   * @hidden\n   */\n\n\n  createTable(tableEle = null) {\n    return this.createHeader(tableEle);\n  }\n\n  createHeaderContent(tableName) {\n    const gObj = this.parent;\n    let index = 1;\n    const frozenMode = gObj.getFrozenMode();\n    const columns = gObj.getColumns();\n    const thead = this.parent.createElement('thead');\n    const colHeader = this.parent.createElement('tr', {\n      className: 'e-columnheader'\n    });\n    const rowRenderer = new RowRenderer(this.serviceLocator, CellType.Header, gObj);\n    rowRenderer.element = colHeader;\n    let rows = [];\n    let headerRow;\n    this.colDepth = measureColumnDepth(gObj.columns);\n\n    for (let i = 0, len = this.colDepth; i < len; i++) {\n      rows[i] = this.generateRow(i);\n      rows[i].cells = [];\n    }\n\n    if (frozenMode !== 'Right') {\n      rows = this.ensureColumns(rows);\n    }\n\n    rows = this.getHeaderCells(rows, tableName);\n\n    if (frozenMode === 'Right') {\n      index = 0;\n      rows = this.ensureColumns(rows);\n    }\n\n    const frzCols = this.parent.getFrozenColumns();\n\n    if (this.parent.isRowDragable() && this.parent.isFrozenGrid() && rows[0].cells[index]) {\n      const colFreezeMode = rows[0].cells[index].column.getFreezeTableName();\n\n      if (colFreezeMode === 'movable' || frozenMode === leftRight && colFreezeMode === frozenRight) {\n        if (frozenMode === 'Right') {\n          rows[0].cells.pop();\n        } else {\n          rows[0].cells.shift();\n        }\n      } else if (!frzCols && colFreezeMode === frozenLeft) {\n        rows[0].cells[0].column.freeze = colFreezeMode === frozenLeft ? 'Left' : 'Right';\n      } else if (frozenMode === 'Right' && colFreezeMode === frozenRight) {\n        rows[0].cells[rows[0].cells.length - 1].column.freeze = 'Right';\n      }\n    }\n\n    for (let i = 0, len = this.colDepth; i < len; i++) {\n      headerRow = rowRenderer.render(rows[i], columns);\n\n      if (this.parent.rowHeight && headerRow.querySelector('.e-headercell')) {\n        headerRow.style.height = this.parent.rowHeight + 'px';\n      }\n\n      thead.appendChild(headerRow);\n    }\n\n    const findHeaderRow = {\n      thead: thead,\n      rows: rows\n    };\n    return findHeaderRow;\n  }\n\n  updateColGroup(colGroup$$1) {\n    let cols = this.parent.getColumns();\n    let col;\n    const indexes = this.parent.getColumnIndexesInView();\n\n    if (this.parent.enableColumnVirtualization && this.parent.getFrozenColumns() && this.parent.contentModule.isXaxis()) {\n      cols = extend([], this.parent.getColumns());\n      cols.splice(0, this.parent.getFrozenColumns());\n    }\n\n    colGroup$$1.id = this.parent.element.id + colGroup;\n\n    if (this.parent.allowGrouping) {\n      for (let i = 0, len = this.parent.groupSettings.columns.length; i < len; i++) {\n        if (this.parent.enableColumnVirtualization && indexes.indexOf(i) === -1) {\n          continue;\n        }\n\n        col = this.parent.createElement('col', {\n          className: 'e-group-intent'\n        });\n        colGroup$$1.appendChild(col);\n      }\n    }\n\n    if (this.parent.detailTemplate || this.parent.childGrid) {\n      col = this.parent.createElement('col', {\n        className: 'e-detail-intent'\n      });\n      colGroup$$1.appendChild(col);\n    }\n\n    if (this.parent.isRowDragable() && this.parent.getFrozenMode() !== 'Right') {\n      col = this.parent.createElement('col', {\n        className: 'e-drag-intent'\n      });\n      colGroup$$1.appendChild(col);\n    }\n\n    for (let i = 0, len = cols.length; i < len; i++) {\n      col = this.parent.createElement('col');\n\n      if (cols[i].visible === false) {\n        setStyleAttribute(col, {\n          'display': 'none'\n        });\n      }\n\n      colGroup$$1.appendChild(col);\n    }\n\n    if (this.parent.isRowDragable() && this.parent.getFrozenMode() === 'Right') {\n      col = this.parent.createElement('col', {\n        className: 'e-drag-intent'\n      });\n      colGroup$$1.appendChild(col);\n    }\n\n    return colGroup$$1;\n  }\n\n  ensureColumns(rows) {\n    //TODO: generate dummy column for group, detail, stacked row here; ensureColumns here\n    const gObj = this.parent;\n    const indexes = this.parent.getColumnIndexesInView();\n\n    for (let i = 0, len = rows.length; i < len; i++) {\n      if (gObj.allowGrouping) {\n        for (let c = 0, len = gObj.groupSettings.columns.length; c < len; c++) {\n          if (this.parent.enableColumnVirtualization && indexes.indexOf(c) === -1) {\n            continue;\n          }\n\n          rows[i].cells.push(this.generateCell({}, CellType.HeaderIndent));\n        }\n      }\n\n      if (gObj.detailTemplate || gObj.childGrid) {\n        const args = {};\n        this.parent.notify(detailIndentCellInfo, args);\n        rows[i].cells.push(this.generateCell(args, CellType.DetailHeader));\n      }\n\n      if (gObj.isRowDragable()) {\n        rows[i].cells.push(this.generateCell({}, CellType.RowDragHIcon));\n      }\n    }\n\n    return rows;\n  }\n\n  getHeaderCells(rows, tableName) {\n    const thead = this.parent.getHeaderTable() && this.parent.getHeaderTable().querySelector('thead');\n    const cols = this.parent.enableColumnVirtualization ? this.parent.getColumns(this.parent.enablePersistence) : this.parent.columns;\n    this.frzIdx = 0;\n    this.notfrzIdx = 0;\n\n    if (this.parent.lockcolPositionCount) {\n      for (let i = 0; i < cols.length; i++) {\n        this.lockColsRendered = false;\n        rows = this.appendCells(cols[i], rows, 0, i === 0, false, i === cols.length - 1, thead, tableName);\n      }\n    }\n\n    for (let i = 0, len = cols.length; i < len; i++) {\n      this.notfrzIdx = 0;\n      this.lockColsRendered = true;\n      rows = this.appendCells(cols[i], rows, 0, i === 0, false, i === len - 1, thead, tableName);\n    }\n\n    return rows;\n  }\n\n  appendCells(cols, rows, index, isFirstObj, isFirstCol, isLastCol, isMovable, tableName) {\n    const lastCol = isLastCol ? 'e-lastcell' : '';\n    const isFrozen = this.parent.isFrozenGrid();\n    const isLockColumn = !this.parent.lockcolPositionCount || cols.lockColumn && !this.lockColsRendered || !cols.lockColumn && this.lockColsRendered;\n    const isFrozenLockColumn = !this.parent.lockcolPositionCount || cols.lockColumn && !this.lockColsRendered || !cols.lockColumn && this.lockColsRendered;\n    const scrollbar = this.parent.getContent().querySelector('.e-movablescrollbar');\n    let left;\n\n    if (isFrozen && scrollbar && this.parent.enableColumnVirtualization) {\n      left = scrollbar.scrollLeft;\n    }\n\n    if (!cols.columns) {\n      if (left && left > 0 && this.parent.contentModule.isXaxis() && this.parent.inViewIndexes[0] !== 0 && cols.getFreezeTableName() === 'movable') {\n        rows[index].cells.push(this.generateCell(cols, CellType.Header, this.colDepth - index, (isFirstObj ? '' : isFirstCol ? 'e-firstcell' : '') + lastCol, index, this.parent.getColumnIndexByUid(cols.uid)));\n      } else {\n        if (!isFrozen && isLockColumn || isFrozen && cols.getFreezeTableName() === tableName && isFrozenLockColumn) {\n          rows[index].cells.push(this.generateCell(cols, CellType.Header, this.colDepth - index, (isFirstObj ? '' : isFirstCol ? 'e-firstcell' : '') + lastCol, index, this.parent.getColumnIndexByUid(cols.uid)));\n        }\n      }\n\n      if (this.parent.lockcolPositionCount) {\n        if (this.frzIdx + this.notfrzIdx < this.parent.frozenColumns && (cols.lockColumn && !this.lockColsRendered || !cols.lockColumn && this.lockColsRendered)) {\n          this.frzIdx++;\n        } else {\n          this.notfrzIdx++;\n        }\n      } else {\n        this.frzIdx++;\n      }\n    } else {\n      this.isFirstCol = false;\n      const colSpan = this.getCellCnt(cols, 0);\n\n      if (colSpan) {\n        const stackedLockColsCount = this.getStackedLockColsCount(cols, 0);\n        const isStackedLockColumn = this.parent.lockcolPositionCount === 0 || !this.lockColsRendered && stackedLockColsCount !== 0 || this.lockColsRendered && colSpan - stackedLockColsCount !== 0;\n        const isFrozenStack = isFrozen && this.ensureStackedFrozen(cols.columns, tableName, false);\n\n        if (!isFrozen && isStackedLockColumn || isFrozenStack) {\n          rows[index].cells.push(new Cell({\n            cellType: CellType.StackedHeader,\n            column: cols,\n            colSpan: this.getColSpan(colSpan, stackedLockColsCount, cols.columns, tableName, isFrozen)\n          }));\n        }\n      }\n\n      if (this.parent.lockcolPositionCount && !this.lockColsRendered) {\n        for (let i = 0; i < cols.columns.length; i++) {\n          rows = this.appendCells(cols.columns[i], rows, index + 1, isFirstObj, i === 0, i === cols.columns.length - 1 && isLastCol, isMovable, tableName);\n        }\n      }\n\n      if (this.lockColsRendered) {\n        for (let i = 0, len = cols.columns.length; i < len; i++) {\n          isFirstObj = isFirstObj && i === 0;\n          const isFirstCol = this.isFirstCol = cols.columns[i].visible && !isFirstObj;\n          const isLaststackedCol = i === len - 1 && isLastCol;\n          rows = this.appendCells(cols.columns[i], rows, index + 1, isFirstObj, isFirstCol && !isLaststackedCol, isLaststackedCol, isMovable, tableName);\n        }\n      }\n    }\n\n    return rows;\n  }\n\n  ensureStackedFrozen(columns, tableName, isTrue) {\n    const length = columns.length;\n\n    for (let i = 0; i < length; i++) {\n      if (columns[i].columns) {\n        isTrue = this.ensureStackedFrozen(columns[i].columns, tableName, isTrue);\n      } else if (columns[i].getFreezeTableName() === tableName) {\n        isTrue = true;\n        break;\n      }\n    }\n\n    return isTrue;\n  }\n\n  getStackedLockColsCount(col, lockColsCount) {\n    if (col.columns) {\n      for (let i = 0; i < col.columns.length; i++) {\n        lockColsCount = this.getStackedLockColsCount(col.columns[i], lockColsCount);\n      }\n    } else if (col.lockColumn) {\n      lockColsCount++;\n    }\n\n    return lockColsCount;\n  }\n\n  getColSpan(colSpan, stackedLockColsCount, columns, tableName, isFrozen) {\n    if (isFrozen) {\n      colSpan = this.getFrozenColSpan(columns, tableName, 0);\n    } else if (this.parent.lockcolPositionCount) {\n      colSpan = !this.lockColsRendered ? stackedLockColsCount : colSpan - stackedLockColsCount;\n    }\n\n    return colSpan;\n  }\n\n  getFrozenColSpan(columns, tableName, count) {\n    const length = columns.length;\n\n    for (let i = 0; i < length; i++) {\n      if (columns[i].columns) {\n        count = this.getFrozenColSpan(columns[i].columns, tableName, count);\n      } else if (columns[i].getFreezeTableName() === tableName && columns[i].visible) {\n        count++;\n      }\n    }\n\n    return count;\n  } // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  generateRow(index) {\n    return new Row({});\n  }\n\n  generateCell(column, cellType, rowSpan, className, rowIndex, colIndex) {\n    const opt = {\n      'visible': column.visible,\n      'isDataCell': false,\n      'isTemplate': !isNullOrUndefined(column.headerTemplate),\n      'rowID': '',\n      'column': column,\n      'cellType': cellType,\n      'rowSpan': rowSpan,\n      'className': className,\n      'index': rowIndex,\n      'colIndex': colIndex\n    };\n\n    if (!opt.rowSpan || opt.rowSpan < 2) {\n      delete opt.rowSpan;\n    }\n\n    return new Cell(opt);\n  }\n  /**\n   * Function to hide header table column based on visible property\n   *\n   * @param {Column[]} columns - specifies the column\n   * @returns {void}\n   */\n\n\n  setVisible(columns) {\n    const gObj = this.parent;\n    let displayVal;\n    let idx;\n    const frzCols = gObj.getFrozenColumns();\n\n    for (let c = 0, clen = columns.length; c < clen; c++) {\n      const column = columns[c];\n      idx = gObj.getNormalizedColumnIndex(column.uid);\n      displayVal = column.visible ? '' : 'none';\n\n      if (frzCols) {\n        const normalizedfrzCols = this.parent.isRowDragable() ? frzCols + 1 : frzCols;\n\n        if (idx < normalizedfrzCols) {\n          setStyleAttribute(this.getColGroup().children[idx], {\n            'display': displayVal\n          });\n        } else {\n          const mTblColGrp = gObj.getHeaderContent().querySelector('.' + movableHeader).querySelector(colGroup);\n          setStyleAttribute(mTblColGrp.children[idx - normalizedfrzCols], {\n            'display': displayVal\n          });\n        }\n      } else {\n        setStyleAttribute(this.getColGroup().children[idx], {\n          'display': displayVal\n        });\n      }\n    }\n\n    this.refreshUI();\n  }\n\n  colPosRefresh() {\n    this.refreshUI();\n  }\n  /**\n   * Refresh the header of the Grid.\n   *\n   * @returns {void}\n   */\n\n\n  refreshUI() {\n    const frzCols = this.parent.isFrozenGrid();\n    const isVFTable = this.parent.enableColumnVirtualization && frzCols;\n    const headerDiv = this.getPanel();\n    this.toggleStackClass(headerDiv);\n    let table$$1 = this.freezeReorder ? this.headerPanel.querySelector('.' + movableHeader).querySelector('.' + table) : this.getTable();\n    let tableName = this.parent.isFrozenGrid() ? this.parent.getFrozenLeftCount() ? 'frozen-left' : 'frozen-right' : undefined;\n\n    if (isVFTable) {\n      table$$1 = this.parent.contentModule.getVirtualFreezeHeader();\n      tableName = this.parent.contentModule.isXaxis() ? 'movable' : tableName;\n    }\n\n    if (table$$1) {\n      remove(table$$1);\n      table$$1.removeChild(table$$1.firstChild);\n      table$$1.removeChild(table$$1.childNodes[0]);\n      const colGroup$$1 = this.parent.createElement(colGroup);\n      const findHeaderRow = this.createHeaderContent(tableName);\n      this.rows = findHeaderRow.rows;\n      table$$1.insertBefore(findHeaderRow.thead, table$$1.firstChild);\n      this.updateColGroup(colGroup$$1);\n      table$$1.insertBefore(this.setColGroup(colGroup$$1), table$$1.firstChild);\n\n      if (!isVFTable) {\n        this.setTable(table$$1);\n      }\n\n      this.appendContent(table$$1);\n      this.parent.notify(colGroupRefresh, {});\n      this.widthService.setWidthToColumns();\n      this.parent.updateDefaultCursor();\n\n      if (!frzCols || this.parent.enableColumnVirtualization && frzCols) {\n        this.initializeHeaderDrag();\n      }\n\n      const rows = [].slice.call(headerDiv.querySelectorAll('tr.e-columnheader'));\n\n      for (const row$$1 of rows) {\n        const gCells = [].slice.call(row$$1.getElementsByClassName('e-grouptopleftcell'));\n\n        if (gCells.length) {\n          gCells[gCells.length - 1].classList.add('e-lastgrouptopleftcell');\n        }\n      }\n\n      if (!frzCols) {\n        this.parent.notify(headerRefreshed, {\n          rows: this.rows,\n          args: {\n            isFrozen: frzCols\n          }\n        });\n      }\n\n      if (this.parent.enableColumnVirtualization && parentsUntil(table$$1, movableHeader)) {\n        this.parent.notify(headerRefreshed, {\n          rows: this.rows,\n          args: {\n            isFrozen: false,\n            isXaxis: true\n          }\n        });\n      }\n\n      if (this.parent.allowTextWrap && this.parent.textWrapSettings.wrapMode === 'Header') {\n        wrap(rows, true);\n      }\n    }\n  }\n\n  toggleStackClass(div) {\n    const column = this.parent.columns;\n    const stackedHdr = column.some(column => !isNullOrUndefined(column.columns));\n\n    if (stackedHdr) {\n      div.classList.add('e-stackedheader');\n    } else {\n      div.classList.remove('e-stackedheader');\n    }\n  }\n\n  appendContent(table$$1) {\n    this.getPanel().querySelector('.' + headerContent).appendChild(table$$1);\n  }\n\n  getCellCnt(col, cnt) {\n    if (col.columns) {\n      for (let i = 0, len = col.columns.length; i < len; i++) {\n        cnt = this.getCellCnt(col.columns[i], cnt);\n      }\n    } else {\n      if (col.visible) {\n        cnt++;\n      }\n    }\n\n    return cnt;\n  }\n\n  initializeHeaderDrag() {\n    const gObj = this.parent;\n\n    if (!(this.parent.allowReordering || this.parent.allowGrouping && this.parent.groupSettings.showDropArea)) {\n      return;\n    }\n\n    this.draggable = new Draggable(gObj.getHeaderContent(), {\n      dragTarget: '.e-headercell',\n      distance: 5,\n      helper: this.helper,\n      dragStart: this.dragStart,\n      drag: this.drag,\n      dragStop: this.dragStop,\n      abort: '.e-rhandler',\n      isReplaceDragEle: this.isReplaceDragEle\n    });\n  }\n\n  initializeHeaderDrop() {\n    const gObj = this.parent; // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n    const drop = new Droppable(gObj.getHeaderContent(), {\n      accept: '.e-dragclone',\n      drop: this.drop\n    });\n  }\n\n  renderCustomToolbar() {\n    const gObj = this.parent;\n\n    if (gObj.rowRenderingMode === 'Vertical' && !gObj.toolbar && (gObj.allowSorting || gObj.allowFiltering && gObj.filterSettings.type !== 'FilterBar')) {\n      const div = gObj.createElement('div', {\n        className: 'e-res-toolbar e-toolbar'\n      });\n      const toolbarItems = gObj.createElement('div', {\n        className: 'e-toolbar-items'\n      });\n      const toolbarLeft = gObj.createElement('div', {\n        className: 'e-toolbar-left'\n      });\n      const count = this.parent.allowFiltering && this.parent.allowSorting ? 2 : 1;\n\n      for (let i = 0; i < count; i++) {\n        const toolbarItem = gObj.createElement('div', {\n          className: 'e-toolbar-item e-gridresponsiveicons e-icons e-tbtn-align'\n        });\n        const cls = count === 1 ? this.parent.allowSorting ? 'sort' : 'filter' : i === 1 ? 'sort' : 'filter';\n        const button = gObj.createElement('button', {\n          className: 'e-tbar-btn e-control e-btn e-lib e-icon-btn'\n        });\n        const span = gObj.createElement('span', {\n          className: 'e-btn-icon e-res' + cls + '-icon e-icons'\n        });\n        button.appendChild(span);\n        const btnObj = new Button({});\n        btnObj.appendTo(button);\n\n        button.onclick = e => {\n          if (e.target.classList.contains('e-ressort-btn') || e.target.classList.contains('e-ressort-icon')) {\n            this.parent.showResponsiveCustomSort();\n          } else {\n            this.parent.showResponsiveCustomFilter();\n          }\n        };\n\n        toolbarItem.appendChild(button);\n        toolbarLeft.appendChild(toolbarItem);\n      }\n\n      toolbarItems.appendChild(toolbarLeft);\n      div.appendChild(toolbarItems);\n      gObj.element.insertBefore(div, this.parent.element.querySelector('.' + gridHeader));\n    } else {\n      if (gObj.enableAdaptiveUI && !gObj.toolbar) {\n        gObj.getContent().classList.add('e-responsive-header');\n      }\n    }\n  }\n\n  updateCustomResponsiveToolbar(args) {\n    const resToolbar = this.parent.element.querySelector('.e-responsive-toolbar');\n\n    if (args.module === 'toolbar') {\n      if (resToolbar) {\n        remove(resToolbar);\n      } else {\n        this.renderCustomToolbar();\n      }\n    }\n  }\n\n}\n/**\n * CellRenderer class which responsible for building cell content.\n *\n * @hidden\n */\n\n\nclass CellRenderer {\n  constructor(parent, locator) {\n    this.localizer = locator.getService('localization');\n    this.formatter = locator.getService('valueFormatter');\n    this.parent = parent;\n    this.element = this.parent.createElement('TD', {\n      className: rowCell,\n      attrs: {\n        role: 'gridcell',\n        tabindex: '-1'\n      }\n    });\n    this.rowChkBox = this.parent.createElement('input', {\n      className: 'e-checkselect',\n      attrs: {\n        'type': 'checkbox'\n      }\n    });\n  }\n  /**\n   * Function to return the wrapper for the TD content\n   *\n   * @returns {string | Element} returns the string\n   */\n\n\n  getGui() {\n    return '';\n  }\n  /**\n   * Function to format the cell value.\n   *\n   * @param  {Column} column - specifies the column\n   * @param  {Object} value - specifies the value\n   * @param  {Object} data - specifies the data\n   * @returns {string} returns the format\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  format(column, value, data) {\n    if (!isNullOrUndefined(column.format)) {\n      if (column.type === 'number' && isNaN(parseInt(value, 10))) {\n        value = null;\n      }\n\n      value = this.formatter.toView(value, column.getFormatter());\n    }\n\n    return isNullOrUndefined(value) ? '' : value.toString();\n  } // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  evaluate(node, cell, data, attributes$$1, fData, isEdit) {\n    let result;\n\n    if (cell.column.template) {\n      const isReactCompiler = this.parent.isReact && typeof cell.column.template !== 'string';\n      const literals = ['index'];\n      const dummyData = extendObjWithFn({}, data, {\n        [foreignKeyData]: fData,\n        column: cell.column\n      });\n      const templateID = this.parent.element.id + cell.column.uid;\n      const str = 'isStringTemplate';\n\n      if (isReactCompiler) {\n        const copied = {\n          'index': attributes$$1[literals[0]]\n        };\n        cell.column.getColumnTemplate()(extend(copied, dummyData), this.parent, 'columnTemplate', templateID, this.parent[str], null, node);\n        this.parent.renderTemplates();\n      } else {\n        result = cell.column.getColumnTemplate()(extend({\n          'index': attributes$$1[literals[0]]\n        }, dummyData), this.parent, 'template', templateID, this.parent[str]);\n      }\n\n      if (!isReactCompiler) {\n        appendChildren(node, result);\n      }\n\n      this.parent.notify('template-result', {\n        template: result\n      });\n      result = null;\n      node.setAttribute('aria-label', node.innerText + ' is template cell' + ' column header ' + cell.column.headerText);\n      return false;\n    }\n\n    return true;\n  }\n  /**\n   * Function to invoke the custom formatter available in the column object.\n   *\n   * @param  {Column} column - specifies the column\n   * @param  {Object} value - specifies the value\n   * @param  {Object} data - specifies the data\n   * @returns {Object} returns the object\n   */\n\n\n  invokeFormatter(column, value, data) {\n    if (!isNullOrUndefined(column.formatter)) {\n      if (doesImplementInterface(column.formatter, 'getValue')) {\n        const formatter = column.formatter;\n        value = new formatter().getValue(column, data);\n      } else if (typeof column.formatter === 'function') {\n        value = column.formatter(column, data);\n      } else {\n        value = column.formatter.getValue(column, data);\n      }\n    }\n\n    return value;\n  }\n  /**\n   * Function to render the cell content based on Column object.\n   *\n   * @param {Cell<Column>} cell - specifies the cell\n   * @param {Object} data - specifies the data\n   * @param {Object} attributes - specifies the attributes\n   * @param {boolean} isExpand - specifies the boolean for expand\n   * @param {boolean} isEdit - specifies the boolean for edit\n   * @returns {Element} returns the element\n   */\n\n\n  render(cell, data, attributes$$1, isExpand, isEdit) {\n    return this.refreshCell(cell, data, attributes$$1, isEdit);\n  }\n  /**\n   * Function to refresh the cell content based on Column object.\n   *\n   * @param {Element} td - specifies the element\n   * @param {Cell<Column>} cell - specifies the cell\n   * @param {Object} data - specifies the data\n   * @param {Object} attributes - specifies the attribute\n   * @returns {void}\n   */\n\n\n  refreshTD(td, cell, data, attributes$$1) {\n    const isEdit = this.parent.editSettings.mode === 'Batch' && td.classList.contains('e-editedbatchcell');\n\n    if (this.parent.isReact) {\n      td.innerHTML = '';\n      const cellIndex = td.cellIndex;\n      const parentRow = td.parentElement;\n      remove(td);\n      const newTD = this.refreshCell(cell, data, attributes$$1, isEdit);\n      this.cloneAttributes(newTD, td);\n\n      if (parentRow.cells.length !== cellIndex - 1) {\n        parentRow.insertBefore(newTD, parentRow.cells[cellIndex]);\n      } else {\n        parentRow.appendChild(newTD);\n      }\n    } else {\n      const node = this.refreshCell(cell, data, attributes$$1, isEdit);\n      td.innerHTML = '';\n      td.setAttribute('aria-label', node.getAttribute('aria-label'));\n      const elements = [].slice.call(node.childNodes);\n\n      for (const elem of elements) {\n        td.appendChild(elem);\n      }\n    }\n  } // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n\n  cloneAttributes(target, source) {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const attrs = source.attributes; // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n    let i = attrs.length; // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n    let attr;\n\n    while (i--) {\n      attr = attrs[i];\n      target.setAttribute(attr.name, attr.value);\n    }\n  }\n\n  refreshCell(cell, data, attributes$$1, isEdit) {\n    const node = this.element.cloneNode();\n    const column = cell.column;\n    let fData;\n\n    if (cell.isForeignKey) {\n      fData = cell.foreignKeyData[0] || {\n        [column.foreignKeyValue]: column.format ? null : ''\n      };\n    } //Prepare innerHtml\n\n\n    let innerHtml = this.getGui();\n    let value = cell.isForeignKey ? this.getValue(column.foreignKeyValue, fData, column) : this.getValue(column.field, data, column);\n\n    if ((column.type === 'date' || column.type === 'datetime') && !isNullOrUndefined(value)) {\n      value = new Date(value);\n    }\n\n    value = this.format(column, value, data);\n    innerHtml = value.toString();\n\n    if (column.type === 'boolean' && !column.displayAsCheckBox) {\n      const localeStr = value !== 'true' && value !== 'false' ? null : value === 'true' ? 'True' : 'False';\n      innerHtml = localeStr ? this.localizer.getConstant(localeStr) : innerHtml;\n    }\n\n    const fromFormatter = this.invokeFormatter(column, value, data);\n    innerHtml = !isNullOrUndefined(column.formatter) ? isNullOrUndefined(fromFormatter) ? '' : fromFormatter.toString() : innerHtml;\n    node.setAttribute('aria-label', innerHtml + ' column header ' + cell.column.headerText);\n\n    if (this.evaluate(node, cell, data, attributes$$1, fData, isEdit) && column.type !== 'checkbox') {\n      this.appendHtml(node, innerHtml, column.getDomSetter ? column.getDomSetter() : 'innerHTML');\n    } else if (column.type === 'checkbox') {\n      node.classList.add(gridChkBox);\n      node.setAttribute('aria-label', 'checkbox');\n\n      if (this.parent.selectionSettings.persistSelection) {\n        value = value === 'true';\n      } else {\n        value = false;\n      }\n\n      const checkWrap = createCheckBox(this.parent.createElement, false, {\n        checked: value,\n        label: ' '\n      });\n      checkWrap.insertBefore(this.rowChkBox.cloneNode(), checkWrap.firstChild);\n      node.appendChild(checkWrap);\n    }\n\n    if (this.parent.checkAllRows === 'Check' && this.parent.enableVirtualization) {\n      cell.isSelected = true;\n    }\n\n    this.setAttributes(node, cell, attributes$$1);\n\n    if (column.type === 'boolean' && column.displayAsCheckBox) {\n      const checked = isNaN(parseInt(value.toString(), 10)) ? value === 'true' : parseInt(value.toString(), 10) > 0;\n      const checkWrap = createCheckBox(this.parent.createElement, false, {\n        checked: checked,\n        label: ' '\n      });\n      node.innerHTML = '';\n      checkWrap.classList.add('e-checkbox-disabled');\n      node.appendChild(checkWrap);\n      node.setAttribute('aria-label', checked + ' column header ' + cell.column.headerText);\n    }\n\n    return node;\n  }\n  /**\n   * Function to specifies how the result content to be placed in the cell.\n   *\n   * @param {Element} node - specifies the node\n   * @param {string|Element} innerHtml - specifies the innerHTML\n   * @param {string} property - specifies the element\n   * @returns {Element} returns the element\n   */\n\n\n  appendHtml(node, innerHtml, property = 'innerHTML') {\n    node[property] = innerHtml;\n    return node;\n  }\n  /**\n   * @param {HTMLElement} node - specifies the node\n   * @param {cell<Column>} cell - specifies the cell\n   * @param {Object} attributes - specifies the attributes\n   * @returns {void}\n   * @hidden\n   */\n\n\n  setAttributes(node, cell, attributes$$1) {\n    const column = cell.column;\n    this.buildAttributeFromCell(node, cell, column.type === 'checkbox');\n    setStyleAndAttributes(node, attributes$$1);\n    setStyleAndAttributes(node, cell.attributes);\n\n    if (column.customAttributes) {\n      setStyleAndAttributes(node, column.customAttributes);\n    }\n\n    if (this.parent.rowRenderingMode === 'Vertical') {\n      setStyleAndAttributes(node, {\n        'data-cell': column.headerText\n      });\n    }\n\n    if (column.textAlign) {\n      node.style.textAlign = column.textAlign;\n    }\n\n    if (column.clipMode === 'Clip' || !column.clipMode && this.parent.clipMode === 'Clip') {\n      node.classList.add('e-gridclip');\n    } else if (column.clipMode === 'EllipsisWithTooltip' || !column.clipMode && this.parent.clipMode === 'EllipsisWithTooltip') {\n      if (column.type !== 'checkbox') {\n        node.classList.add('e-ellipsistooltip');\n      }\n    }\n  }\n\n  buildAttributeFromCell(node, cell, isCheckBoxType) {\n    const attr = {};\n    const prop = {\n      'colindex': ariaColIndex\n    };\n    const classes = [];\n\n    if (cell.colSpan) {\n      attr.colSpan = cell.colSpan;\n    }\n\n    if (cell.rowSpan) {\n      attr.rowSpan = cell.rowSpan;\n    }\n\n    if (cell.isTemplate) {\n      classes.push('e-templatecell');\n    }\n\n    if (cell.isSelected) {\n      classes.push(...['e-selectionbackground', 'e-active']);\n\n      if (isCheckBoxType) {\n        node.querySelector('.e-frame').classList.add('e-check');\n      }\n    }\n\n    if (cell.isColumnSelected) {\n      classes.push(...['e-columnselection']);\n    }\n\n    if (cell.cellType === CellType.Header) {\n      attr[prop.colindex] = cell.colIndex;\n    } else if (!isNullOrUndefined(cell.index)) {\n      attr[prop.colindex] = cell.index;\n    }\n\n    if (!cell.visible) {\n      classes.push('e-hide');\n    }\n\n    attr.class = classes;\n    setStyleAndAttributes(node, attr);\n  }\n\n  getValue(field, data, column) {\n    return column.valueAccessor(field, data, column);\n  }\n\n}\n/**\n * AriaService\n *\n * @hidden\n */\n\n\nclass AriaService {\n  setOptions(target, options) {\n    const props = Object.keys(options);\n\n    for (let i = 0; i < props.length; i++) {\n      setStateAndProperties(target, config[props[i]], options[props[i]]);\n    }\n  }\n\n  setExpand(target, expand) {\n    setStateAndProperties(target, config.expand, expand);\n  }\n\n  setSort(target, direction) {\n    setStateAndProperties(target, config.sort, direction, typeof direction === 'boolean');\n  }\n\n  setBusy(target, isBusy) {\n    setStateAndProperties(target, config.busy, isBusy);\n    setStateAndProperties(target, config.invalid, null, true);\n  }\n\n  setGrabbed(target, isGrabbed, remove$$1) {\n    setStateAndProperties(target, config.grabbed, isGrabbed, remove$$1);\n  }\n\n  setDropTarget(target, isTarget) {\n    setStateAndProperties(target, config.dropeffect, 'copy', !isTarget);\n  }\n\n}\n/**\n * @param {HTMLElement} target - specifies the target\n * @param {string} attribute - specifies the attribute\n * @param {ValueType} value - specifies the value\n * @param {boolean} remove - specifies the boolean for remove\n * @returns {void}\n * @hidden\n */\n\n\nfunction setStateAndProperties(target, attribute, value, remove$$1) {\n  if (remove$$1 && target) {\n    target.removeAttribute(attribute);\n    return;\n  }\n\n  if (target) {\n    target.setAttribute(attribute, value);\n  }\n}\n\nconst config = {\n  expand: 'aria-expanded',\n  role: 'role',\n  selected: 'aria-selected',\n  multiselectable: 'aria-multiselectable',\n  sort: 'aria-sort',\n  busy: 'aria-busy',\n  invalid: 'aria-invalid',\n  grabbed: 'aria-grabbed',\n  dropeffect: 'aria-dropeffect',\n  haspopup: 'aria-haspopup',\n  level: 'aria-level',\n  colcount: 'aria-colcount',\n  rowcount: 'aria-rowcount'\n};\n/**\n * HeaderCellRenderer class which responsible for building header cell content.\n *\n * @hidden\n */\n\nclass HeaderCellRenderer extends CellRenderer {\n  constructor() {\n    super(...arguments);\n    this.element = this.parent.createElement('TH', {\n      className: 'e-headercell',\n      attrs: {\n        role: 'columnheader',\n        tabindex: '-1'\n      }\n    });\n    this.ariaService = new AriaService();\n    this.hTxtEle = this.parent.createElement('span', {\n      className: 'e-headertext'\n    });\n    this.sortEle = this.parent.createElement('div', {\n      className: 'e-sortfilterdiv e-icons'\n    });\n    this.gui = this.parent.createElement('div');\n    this.chkAllBox = this.parent.createElement('input', {\n      className: 'e-checkselectall',\n      attrs: {\n        'type': 'checkbox'\n      }\n    });\n  }\n  /**\n   * Function to return the wrapper for the TH content.\n   *\n   * @returns {string | Element} returns the element\n   */\n\n\n  getGui() {\n    return this.gui.cloneNode();\n  }\n  /**\n   * Function to render the cell content based on Column object.\n   *\n   * @param {Cell} cell - specifies the column\n   * @param {Object} data - specifies the data\n   * @param {object} attributes - specifies the aattributes\n   * @returns {Element} returns the element\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  render(cell, data, attributes$$1) {\n    const node = this.element.cloneNode();\n    const fltrMenuEle = this.parent.createElement('div', {\n      className: 'e-filtermenudiv e-icons e-icon-filter'\n    });\n    return this.prepareHeader(cell, node, fltrMenuEle);\n  }\n  /**\n   * Function to refresh the cell content based on Column object.\n   *\n   * @param  {Cell} cell - specifies the cell\n   * @param  {Element} node - specifies the noe\n   * @returns {Element} returns the element\n   */\n\n\n  refresh(cell, node) {\n    this.clean(node);\n    const fltrMenuEle = this.parent.createElement('div', {\n      className: 'e-filtermenudiv e-icons e-icon-filter'\n    });\n    return this.prepareHeader(cell, node, fltrMenuEle);\n  }\n\n  clean(node) {\n    node.innerHTML = '';\n  }\n  /* tslint:disable-next-line:max-func-body-length */\n\n\n  prepareHeader(cell, node, fltrMenuEle) {\n    const column = cell.column;\n    const ariaAttr = {}; //Prepare innerHtml\n\n    const innerDIV = this.getGui();\n    let hValueAccer;\n    attributes(innerDIV, {\n      'e-mappinguid': column.uid,\n      'class': 'e-headercelldiv'\n    });\n\n    if (!isNullOrUndefined(column.headerValueAccessor)) {\n      hValueAccer = this.getValue(column.headerText, column);\n    }\n\n    if (column.type !== 'checkbox') {\n      let value = column.headerText;\n\n      if (!isNullOrUndefined(hValueAccer)) {\n        value = hValueAccer;\n      }\n\n      const headerText = this.hTxtEle.cloneNode();\n      headerText[column.getDomSetter()] = value;\n      innerDIV.appendChild(headerText);\n    } else {\n      column.editType = 'booleanedit';\n      const checkAllWrap = createCheckBox(this.parent.createElement, false, {\n        checked: false,\n        label: ' '\n      });\n      checkAllWrap.insertBefore(this.chkAllBox.cloneNode(), checkAllWrap.firstChild);\n      innerDIV.appendChild(checkAllWrap);\n      innerDIV.classList.add('e-headerchkcelldiv');\n    }\n\n    this.buildAttributeFromCell(node, cell);\n    this.appendHtml(node, innerDIV);\n    node.appendChild(this.sortEle.cloneNode());\n\n    if (this.parent.allowFiltering && this.parent.filterSettings.type !== 'FilterBar' && column.allowFiltering && !isNullOrUndefined(column.field) && !(this.parent.showColumnMenu && column.showColumnMenu)) {\n      attributes(fltrMenuEle, {\n        'e-mappinguid': 'e-flmenu-' + column.uid\n      });\n      node.classList.add('e-fltr-icon');\n      const matchFlColumns = [];\n\n      if (this.parent.filterSettings.columns.length && this.parent.filterSettings.columns.length !== matchFlColumns.length) {\n        const foreignColumn = this.parent.getForeignKeyColumns();\n\n        for (let index = 0; index < this.parent.columns.length; index++) {\n          for (let count = 0; count < this.parent.filterSettings.columns.length; count++) {\n            if (this.parent.filterSettings.columns[count].field === column.field || foreignColumn.length && column.foreignKeyValue === this.parent.filterSettings.columns[count].field) {\n              fltrMenuEle.classList.add('e-filtered');\n              matchFlColumns.push(column.field);\n              break;\n            }\n          }\n        }\n      }\n\n      node.appendChild(fltrMenuEle.cloneNode());\n    }\n\n    if (cell.className) {\n      node.classList.add(cell.className);\n    }\n\n    if (column.customAttributes) {\n      setStyleAndAttributes(node, column.customAttributes);\n    }\n\n    if (column.allowSorting) {\n      ariaAttr.sort = 'none';\n    }\n\n    if (column.allowGrouping) {\n      ariaAttr.grabbed = false;\n    }\n\n    node = this.extendPrepareHeader(column, node);\n    let result;\n    const gridObj = this.parent;\n    const colIndex = gridObj.getColumnIndexByField(column.field);\n\n    if (!isNullOrUndefined(column.headerTemplate)) {\n      //need to pass the template id for blazor headertemplate\n      const headerTempID = gridObj.element.id + column.uid + 'headerTemplate';\n      const str = 'isStringTemplate';\n      const col = column;\n      const isReactCompiler = this.parent.isReact && typeof column.headerTemplate !== 'string';\n\n      if (isReactCompiler) {\n        const copied = {\n          'index': colIndex\n        };\n        node.firstElementChild.innerHTML = '';\n        column.getHeaderTemplate()(extend(copied, col), gridObj, 'headerTemplate', headerTempID, this.parent[str], null, node.firstElementChild);\n        this.parent.renderTemplates();\n      } else {\n        result = column.getHeaderTemplate()(extend({\n          'index': colIndex\n        }, col), gridObj, 'headerTemplate', headerTempID, this.parent[str]);\n        node.firstElementChild.innerHTML = '';\n        appendChildren(node.firstElementChild, result);\n      }\n    }\n\n    this.ariaService.setOptions(node, ariaAttr);\n\n    if (!isNullOrUndefined(column.headerTextAlign) || !isNullOrUndefined(column.textAlign)) {\n      const alignment = column.headerTextAlign || column.textAlign;\n      innerDIV.style.textAlign = alignment;\n\n      if (alignment === 'Right' || alignment === 'Left') {\n        node.classList.add(alignment === 'Right' ? 'e-rightalign' : 'e-leftalign');\n      } else if (alignment === 'Center') {\n        node.classList.add('e-centeralign');\n      }\n    }\n\n    if (column.clipMode === 'Clip' || !column.clipMode && this.parent.clipMode === 'Clip') {\n      node.classList.add('e-gridclip');\n    } else if (column.clipMode === 'EllipsisWithTooltip' || !column.clipMode && this.parent.clipMode === 'EllipsisWithTooltip') {\n      if (column.type !== 'checkbox') {\n        node.classList.add('e-ellipsistooltip');\n      }\n    }\n\n    node.setAttribute('aria-rowspan', (!isNullOrUndefined(cell.rowSpan) ? cell.rowSpan : 1).toString());\n    node.setAttribute('aria-colspan', '1');\n    this.parent.trigger(headerCellInfo, {\n      cell,\n      node\n    });\n    return node;\n  }\n\n  getValue(field, column) {\n    return column.headerValueAccessor(field, column);\n  }\n\n  extendPrepareHeader(column, node) {\n    if (this.parent.showColumnMenu && column.showColumnMenu && !isNullOrUndefined(column.field)) {\n      const element = this.parent.createElement('div', {\n        className: 'e-icons e-columnmenu'\n      });\n      const matchFilteredColumns = [];\n\n      if (this.parent.filterSettings.columns.length && this.parent.filterSettings.columns.length !== matchFilteredColumns.length) {\n        for (let i = 0; i < this.parent.columns.length; i++) {\n          for (let j = 0; j < this.parent.filterSettings.columns.length; j++) {\n            if (this.parent.filterSettings.columns[j].field === column.field) {\n              element.classList.add('e-filtered');\n              matchFilteredColumns.push(column.field);\n              break;\n            }\n          }\n        }\n      }\n\n      node.classList.add('e-fltr-icon');\n      node.appendChild(element);\n    }\n\n    if (this.parent.allowResizing) {\n      const handler = this.parent.createElement('div');\n      handler.className = column.allowResizing ? 'e-rhandler e-rcursor' : 'e-rsuppress';\n      node.appendChild(handler);\n    }\n\n    return node;\n  }\n  /**\n   * Function to specifies how the result content to be placed in the cell.\n   *\n   * @param  {Element} node - specifies the node\n   * @param  {string|Element} innerHtml - specifies the innerHtml\n   * @returns {Element} returns the element\n   */\n\n\n  appendHtml(node, innerHtml) {\n    node.appendChild(innerHtml);\n    return node;\n  }\n\n}\n/**\n * StackedHeaderCellRenderer class which responsible for building stacked header cell content.\n *\n * @hidden\n */\n\n\nclass StackedHeaderCellRenderer extends CellRenderer {\n  constructor() {\n    super(...arguments);\n    this.element = this.parent.createElement('TH', {\n      className: 'e-headercell e-stackedheadercell',\n      attrs: {\n        role: 'columnheader',\n        tabindex: '-1'\n      }\n    });\n  }\n  /**\n   * Function to render the cell content based on Column object.\n   *\n   * @param {Cell<Column>} cell - specifies the cell\n   * @param {Object} data - specifies the data\n   * @param {object} attributes - specifies the attributes\n   * @returns {Element} returns the element\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  render(cell, data, attributes$$1) {\n    const node = this.element.cloneNode();\n    const div = this.parent.createElement('div', {\n      className: 'e-stackedheadercelldiv',\n      attrs: {\n        'e-mappinguid': cell.column.uid\n      }\n    });\n    const column = cell.column;\n    node.appendChild(div);\n\n    if (!isNullOrUndefined(column.headerTemplate)) {\n      appendChildren(div, column.getHeaderTemplate()(column, this.parent, 'headerTemplate'));\n    } else {\n      this.appendHtml(div, column.headerText, column.getDomSetter());\n    }\n\n    if (cell.column.toolTip) {\n      node.setAttribute('title', cell.column.toolTip);\n    }\n\n    if (column.clipMode === 'Clip' || !column.clipMode && this.parent.clipMode === 'Clip') {\n      node.classList.add('e-gridclip');\n    } else if (column.clipMode === 'EllipsisWithTooltip' || !column.clipMode && this.parent.clipMode === 'EllipsisWithTooltip') {\n      node.classList.add('e-ellipsistooltip');\n    }\n\n    if (!isNullOrUndefined(cell.column.textAlign)) {\n      div.style.textAlign = cell.column.textAlign;\n    }\n\n    if (cell.column.customAttributes) {\n      setStyleAndAttributes(node, cell.column.customAttributes);\n    }\n\n    node.setAttribute('colspan', cell.colSpan.toString());\n    node.setAttribute('aria-colspan', cell.colSpan.toString());\n    node.setAttribute('aria-rowspan', '1');\n\n    if (this.parent.allowResizing) {\n      const handler = this.parent.createElement('div');\n      handler.className = cell.column.allowResizing ? 'e-rhandler e-rcursor' : 'e-rsuppress';\n      node.appendChild(handler);\n    }\n\n    this.parent.trigger(headerCellInfo, {\n      cell,\n      node\n    });\n    return node;\n  }\n\n}\n/**\n * IndentCellRenderer class which responsible for building group indent cell.\n *\n * @hidden\n */\n\n\nclass IndentCellRenderer extends CellRenderer {\n  constructor() {\n    super(...arguments);\n    this.element = this.parent.createElement('TD', {\n      className: 'e-indentcell'\n    });\n  }\n  /**\n   * Function to render the indent cell\n   *\n   * @param  {Cell} cell - specifies the cell\n   * @param  {Object} data - specifies the data\n   * @returns {Element} returns the element\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  render(cell, data) {\n    const node = this.element.cloneNode();\n    setStyleAndAttributes(node, cell.attributes);\n    return node;\n  }\n\n}\n/**\n * GroupCaptionCellRenderer class which responsible for building group caption cell.\n *\n * @hidden\n */\n\n\nclass GroupCaptionCellRenderer extends CellRenderer {\n  constructor() {\n    super(...arguments);\n    this.element = this.parent.createElement('TD', {\n      className: 'e-groupcaption',\n      attrs: {\n        id: this.parent.element.id + 'captioncell',\n        role: 'gridcell',\n        tabindex: '-1'\n      }\n    });\n  }\n  /**\n   * Function to render the cell content based on Column object.\n   *\n   * @param  {Cell} cell - specifies the cell\n   * @param  {Object} data - specifies the GroupedData\n   * @returns {Element} returns the element\n   */\n\n\n  render(cell, data) {\n    const node = this.element.cloneNode();\n    const gObj = this.parent;\n    let result;\n    let fKeyValue;\n    data.headerText = cell.column.headerText;\n\n    if (cell.isForeignKey) {\n      fKeyValue = this.format(cell.column, cell.column.valueAccessor('foreignKey', data, cell.column));\n    }\n\n    const value = cell.isForeignKey ? fKeyValue : cell.column.enableGroupByFormat ? data.key : this.format(cell.column, cell.column.valueAccessor('key', data, cell.column));\n\n    if (!isNullOrUndefined(gObj.groupSettings.captionTemplate)) {\n      const isReactCompiler = this.parent.isReact && typeof gObj.groupSettings.captionTemplate !== 'string';\n\n      if (isReactCompiler) {\n        const tempID = gObj.element.id + 'captionTemplate';\n        templateCompiler(gObj.groupSettings.captionTemplate)(data, this.parent, 'captionTemplate', tempID, null, null, node);\n        this.parent.renderTemplates();\n      } else if (this.parent.isVue) {\n        result = templateCompiler(gObj.groupSettings.captionTemplate)(data, this.parent);\n      } else {\n        result = templateCompiler(gObj.groupSettings.captionTemplate)(data);\n      }\n\n      if (!isReactCompiler) {\n        appendChildren(node, result);\n      }\n    } else {\n      if (gObj.groupSettings.enableLazyLoading) {\n        node.innerHTML = cell.column.headerText + ': ' + value;\n      } else {\n        node.innerHTML = cell.column.headerText + ': ' + value + ' - ' + data.count + ' ' + (data.count < 2 ? this.localizer.getConstant('Item') : this.localizer.getConstant('Items'));\n      }\n    }\n\n    node.setAttribute('colspan', cell.colSpan.toString());\n    node.setAttribute('aria-label', node.innerHTML + ' is groupcaption cell');\n    node.setAttribute('title', node.innerHTML);\n    return node;\n  }\n\n}\n/**\n * GroupCaptionEmptyCellRenderer class which responsible for building group caption empty cell.\n *\n * @hidden\n */\n\n\nclass GroupCaptionEmptyCellRenderer extends CellRenderer {\n  constructor() {\n    super(...arguments);\n    this.element = this.parent.createElement('TD', {\n      className: 'e-groupcaption'\n    });\n  }\n  /**\n   * Function to render the cell content based on Column object.\n   *\n   * @param {Cell} cell - specifies the cell\n   * @param {Object} data - specifies the Object\n   * @param {string} data.field - Defines the field\n   * @param {string} data.key - Defines the key\n   * @param {number} data.count - Defines the count\n   * @returns {Element} returns the element\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  render(cell, data) {\n    const node = this.element.cloneNode();\n    node.innerHTML = '&nbsp;';\n    node.setAttribute('colspan', cell.colSpan.toString());\n    return node;\n  }\n\n}\n/**\n * ExpandCellRenderer class which responsible for building group expand cell.\n *\n * @hidden\n */\n\n\nclass ExpandCellRenderer extends IndentCellRenderer {\n  /**\n   * Function to render the expand cell\n   *\n   * @param {Cell} cell - specifies the cell\n   * @param {Object} data - specifies the data\n   * @param {string} data.field - Defines the field\n   * @param {string} data.key - Defines the key\n   * @param {Object} attr - specifies the attribute\n   * @param {boolean} isExpand - specifies isexpand\n   * @returns {Element} returns the element\n   */\n  render(cell, data, attr, isExpand) {\n    const node = this.element.cloneNode();\n    node.className = isExpand ? 'e-recordplusexpand' : 'e-recordpluscollapse';\n    node.setAttribute('ej-mappingname', data.field);\n    node.setAttribute('ej-mappingvalue', data.key);\n    node.setAttribute('aria-expanded', isExpand ? 'true' : 'false');\n    node.setAttribute('tabindex', '-1');\n    node.appendChild(this.parent.createElement('div', {\n      className: isExpand ? 'e-icons e-gdiagonaldown e-icon-gdownarrow' : 'e-icons e-gnextforward e-icon-grightarrow'\n    }));\n    return node;\n  }\n\n}\n/**\n * HeaderIndentCellRenderer class which responsible for building header indent cell.\n *\n * @hidden\n */\n\n\nclass HeaderIndentCellRenderer extends CellRenderer {\n  constructor() {\n    super(...arguments);\n    this.element = this.parent.createElement('TH', {\n      className: 'e-grouptopleftcell'\n    });\n  }\n  /**\n   * Function to render the indent cell\n   *\n   * @param  {Cell} cell - specifies the cell\n   * @param  {Object} data - specifies the data\n   * @returns {Element} returns the element\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  render(cell, data) {\n    const node = this.element.cloneNode();\n    node.appendChild(this.parent.createElement('div', {\n      className: 'e-headercelldiv e-emptycell',\n      innerHTML: ''\n    }));\n    return node;\n  }\n\n}\n/**\n * DetailHeaderIndentCellRenderer class which responsible for building detail header indent cell.\n *\n * @hidden\n */\n\n\nclass DetailHeaderIndentCellRenderer extends CellRenderer {\n  constructor() {\n    super(...arguments);\n    this.element = this.parent.createElement('TH', {\n      className: 'e-detailheadercell'\n    });\n  }\n  /**\n   * Function to render the detail indent cell\n   *\n   * @param  {Cell} cell - specifies the cell\n   * @param  {Object} data - specifies the data\n   * @returns {Element} returns the element\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  render(cell, data) {\n    const node = this.element.cloneNode();\n    node.appendChild(this.parent.createElement('div', {\n      className: 'e-emptycell'\n    }));\n    return node;\n  }\n\n}\n/**\n * ExpandCellRenderer class which responsible for building group expand cell.\n *\n * @hidden\n */\n\n\nclass DetailExpandCellRenderer extends CellRenderer {\n  constructor() {\n    super(...arguments);\n    this.element = this.parent.createElement('TD', {\n      className: 'e-detailrowcollapse',\n      attrs: {\n        'aria-expanded': 'false',\n        role: 'gridcell',\n        tabindex: '-1'\n      }\n    });\n  }\n  /**\n   * Function to render the detail expand cell\n   *\n   * @param {Cell<Column>} cell - specifies the cell\n   * @param {Object} data - specifies the data\n   * @param {Object} attributes - specifies the attributes\n   * @returns {Element} returns the element\n   */\n\n\n  render(cell, data, attributes$$1) {\n    const node = this.element.cloneNode();\n\n    if (attributes$$1 && !isNullOrUndefined(attributes$$1['class'])) {\n      node.className = '';\n      node.className = attributes$$1['class'];\n      node.appendChild(this.parent.createElement('div', {\n        className: 'e-icons e-dtdiagonaldown e-icon-gdownarrow'\n      }));\n    } else {\n      node.appendChild(this.parent.createElement('div', {\n        className: 'e-icons e-dtdiagonalright e-icon-grightarrow'\n      }));\n    }\n\n    return node;\n  }\n\n}\n/**\n * ExpandCellRenderer class which responsible for building group expand cell.\n *\n * @hidden\n */\n\n\nclass RowDragDropRenderer extends CellRenderer {\n  constructor() {\n    super(...arguments);\n    this.element = this.parent.createElement('TD', {\n      className: 'e-rowdragdrop e-rowdragdropcell',\n      attrs: {\n        role: 'gridcell',\n        tabindex: '-1'\n      }\n    });\n  }\n  /**\n   * Function to render the detail expand cell\n   *\n   * @param {Cell<Column>} cell - specifies the cell\n   * @param {Object} data - specifies the data\n   * @returns {Element} returns the element\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  render(cell, data) {\n    const nodeElement = this.element.cloneNode();\n    nodeElement.appendChild(this.parent.createElement('div', {\n      className: 'e-icons e-rowcelldrag e-dtdiagonalright e-icon-rowdragicon'\n    }));\n\n    if (cell.isSelected) {\n      nodeElement.classList.add('e-selectionbackground');\n      nodeElement.classList.add('e-active');\n    }\n\n    return nodeElement;\n  }\n\n}\n/**\n * DetailHeaderIndentCellRenderer class which responsible for building detail header indent cell.\n *\n * @hidden\n */\n\n\nclass RowDragDropHeaderRenderer extends CellRenderer {\n  constructor() {\n    super(...arguments);\n    this.element = this.parent.createElement('TH', {\n      className: 'e-rowdragheader'\n    });\n  }\n  /**\n   * Function to render the detail indent cell\n   *\n   * @param  {Cell} cell - specifies the cell\n   * @param  {Object} data - specifies the data\n   * @returns {Element} returns the element\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  render(cell, data) {\n    const node = this.element.cloneNode();\n    node.appendChild(createElement('div', {\n      className: 'e-emptycell'\n    }));\n    return node;\n  }\n\n}\n/**\n * Content module is used to render grid content\n *\n * @hidden\n */\n\n\nclass Render {\n  /**\n   * Constructor for render module\n   *\n   * @param {IGrid} parent - specifies the IGrid\n   * @param {ServiceLocator} locator - specifies the serviceLocator\n   */\n  constructor(parent, locator) {\n    this.emptyGrid = false;\n    this.counter = 0;\n    this.parent = parent;\n    this.locator = locator;\n    this.data = new Data(parent, locator);\n    this.l10n = locator.getService('localization');\n    this.ariaService = this.locator.getService('ariaService');\n    this.renderer = this.locator.getService('rendererFactory');\n    this.addEventListener();\n  }\n  /**\n   * To initialize grid header, content and footer rendering\n   *\n   * @returns {void}\n   */\n\n\n  render() {\n    const gObj = this.parent;\n    this.headerRenderer = this.renderer.getRenderer(RenderType.Header);\n    this.contentRenderer = this.renderer.getRenderer(RenderType.Content);\n    this.headerRenderer.renderPanel();\n    this.contentRenderer.renderPanel();\n\n    if (gObj.getColumns().length) {\n      this.isLayoutRendered = true;\n      this.headerRenderer.renderTable();\n      this.contentRenderer.renderTable();\n      this.emptyRow(false);\n    }\n\n    this.parent.scrollModule.setWidth();\n    this.parent.scrollModule.setHeight();\n\n    if (this.parent.height !== 'auto') {\n      this.parent.scrollModule.setPadding();\n    }\n\n    this.refreshDataManager();\n  }\n  /**\n   * Refresh the entire Grid.\n   *\n   * @param {NotifyArgs} e - specifies the NotifyArgs\n   * @returns {void}\n   */\n\n\n  refresh(e = {\n    requestType: 'refresh'\n  }) {\n    const gObj = this.parent;\n    gObj.notify(`${e.requestType}-begin`, e);\n    gObj.trigger(actionBegin, e, (args = {\n      requestType: 'refresh'\n    }) => {\n      if (args.cancel) {\n        gObj.notify(cancelBegin, args);\n        return;\n      }\n\n      if (args.requestType === 'delete' && gObj.allowPaging) {\n        const dataLength = args.data.length;\n        const count = gObj.pageSettings.totalRecordsCount - dataLength;\n        const currentViewData = gObj.getCurrentViewRecords().length; // eslint-disable-next-line max-len\n\n        if (!(currentViewData - dataLength) && count && (gObj.pageSettings.currentPage - 1) * gObj.pageSettings.pageSize === count) {\n          gObj.prevPageMoving = true;\n          gObj.setProperties({\n            pageSettings: {\n              totalRecordsCount: count,\n              currentPage: Math.ceil(count / gObj.pageSettings.pageSize)\n            }\n          }, true);\n          gObj.pagerModule.pagerObj.totalRecordsCount = count;\n        }\n      }\n\n      if (args.requestType === 'reorder' && this.parent.dataSource && 'result' in this.parent.dataSource) {\n        this.contentRenderer.refreshContentRows(args);\n      } else if ((args.requestType === 'paging' || args.requestType === 'columnstate' || args.requestType === 'reorder') && this.parent.groupSettings.enableLazyLoading && this.parent.groupSettings.columns.length && this.parent.contentModule.getGroupCache()[this.parent.pageSettings.currentPage]) {\n        this.contentRenderer.refreshContentRows(args);\n      } else {\n        this.refreshDataManager(args);\n      }\n    });\n  }\n  /**\n   * @returns {void}\n   * @hidden\n   */\n\n\n  resetTemplates() {\n    const gObj = this.parent;\n    const gridColumns = gObj.getColumns();\n\n    if (gObj.detailTemplate) {\n      const detailTemplateID = gObj.element.id + 'detailTemplate';\n      blazorTemplates[detailTemplateID] = [];\n      resetBlazorTemplate(detailTemplateID, 'DetailTemplate');\n    }\n\n    if (gObj.groupSettings.captionTemplate) {\n      resetBlazorTemplate(gObj.element.id + 'captionTemplate', 'CaptionTemplate');\n    }\n\n    if (gObj.rowTemplate) {\n      resetBlazorTemplate(gObj.element.id + 'rowTemplate', 'RowTemplate');\n    }\n\n    if (gObj.toolbarTemplate) {\n      resetBlazorTemplate(gObj.element.id + 'toolbarTemplate', 'ToolbarTemplate');\n    }\n\n    if (gObj.pageSettings.template) {\n      resetBlazorTemplate(gObj.element.id + '_template', 'pageSettings');\n    }\n\n    for (let i = 0; i < gridColumns.length; i++) {\n      if (gridColumns[i].template) {\n        blazorTemplates[gObj.element.id + gridColumns[i].uid] = [];\n        resetBlazorTemplate(gObj.element.id + gridColumns[i].uid, 'Template');\n      }\n\n      if (gridColumns[i].headerTemplate) {\n        resetBlazorTemplate(gObj.element.id + gridColumns[i].uid + 'headerTemplate', 'HeaderTemplate');\n      }\n\n      if (gridColumns[i].filterTemplate) {\n        resetBlazorTemplate(gObj.element.id + gridColumns[i].uid + 'filterTemplate', 'FilterTemplate');\n      }\n    }\n\n    const guid = 'guid';\n\n    for (let k = 0; k < gObj.aggregates.length; k++) {\n      for (let j = 0; j < gObj.aggregates[k].columns.length; j++) {\n        if (gObj.aggregates[k].columns[j].footerTemplate) {\n          const tempID = gObj.element.id + gObj.aggregates[k].columns[j][guid] + 'footerTemplate';\n          resetBlazorTemplate(tempID, 'FooterTemplate');\n        }\n\n        if (gObj.aggregates[k].columns[j].groupFooterTemplate) {\n          const tempID = gObj.element.id + gObj.aggregates[k].columns[j][guid] + 'groupFooterTemplate';\n          resetBlazorTemplate(tempID, 'GroupFooterTemplate');\n        }\n\n        if (gObj.aggregates[k].columns[j].groupCaptionTemplate) {\n          const tempID = gObj.element.id + gObj.aggregates[k].columns[j][guid] + 'groupCaptionTemplate';\n          resetBlazorTemplate(tempID, 'GroupCaptionTemplate');\n        }\n      }\n    }\n  }\n\n  refreshComplete(e) {\n    this.parent.trigger(actionComplete, e);\n  }\n  /**\n   * The function is used to refresh the dataManager\n   *\n   * @param {NotifyArgs} args - specifies the args\n   * @returns {void}\n   */\n\n\n  refreshDataManager(args = {}) {\n    if (args.requestType !== 'virtualscroll' && !args.isCaptionCollapse) {\n      this.parent.showSpinner();\n    }\n\n    this.parent.notify(resetInfiniteBlocks, args);\n    this.emptyGrid = false;\n    let dataManager;\n    const isFActon = this.isNeedForeignAction();\n    this.ariaService.setBusy(this.parent.getContent().querySelector('.' + content), true);\n\n    if (isFActon) {\n      const deffered = new Deferred();\n      dataManager = this.getFData(deffered, args);\n    }\n\n    if (!dataManager) {\n      dataManager = this.data.getData(args, this.data.generateQuery().requiresCount());\n    } else {\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      dataManager = dataManager.then(e => {\n        const query = this.data.generateQuery().requiresCount();\n\n        if (this.emptyGrid) {\n          const def = new Deferred();\n          def.resolve({\n            result: [],\n            count: 0\n          });\n          return def.promise;\n        }\n\n        return this.data.getData(args, query);\n      });\n    }\n\n    if (this.parent.getForeignKeyColumns().length && (!isFActon || this.parent.searchSettings.key.length)) {\n      const deffered = new Deferred();\n      dataManager = dataManager.then(e => {\n        this.parent.notify(getForeignKeyData, {\n          dataManager: dataManager,\n          result: e,\n          promise: deffered,\n          action: args\n        });\n        return deffered.promise;\n      });\n    }\n\n    if (this.parent.groupSettings.disablePageWiseAggregates && this.parent.groupSettings.columns.length) {\n      dataManager = dataManager.then(e => this.validateGroupRecords(e));\n    }\n\n    dataManager.then(e => this.dataManagerSuccess(e, args)).catch(e => this.dataManagerFailure(e, args));\n  }\n\n  getFData(deferred, args) {\n    this.parent.notify(getForeignKeyData, {\n      isComplex: true,\n      promise: deferred,\n      action: args\n    });\n    return deferred.promise;\n  }\n\n  isNeedForeignAction() {\n    const gObj = this.parent;\n    return !!(gObj.allowFiltering && gObj.filterSettings.columns.length || gObj.searchSettings.key.length) && this.foreignKey(this.parent.getForeignKeyColumns());\n  }\n\n  foreignKey(columns) {\n    return columns.some(col => {\n      let fbool = false;\n      fbool = this.parent.filterSettings.columns.some(value => {\n        return col.uid === value.uid;\n      });\n      return !!(fbool || this.parent.searchSettings.key.length);\n    });\n  }\n\n  sendBulkRequest(args) {\n    args.requestType = 'batchsave';\n    const promise = this.data.saveChanges(args.changes, this.parent.getPrimaryKeyFieldNames()[0], args.original);\n    const query = this.data.generateQuery().requiresCount();\n\n    if (this.data.dataManager.dataSource.offline) {\n      this.refreshDataManager({\n        requestType: 'batchsave'\n      });\n      return;\n    } else {\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      promise.then(e => {\n        this.data.getData(args, query).then(e => this.dmSuccess(e, args)).catch(e => this.dmFailure(e, args));\n      }).catch(e => this.dmFailure(e, args));\n    }\n  }\n\n  dmSuccess(e, args) {\n    this.dataManagerSuccess(e, args);\n  }\n\n  dmFailure(e, args) {\n    this.dataManagerFailure(e, args);\n  }\n  /**\n   * Render empty row to Grid which is used at the time to represent to no records.\n   *\n   * @returns {void}\n   * @hidden\n   */\n\n\n  renderEmptyRow() {\n    this.emptyRow(true);\n  }\n\n  emptyRow(isTrigger) {\n    const gObj = this.parent;\n    let tbody$$1 = this.contentRenderer.getTable().querySelector(tbody);\n\n    if (!isNullOrUndefined(tbody$$1)) {\n      remove(tbody$$1);\n    }\n\n    tbody$$1 = this.parent.createElement(tbody);\n    let spanCount = 0;\n\n    if (gObj.detailTemplate || gObj.childGrid) {\n      ++spanCount;\n    }\n\n    const tr = this.parent.createElement('tr', {\n      className: 'e-emptyrow'\n    });\n    tr.appendChild(this.parent.createElement('td', {\n      innerHTML: this.l10n.getConstant('EmptyRecord'),\n      attrs: {\n        colspan: (gObj.getVisibleColumns().length + spanCount + gObj.groupSettings.columns.length).toString()\n      }\n    }));\n    tbody$$1.appendChild(tr);\n    this.contentRenderer.renderEmpty(tbody$$1);\n\n    if (isTrigger) {\n      this.parent.trigger(dataBound, {});\n      this.parent.notify(onEmpty, {\n        rows: [new Row({\n          isDataRow: true,\n          cells: [new Cell({\n            isDataCell: true,\n            visible: true\n          })]\n        })]\n      });\n    }\n  }\n\n  dynamicColumnChange() {\n    if (this.parent.getCurrentViewRecords().length) {\n      this.updateColumnType(this.parent.getCurrentViewRecords()[0]);\n    }\n  }\n\n  updateColumnType(record) {\n    const columns = this.parent.getColumns();\n    let value;\n    const cFormat = 'customFormat';\n    const equalTo = 'equalTo';\n    const data = record && record.items ? record.items[0] : record;\n    const fmtr = this.locator.getService('valueFormatter');\n\n    for (let i = 0, len = columns.length; i < len; i++) {\n      value = getObject(columns[i].field || '', data);\n\n      if (!isNullOrUndefined(columns[i][cFormat])) {\n        columns[i].format = columns[i][cFormat];\n      }\n\n      if (!isNullOrUndefined(columns[i].validationRules) && !isNullOrUndefined(columns[i].validationRules[equalTo])) {\n        columns[i].validationRules[equalTo][0] = this.parent.element.id + columns[i].validationRules[equalTo][0];\n      }\n\n      if (columns[i].isForeignColumn() && columns[i].columnData) {\n        value = getObject(columns[i].foreignKeyValue || '', columns[i].columnData[0]);\n      }\n\n      if (!isNullOrUndefined(value)) {\n        this.isColTypeDef = true;\n\n        if (!columns[i].type) {\n          columns[i].type = value.getDay ? value.getHours() > 0 || value.getMinutes() > 0 || value.getSeconds() > 0 || value.getMilliseconds() > 0 ? 'datetime' : 'date' : typeof value;\n        }\n      } else {\n        columns[i].type = columns[i].type || null;\n      }\n\n      const valueFormatter = new ValueFormatter();\n\n      if (columns[i].format && (columns[i].format.skeleton || columns[i].format.format && typeof columns[i].format.format === 'string')) {\n        columns[i].setFormatter(valueFormatter.getFormatFunction(extend({}, columns[i].format)));\n        columns[i].setParser(valueFormatter.getParserFunction(columns[i].format));\n      }\n\n      if (typeof columns[i].format === 'string') {\n        setFormatter(this.locator, columns[i]);\n      } else if (!columns[i].format && columns[i].type === 'number') {\n        columns[i].setParser(fmtr.getParserFunction({\n          format: 'n2'\n        }));\n      }\n    }\n  }\n  /**\n   * @param {ReturnType} e - specifies the return type\n   * @param {NotifyArgs} args - specifies the Notifyargs\n   * @returns {void}\n   * @hidden\n   */\n  // tslint:disable-next-line:max-func-body-length\n\n\n  dataManagerSuccess(e, args) {\n    const gObj = this.parent;\n    this.contentRenderer = this.renderer.getRenderer(RenderType.Content);\n    this.headerRenderer = this.renderer.getRenderer(RenderType.Header);\n    e.actionArgs = args;\n    const isInfiniteDelete = this.parent.enableInfiniteScrolling && !this.parent.infiniteScrollSettings.enableCache && (args.requestType === 'delete' || args.requestType === 'save' && this.parent.infiniteScrollModule.requestType === 'add'); // tslint:disable-next-line:max-func-body-length\n\n    gObj.trigger(beforeDataBound, e, dataArgs => {\n      if (dataArgs.cancel) {\n        return;\n      }\n\n      dataArgs.result = isNullOrUndefined(dataArgs.result) ? [] : dataArgs.result;\n      const len = Object.keys(dataArgs.result).length;\n\n      if (this.parent.isDestroyed) {\n        return;\n      }\n\n      if (!gObj.getColumns().length && !len && !(gObj.columns.length && gObj.columns[0] instanceof Column)) {\n        gObj.hideSpinner();\n        return;\n      }\n\n      if (this.isInfiniteEnd(args) && !len) {\n        this.parent.notify(infiniteEditHandler, {\n          e: args,\n          result: e.result,\n          count: e.count,\n          agg: e.aggregates\n        });\n        return;\n      }\n\n      this.parent.isEdit = false;\n      this.parent.notify(editReset, {});\n      this.parent.notify(tooltipDestroy, {});\n      this.contentRenderer.prevCurrentView = this.parent.currentViewData.slice();\n      gObj.currentViewData = dataArgs.result;\n      gObj.notify(refreshInfiniteCurrentViewData, {\n        args: args,\n        data: dataArgs.result\n      });\n\n      if (!len && dataArgs.count && gObj.allowPaging && args && args.requestType !== 'delete') {\n        if (this.parent.groupSettings.enableLazyLoading && (args.requestType === 'grouping' || args.requestType === 'ungrouping')) {\n          this.parent.notify(groupComplete, args);\n        }\n\n        gObj.prevPageMoving = true;\n        gObj.pageSettings.totalRecordsCount = dataArgs.count;\n\n        if (args.requestType !== 'paging') {\n          gObj.pageSettings.currentPage = Math.ceil(dataArgs.count / gObj.pageSettings.pageSize);\n        }\n\n        gObj.dataBind();\n        return;\n      }\n\n      if ((!gObj.getColumns().length && len || !this.isLayoutRendered) && !isGroupAdaptive(gObj)) {\n        this.updatesOnInitialRender(dataArgs);\n      }\n\n      if (!this.isColTypeDef && gObj.getCurrentViewRecords()) {\n        if (this.data.dataManager.dataSource.offline && gObj.dataSource && gObj.dataSource.length) {\n          this.updateColumnType(gObj.dataSource[0]);\n        } else {\n          this.updateColumnType(gObj.getCurrentViewRecords()[0]);\n        }\n      }\n\n      if (!this.parent.isInitialLoad && this.parent.groupSettings.disablePageWiseAggregates && !this.parent.groupSettings.columns.length) {\n        dataArgs.result = this.parent.dataSource instanceof Array ? this.parent.dataSource : this.parent.currentViewData;\n      }\n\n      if ((this.parent.isReact || this.parent.isVue) && !isNullOrUndefined(args) && args.requestType !== 'infiniteScroll' && !args.isFrozen) {\n        clearReactVueTemplates(this.parent, ['footerTemplate']);\n      }\n\n      this.parent.notify(dataReady, extend({\n        count: dataArgs.count,\n        result: dataArgs.result,\n        aggregates: dataArgs.aggregates\n      }, args));\n\n      if ((gObj.groupSettings.columns.length || args && args.requestType === 'ungrouping') && args && args.requestType !== 'filtering') {\n        this.headerRenderer.refreshUI();\n      }\n\n      if (len) {\n        if (isGroupAdaptive(gObj)) {\n          const content$$1 = 'content';\n          args.scrollTop = {\n            top: this.contentRenderer[content$$1].scrollTop\n          };\n        }\n\n        if (!isInfiniteDelete) {\n          if (this.parent.enableImmutableMode) {\n            this.contentRenderer.immutableModeRendering(args);\n          } else {\n            this.contentRenderer.refreshContentRows(args);\n          }\n        } else {\n          this.parent.notify(infiniteEditHandler, {\n            e: args,\n            result: e.result,\n            count: e.count,\n            agg: e.aggregates\n          });\n        }\n      } else {\n        if (args && args.isCaptionCollapse) {\n          return;\n        }\n\n        if (!gObj.getColumns().length) {\n          gObj.element.innerHTML = '';\n          alert(this.l10n.getConstant('EmptyDataSourceError')); //ToDO: change this alert as dialog\n\n          return;\n        }\n\n        this.contentRenderer.setRowElements([]);\n        this.contentRenderer.setRowObjects([]);\n        this.ariaService.setBusy(this.parent.getContent().querySelector('.' + content), false);\n        this.renderEmptyRow();\n\n        if (args) {\n          const action = (args.requestType || '').toLowerCase() + '-complete';\n          this.parent.notify(action, args);\n\n          if (args.requestType === 'batchsave') {\n            args.cancel = false;\n            args.rows = [];\n            args.isFrozen = this.parent.getFrozenColumns() !== 0 && !args.isFrozen;\n            this.parent.trigger(actionComplete, args);\n          }\n        }\n\n        this.parent.hideSpinner();\n      }\n\n      this.parent.notify(toolbarRefresh, {});\n      this.setRowCount(this.parent.getCurrentViewRecords().length);\n      this.parent.getDataModule().isQueryInvokedFromData = false;\n    });\n  }\n  /**\n   * @param {object} e - specifies the object\n   * @param {Object[]} e.result - specifies the result\n   * @param {NotifyArgs} args - specifies the args\n   * @returns {void}\n   * @hidden\n   */\n\n\n  dataManagerFailure(e, args) {\n    this.ariaService.setOptions(this.parent.getContent().querySelector('.' + content), {\n      busy: false,\n      invalid: true\n    });\n    this.setRowCount(1);\n    this.parent.trigger(actionFailure, {\n      error: e\n    });\n    this.parent.hideSpinner();\n\n    if (args.requestType === 'save' || args.requestType === 'delete' || args.name === 'bulk-save') {\n      return;\n    }\n\n    this.parent.currentViewData = [];\n    this.renderEmptyRow();\n    this.parent.log('actionfailure', {\n      error: e\n    });\n  }\n\n  setRowCount(dataRowCount) {\n    this.ariaService.setOptions(this.parent.getHeaderTable(), {\n      rowcount: dataRowCount ? dataRowCount.toString() : '1'\n    });\n  }\n\n  isInfiniteEnd(args) {\n    return this.parent.enableInfiniteScrolling && !this.parent.infiniteScrollSettings.enableCache && args.requestType === 'delete';\n  }\n\n  updatesOnInitialRender(e) {\n    this.isLayoutRendered = true;\n\n    if (this.parent.columns.length < 1) {\n      this.buildColumns(e.result[0]);\n    }\n\n    prepareColumns(this.parent.columns, null, this.parent);\n    this.headerRenderer.renderTable();\n    this.contentRenderer.renderTable();\n    this.parent.isAutoGen = true;\n    this.parent.notify(autoCol, {});\n  }\n\n  iterateComplexColumns(obj, field, split) {\n    const keys = Object.keys(obj);\n\n    for (let i = 0; i < keys.length; i++) {\n      const childKeys = typeof obj[keys[i]] === 'object' && obj[keys[i]] && !(obj[keys[i]] instanceof Date) ? Object.keys(obj[keys[i]]) : [];\n\n      if (childKeys.length) {\n        this.iterateComplexColumns(obj[keys[i]], field + (keys[i] + '.'), split);\n      } else {\n        split[this.counter] = field + keys[i];\n        this.counter++;\n      }\n    }\n  }\n\n  buildColumns(record) {\n    const cols = [];\n    const complexCols = {};\n    this.iterateComplexColumns(record, '', complexCols);\n    const columns = Object.keys(complexCols).filter(e => complexCols[e] !== 'BlazId').map(field => complexCols[field]);\n\n    for (let i = 0, len = columns.length; i < len; i++) {\n      cols[i] = {\n        'field': columns[i]\n      };\n\n      if (this.parent.enableColumnVirtualization) {\n        cols[i].width = !isNullOrUndefined(cols[i].width) ? cols[i].width : 200;\n      }\n    }\n\n    this.parent.setProperties({\n      'columns': cols\n    }, true);\n  }\n\n  instantiateRenderer() {\n    this.renderer.addRenderer(RenderType.Header, new HeaderRender(this.parent, this.locator));\n    this.renderer.addRenderer(RenderType.Content, new ContentRender(this.parent, this.locator));\n    const cellrender = this.locator.getService('cellRendererFactory');\n    cellrender.addCellRenderer(CellType.Header, new HeaderCellRenderer(this.parent, this.locator));\n    cellrender.addCellRenderer(CellType.Data, new CellRenderer(this.parent, this.locator));\n    cellrender.addCellRenderer(CellType.StackedHeader, new StackedHeaderCellRenderer(this.parent, this.locator));\n    cellrender.addCellRenderer(CellType.Indent, new IndentCellRenderer(this.parent, this.locator));\n    cellrender.addCellRenderer(CellType.GroupCaption, new GroupCaptionCellRenderer(this.parent, this.locator));\n    cellrender.addCellRenderer(CellType.GroupCaptionEmpty, new GroupCaptionEmptyCellRenderer(this.parent, this.locator));\n    cellrender.addCellRenderer(CellType.Expand, new ExpandCellRenderer(this.parent, this.locator));\n    cellrender.addCellRenderer(CellType.HeaderIndent, new HeaderIndentCellRenderer(this.parent, this.locator));\n    cellrender.addCellRenderer(CellType.StackedHeader, new StackedHeaderCellRenderer(this.parent, this.locator));\n    cellrender.addCellRenderer(CellType.DetailHeader, new DetailHeaderIndentCellRenderer(this.parent, this.locator));\n    cellrender.addCellRenderer(CellType.RowDragHIcon, new RowDragDropHeaderRenderer(this.parent, this.locator));\n    cellrender.addCellRenderer(CellType.DetailExpand, new DetailExpandCellRenderer(this.parent, this.locator));\n    cellrender.addCellRenderer(CellType.DetailFooterIntent, new IndentCellRenderer(this.parent, this.locator));\n    cellrender.addCellRenderer(CellType.RowDragIcon, new RowDragDropRenderer(this.parent, this.locator));\n  }\n\n  addEventListener() {\n    if (this.parent.isDestroyed) {\n      return;\n    }\n\n    this.parent.on(initialLoad, this.instantiateRenderer, this);\n    this.parent.on('refreshdataSource', this.dataManagerSuccess, this);\n    this.parent.on(modelChanged, this.refresh, this);\n    this.parent.on(refreshComplete, this.refreshComplete, this);\n    this.parent.on(bulkSave, this.sendBulkRequest, this);\n    this.parent.on(showEmptyGrid, () => {\n      this.emptyGrid = true;\n    }, this);\n    this.parent.on(autoCol, this.dynamicColumnChange, this);\n  }\n  /**\n   * @param {ReturnType} e - specifies the Return type\n   * @returns {Promise<Object>} returns the object\n   * @hidden\n   */\n\n\n  validateGroupRecords(e) {\n    const index = e.result.length - 1;\n\n    if (index < 0) {\n      return Promise.resolve(e);\n    }\n\n    const group0 = e.result[0];\n    const groupN = e.result[index];\n    const predicate = [];\n\n    const addWhere = input => {\n      const groups = [group0, groupN];\n\n      for (let i = 0; i < groups.length; i++) {\n        predicate.push(new Predicate('field', '==', groups[i].field).and(this.getPredicate('key', 'equal', groups[i].key)));\n      }\n\n      input.where(Predicate.or(predicate));\n    };\n\n    const query = new Query();\n    addWhere(query);\n    const curDm = new DataManager(e.result);\n    const curFilter = curDm.executeLocal(query);\n    const newQuery = this.data.generateQuery(true);\n    const rPredicate = [];\n\n    if (this.data.isRemote()) {\n      const groups = [group0, groupN];\n\n      for (let i = 0; i < groups.length; i++) {\n        rPredicate.push(this.getPredicate(groups[i].field, 'equal', groups[i].key));\n      }\n\n      newQuery.where(Predicate.or(rPredicate));\n    } else {\n      addWhere(newQuery);\n    }\n\n    const deferred = new Deferred();\n    this.data.getData({}, newQuery).then(r => {\n      this.updateGroupInfo(curFilter, r.result);\n      deferred.resolve(e);\n    }).catch(e => deferred.reject(e));\n    return deferred.promise;\n  }\n\n  getPredicate(key, operator, value) {\n    if (value instanceof Date) {\n      return getDatePredicate({\n        field: key,\n        operator: operator,\n        value: value\n      });\n    }\n\n    return new Predicate(key, operator, value);\n  }\n\n  updateGroupInfo(current, untouched) {\n    const dm = new DataManager(untouched);\n    const elements = current;\n\n    for (let i = 0; i < elements.length; i++) {\n      const uGroup = dm.executeLocal(new Query().where(new Predicate('field', '==', elements[i].field).and(this.getPredicate('key', 'equal', elements[i].key))))[0];\n      elements[i].count = uGroup.count;\n      const itemGroup = elements[i].items;\n      const uGroupItem = uGroup.items;\n\n      if (itemGroup.GroupGuid) {\n        elements[i].items = this.updateGroupInfo(elements[i].items, uGroup.items);\n      }\n\n      const rows = this.parent.aggregates;\n\n      for (let j = 0; j < rows.length; j++) {\n        const row$$1 = rows[j];\n\n        for (let k = 0; k < row$$1.columns.length; k++) {\n          const types = row$$1.columns[k].type instanceof Array ? row$$1.columns[k].type : [row$$1.columns[k].type];\n\n          for (let l = 0; l < types.length; l++) {\n            const key = row$$1.columns[k].field + ' - ' + types[l].toLowerCase();\n            const data = itemGroup.level ? uGroupItem.records : uGroup.items;\n            const context = this.parent;\n\n            if (types[l] === 'Custom') {\n              const data = itemGroup.level ? uGroupItem : uGroup;\n              let temp = row$$1.columns[k].customAggregate;\n\n              if (typeof temp === 'string') {\n                temp = getValue(temp, window);\n              }\n\n              elements[i].aggregates[key] = temp ? temp.call(context, data, row$$1.columns[k]) : '';\n            } else {\n              // eslint-disable-next-line max-len\n              elements[i].aggregates[key] = DataUtil.aggregates[types[l].toLowerCase()](data, row$$1.columns[k].field);\n            }\n          }\n        }\n      }\n    }\n\n    return current;\n  }\n\n}\n/**\n * CellRendererFactory\n *\n * @hidden\n */\n\n\nclass CellRendererFactory {\n  constructor() {\n    this.cellRenderMap = {};\n  }\n\n  addCellRenderer(name, type) {\n    name = typeof name === 'string' ? name : getEnumValue(CellType, name);\n\n    if (isNullOrUndefined(this.cellRenderMap[name])) {\n      this.cellRenderMap[name] = type;\n    }\n  }\n\n  getCellRenderer(name) {\n    name = typeof name === 'string' ? name : getEnumValue(CellType, name);\n\n    if (isNullOrUndefined(this.cellRenderMap[name])) {\n      // eslint-disable-next-line no-throw-literal\n      throw `The cellRenderer ${name} is not found`;\n    } else {\n      return this.cellRenderMap[name];\n    }\n  }\n\n}\n/**\n *\n * The `ResponsiveDialogRenderer` module is used to render the responsive dialogs.\n */\n\n\nclass ResponsiveDialogRenderer {\n  constructor(parent, serviceLocator) {\n    this.sortedCols = [];\n    this.sortPredicate = [];\n    /** @hidden */\n\n    this.isCustomDialog = false;\n    this.parent = parent;\n    this.serviceLocator = serviceLocator;\n    this.addEventListener();\n  }\n\n  addEventListener() {\n    this.evtHandlers = [{\n      event: filterDialogClose,\n      handler: this.closeCustomDialog\n    }, {\n      event: refreshCustomFilterOkBtn,\n      handler: this.refreshCustomFilterOkBtn\n    }, {\n      event: renderResponsiveCmenu,\n      handler: this.renderResponsiveContextMenu\n    }, {\n      event: filterCmenuSelect,\n      handler: this.renderCustomFilterDiv\n    }, {\n      event: customFilterClose,\n      handler: this.customExFilterClose\n    }, {\n      event: refreshCustomFilterClearBtn,\n      handler: this.refreshCustomFilterClearBtn\n    }];\n    addRemoveEventListener(this.parent, this.evtHandlers, true, this);\n    this.onActionCompleteFn = this.editComplate.bind(this);\n    this.parent.addEventListener(actionComplete, this.onActionCompleteFn);\n  }\n\n  customExFilterClose() {\n    this.isCustomDlgRender = false;\n  }\n\n  renderCustomFilterDiv() {\n    const header = this.customResponsiveDlg.element.querySelector('.e-dlg-header-content');\n    const title = header.querySelector('.e-dlg-custom-header');\n    const closeBtn = header.querySelector('.e-dlg-closeicon-btn');\n    this.isCustomDlgRender = true;\n    this.parent.filterModule.filterModule.closeDialog();\n    this.saveBtn.element.style.display = '';\n    this.refreshCustomFilterOkBtn({\n      disabled: false\n    });\n    this.backBtn.element.style.display = 'none';\n    closeBtn.style.display = '';\n    title.innerHTML = this.parent.localeObj.getConstant('CustomFilter');\n    const content = this.customResponsiveDlg.element.querySelector('.e-dlg-content');\n    this.customExcelFilterParent = this.parent.createElement('div', {\n      className: 'e-xl-customfilterdiv e-default-filter'\n    });\n    content.appendChild(this.customExcelFilterParent);\n  }\n\n  renderResponsiveContextMenu(args) {\n    if (this.action === ResponsiveDialogAction.isFilter) {\n      const content = this.customResponsiveDlg.element.querySelector('.e-dlg-content');\n      const header = this.customResponsiveDlg.element.querySelector('.e-dlg-header-content');\n      const closeBtn = header.querySelector('.e-dlg-closeicon-btn');\n      const text = header.querySelector('.e-dlg-custom-header');\n\n      if (args.isOpen) {\n        content.firstChild.style.display = 'none';\n        content.appendChild(args.target);\n        closeBtn.style.display = 'none';\n        this.saveBtn.element.style.display = 'none';\n        this.filterClearBtn.element.style.display = 'none';\n        text.innerHTML = args.header;\n        const backBtn = this.parent.createElement('button');\n        const span = this.parent.createElement('span', {\n          className: 'e-btn-icon e-resfilterback e-icons'\n        });\n        backBtn.appendChild(span);\n        this.backBtn = new Button({\n          cssClass: 'e-res-back-btn'\n        });\n        this.backBtn.appendTo(backBtn);\n        text.parentElement.insertBefore(backBtn, text);\n      } else if (this.backBtn && !this.isCustomDlgRender) {\n        content.firstChild.style.display = '';\n        remove(this.backBtn.element);\n        closeBtn.style.display = '';\n        this.saveBtn.element.style.display = '';\n\n        if (this.isFiltered) {\n          this.filterClearBtn.element.style.display = '';\n        }\n\n        text.innerHTML = this.getHeaderTitle({\n          action: ResponsiveDialogAction.isFilter\n        }, args.col);\n      }\n    }\n  }\n\n  refreshCustomFilterClearBtn(args) {\n    if (this.filterClearBtn) {\n      this.isFiltered = args.isFiltered;\n      this.filterClearBtn.element.style.display = args.isFiltered ? '' : 'none';\n    }\n  }\n\n  refreshCustomFilterOkBtn(args) {\n    if (this.saveBtn) {\n      this.saveBtn.disabled = args.disabled;\n    }\n  }\n\n  renderResponsiveContent(col) {\n    const gObj = this.parent;\n\n    if (col) {\n      this.filterParent = this.parent.createElement('div', {\n        className: 'e-mainfilterdiv e-default-filter',\n        id: col.uid + '-main-filter'\n      });\n      return this.filterParent;\n    } else {\n      const cols = gObj.getColumns();\n      this.customColumnDiv = gObj.createElement('div', {\n        className: 'columndiv',\n        styles: 'width: 100%'\n      });\n      const sortBtnParent = gObj.createElement('div', {\n        className: 'e-ressortbutton-parent'\n      });\n      const filteredCols = [];\n      const isSort = this.action === ResponsiveDialogAction.isSort;\n      const isFilter = this.action === ResponsiveDialogAction.isFilter;\n\n      if (isFilter) {\n        for (let i = 0; i < gObj.filterSettings.columns.length; i++) {\n          filteredCols.push(gObj.filterSettings.columns[i].field);\n        }\n      }\n\n      for (let i = 0; i < cols.length; i++) {\n        if (!cols[i].visible || !cols[i].allowSorting && isSort || !cols[i].allowFiltering && isFilter) {\n          continue;\n        }\n\n        const cDiv = gObj.createElement('div', {\n          className: 'e-responsivecoldiv'\n        });\n        cDiv.setAttribute('data-e-mappingname', cols[i].field);\n        cDiv.setAttribute('data-e-mappinguid', cols[i].uid);\n        const span = gObj.createElement('span', {\n          innerHTML: cols[i].headerText,\n          className: 'e-res-header-text'\n        });\n        cDiv.appendChild(span);\n        this.customColumnDiv.appendChild(cDiv);\n\n        if (isSort) {\n          const fields = this.getSortedFieldsAndDirections('field');\n          const index = fields.indexOf(cols[i].field);\n          const button = gObj.createElement('button', {\n            id: gObj.element.id + cols[i].field + 'sortbutton'\n          });\n          const clone = sortBtnParent.cloneNode();\n          clone.appendChild(button);\n          cDiv.appendChild(clone);\n          const btnObj = new Button({\n            cssClass: 'e-ressortbutton'\n          });\n          btnObj.appendTo(button);\n          button.innerHTML = index > -1 ? this.parent.sortSettings.columns[index].direction : 'None';\n\n          button.onclick = e => {\n            this.sortButtonClickHandler(e.target);\n          };\n        }\n\n        if (isFilter && filteredCols.indexOf(cols[i].field) > -1) {\n          const divIcon = gObj.createElement('div', {\n            className: 'e-icons e-res-icon e-filtersetdiv'\n          });\n          const iconSpan = gObj.createElement('span', {\n            className: 'e-icons e-res-icon e-filterset'\n          });\n          iconSpan.setAttribute('colType', cols[i].type);\n          divIcon.appendChild(iconSpan);\n          cDiv.appendChild(divIcon);\n        }\n      }\n\n      EventHandler.add(this.customColumnDiv, 'click', this.customFilterColumnClickHandler, this);\n      return this.customColumnDiv;\n    }\n  }\n\n  getSortedFieldsAndDirections(name) {\n    const fields = [];\n\n    for (let i = 0; i < this.parent.sortSettings.columns.length; i++) {\n      fields.push(this.parent.sortSettings.columns[i][name]);\n    }\n\n    return fields;\n  }\n\n  sortButtonClickHandler(target) {\n    if (target) {\n      const columndiv = parentsUntil(target, 'e-responsivecoldiv');\n      const field = columndiv.getAttribute('data-e-mappingname');\n\n      if (!this.parent.allowMultiSorting) {\n        this.sortPredicate = [];\n        this.sortedCols = [];\n        this.isSortApplied = false;\n        this.resetSortButtons(target);\n      }\n\n      const txt = target.textContent;\n      const direction = txt === 'None' ? 'Ascending' : txt === 'Ascending' ? 'Descending' : 'None';\n      target.innerHTML = direction;\n      this.setSortedCols(field, direction);\n    }\n  }\n\n  resetSortButtons(target) {\n    const buttons = [].slice.call(this.customColumnDiv.getElementsByClassName('e-ressortbutton'));\n\n    for (let i = 0; i < buttons.length; i++) {\n      if (buttons[i] !== target) {\n        buttons[i].innerHTML = 'None';\n      }\n    }\n  }\n\n  setSortedCols(field, direction) {\n    const fields = this.getCurrentSortedFields();\n    const index = fields.indexOf(field);\n\n    if (this.parent.allowMultiSorting && index > -1) {\n      this.sortedCols.splice(index, 1);\n      this.sortPredicate.splice(index, 1);\n    }\n\n    this.isSortApplied = true;\n\n    if (direction !== 'None') {\n      this.sortedCols.push(field);\n      this.sortPredicate.push({\n        field: field,\n        direction: direction\n      });\n    }\n  }\n\n  getCurrentSortedFields() {\n    const fields = [];\n\n    for (let i = 0; i < this.sortedCols.length; i++) {\n      fields.push(this.sortedCols[i]);\n    }\n\n    return fields;\n  }\n\n  customFilterColumnClickHandler(e) {\n    if (this.action !== ResponsiveDialogAction.isFilter) {\n      return;\n    }\n\n    const gObj = this.parent;\n    const target = e.target;\n\n    if (gObj.filterSettings.type !== 'FilterBar') {\n      if (target.classList.contains('e-responsivecoldiv') || target.parentElement.classList.contains('e-responsivecoldiv')) {\n        let field = target.getAttribute('data-e-mappingname');\n\n        if (!field) {\n          field = target.parentElement.getAttribute('data-e-mappingname');\n        }\n\n        if (field) {\n          const col = gObj.getColumnByField(field);\n          this.isRowResponsive = true;\n          this.showResponsiveDialog(col);\n        }\n      } else if (target.classList.contains('e-filterset') || target.parentElement.classList.contains('e-filtersetdiv')) {\n        const colDiv = parentsUntil(target, 'e-responsivecoldiv');\n\n        if (colDiv) {\n          const field = colDiv.getAttribute('data-e-mappingname');\n          const col = gObj.getColumnByField(field);\n\n          if (col.filter.type === 'Menu' || !col.filter.type && gObj.filterSettings.type === 'Menu') {\n            this.isDialogClose = true;\n          }\n\n          this.parent.filterModule.filterModule.clearCustomFilter(col);\n          this.removeCustomDlgFilterEle(target);\n        }\n      }\n    }\n  }\n  /**\n   * Function to show the responsive dialog\n   *\n   * @param {Column} col - specifies the column\n   * @returns {void}\n   */\n\n\n  showResponsiveDialog(col) {\n    if (this.isCustomDialog && this.action === ResponsiveDialogAction.isFilter && !this.isRowResponsive) {\n      this.renderCustomFilterDialog();\n    } else {\n      this.filteredCol = col;\n      this.renderResponsiveDialog(col);\n\n      if (this.parent.enableAdaptiveUI && col) {\n        this.parent.filterModule.setFilterModel(col);\n        this.parent.filterModule.filterModule.openDialog(this.parent.filterModule.createOptions(col, undefined));\n      }\n\n      if (this.action === ResponsiveDialogAction.isSort) {\n        const args = {\n          cancel: false,\n          dialogObj: this.customResponsiveDlg,\n          requestType: 'beforeOpenAptiveSortDialog'\n        };\n        this.parent.trigger(beforeOpenAdaptiveDialog, args);\n\n        if (args.cancel) {\n          return;\n        }\n      }\n\n      this.customResponsiveDlg.show(true);\n      this.customResponsiveDlg.element.style.maxHeight = '100%';\n      this.setTopToChildDialog(this.customResponsiveDlg.element);\n    }\n  }\n\n  setTopToChildDialog(dialogEle) {\n    const child = dialogEle.querySelector('.e-dialog');\n\n    if (child) {\n      const top = dialogEle.querySelector('.e-dlg-header-content').getBoundingClientRect().height;\n      child.style.top = top + 'px';\n    }\n  }\n\n  renderCustomFilterDialog(col) {\n    const gObj = this.parent;\n\n    if (this.action === ResponsiveDialogAction.isFilter && gObj.filterSettings.type === 'FilterBar') {\n      return;\n    }\n\n    const outerDiv = this.parent.createElement('div', {\n      id: gObj.element.id + 'customfilter',\n      className: 'e-customfilterdiv e-responsive-dialog'\n    });\n    this.parent.element.appendChild(outerDiv);\n    this.customFilterDlg = this.getDialogOptions(col, true);\n    const args = {\n      cancel: false,\n      dialogObj: this.customFilterDlg,\n      requestType: 'beforeOpenAptiveFilterDialog'\n    };\n    this.parent.trigger(beforeOpenAdaptiveDialog, args);\n\n    if (args.cancel) {\n      return;\n    }\n\n    this.customFilterDlg.appendTo(outerDiv);\n    this.customFilterDlg.show(true);\n    this.customFilterDlg.element.style.maxHeight = '100%';\n  }\n\n  getDialogOptions(col, isCustomFilter, id) {\n    const options = new Dialog({\n      isModal: true,\n      showCloseIcon: true,\n      closeOnEscape: false,\n      locale: this.parent.locale,\n      target: this.parent.adaptiveDlgTarget ? this.parent.adaptiveDlgTarget : document.body,\n      visible: false,\n      enableRtl: this.parent.enableRtl,\n      content: this.renderResponsiveContent(col),\n      open: this.dialogOpen.bind(this),\n      created: this.dialogCreated.bind(this),\n      close: this.beforeDialogClose.bind(this),\n      width: '100%',\n      height: '100%',\n      animationSettings: {\n        effect: 'None'\n      }\n    });\n    const isStringTemplate = 'isStringTemplate';\n    options[isStringTemplate] = true;\n\n    if (isCustomFilter) {\n      options.header = this.renderResponsiveHeader(col, undefined, true);\n      options.cssClass = 'e-customfilter';\n    } else {\n      options.header = this.renderResponsiveHeader(col);\n      options.cssClass = this.parent.rowRenderingMode === 'Vertical' && this.action === ResponsiveDialogAction.isFilter ? 'e-res' + id + ' e-row-responsive-filter' : 'e-res' + id;\n    }\n\n    return options;\n  }\n\n  renderResponsiveDialog(col) {\n    const gObj = this.parent;\n\n    if (this.action === ResponsiveDialogAction.isFilter && gObj.filterSettings.type === 'FilterBar') {\n      return;\n    }\n\n    const id = this.action === ResponsiveDialogAction.isFilter ? 'filter' : 'sort';\n    const outerDiv = this.parent.createElement('div', {\n      id: gObj.element.id + 'responsive' + id,\n      className: 'e-res' + id + 'div e-responsive-dialog'\n    });\n    this.parent.element.appendChild(outerDiv);\n    this.customResponsiveDlg = this.getDialogOptions(col, false, id);\n    this.customResponsiveDlg.appendTo(outerDiv);\n  }\n\n  dialogCreated() {\n    addBiggerDialog(this.parent);\n  }\n\n  dialogOpen() {\n    if (this.action === ResponsiveDialogAction.isSort && this.parent.allowMultiSorting) {\n      for (let i = 0; i < this.parent.sortSettings.columns.length; i++) {\n        this.sortedCols.push(this.parent.sortSettings.columns[i].field);\n        const sortField = this.parent.sortSettings.columns[i].field;\n        const sortDirection = this.parent.sortSettings.columns[i].direction;\n        this.sortPredicate.push({\n          field: sortField,\n          direction: sortDirection\n        });\n      }\n    }\n  }\n\n  beforeDialogClose(args) {\n    this.isDialogClose = args.element && !args.element.querySelector('.e-xl-customfilterdiv') && args.element.classList.contains('e-resfilterdiv');\n\n    if (this.action === ResponsiveDialogAction.isFilter) {\n      if (args.element.classList.contains('e-resfilterdiv')) {\n        this.parent.filterModule.filterModule.closeResponsiveDialog(this.isCustomDlgRender);\n      } else if (args.element.classList.contains('e-customfilterdiv')) {\n        this.closeCustomFilter();\n      }\n    } else if (this.action === ResponsiveDialogAction.isSort) {\n      this.closeCustomDialog();\n    }\n\n    this.parent.off(enterKeyHandler, this.keyHandler);\n  }\n\n  sortColumn() {\n    if (!this.isSortApplied) {\n      this.closeCustomDialog();\n      return;\n    }\n\n    if (this.sortPredicate.length) {\n      this.parent.setProperties({\n        sortSettings: {\n          columns: []\n        }\n      }, true);\n    }\n\n    for (let i = 0; i < this.sortPredicate.length; i++) {\n      this.parent.sortColumn(this.sortPredicate[i].field, this.sortPredicate[i].direction, this.parent.allowMultiSorting);\n    }\n\n    if (!this.sortPredicate.length) {\n      this.parent.clearSorting();\n    }\n\n    this.closeCustomDialog();\n  }\n\n  getHeaderTitle(args, col) {\n    const gObj = this.parent;\n    let title;\n\n    if (this.action === ResponsiveDialogAction.isEdit) {\n      title = gObj.localeObj.getConstant('EditFormTitle') + args.primaryKeyValue[0];\n    } else if (this.action === ResponsiveDialogAction.isAdd) {\n      title = gObj.localeObj.getConstant('AddFormTitle');\n    } else if (this.action === ResponsiveDialogAction.isFilter) {\n      title = col ? col.headerText || col.field : gObj.localeObj.getConstant('FilterButton');\n    } else if (this.action === ResponsiveDialogAction.isSort) {\n      title = gObj.localeObj.getConstant('Sort');\n    }\n\n    return title;\n  }\n\n  getDialogName(action) {\n    let name;\n\n    if (action === ResponsiveDialogAction.isAdd || action === ResponsiveDialogAction.isEdit) {\n      name = 'dialogEdit_wrapper_title';\n    } else if (action === ResponsiveDialogAction.isFilter) {\n      name = 'responsive_filter_dialog_wrapper';\n    }\n\n    return name;\n  }\n\n  getButtonText(action) {\n    let text;\n\n    if (action === ResponsiveDialogAction.isAdd || action === ResponsiveDialogAction.isEdit) {\n      text = 'Save';\n    } else if (action === ResponsiveDialogAction.isFilter || this.action === ResponsiveDialogAction.isSort) {\n      text = 'OKButton';\n    }\n\n    return text;\n  }\n  /**\n   * Function to render the responsive header\n   *\n   * @param {Column} col - specifies the column\n   * @param {ResponsiveDialogArgs} args - specifies the responsive dialog arguments\n   * @param {boolean} isCustomFilter - specifies whether it is custom filter or not\n   * @returns {HTMLElement | string} returns the html element or string\n   */\n\n\n  renderResponsiveHeader(col, args, isCustomFilter) {\n    const gObj = this.parent;\n    gObj.on(enterKeyHandler, this.keyHandler, this);\n    const id = gObj.element.id + this.getDialogName(this.action);\n    const header = gObj.createElement('div', {\n      className: 'e-res-custom-element'\n    });\n    const titleDiv = gObj.createElement('div', {\n      className: 'e-dlg-custom-header',\n      id: id\n    });\n    titleDiv.innerHTML = this.getHeaderTitle(args, col);\n    header.appendChild(titleDiv);\n    const saveBtn = gObj.createElement('button');\n\n    if (!isCustomFilter) {\n      this.saveBtn = new Button({\n        cssClass: 'e-primary e-flat e-res-apply-btn'\n      });\n      saveBtn.innerHTML = gObj.localeObj.getConstant(this.getButtonText(this.action));\n      this.saveBtn.appendTo(saveBtn); // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n      saveBtn.onclick = e => {\n        this.dialogHdrBtnClickHandler();\n      };\n    }\n\n    const isSort = this.action === ResponsiveDialogAction.isSort;\n    const isFilter = this.action === ResponsiveDialogAction.isFilter;\n\n    if (isFilter || isSort) {\n      const id = isSort ? 'sort' : 'filter';\n      const clearBtn = gObj.createElement('button');\n      this.filterClearBtn = new Button({\n        cssClass: 'e-primary e-flat e-res-' + id + '-clear-btn'\n      });\n\n      if (isFilter) {\n        const span = gObj.createElement('span', {\n          className: 'e-btn-icon e-icon-filter-clear e-icons'\n        });\n        clearBtn.appendChild(span);\n      } else {\n        clearBtn.innerHTML = gObj.localeObj.getConstant('Clear');\n      }\n\n      header.appendChild(clearBtn);\n      this.filterClearBtn.appendTo(clearBtn);\n\n      clearBtn.onclick = e => {\n        if (parentsUntil(e.target, 'e-customfilter')) {\n          this.parent.filterModule.clearFiltering();\n          this.removeCustomDlgFilterEle();\n        } else {\n          if (isFilter) {\n            this.filterClear();\n          } else {\n            this.resetSortButtons();\n            this.sortedCols = [];\n            this.sortPredicate = [];\n            this.isSortApplied = true;\n          }\n        }\n      };\n\n      header.appendChild(clearBtn);\n    }\n\n    if (!isCustomFilter) {\n      header.appendChild(saveBtn);\n    }\n\n    return header;\n  }\n\n  filterClear() {\n    this.parent.filterModule.filterModule.clearCustomFilter(this.filteredCol);\n    this.parent.filterModule.filterModule.closeResponsiveDialog();\n  }\n\n  dialogHdrBtnClickHandler() {\n    if (this.action === ResponsiveDialogAction.isEdit || this.action === ResponsiveDialogAction.isAdd) {\n      this.parent.endEdit();\n    } else if (this.action === ResponsiveDialogAction.isFilter) {\n      this.parent.filterModule.filterModule.applyCustomFilter({\n        col: this.filteredCol,\n        isCustomFilter: this.isCustomDlgRender\n      });\n    } else if (this.action === ResponsiveDialogAction.isSort) {\n      this.sortColumn();\n    }\n  }\n\n  closeCustomDialog() {\n    if (this.isCustomDlgRender) {\n      const mainfilterdiv = this.customResponsiveDlg.element.querySelector('.e-mainfilterdiv');\n      remove(mainfilterdiv);\n      return;\n    }\n\n    this.isRowResponsive = false;\n    this.isCustomDlgRender = false;\n    this.destroyCustomFilterDialog();\n  }\n\n  destroyCustomFilterDialog() {\n    if (!this.customResponsiveDlg) {\n      return;\n    }\n\n    const elem = document.getElementById(this.customResponsiveDlg.element.id);\n\n    if (this.customResponsiveDlg && !this.customResponsiveDlg.isDestroyed && elem) {\n      this.customResponsiveDlg.destroy();\n      remove(elem);\n    }\n\n    this.closeCustomFilter();\n\n    if (this.action === ResponsiveDialogAction.isSort) {\n      this.sortPredicate = [];\n      this.sortedCols = [];\n      this.isSortApplied = false;\n    }\n  }\n\n  closeCustomFilter() {\n    if (!this.isDialogClose && this.customFilterDlg) {\n      const customEle = document.getElementById(this.customFilterDlg.element.id);\n\n      if (this.customFilterDlg && !this.customFilterDlg.isDestroyed && customEle) {\n        this.customFilterDlg.destroy();\n        remove(customEle);\n      }\n    }\n\n    this.isCustomDialog = false;\n    this.isDialogClose = false;\n  }\n\n  removeCustomDlgFilterEle(target) {\n    if (target) {\n      if (target.parentElement.classList.contains('e-filtersetdiv')) {\n        remove(target.parentElement);\n      } else {\n        remove(target);\n      }\n    } else {\n      const child = this.customColumnDiv.children;\n\n      for (let i = 0; i < child.length; i++) {\n        target = child[i].querySelector('.e-filtersetdiv');\n\n        if (target) {\n          remove(target);\n          i--;\n        }\n      }\n    }\n  }\n\n  keyHandler(e) {\n    if (e.keyCode === 13 && (this.action === ResponsiveDialogAction.isFilter && e.target.classList.contains('e-searchinput') || this.action === ResponsiveDialogAction.isEdit || this.action === ResponsiveDialogAction.isAdd)) {\n      this.dialogHdrBtnClickHandler();\n    }\n  }\n\n  editComplate(args) {\n    if (args.requestType === 'save' || args.requestType === 'cancel') {\n      this.parent.off(enterKeyHandler, this.keyHandler);\n    }\n  }\n\n  removeEventListener() {\n    if (this.customColumnDiv) {\n      EventHandler.remove(this.customColumnDiv, 'click', this.customFilterColumnClickHandler);\n    }\n\n    addRemoveEventListener(this.parent, this.evtHandlers, true, this);\n    this.parent.removeEventListener(actionComplete, this.onActionCompleteFn);\n  }\n\n}\n/**\n * ServiceLocator\n *\n * @hidden\n */\n\n\nclass ServiceLocator {\n  constructor() {\n    this.services = {};\n  }\n\n  register(name, type) {\n    if (isNullOrUndefined(this.services[name])) {\n      this.services[name] = type;\n    }\n  }\n\n  getService(name) {\n    if (isNullOrUndefined(this.services[name])) {\n      // eslint-disable-next-line no-throw-literal\n      throw `The service ${name} is not registered`;\n    }\n\n    return this.services[name];\n  }\n\n  registerAdaptiveService(type, isAdaptiveUI, action) {\n    if (isAdaptiveUI) {\n      type.responsiveDialogRenderer = new ResponsiveDialogRenderer(type.parent, type.serviceLocator);\n      type.responsiveDialogRenderer.action = action;\n    } else {\n      if (type.responsiveDialogRenderer) {\n        type.responsiveDialogRenderer.removeEventListener();\n        type.responsiveDialogRenderer = undefined;\n      }\n    }\n  }\n\n}\n/**\n * RendererFactory\n *\n * @hidden\n */\n\n\nclass RendererFactory {\n  constructor() {\n    this.rendererMap = {};\n  }\n\n  addRenderer(name, type) {\n    const rName = getEnumValue(RenderType, name);\n\n    if (isNullOrUndefined(this.rendererMap[rName])) {\n      this.rendererMap[rName] = type;\n    }\n  }\n\n  getRenderer(name) {\n    const rName = getEnumValue(RenderType, name);\n\n    if (isNullOrUndefined(this.rendererMap[rName])) {\n      // eslint-disable-next-line no-throw-literal\n      throw `The renderer ${rName} is not found`;\n    } else {\n      return this.rendererMap[rName];\n    }\n  }\n\n}\n/**\n * ColumnWidthService\n *\n * @hidden\n */\n\n\nclass ColumnWidthService {\n  constructor(parent) {\n    this.parent = parent;\n  }\n\n  setWidthToColumns() {\n    let i = 0;\n    const indexes = this.parent.getColumnIndexesInView();\n    let wFlag = true;\n    let totalColumnsWidth = 0;\n\n    if (this.parent.allowGrouping) {\n      for (let len = this.parent.groupSettings.columns.length; i < len; i++) {\n        if (this.parent.enableColumnVirtualization && indexes.indexOf(i) === -1) {\n          wFlag = false;\n          continue;\n        }\n\n        this.setColumnWidth(new Column({\n          width: '30px'\n        }), i);\n      }\n    }\n\n    if (this.parent.detailTemplate || this.parent.childGrid) {\n      this.setColumnWidth(new Column({\n        width: '30px'\n      }), i);\n      i++;\n    }\n\n    if (this.parent.isRowDragable() && this.parent.getFrozenMode() !== 'Right') {\n      this.setColumnWidth(new Column({\n        width: '30px'\n      }), i);\n      i++;\n    }\n\n    const columns = this.parent.getColumns();\n\n    for (let j = 0; j < columns.length; j++) {\n      this.setColumnWidth(columns[j], wFlag && this.parent.enableColumnVirtualization ? undefined : j + i);\n    }\n\n    if (this.parent.isRowDragable() && this.parent.getFrozenMode() === 'Right') {\n      this.setColumnWidth(new Column({\n        width: '30px'\n      }), columns.length);\n    }\n\n    totalColumnsWidth = this.getTableWidth(this.parent.getColumns());\n\n    if (this.parent.width !== 'auto' && this.parent.width.toString().indexOf('%') === -1) {\n      this.setMinwidthBycalculation(totalColumnsWidth);\n    }\n  }\n\n  setMinwidthBycalculation(tWidth) {\n    let difference = 0;\n    const collection = this.parent.getColumns().filter(a => {\n      return isNullOrUndefined(a.width) || a.width === 'auto';\n    });\n\n    if (collection.length) {\n      if (!isNullOrUndefined(this.parent.width) && this.parent.width !== 'auto' && typeof this.parent.width === 'string' && this.parent.width.indexOf('%') === -1) {\n        difference = (typeof this.parent.width === 'string' ? parseInt(this.parent.width, 10) : this.parent.width) - tWidth;\n      } else {\n        difference = this.parent.element.getBoundingClientRect().width - tWidth;\n      }\n\n      let tmWidth = 0;\n\n      for (const cols of collection) {\n        tmWidth += !isNullOrUndefined(cols.minWidth) ? typeof cols.minWidth === 'string' ? parseInt(cols.minWidth, 10) : cols.minWidth : 0;\n      }\n\n      for (let i = 0; i < collection.length; i++) {\n        if (tWidth === 0 && this.parent.allowResizing && this.isWidthUndefined() && i !== collection.length - 1) {\n          this.setUndefinedColumnWidth(collection);\n        }\n\n        const index = this.parent.getColumnIndexByField(collection[i].field) + this.parent.getIndentCount();\n\n        if (tWidth !== 0 && difference < tmWidth) {\n          this.setWidth(collection[i].minWidth, index);\n        } else if (tWidth !== 0 && difference > tmWidth) {\n          this.setWidth('', index, true);\n        }\n      }\n    }\n  }\n\n  setUndefinedColumnWidth(collection) {\n    for (let k = 0; k < collection.length; k++) {\n      if (k !== collection.length - 1) {\n        collection[k].width = 200;\n        this.setWidth(200, this.parent.getColumnIndexByField(collection[k].field));\n      }\n    }\n  }\n\n  setColumnWidth(column, index, module) {\n    if (this.parent.getColumns().length < 1) {\n      return;\n    }\n\n    const columnIndex = isNullOrUndefined(index) ? this.parent.getNormalizedColumnIndex(column.uid) : index;\n    const cWidth = this.getWidth(column);\n    const tgridWidth = this.getTableWidth(this.parent.getColumns());\n\n    if (cWidth !== null) {\n      this.setWidth(cWidth, columnIndex);\n\n      if (this.parent.width !== 'auto' && this.parent.width.toString().indexOf('%') === -1) {\n        this.setMinwidthBycalculation(tgridWidth);\n      }\n\n      if (this.parent.allowResizing && module === 'resize' || this.parent.getFrozenColumns() && this.parent.allowResizing) {\n        this.setWidthToTable();\n      }\n\n      this.parent.notify(columnWidthChanged, {\n        index: columnIndex,\n        width: cWidth,\n        column: column,\n        module: module\n      });\n    }\n  }\n\n  setWidth(width, index, clear) {\n    if (this.parent.groupSettings.columns.length > index && ispercentageWidth(this.parent)) {\n      const elementWidth = this.parent.element.offsetWidth;\n      width = (30 / elementWidth * 100).toFixed(1) + '%';\n    }\n\n    const header = this.parent.getHeaderTable();\n    const content$$1 = this.parent.getContentTable();\n    const fWidth = formatUnit(width);\n    let headerCol;\n    let frzCols = this.parent.getFrozenColumns();\n    const isDraggable = this.parent.isRowDragable();\n    frzCols = frzCols && isDraggable ? frzCols + 1 : frzCols;\n    const mHdr = this.parent.getHeaderContent().querySelector('.' + movableHeader);\n    const mCont = this.parent.getContent().querySelector('.' + movableContent);\n    const freezeLeft = this.parent.getFrozenLeftColumnsCount();\n    const freezeRight = this.parent.getFrozenRightColumnsCount();\n    const movableCount = this.parent.getMovableColumnsCount();\n    const isColFrozen = freezeLeft !== 0 || freezeRight !== 0;\n\n    if (frzCols && index >= frzCols) {\n      if (!mHdr || !mHdr.querySelector(colGroup)) {\n        return;\n      }\n\n      headerCol = mHdr.querySelector(colGroup).children[index - frzCols];\n    } else if (this.parent.enableColumnVirtualization && frzCols && this.parent.contentModule.isXaxis() && mHdr.scrollLeft > 0) {\n      const colGroup$$1 = mHdr.querySelector(colGroup);\n      headerCol = colGroup$$1.children[colGroup$$1.children.length - 1 - index];\n    } else if (isColFrozen) {\n      let target;\n\n      if (freezeLeft && !freezeRight) {\n        index = isDraggable ? index - 1 : index;\n        target = index < freezeLeft ? header : mHdr;\n      } else if (!freezeLeft && freezeRight) {\n        target = index >= movableCount ? header : mHdr;\n      } else if (freezeLeft && freezeRight) {\n        index = isDraggable ? index - 1 : index;\n        const frHdr = this.parent.getFrozenRightHeader();\n        target = index < freezeLeft ? header : index < freezeLeft + movableCount ? mHdr : frHdr;\n      }\n\n      headerCol = this.getColumnLevelFrozenColgroup(index, freezeLeft, movableCount, target);\n\n      if (!headerCol) {\n        return;\n      }\n    } else {\n      headerCol = header.querySelector(colGroup).children[index];\n    }\n\n    if (headerCol && !clear) {\n      headerCol.style.width = fWidth;\n    } else if (headerCol && clear) {\n      headerCol.style.width = '';\n    }\n\n    let contentCol;\n\n    if (frzCols && index >= frzCols) {\n      contentCol = this.parent.getContent().querySelector('.' + movableContent).querySelector(colGroup).children[index - frzCols];\n    } else if (this.parent.enableColumnVirtualization && frzCols && this.parent.contentModule.isXaxis() && mCont.scrollLeft > 0) {\n      const colGroup$$1 = this.parent.getContent().querySelector('.' + movableContent).querySelector(colGroup);\n      contentCol = colGroup$$1.children[colGroup$$1.children.length - 1 - index];\n    } else if (isColFrozen) {\n      let target;\n\n      if (freezeLeft && !freezeRight) {\n        target = index < freezeLeft ? content$$1 : mCont;\n      }\n\n      if (!freezeLeft && freezeRight) {\n        target = index >= movableCount ? content$$1 : mCont;\n      }\n\n      if (freezeLeft && freezeRight) {\n        const frCont = this.parent.getContent().querySelector('.e-frozen-right-content');\n        target = index < freezeLeft ? content$$1 : index < freezeLeft + movableCount ? mCont : frCont;\n      }\n\n      contentCol = this.getColumnLevelFrozenColgroup(index, freezeLeft, movableCount, target);\n    } else {\n      contentCol = content$$1.querySelector(colGroup).children[index];\n    }\n\n    if (contentCol && !clear) {\n      contentCol.style.width = fWidth;\n    } else if (contentCol && clear) {\n      contentCol.style.width = '';\n    }\n\n    if (!this.parent.enableColumnVirtualization) {\n      const edit = this.parent.element.querySelectorAll('.e-table.e-inline-edit');\n      const editTableCol = [];\n\n      for (let i = 0; i < edit.length; i++) {\n        if (parentsUntil(edit[i], 'e-grid').id === this.parent.element.id) {\n          for (let j = 0; j < edit[i].querySelector('colgroup').children.length; j++) {\n            editTableCol.push(edit[i].querySelector('colgroup').children[j]);\n          }\n        }\n      }\n\n      if (edit.length && editTableCol.length) {\n        editTableCol[index].style.width = fWidth;\n      }\n    }\n\n    if (this.parent.isFrozenGrid()) {\n      this.refreshFrozenScrollbar();\n    }\n  }\n\n  getColumnLevelFrozenColgroup(index, left, movable, ele) {\n    if (!ele || !ele.querySelector(colGroup)) {\n      return null;\n    }\n\n    const columns = this.parent.getColumns();\n    const isDrag = this.parent.isRowDragable();\n    const frzMode = this.parent.getFrozenMode();\n    let headerCol;\n    const colGroup$$1 = [].slice.call(ele.querySelector(colGroup).children);\n\n    if (frzMode === 'Right' && isDrag && index === movable + this.parent.getFrozenRightColumnsCount()) {\n      headerCol = colGroup$$1[colGroup$$1.length - 1];\n    } else if (isDrag && index === -1) {\n      headerCol = colGroup$$1[0];\n    } else if (columns[index].freeze === 'Left') {\n      headerCol = colGroup$$1[isDrag ? index + 1 : index];\n    } else if (columns[index].freeze === 'Right') {\n      headerCol = colGroup$$1[index - (left + movable)];\n    } else {\n      headerCol = colGroup$$1[index - left];\n    }\n\n    return headerCol;\n  }\n  /**\n   * @returns {void}\n   * @hidden\n   */\n\n\n  refreshFrozenScrollbar() {\n    const args = {\n      cancel: false\n    };\n    this.parent.notify(preventFrozenScrollRefresh, args);\n\n    if (args.cancel) {\n      return;\n    }\n\n    const scrollWidth = getScrollBarWidth();\n    const frozenScrollbar = this.parent.element.querySelector('.e-frozenscrollbar');\n    const movableScrollbar = this.parent.element.querySelector('.e-movablescrollbar');\n    const frozencontent = this.parent.getContent().querySelector('.' + frozenContent);\n    const movableContent$$1 = this.parent.getContent().querySelector('.' + movableContent);\n    let frozenWidth = frozencontent.firstElementChild.getBoundingClientRect().width;\n    let movableWidth = movableContent$$1.firstElementChild.getBoundingClientRect().width;\n\n    if (this.parent.getFrozenMode() === 'Right') {\n      frozenWidth = frozenWidth + scrollWidth;\n    }\n\n    frozenScrollbar.style.width = frozenWidth + 'px';\n\n    if (this.parent.getFrozenMode() === leftRight) {\n      const frozenRightScrollbar = this.parent.element.querySelector('.e-frozen-right-scrollbar');\n      let frozenRightWidth = this.parent.getContent().querySelector('.e-frozen-right-content').firstElementChild.getBoundingClientRect().width;\n\n      if (this.parent.height !== 'auto') {\n        frozenRightWidth = frozenRightWidth + scrollWidth;\n      }\n\n      frozenRightScrollbar.style.width = frozenRightWidth + 'px';\n    } else {\n      if (this.parent.enableColumnVirtualization) {\n        const placeHolder = this.parent.getMovableVirtualContent().querySelector('.e-virtualtrack');\n\n        if (placeHolder) {\n          movableWidth = placeHolder.scrollWidth;\n        }\n      }\n\n      if (this.parent.getFrozenMode() !== 'Right' && this.parent.height !== 'auto') {\n        movableWidth = movableWidth + scrollWidth;\n      }\n    }\n\n    movableScrollbar.firstElementChild.style.width = movableWidth + 'px';\n  }\n\n  getSiblingsHeight(element) {\n    const previous = this.getHeightFromDirection(element, 'previous');\n    const next = this.getHeightFromDirection(element, 'next');\n    return previous + next;\n  }\n\n  getHeightFromDirection(element, direction) {\n    let sibling = element[direction + 'ElementSibling'];\n    let result = 0;\n    const classList$$1 = [gridHeader, gridFooter, 'e-groupdroparea', 'e-gridpager', 'e-toolbar'];\n\n    while (sibling) {\n      if (classList$$1.some(value => sibling.classList.contains(value))) {\n        result += sibling.offsetHeight;\n      }\n\n      sibling = sibling[direction + 'ElementSibling'];\n    }\n\n    return result;\n  }\n\n  isWidthUndefined() {\n    const isWidUndefCount = this.parent.getColumns().filter(col => {\n      return isNullOrUndefined(col.width) && isNullOrUndefined(col.minWidth);\n    }).length;\n    return this.parent.getColumns().length === isWidUndefCount;\n  }\n\n  getWidth(column) {\n    if (isNullOrUndefined(column.width) && this.parent.allowResizing && isNullOrUndefined(column.minWidth) && !this.isWidthUndefined()) {\n      column.width = 200;\n    }\n\n    if (this.parent.isFrozenGrid() && isNullOrUndefined(column.width) && (column.getFreezeTableName() === frozenLeft || column.getFreezeTableName() === frozenRight)) {\n      column.width = 200;\n    }\n\n    if (!column.width) {\n      return null;\n    }\n\n    const width = parseInt(column.width.toString(), 10);\n\n    if (column.minWidth && width < parseInt(column.minWidth.toString(), 10)) {\n      return column.minWidth;\n    } else if (column.maxWidth && width > parseInt(column.maxWidth.toString(), 10)) {\n      return column.maxWidth;\n    } else {\n      return column.width;\n    }\n  }\n\n  getTableWidth(columns) {\n    let tWidth = 0;\n\n    for (const column of columns) {\n      let cWidth = this.getWidth(column);\n\n      if (column.width === 'auto') {\n        cWidth = 0;\n      }\n\n      if (column.visible !== false && cWidth !== null) {\n        tWidth += parseInt(cWidth.toString(), 10);\n      }\n    }\n\n    return tWidth;\n  }\n\n  calcMovableOrFreezeColWidth(tableType) {\n    const columns = this.parent.getColumns().slice();\n    const left = this.parent.getFrozenLeftColumnsCount() || this.parent.getFrozenColumns();\n    const movable = this.parent.getMovableColumnsCount();\n    const right = this.parent.getFrozenRightColumnsCount();\n\n    if (tableType === 'movable') {\n      if (right) {\n        columns.splice(left + movable, columns.length);\n      }\n\n      if (left) {\n        columns.splice(0, left);\n      }\n    } else if (tableType === 'freeze-left') {\n      columns.splice(left, columns.length);\n    } else if (tableType === 'freeze-right') {\n      columns.splice(0, left + movable);\n    }\n\n    return formatUnit(this.getTableWidth(columns));\n  }\n\n  setWidthToFrozenRightTable() {\n    let freezeWidth = this.calcMovableOrFreezeColWidth('freeze-right');\n    freezeWidth = this.isAutoResize() ? '100%' : freezeWidth;\n    const headerTbl = this.parent.getHeaderContent().querySelector('.e-frozen-right-header').querySelector('.' + table);\n    const cntTbl = this.parent.getContent().querySelector('.e-frozen-right-content').querySelector('.' + table);\n    headerTbl.style.width = freezeWidth;\n    cntTbl.style.width = freezeWidth;\n  }\n\n  setWidthToFrozenLeftTable() {\n    let freezeWidth = this.calcMovableOrFreezeColWidth('freeze-left');\n    freezeWidth = this.isAutoResize() ? '100%' : freezeWidth;\n    this.parent.getHeaderTable().style.width = freezeWidth;\n    this.parent.getContentTable().style.width = freezeWidth;\n  }\n\n  setWidthToMovableTable() {\n    let movableWidth = '';\n    const isColUndefined = this.parent.getColumns().filter(a => {\n      return isNullOrUndefined(a.width);\n    }).length >= 1;\n    const isWidthAuto = this.parent.getColumns().filter(a => {\n      return a.width === 'auto';\n    }).length >= 1;\n\n    if (typeof this.parent.width === 'number' && !isColUndefined && !isWidthAuto) {\n      movableWidth = formatUnit(this.parent.width - parseInt(this.calcMovableOrFreezeColWidth('freeze').split('px')[0], 10) - 5);\n    } else if (!isColUndefined && !isWidthAuto) {\n      movableWidth = this.calcMovableOrFreezeColWidth('movable');\n    }\n\n    movableWidth = this.isAutoResize() ? '100%' : movableWidth;\n\n    if (this.parent.getHeaderContent().querySelector('.' + movableHeader).firstElementChild) {\n      this.parent.getHeaderContent().querySelector('.' + movableHeader).firstElementChild.style.width = movableWidth;\n    }\n\n    this.parent.getContent().querySelector('.' + movableContent).firstElementChild.style.width = movableWidth;\n  }\n\n  setWidthToFrozenEditTable() {\n    let freezeWidth = this.calcMovableOrFreezeColWidth('freeze');\n    freezeWidth = this.isAutoResize() ? '100%' : freezeWidth;\n    this.parent.element.querySelectorAll('.e-table.e-inline-edit')[0].style.width = freezeWidth;\n  }\n\n  setWidthToMovableEditTable() {\n    let movableWidth = this.calcMovableOrFreezeColWidth('movable');\n    movableWidth = this.isAutoResize() ? '100%' : movableWidth;\n    this.parent.element.querySelectorAll('.e-table.e-inline-edit')[1].style.width = movableWidth;\n  }\n\n  setWidthToTable() {\n    let tWidth = formatUnit(this.getTableWidth(this.parent.getColumns()));\n\n    if (this.parent.isFrozenGrid()) {\n      if (this.parent.getFrozenColumns() || this.parent.getFrozenLeftColumnsCount()) {\n        this.setWidthToFrozenLeftTable();\n      }\n\n      this.setWidthToMovableTable();\n\n      if (this.parent.getFrozenRightColumnsCount()) {\n        this.setWidthToFrozenRightTable();\n      }\n    } else {\n      if (this.parent.detailTemplate || this.parent.childGrid) {\n        this.setColumnWidth(new Column({\n          width: '30px'\n        }));\n      }\n\n      tWidth = this.isAutoResize() ? '100%' : tWidth;\n      this.parent.getHeaderTable().style.width = tWidth;\n      this.parent.getContentTable().style.width = tWidth;\n    }\n\n    const edit = this.parent.element.querySelector('.e-table.e-inline-edit');\n\n    if (edit && this.parent.getFrozenColumns()) {\n      this.setWidthToFrozenEditTable();\n      this.setWidthToMovableEditTable();\n    } else if (edit) {\n      edit.style.width = tWidth;\n    }\n  }\n\n  isAutoResize() {\n    return this.parent.allowResizing && this.parent.resizeSettings.mode === 'Auto';\n  }\n\n}\n/**\n * FocusStrategy class\n *\n * @hidden\n */\n\n\nclass FocusStrategy {\n  constructor(parent) {\n    this.currentInfo = {};\n    this.oneTime = true;\n    this.swap = {};\n    /** @hidden */\n\n    this.isInfiniteScroll = false;\n    this.forget = false;\n    this.skipFocus = true;\n    this.focusByClick = false;\n    this.prevIndexes = {};\n    this.refMatrix = this.refreshMatrix(true);\n    this.actions = ['downArrow', 'upArrow'];\n    this.isVirtualScroll = false;\n    this.parent = parent;\n    this.rowModelGen = new RowModelGenerator(this.parent);\n    this.addEventListener();\n  }\n\n  focusCheck(e) {\n    const target = e.target;\n    this.focusByClick = true;\n    this.skipFocus = target.classList.contains('e-grid');\n  }\n\n  onFocus(e) {\n    if (this.parent.isDestroyed || Browser.isDevice || this.parent.enableVirtualization) {\n      return;\n    }\n\n    this.setActive(!this.parent.enableHeaderFocus && this.parent.frozenRows === 0, this.parent.isFrozenGrid());\n\n    if (!this.parent.enableHeaderFocus && !this.parent.getCurrentViewRecords().length && (this.parent.editSettings.mode !== 'Batch' || this.parent.editSettings.mode === 'Batch' && !this.parent.editModule.getBatchChanges()[addedRecords].length)) {\n      this.getContent().matrix.generate(this.rowModelGen.generateRows({\n        rows: [new Row({\n          isDataRow: true\n        })]\n      }), this.getContent().selector, false);\n    }\n\n    const current = this.getContent().matrix.get(0, -1, [0, 1], null, this.getContent().validator());\n    this.getContent().matrix.select(current[0], current[1]);\n\n    if (this.skipFocus) {\n      this.focus(e);\n      this.skipFocus = false;\n    }\n  }\n\n  passiveFocus(e) {\n    if (this.parent.isDestroyed) {\n      return;\n    }\n\n    if (e.target && e.target.classList.contains('e-detailcell')) {\n      this.currentInfo.skipAction = false;\n      addClass([this.currentInfo.element], ['e-focused', 'e-focus']);\n    }\n  }\n\n  onBlur(e) {\n    if ((this.parent.isEdit || e && (!e.relatedTarget || closest(e.relatedTarget, '.e-grid'))) && !(isNullOrUndefined(e.relatedTarget) && parseInt(e.target.getAttribute('aria-colindex'), 10) === 0 && parseInt(e.target.getAttribute('index'), 10) === 0)) {\n      return;\n    }\n\n    this.removeFocus();\n    this.skipFocus = true;\n    this.currentInfo.skipAction = false;\n    this.parent.element.tabIndex = 0;\n  }\n\n  onClick(e, force) {\n    if (parentsUntil(e.target, 'e-filterbarcell') && (parentsUntil(e.target, 'e-multiselect') || e.target.classList.contains('e-input-group-icon'))) {\n      return;\n    }\n\n    let isContent = !isNullOrUndefined(closest(e.target, '.' + gridContent));\n    const isHeader = !isNullOrUndefined(closest(e.target, '.' + gridHeader));\n    isContent = isContent && isHeader ? !isContent : isContent;\n    let isFrozen = !isNullOrUndefined(closest(e.target, '.' + frozenContent)) || !isNullOrUndefined(closest(e.target, '.' + frozenHeader));\n    let isFrozenRight = false;\n\n    if (this.parent.getFrozenMode() === leftRight) {\n      isFrozenRight = !isNullOrUndefined(closest(e.target, '.e-frozen-right-content')) || !isNullOrUndefined(closest(e.target, '.e-frozen-right-header'));\n      isFrozen = isFrozen && !isFrozenRight;\n    }\n\n    if (!isContent && isNullOrUndefined(closest(e.target, '.' + gridHeader)) || e.target.classList.contains(content) || !isNullOrUndefined(closest(e.target, '.e-unboundcell'))) {\n      return;\n    }\n\n    this.setActive(isContent, isFrozen, isFrozenRight);\n\n    if (!isContent && isNullOrUndefined(closest(e.target, '.' + gridHeader))) {\n      this.clearOutline();\n      return;\n    }\n\n    const beforeArgs = {\n      cancel: false,\n      byKey: false,\n      byClick: !isNullOrUndefined(e.target),\n      clickArgs: e\n    };\n    this.parent.notify(beforeCellFocused, beforeArgs);\n\n    if (beforeArgs.cancel || closest(e.target, '.e-inline-edit')) {\n      return;\n    }\n\n    this.setActive(isContent, isFrozen, isFrozenRight);\n\n    if (this.getContent()) {\n      const returnVal = this.getContent().onClick(e, force);\n\n      if (returnVal === false) {\n        return;\n      }\n\n      this.focus();\n    }\n  }\n\n  onKeyPress(e) {\n    if (this.skipOn(e)) {\n      return;\n    }\n\n    this.activeKey = e.action;\n    const beforeArgs = {\n      cancel: false,\n      byKey: true,\n      byClick: false,\n      keyArgs: e\n    };\n    this.parent.notify(beforeCellFocused, beforeArgs);\n\n    if (beforeArgs.cancel) {\n      return;\n    }\n\n    const bValue = this.getContent().matrix.current;\n    this.currentInfo.outline = true;\n    const swapInfo = this.getContent().jump(e.action, bValue);\n    this.swap = swapInfo;\n\n    if (swapInfo.swap) {\n      this.setActive(!swapInfo.toHeader, swapInfo.toFrozen, swapInfo.toFrozenRight);\n      this.getContent().matrix.current = this.getContent().getNextCurrent(bValue, swapInfo, this.active, e.action);\n      this.prevIndexes = {};\n    }\n\n    this.setActiveByKey(e.action, this.getContent());\n    const returnVal = this.content.lastIdxCell ? false : this.getContent().onKeyPress(e);\n\n    if (returnVal === false) {\n      this.clearIndicator();\n\n      if (e.action === 'shiftTab' && bValue.toString() === [0, 0].toString()) {\n        this.parent.element.tabIndex = -1;\n      }\n\n      return;\n    }\n\n    e.preventDefault();\n    this.focus(e);\n  }\n\n  skipOn(e) {\n    const target = e.target;\n\n    if (!target) {\n      return false;\n    }\n\n    if (this.currentInfo.skipAction) {\n      this.clearIndicator();\n      return true;\n    }\n\n    if (['pageUp', 'pageDown', 'altDownArrow'].indexOf(e.action) > -1) {\n      this.clearIndicator();\n      return true;\n    }\n\n    const th = closest(target, 'th') && !closest(target, 'th').tabIndex;\n\n    if (e.target.classList.contains('e-filterbaroperator') && (e.keyCode === 13 || e.keyCode === 27)) {\n      const inputTarget = closest(e.target, '.e-filterbarcell');\n      inputTarget.querySelector('input').focus();\n    }\n\n    if (th && closest(document.activeElement, '.e-filterbarcell') !== null) {\n      this.removeFocus();\n    }\n\n    let filterCell = closest(document.activeElement, '.e-filterbarcell') !== null;\n\n    if (this.parent.enableHeaderFocus && filterCell) {\n      const matrix = this.active.matrix;\n      const current = matrix.current;\n      filterCell = matrix.matrix[current[0]].lastIndexOf(1) !== current[1];\n    }\n\n    return e.action === 'delete' || this.parent.editSettings.mode !== 'Batch' && (this.parent.isEdit || ['insert', 'f2'].indexOf(e.action) > -1) || filterCell || closest(document.activeElement, '#' + this.parent.element.id + '_searchbar') !== null && ['enter', 'leftArrow', 'rightArrow', 'shiftLeft', 'shiftRight', 'ctrlPlusA'].indexOf(e.action) > -1 || closest(target, '.' + gridContent) === null && closest(target, '.' + gridHeader) === null || e.action === 'space' && !target.classList.contains(gridChkBox) && closest(target, '.' + gridChkBox) === null && closest(target, '.e-headerchkcelldiv') === null || closest(target, '.e-filter-popup') !== null;\n  }\n\n  focusVirtualElement(e) {\n    if (this.parent.enableVirtualization || this.parent.enableInfiniteScrolling) {\n      const data = {\n        virtualData: {},\n        isAdd: false,\n        isCancel: false\n      };\n      this.parent.notify(getVirtualData, data);\n      const isKeyFocus = this.actions.some(value => value === this.activeKey);\n      const isSelected = this.parent.contentModule ? this.parent.contentModule.selectedRowIndex > -1 : false;\n\n      if (data.isAdd || Object.keys(data.virtualData).length || isKeyFocus || data.isCancel || isSelected) {\n        this.parent.notify(resetVirtualFocus, {\n          isCancel: false\n        });\n        data.isCancel = false;\n        this.parent.contentModule.selectedRowIndex = -1;\n\n        if (isKeyFocus) {\n          this.activeKey = this.empty;\n          this.parent.notify('virtaul-key-handler', e);\n        } // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n\n        this.currentInfo.elementToFocus.focus({\n          preventScroll: true\n        });\n      } else {\n        if (this.isVirtualScroll || this.isInfiniteScroll) {\n          // eslint-disable-next-line @typescript-eslint/no-explicit-any\n          this.currentInfo.elementToFocus.focus({\n            preventScroll: true\n          });\n        } else {\n          this.currentInfo.elementToFocus.focus();\n        }\n      }\n    }\n\n    this.isVirtualScroll = this.isInfiniteScroll = false;\n  }\n\n  getFocusedElement() {\n    return this.currentInfo.elementToFocus;\n  }\n\n  getContent() {\n    return this.active || this.content;\n  }\n\n  setActive(content$$1, isFrozen, isFrozenRight) {\n    this.active = content$$1 ? isFrozen ? this.fContent : isFrozenRight ? this.frContent : this.content : isFrozen ? this.fHeader : isFrozenRight ? this.frHeader : this.header;\n  }\n\n  setFocusedElement(element, e) {\n    this.currentInfo.elementToFocus = element;\n    setTimeout(() => {\n      if (!isNullOrUndefined(this.currentInfo.elementToFocus)) {\n        if (this.parent.enableVirtualization || this.parent.enableInfiniteScrolling) {\n          this.focusVirtualElement(e);\n        } else {\n          this.currentInfo.elementToFocus.focus();\n        }\n      }\n    }, 0);\n  }\n\n  focus(e) {\n    this.parent.notify(virtaulCellFocus, e);\n    this.removeFocus();\n    this.addFocus(this.getContent().getFocusInfo(), e);\n  } // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  removeFocus(e) {\n    if (!this.currentInfo.element) {\n      return;\n    }\n\n    removeClass([this.currentInfo.element, this.currentInfo.elementToFocus], ['e-focused', 'e-focus']);\n    this.currentInfo.element.tabIndex = -1;\n  }\n  /**\n   * @returns {void}\n   * @hidden */\n\n\n  addOutline() {\n    const info = this.getContent().getFocusInfo();\n\n    if (info.element) {\n      addClass([info.element], ['e-focused']);\n      addClass([info.elementToFocus], ['e-focus']);\n    }\n  }\n  /**\n   * @returns {void}\n   * @hidden */\n\n\n  focusHeader() {\n    this.setActive(false, this.parent.isFrozenGrid());\n    this.resetFocus();\n  }\n  /**\n   * @returns {void}\n   * @hidden */\n\n\n  focusContent() {\n    this.setActive(true, this.parent.isFrozenGrid());\n    this.resetFocus();\n  }\n\n  resetFocus() {\n    const current = this.getContent().matrix.get(0, -1, [0, 1], null, this.getContent().validator());\n    this.getContent().matrix.select(current[0], current[1]);\n    this.focus();\n  }\n\n  addFocus(info, e) {\n    this.currentInfo = info;\n    this.currentInfo.outline = info.outline && !isNullOrUndefined(e);\n\n    if (this.isInfiniteScroll) {\n      this.currentInfo.outline = true;\n    }\n\n    if (!info.element) {\n      return;\n    }\n\n    const isFocused = info.elementToFocus.classList.contains('e-focus');\n\n    if (isFocused) {\n      return;\n    }\n\n    if (this.currentInfo.outline) {\n      addClass([info.element], ['e-focused']);\n    }\n\n    addClass([info.elementToFocus], ['e-focus']);\n    info.element.tabIndex = 0;\n\n    if (!isFocused) {\n      this.setFocusedElement(info.elementToFocus, e);\n    }\n\n    this.parent.notify(cellFocused, {\n      element: info.elementToFocus,\n      parent: info.element,\n      indexes: this.getContent().matrix.current,\n      byKey: !isNullOrUndefined(e),\n      byClick: isNullOrUndefined(e),\n      keyArgs: e,\n      isJump: this.swap.swap,\n      container: this.getContent().getInfo(e),\n      outline: !isNullOrUndefined(e),\n      swapInfo: this.swap\n    });\n    const [rowIndex, cellIndex] = this.getContent().matrix.current;\n    this.prevIndexes = {\n      rowIndex,\n      cellIndex\n    };\n    this.focusedColumnUid = this.parent.getColumnByIndex(cellIndex).uid;\n    this.focusByClick = false;\n  }\n\n  refreshMatrix(content$$1) {\n    return e => {\n      if (content$$1 && e.args && e.args.isFrozen && !this.fContent) {\n        this.fContent = new FixedContentFocus(this.parent);\n      } else if (content$$1 && !this.frContent && e.args && e.args.renderFrozenRightContent) {\n        this.frContent = new FixedRightContentFocus(this.parent);\n      } else if (content$$1 && !this.content) {\n        this.content = new ContentFocus(this.parent);\n      }\n\n      if (!content$$1 && e.args && e.args.isFrozen && !this.fHeader) {\n        this.fHeader = new FixedHeaderFocus(this.parent);\n      } else if (!content$$1 && e.args && e.args.renderFrozenRightContent && !this.frHeader) {\n        this.frHeader = new FixedRightHeaderFocus(this.parent);\n      } else if (!content$$1 && !this.header) {\n        this.header = new HeaderFocus(this.parent);\n      }\n\n      const cFocus = content$$1 ? e.args && e.args.isFrozen ? this.fContent : e.args && e.args.renderFrozenRightContent ? this.frContent : this.content : e.args && e.args.isFrozen ? this.fHeader : e.args && e.args.renderFrozenRightContent ? this.frHeader : this.header;\n      let rows = content$$1 ? e.rows.slice(this.parent.frozenRows) : e.rows;\n      const updateRow = content$$1 ? e.rows.slice(0, this.parent.frozenRows) : e.rows;\n\n      if (this.parent.isCollapseStateEnabled() && content$$1) {\n        rows = rows.filter(x => x.visible !== false);\n      }\n\n      const isRowTemplate = !isNullOrUndefined(this.parent.rowTemplate);\n      const matrix = cFocus.matrix.generate(updateRow, cFocus.selector, isRowTemplate);\n\n      if (e.name === 'batchAdd' && this.parent.isFrozenGrid()) {\n        const mRows = this.parent.getMovableRowsObject();\n        const newMovableRows = mRows.map(row$$1 => {\n          return row$$1.clone();\n        });\n        const newFrozenRows = rows.map(row$$1 => {\n          return row$$1.clone();\n        });\n        this.fContent.matrix.generate(newFrozenRows, this.fContent.selector, isRowTemplate);\n        this.content.matrix.generate(newMovableRows, this.content.selector, isRowTemplate);\n\n        if (this.parent.getFrozenMode() === leftRight) {\n          const frRows = this.parent.getFrozenRightRowsObject();\n          const newfrRows = frRows.map(row$$1 => {\n            return row$$1.clone();\n          });\n          this.frContent.matrix.generate(newfrRows, this.frContent.selector, isRowTemplate);\n        }\n      } else {\n        cFocus.matrix.generate(rows, cFocus.selector, isRowTemplate);\n      }\n\n      cFocus.generateRows(updateRow, {\n        matrix,\n        handlerInstance: e.args && e.args.isFrozen ? this.fHeader : e.args && e.args.renderFrozenRightContent ? this.frHeader : this.header\n      });\n\n      if (!Browser.isDevice && e && e.args) {\n        if (!this.focusByClick && e.args.requestType === 'paging') {\n          this.skipFocus = false;\n          this.parent.element.focus();\n        }\n\n        if (e.args.requestType === 'grouping') {\n          this.skipFocus = true;\n        }\n      }\n\n      if (e && e.args && e.args.requestType === 'virtualscroll') {\n        if (this.currentInfo.uid) {\n          let index;\n          const bool = e.rows.some((row$$1, i) => {\n            index = i;\n            return row$$1.uid === this.currentInfo.uid;\n          });\n\n          if (bool) {\n            this.content.matrix.current[0] = index;\n            this.content.matrix.current[1] = this.parent.getColumnIndexByUid(this.focusedColumnUid) || 0;\n            const focusElement = this.getContent().getFocusInfo().elementToFocus;\n\n            if (focusElement) {\n              const cellPosition = focusElement.getBoundingClientRect();\n              const gridPosition = this.parent.element.getBoundingClientRect();\n\n              if (cellPosition.top >= 0 && cellPosition.left >= 0 && cellPosition.right <= Math.min(gridPosition.right, window.innerWidth || document.documentElement.clientWidth) && cellPosition.bottom <= Math.min(gridPosition.bottom, window.innerHeight || document.documentElement.clientHeight)) {\n                this.isVirtualScroll = true;\n                this.focus();\n              }\n            }\n          }\n        } else if (e.args.focusElement && e.args.focusElement.classList.contains('e-filtertext')) {\n          const focusElement = this.parent.element.querySelector('#' + e.args.focusElement.id);\n\n          if (focusElement) {\n            focusElement.focus();\n          }\n        }\n      }\n    };\n  }\n\n  addEventListener() {\n    if (this.parent.isDestroyed) {\n      return;\n    }\n\n    EventHandler.add(this.parent.element, 'mousedown', this.focusCheck, this);\n    EventHandler.add(this.parent.element, 'focus', this.onFocus, this);\n    this.parent.element.addEventListener('focus', this.passiveHandler = e => this.passiveFocus(e), true);\n    EventHandler.add(this.parent.element, 'focusout', this.onBlur, this);\n    this.evtHandlers = [{\n      event: keyPressed,\n      handler: this.onKeyPress\n    }, {\n      event: click,\n      handler: this.onClick\n    }, {\n      event: contentReady,\n      handler: this.refMatrix\n    }, {\n      event: partialRefresh,\n      handler: this.refMatrix\n    }, {\n      event: refreshExpandandCollapse,\n      handler: this.refMatrix\n    }, {\n      event: headerRefreshed,\n      handler: this.refreshMatrix()\n    }, {\n      event: closeEdit,\n      handler: this.restoreFocus\n    }, {\n      event: restoreFocus,\n      handler: this.restoreFocus\n    }, {\n      event: 'start-edit',\n      handler: this.clearIndicator\n    }, {\n      event: 'start-add',\n      handler: this.clearIndicator\n    }, {\n      event: 'sorting-complete',\n      handler: this.restoreFocus\n    }, {\n      event: 'filtering-complete',\n      handler: this.filterfocus\n    }, {\n      event: 'grouping-complete',\n      handler: this.restoreFocusWithAction\n    }, {\n      event: 'ungrouping-complete',\n      handler: this.restoreFocusWithAction\n    }, {\n      event: batchAdd,\n      handler: this.refMatrix\n    }, {\n      event: batchCancel,\n      handler: this.refMatrix\n    }, {\n      event: batchDelete,\n      handler: this.refMatrix\n    }, {\n      event: detailDataBound,\n      handler: this.refMatrix\n    }, {\n      event: onEmpty,\n      handler: this.refMatrix\n    }, {\n      event: cellFocused,\n      handler: this.internalCellFocus\n    }];\n    addRemoveEventListener(this.parent, this.evtHandlers, true, this);\n  }\n\n  filterfocus() {\n    if (this.parent.filterSettings.type !== 'FilterBar') {\n      this.restoreFocus();\n    }\n  }\n\n  removeEventListener() {\n    if (this.parent.isDestroyed) {\n      return;\n    }\n\n    EventHandler.remove(this.parent.element, 'mousedown', this.focusCheck);\n    EventHandler.remove(this.parent.element, 'focus', this.onFocus);\n    EventHandler.remove(this.parent.element, 'focusout', this.onBlur);\n    this.parent.element.removeEventListener('focus', this.passiveHandler, true);\n    addRemoveEventListener(this.parent, this.evtHandlers, false);\n  }\n\n  destroy() {\n    this.removeEventListener();\n  }\n\n  restoreFocus() {\n    this.addFocus(this.getContent().getFocusInfo());\n  }\n\n  restoreFocusWithAction(e) {\n    if (!this.parent.enableInfiniteScrolling) {\n      const matrix = this.getContent().matrix;\n      const current = matrix.current;\n\n      switch (e.requestType) {\n        case 'grouping':\n        case 'ungrouping':\n          current[1] = current.length && !this.parent.groupSettings.showGroupedColumn && !isNullOrUndefined(matrix.matrix[current[0]]) ? matrix.matrix[current[0]].indexOf(1) : e.requestType === 'grouping' ? current[1] + 1 : current[1] - 1;\n          break;\n      }\n\n      this.getContent().matrix.current = current;\n      this.addFocus(this.getContent().getFocusInfo());\n    }\n  }\n\n  clearOutline() {\n    this.getContent().matrix.current = this.getContent().matrix.get(0, -1, [0, 1], 'downArrow', this.getContent().validator());\n    this.clearIndicator();\n  }\n\n  clearIndicator() {\n    if (!this.currentInfo.element || !this.currentInfo.elementToFocus) {\n      return;\n    }\n\n    removeClass([this.currentInfo.element, this.currentInfo.elementToFocus], ['e-focus', 'e-focused']);\n  }\n\n  getPrevIndexes() {\n    const forget = this.forget;\n    this.forget = false;\n    return forget || !Object.keys(this.prevIndexes).length ? {\n      rowIndex: null,\n      cellIndex: null\n    } : this.prevIndexes;\n  }\n\n  forgetPrevious() {\n    this.forget = true;\n  }\n\n  setActiveByKey(action, active) {\n    if (!this.parent.isFrozenGrid() && this.parent.frozenRows === 0) {\n      return;\n    } // eslint-disable-next-line prefer-const\n\n\n    let info;\n    const actions = {\n      'home': () => ({\n        toHeader: !info.isContent,\n        toFrozen: true\n      }),\n      'end': () => ({\n        toHeader: !info.isContent,\n        toFrozen: false\n      }),\n      'ctrlHome': () => ({\n        toHeader: true,\n        toFrozen: this.parent.isFrozenGrid()\n      }),\n      'ctrlEnd': () => ({\n        toHeader: false,\n        toFrozen: false\n      })\n    };\n\n    if (!(action in actions)) {\n      return;\n    }\n\n    info = active.getInfo();\n    const swap = actions[action]();\n    this.setActive(!swap.toHeader, swap.toFrozen);\n    this.getContent().matrix.current = active.matrix.current;\n  }\n\n  internalCellFocus(e) {\n    if (!(e.byKey && e.container.isContent && e.keyArgs.action === 'enter' && (e.parent.classList.contains('e-detailcell') || e.parent.classList.contains('e-unboundcell') || e.parent.classList.contains('e-templatecell')))) {\n      return;\n    }\n\n    this.clearIndicator();\n    const focusEle = this.getContent().getFocusable(this.getFocusedElement());\n    this.setFocusedElement(focusEle);\n    this.currentInfo.skipAction = true;\n  }\n\n}\n/**\n * Create matrix from row collection which act as mental model for cell navigation\n *\n * @hidden\n */\n\n\nclass Matrix {\n  constructor() {\n    this.matrix = [];\n    this.current = [];\n  }\n\n  set(rowIndex, columnIndex, allow) {\n    rowIndex = Math.max(0, Math.min(rowIndex, this.rows));\n    columnIndex = Math.max(0, Math.min(columnIndex, this.columns));\n    this.matrix[rowIndex] = this.matrix[rowIndex] || [];\n    this.matrix[rowIndex][columnIndex] = allow ? 1 : 0;\n  }\n\n  get(rowIndex, columnIndex, navigator, action, validator) {\n    const tmp = columnIndex;\n\n    if (rowIndex + navigator[0] < 0) {\n      return [rowIndex, columnIndex];\n    }\n\n    rowIndex = Math.max(0, Math.min(rowIndex + navigator[0], this.rows));\n    let emptyTable = true;\n\n    if (isNullOrUndefined(this.matrix[rowIndex])) {\n      return null;\n    }\n\n    columnIndex = Math.max(0, Math.min(columnIndex + navigator[1], this.matrix[rowIndex].length - 1));\n\n    if (tmp + navigator[1] > this.matrix[rowIndex].length - 1 && validator(rowIndex, columnIndex, action)) {\n      return [rowIndex, tmp];\n    }\n\n    const first = this.first(this.matrix[rowIndex], columnIndex, navigator, true, action);\n    columnIndex = first === null ? tmp : first;\n    const val = getValue(`${rowIndex}.${columnIndex}`, this.matrix);\n\n    if (rowIndex === this.rows && (action === 'downArrow' || action === 'enter')) {\n      navigator[0] = -1;\n    }\n\n    if (first === null) {\n      for (let i = 0; i < this.rows; i++) {\n        if (this.matrix[i].some(v => {\n          return v === 1;\n        })) {\n          emptyTable = false;\n          break;\n        }\n      }\n\n      if (emptyTable) {\n        rowIndex = this.current[0];\n        return [rowIndex, columnIndex];\n      }\n    }\n\n    return this.inValid(val) || !validator(rowIndex, columnIndex, action) ? this.get(rowIndex, tmp, navigator, action, validator) : [rowIndex, columnIndex];\n  }\n\n  first(vector, index, navigator, moveTo, action) {\n    if ((index < 0 || index === vector.length) && this.inValid(vector[index]) && action !== 'upArrow' && action !== 'downArrow' || !vector.some(v => v === 1)) {\n      return null;\n    }\n\n    return !this.inValid(vector[index]) ? index : this.first(vector, ['upArrow', 'downArrow', 'shiftUp', 'shiftDown'].indexOf(action) !== -1 ? moveTo ? 0 : ++index : index + navigator[1], navigator, false, action);\n  }\n\n  select(rowIndex, columnIndex) {\n    rowIndex = Math.max(0, Math.min(rowIndex, this.rows));\n    columnIndex = Math.max(0, Math.min(columnIndex, this.matrix[rowIndex].length - 1));\n    this.current = [rowIndex, columnIndex];\n  }\n\n  generate(rows, selector, isRowTemplate) {\n    this.rows = rows.length - 1;\n    this.matrix = [];\n\n    for (let i = 0; i < rows.length; i++) {\n      const cells = rows[i].cells.filter(c => c.isSpanned !== true);\n      this.columns = Math.max(cells.length - 1, this.columns | 0);\n\n      for (let j = 0; j < cells.length; j++) {\n        this.set(i, j, rows[i].visible === false ? false : selector(rows[i], cells[j], isRowTemplate));\n      }\n    }\n\n    return this.matrix;\n  }\n\n  inValid(value) {\n    return value === 0 || value === undefined;\n  }\n\n}\n/**\n * @hidden\n */\n\n\nclass ContentFocus {\n  constructor(parent) {\n    this.matrix = new Matrix();\n    this.lastIdxCell = false;\n    this.parent = parent;\n    this.keyActions = {\n      'rightArrow': [0, 1],\n      'tab': [0, 1],\n      'leftArrow': [0, -1],\n      'shiftTab': [0, -1],\n      'upArrow': [-1, 0],\n      'downArrow': [1, 0],\n      'shiftUp': [-1, 0],\n      'shiftDown': [1, 0],\n      'shiftRight': [0, 1],\n      'shiftLeft': [0, -1],\n      'enter': [1, 0],\n      'shiftEnter': [-1, 0]\n    };\n\n    this.indexesByKey = action => {\n      const opt = {\n        'home': [this.matrix.current[0], -1, 0, 1],\n        'end': [this.matrix.current[0], this.matrix.columns + 1, 0, -1],\n        'ctrlHome': [0, -1, 0, 1],\n        'ctrlEnd': [this.matrix.rows, this.matrix.columns + 1, 0, -1]\n      };\n      return opt[action] || null;\n    };\n  }\n\n  getTable() {\n    return this.parent.isFrozenGrid() ? this.parent.getContent().querySelector('.e-movablecontent .e-table') : this.parent.getContentTable();\n  }\n\n  onKeyPress(e) {\n    const navigator = this.keyActions[e.action];\n    let current = this.getCurrentFromAction(e.action, navigator, e.action in this.keyActions, e);\n\n    if (!current) {\n      return;\n    }\n\n    if ((['tab', 'shiftTab'].indexOf(e.action) > -1 && this.matrix.current || []).toString() === current.toString()) {\n      if (current.toString() === [this.matrix.rows, this.matrix.columns].toString() || current.toString() === [0, 0].toString() || this.matrix.current[0] === this.matrix.rows && this.matrix.current.toString() === current.toString()) {\n        return false;\n      } else {\n        current = this.editNextRow(current[0], current[1], e.action);\n      }\n    }\n\n    this.matrix.select(current[0], current[1]);\n  }\n\n  editNextRow(rowIndex, cellIndex, action) {\n    const gObj = this.parent;\n    const editNextRow = gObj.editSettings.allowNextRowEdit && (gObj.isEdit || gObj.isLastCellPrimaryKey);\n    const visibleIndex = gObj.getColumnIndexByField(gObj.getVisibleColumns()[0].field);\n    const cell = this.getTable().rows[rowIndex].cells[cellIndex];\n\n    if (action === 'tab' && editNextRow) {\n      rowIndex++;\n      const index = this.getTable().rows[rowIndex].getElementsByClassName('e-indentcell').length + this.getTable().rows[rowIndex].getElementsByClassName('e-detailrowcollapse').length;\n      cellIndex = visibleIndex + index;\n    }\n\n    if (action === 'shiftTab' && editNextRow) {\n      rowIndex--;\n      cellIndex = gObj.getColumnIndexByField(gObj.getVisibleColumns()[gObj.getVisibleColumns().length - 1].field);\n    }\n\n    return !cell.classList.contains(rowCell) && !cell.classList.contains('e-headercell') && !cell.classList.contains('e-groupcaption') ? this.editNextRow(rowIndex, cellIndex, action) : [rowIndex, cellIndex];\n  }\n\n  getCurrentFromAction(action, navigator = [0, 0], isPresent, e) {\n    if (!isPresent && !this.indexesByKey(action) || this.matrix.current.length === 0) {\n      return null;\n    }\n\n    if (!this.shouldFocusChange(e)) {\n      return this.matrix.current;\n    }\n\n    const [rowIndex, cellIndex, rN, cN] = this.indexesByKey(action) || [...this.matrix.current, ...navigator];\n    const current = this.matrix.get(rowIndex, cellIndex, [rN, cN], action, this.validator());\n    return current;\n  }\n\n  onClick(e, force) {\n    let target = e.target;\n    this.target = target;\n    target = target.classList.contains(rowCell) ? target : closest(target, 'td');\n    target = target ? target : closest(e.target, 'td.e-detailrowcollapse') || closest(e.target, 'td.e-detailrowexpand');\n    target = closest(e.target, 'td.e-detailcell') ? isNullOrUndefined(closest(closest(e.target, '.e-grid'), 'td.e-detailcell')) ? null : target : target;\n    target = target && closest(target, 'table').classList.contains(table) ? target : null;\n\n    if (!target) {\n      return false;\n    }\n\n    const [rowIndex, cellIndex] = [target.parentElement.rowIndex, target.cellIndex];\n    const [oRowIndex, oCellIndex] = this.matrix.current;\n    const val = getValue(`${rowIndex}.${cellIndex}`, this.matrix.matrix);\n\n    if (this.matrix.inValid(val) || !force && oRowIndex === rowIndex && oCellIndex === cellIndex || !parentsUntil(e.target, rowCell) && !parentsUntil(e.target, 'e-groupcaption')) {\n      return false;\n    }\n\n    this.matrix.select(rowIndex, cellIndex);\n  }\n\n  getFocusInfo() {\n    const info = {};\n    const [rowIndex = 0, cellIndex = 0] = this.matrix.current;\n    this.matrix.current = [rowIndex, cellIndex];\n    info.element = !isNullOrUndefined(this.getTable().rows[rowIndex]) ? this.getTable().rows[rowIndex].cells[cellIndex] : null;\n\n    if (!info.element) {\n      return info;\n    }\n\n    info.elementToFocus = !info.element.classList.contains('e-unboundcell') && !info.element.classList.contains('e-detailcell') ? this.getFocusable(info.element) : info.element;\n    info.outline = true;\n    info.uid = info.element.parentElement.getAttribute('data-uid');\n    return info;\n  }\n\n  getFocusable(element) {\n    let query = 'button, [href], input:not([type=\"hidden\"]), select, textarea, [tabindex]:not([tabindex=\"-1\"])';\n    const isTemplate = !isNullOrUndefined(closest(element, '.e-templatecell'));\n\n    if (this.parent.isEdit) {\n      query = 'input:not([type=\"hidden\"]), select:not([aria-hidden=\"true\"]), textarea';\n    }\n\n    const child = [].slice.call(element.querySelectorAll(query));\n    /* Select the first focusable child element\n     * if no child found then select the cell itself.\n     * if Grid is in editable state, check for editable control inside child.\n     */\n\n    return child.length ? isTemplate && child.length > 1 ? this.target : child[0] : element;\n  }\n\n  selector(row$$1, cell, isRowTemplate) {\n    const types = [CellType.Expand, CellType.GroupCaption, CellType.CaptionSummary, CellType.GroupSummary];\n    return (row$$1.isDataRow && cell.visible && (cell.isDataCell || cell.isTemplate) || row$$1.isDataRow && cell.cellType === CellType.DetailExpand && isNullOrUndefined(cell.visible) || !row$$1.isDataRow && types.indexOf(cell.cellType) > -1 || cell.column && cell.visible && cell.column.type === 'checkbox' || cell.cellType === CellType.CommandColumn || row$$1.isDataRow && isRowTemplate) && !(row$$1.edit === 'delete' && row$$1.isDirty);\n  }\n\n  nextRowFocusValidate(index) {\n    const lastIndex = index;\n\n    for (let i = index, len = this.matrix.rows; i <= len; i++) {\n      if (this.matrix.matrix[index].indexOf(1) === -1) {\n        index = index + 1;\n      } else {\n        return index;\n      }\n    }\n\n    this.lastIdxCell = true;\n    return lastIndex;\n  }\n\n  previousRowFocusValidate(index) {\n    const firstIndex = index;\n\n    for (let i = index, len = 0; i >= len; i--) {\n      if (this.matrix.matrix[index].indexOf(1) === -1) {\n        index = index - 1;\n\n        if (index < 0) {\n          this.lastIdxCell = true;\n          return firstIndex;\n        }\n      } else {\n        return index;\n      }\n    }\n\n    return firstIndex;\n  }\n\n  jump(action, current) {\n    let frozenSwap = this.parent.getFrozenLeftCount() && (action === 'leftArrow' || action === 'shiftTab') && current[1] === 0;\n    const right = (action === 'rightArrow' || action === 'tab') && current[1] === this.matrix.columns;\n    const frSwap = this.parent.getFrozenMode() === leftRight && right;\n\n    if (this.parent.getFrozenMode() === 'Right') {\n      frozenSwap = right;\n    }\n\n    this.lastIdxCell = false;\n    const enterFrozen = this.parent.frozenRows !== 0 && action === 'shiftEnter';\n\n    if (action === 'tab' && !this.parent.isEdit && current[1] === this.matrix.matrix[current[0]].lastIndexOf(1) && this.matrix.matrix.length - 1 !== current[0]) {\n      this.matrix.current[0] = this.nextRowFocusValidate(this.matrix.current[0] + 1);\n      this.matrix.current[1] = -1;\n      frozenSwap = this.parent.isFrozenGrid();\n    }\n\n    if (action === 'shiftTab' && !this.parent.isEdit && current[0] !== 0 && this.matrix.matrix[current[0]].indexOf(1) === current[1]) {\n      this.matrix.current[0] = this.previousRowFocusValidate(this.matrix.current[0] - 1);\n      this.matrix.current[1] = this.matrix.matrix[current[0]].length;\n    }\n\n    let isHeaderFocus = false;\n    const row$$1 = document.activeElement.parentElement;\n\n    if ((this.parent.enableVirtualization || this.parent.infiniteScrollSettings.enableCache) && row$$1.classList.contains(row)) {\n      const rowIndex = parseInt(row$$1.getAttribute(ariaRowIndex), 10);\n      isHeaderFocus = rowIndex > 0;\n    }\n\n    const info = {\n      swap: !isHeaderFocus ? (action === 'upArrow' || enterFrozen) && current[0] === 0 || frozenSwap || frSwap : false,\n      toHeader: (action === 'upArrow' || enterFrozen) && current[0] === 0,\n      toFrozen: frozenSwap,\n      toFrozenRight: frSwap\n    };\n    return info;\n  }\n\n  getNextCurrent(previous = [], swap, active, action) {\n    const current = [];\n\n    if (this.parent.getFrozenMode() === 'Right' || this.parent.getFrozenMode() === leftRight) {\n      if (action === 'leftArrow' || action === 'shiftTab') {\n        current[0] = previous[0];\n        current[1] = active.matrix.columns + 1;\n      }\n\n      if (this.parent.getFrozenMode() === leftRight && (action === 'rightArrow' || action === 'tab')) {\n        current[0] = previous[0];\n        current[1] = -1;\n      }\n    } else if (action === 'rightArrow' || action === 'tab') {\n      current[0] = previous[0];\n      current[1] = -1;\n    }\n\n    if (action === 'downArrow' || action === 'enter') {\n      current[0] = -1;\n      current[1] = previous[1];\n    }\n\n    return current;\n  }\n\n  generateRows(rows, optionals) {\n    const {\n      matrix,\n      handlerInstance\n    } = optionals;\n    const len = handlerInstance.matrix.matrix.length;\n    const defaultLen = this.parent.allowFiltering && this.parent.filterSettings.type === 'FilterBar' ? len + 1 : len;\n    handlerInstance.matrix.matrix = handlerInstance.matrix.matrix.slice(0, defaultLen); //Header matrix update.\n\n    handlerInstance.matrix.rows = defaultLen;\n    handlerInstance.matrix.matrix.push(...matrix);\n    handlerInstance.matrix.rows += matrix.length;\n  }\n\n  getInfo(e) {\n    const info = this.getFocusInfo();\n    const [rIndex, cIndex] = this.matrix.current;\n    const isData = info.element.classList.contains(rowCell);\n    const isSelectable = isData || e && e.action !== 'enter' && (info.element.classList.contains('e-detailrowcollapse') || info.element.classList.contains('e-detailrowexpand')); // eslint-disable-next-line max-len\n\n    const [rowIndex, cellIndex] = [Math.min(parseInt(info.element.parentElement.getAttribute(ariaRowIndex), 10), rIndex), Math.min(parseInt(info.element.getAttribute(ariaColIndex), 10), cIndex)];\n    return {\n      isContent: true,\n      isDataCell: isData,\n      indexes: [rowIndex, cellIndex],\n      isSelectable: isSelectable\n    };\n  }\n\n  validator() {\n    const table$$1 = this.getTable();\n    return (rowIndex, cellIndex, action) => {\n      if (!isNullOrUndefined(table$$1.rows[rowIndex])) {\n        let cell;\n        cellIndex = table$$1.querySelector('.e-emptyrow') ? 0 : cellIndex;\n\n        if (table$$1.rows[rowIndex].cells[0].classList.contains('e-editcell')) {\n          cell = table$$1.rows[rowIndex].cells[0].querySelectorAll('td')[cellIndex];\n        } else {\n          cell = table$$1.rows[rowIndex].cells[cellIndex];\n        }\n\n        const isCellWidth = cell.getBoundingClientRect().width !== 0;\n\n        if (action === 'enter' || action === 'shiftEnter') {\n          return isCellWidth && cell.classList.contains(rowCell);\n        }\n\n        if ((action === 'shiftUp' || action === 'shiftDown') && cell.classList.contains(rowCell)) {\n          return isCellWidth;\n        } else if (action !== 'shiftUp' && action !== 'shiftDown') {\n          return isCellWidth;\n        }\n      }\n\n      return false;\n    };\n  }\n\n  shouldFocusChange(e) {\n    const [rIndex = -1, cIndex = -1] = this.matrix.current;\n\n    if (rIndex < 0 || cIndex < 0) {\n      return true;\n    }\n\n    const cell = getValue(`${rIndex}.cells.${cIndex}`, this.getTable().rows);\n\n    if (!cell) {\n      return true;\n    }\n\n    return e.action === 'enter' || e.action === 'shiftEnter' ? cell.classList.contains(rowCell) && !cell.classList.contains('e-unboundcell') && (!cell.classList.contains('e-templatecell') || cell.classList.contains('e-editedbatchcell')) && !cell.classList.contains('e-detailcell') : true;\n  }\n\n  getGridSeletion() {\n    return this.parent.allowSelection && this.parent.selectionSettings.allowColumnSelection;\n  }\n\n}\n/**\n * @hidden\n */\n\n\nclass HeaderFocus extends ContentFocus {\n  constructor(parent) {\n    super(parent);\n  }\n\n  getTable() {\n    return this.parent.isFrozenGrid() ? this.parent.getHeaderContent().querySelector('.e-movableheader .e-table') : this.parent.getHeaderTable();\n  }\n\n  onClick(e) {\n    let target = e.target;\n    this.target = target;\n    target = target.classList.contains('e-headercell') ? target : closest(target, 'th');\n\n    if (!target && this.parent.frozenRows !== 0) {\n      target = e.target.classList.contains(rowCell) ? e.target : closest(e.target, 'td');\n    }\n\n    if (e.target.classList.contains('e-columnheader') || e.target.querySelector('.e-stackedheadercell')) {\n      return false;\n    }\n\n    if (!target) {\n      return;\n    }\n\n    const [rowIndex, cellIndex] = [target.parentElement.rowIndex, target.cellIndex];\n    const val = getValue(`${rowIndex}.${cellIndex}`, this.matrix.matrix);\n\n    if (this.matrix.inValid(val)) {\n      return false;\n    }\n\n    this.matrix.select(target.parentElement.rowIndex, target.cellIndex);\n  }\n\n  getFocusInfo() {\n    const info = {};\n    const [rowIndex = 0, cellIndex = 0] = this.matrix.current;\n    info.element = this.getTable().rows[rowIndex].cells[cellIndex];\n\n    if (!isNullOrUndefined(info.element)) {\n      info.elementToFocus = this.getFocusable(info.element);\n      info.outline = !info.element.classList.contains('e-filterbarcell');\n    }\n\n    return info;\n  }\n\n  selector(row$$1, cell) {\n    return cell.visible && (cell.column.field !== undefined || cell.isTemplate || !isNullOrUndefined(cell.column.template)) || cell.column.type === 'checkbox' || cell.cellType === CellType.StackedHeader;\n  }\n\n  jump(action, current) {\n    let frozenSwap = this.parent.getFrozenLeftCount() && (action === 'leftArrow' || action === 'shiftLeft' && this.getGridSeletion() || action === 'shiftTab') && current[1] === 0;\n    const right = (action === 'rightArrow' || action === 'shiftRight' && this.getGridSeletion() || action === 'tab') && current[1] === this.matrix.columns;\n    const frSwap = this.parent.getFrozenMode() === leftRight && right;\n\n    if (this.parent.getFrozenMode() === 'Right') {\n      frozenSwap = right;\n    }\n\n    const enterFrozen = this.parent.frozenRows !== 0 && action === 'enter';\n    let isLastCell;\n    let lastRow;\n    let headerSwap = frozenSwap || frSwap;\n    const fMatrix = this.parent.focusModule.fHeader && this.parent.focusModule.fHeader.matrix.matrix;\n    const isPresent = fMatrix && !isNullOrUndefined(fMatrix[current[0]]);\n\n    if (this.parent.enableHeaderFocus && action === 'tab') {\n      lastRow = this.matrix.matrix.length - 1 === current[0];\n      isLastCell = current[1] === this.matrix.matrix[current[0]].lastIndexOf(1);\n\n      if (isLastCell) {\n        if (!lastRow) {\n          this.matrix.current[0] = this.matrix.current[0] + 1;\n        } else {\n          this.matrix.current[0] = 0;\n        }\n\n        this.matrix.current[1] = -1;\n      }\n\n      if (this.parent.isFrozenGrid() && lastRow && isLastCell) {\n        frozenSwap = true;\n        headerSwap = false;\n      }\n    }\n\n    return {\n      swap: (action === 'downArrow' || enterFrozen) && current[0] === this.matrix.matrix.length - 1 || isPresent && (frozenSwap || frSwap) || action === 'tab' && lastRow && isLastCell,\n      toHeader: headerSwap,\n      toFrozen: frozenSwap,\n      toFrozenRight: frSwap\n    };\n  }\n\n  getNextCurrent(previous = [], swap, active, action) {\n    const current1 = [];\n\n    if (this.parent.getFrozenMode() === 'Right' || this.parent.getFrozenMode() === leftRight) {\n      if (action === 'leftArrow' || action === 'shiftLeft' && this.getGridSeletion() || action === 'shiftTab') {\n        current1[0] = previous[0];\n        current1[1] = active.matrix.columns + 1;\n      }\n\n      if (this.parent.getFrozenMode() === leftRight && (action === 'rightArrow' || action === 'shiftRight' && this.getGridSeletion() || action === 'tab')) {\n        current1[0] = previous[0];\n        current1[1] = -1;\n      }\n    } else if (action === 'rightArrow' || action === 'shiftRight' && this.getGridSeletion() || action === 'tab') {\n      current1[0] = previous[0];\n      current1[1] = -1;\n    }\n\n    if (action === 'upArrow' || action === 'shiftEnter') {\n      current1[0] = this.matrix.matrix.length;\n      current1[1] = previous[1];\n    }\n\n    return current1;\n  }\n\n  generateRows(rows) {\n    const length = this.matrix.matrix.length;\n\n    if (this.parent.allowFiltering && this.parent.filterSettings.type === 'FilterBar') {\n      this.matrix.rows = ++this.matrix.rows;\n      const cells = rows[0].cells;\n\n      for (let i = 0; i < cells.length; i++) {\n        this.matrix.set(length, i, cells[i].visible && cells[i].column.allowFiltering !== false);\n      }\n    }\n  }\n\n  getInfo(e) {\n    return extend(super.getInfo(e), {\n      isContent: false,\n      isHeader: true\n    });\n  }\n\n  validator() {\n    return () => true;\n  }\n\n  shouldFocusChange(e) {\n    const [rowIndex, columnIndex] = this.matrix.current;\n\n    if (rowIndex < 0 || columnIndex < 0) {\n      return true;\n    }\n\n    const cell = getValue(`${rowIndex}.cells.${columnIndex}`, this.getTable().rows);\n\n    if (!cell) {\n      return true;\n    }\n\n    return e.action === 'enter' || e.action === 'altDownArrow' ? !cell.classList.contains('e-headercell') : true;\n  }\n\n}\n\nclass FixedContentFocus extends ContentFocus {\n  getTable() {\n    return this.parent.getContent().querySelector('.e-frozencontent .e-table');\n  }\n\n  jump(action, current) {\n    const enterFrozen = this.parent.frozenRows !== 0 && action === 'shiftEnter';\n    const toHeader = (action === 'upArrow' || enterFrozen) && current[0] === 0;\n\n    if (this.parent.getFrozenMode() === 'Right') {\n      const swap = toHeader || (action === 'shiftTab' || action === 'leftArrow') && current[1] === 0;\n      return {\n        swap: swap,\n        toHeader: toHeader,\n        toFrozen: toHeader\n      };\n    }\n\n    return {\n      swap: toHeader || (action === 'tab' || action === 'rightArrow') && current[1] === this.matrix.columns,\n      toHeader: toHeader,\n      toFrozen: toHeader\n    };\n  }\n\n  getNextCurrent(previous = [], swap, active, action) {\n    const current2 = [];\n\n    if (this.parent.getFrozenMode() === 'Right') {\n      if (action === 'rightArrow' || action === 'tab') {\n        current2[0] = previous[0];\n        current2[1] = -1;\n      }\n    } else {\n      if (action === 'tab' && this.parent.enableHeaderFocus) {\n        current2[0] = previous[0];\n        current2[1] = -1;\n      }\n\n      if (action === 'leftArrow' || action === 'shiftTab') {\n        current2[0] = previous[0];\n        current2[1] = active.matrix.columns + 1;\n      }\n    }\n\n    if (action === 'downArrow' || action === 'enter') {\n      current2[0] = -1;\n      current2[1] = previous[1];\n    }\n\n    return current2;\n  }\n\n}\n\nclass FixedHeaderFocus extends HeaderFocus {\n  jump(action, current) {\n    const enterFrozen = this.parent.frozenRows !== 0 && action === 'enter';\n    const hMatrix = this.parent.focusModule.header && this.parent.focusModule.header.matrix.matrix;\n    const isPresent = hMatrix && !isNullOrUndefined(hMatrix[current[0]]);\n\n    if (this.parent.getFrozenMode() === 'Right') {\n      const frSwap = (action === 'leftArrow' || action === 'shiftLeft' && this.getGridSeletion() || action === 'shiftTab') && current[1] === 0;\n      const swap = (action === 'downArrow' || enterFrozen) && current[0] === this.matrix.matrix.length - 1 || isPresent && frSwap;\n      const toFrozen = (action === 'downArrow' || enterFrozen) && current[0] === this.matrix.matrix.length - 1;\n      return {\n        swap: swap,\n        toHeader: frSwap,\n        toFrozen: toFrozen\n      };\n    }\n\n    return {\n      swap: (action === 'downArrow' || enterFrozen) && current[0] === this.matrix.matrix.length - 1 || (action === 'rightArrow' || action === 'shiftRight' && this.getGridSeletion() || action === 'tab') && current[1] === this.matrix.columns && isPresent,\n      toHeader: (action === 'rightArrow' || action === 'shiftRight' && this.getGridSeletion() || action === 'tab') && current[1] === this.matrix.columns,\n      toFrozen: (action === 'downArrow' || enterFrozen) && current[0] === this.matrix.matrix.length - 1\n    };\n  }\n\n  getTable() {\n    return this.parent.getHeaderContent().querySelector('.e-frozenheader .e-table');\n  }\n\n  getNextCurrent(previous = [], swap, active, action) {\n    const current3 = [];\n\n    if (this.parent.getFrozenMode() === 'Right') {\n      if (action === 'rightArrow' || action === 'shiftRight' && this.getGridSeletion() || action === 'tab') {\n        current3[0] = previous[0];\n        current3[1] = -1;\n      }\n    } else {\n      if (action === 'leftArrow' || action === 'shiftLeft' && this.getGridSeletion() || action === 'shiftTab') {\n        current3[0] = previous[0];\n        current3[1] = active.matrix.columns + 1;\n      }\n    }\n\n    if (action === 'upArrow' || action === 'shiftEnter') {\n      current3[0] = this.matrix.matrix.length;\n      current3[1] = previous[1];\n    }\n\n    return current3;\n  }\n\n}\n/** @hidden */\n\n\nclass SearchBox {\n  constructor(searchBox) {\n    this.searchBox = searchBox;\n  }\n\n  searchFocus(args) {\n    args.target.parentElement.classList.add('e-input-focus');\n  }\n\n  searchBlur(args) {\n    args.target.parentElement.classList.remove('e-input-focus');\n  }\n\n  wireEvent() {\n    if (this.searchBox) {\n      EventHandler.add(this.searchBox, 'focus', this.searchFocus, this);\n      EventHandler.add(this.searchBox, 'blur', this.searchBlur, this);\n    }\n  }\n\n  unWireEvent() {\n    if (this.searchBox) {\n      EventHandler.remove(this.searchBox, 'focus', this.searchFocus);\n      EventHandler.remove(this.searchBox, 'blur', this.searchBlur);\n    }\n  }\n\n}\n\nclass FixedRightContentFocus extends ContentFocus {\n  getTable() {\n    return this.parent.getContent().querySelector('.e-frozen-right-content .e-table');\n  }\n\n  jump(action, current) {\n    const enterFrozen = this.parent.frozenRows !== 0 && action === 'shiftEnter';\n    const toHeader = (action === 'upArrow' || enterFrozen) && current[0] === 0;\n    return {\n      swap: toHeader || (action === 'shiftTab' || action === 'leftArrow') && current[1] === 0,\n      toHeader: toHeader,\n      toFrozenRight: toHeader\n    };\n  }\n\n  getNextCurrent(previous = [], swap, active, action) {\n    const current2 = [];\n\n    if (action === 'rightArrow' || action === 'tab') {\n      current2[0] = previous[0];\n      current2[1] = -1;\n    }\n\n    if (action === 'downArrow' || action === 'enter') {\n      current2[0] = -1;\n      current2[1] = previous[1];\n    }\n\n    return current2;\n  }\n\n}\n\nclass FixedRightHeaderFocus extends HeaderFocus {\n  jump(action, current) {\n    const headerMat = this.parent.focusModule.header && this.parent.focusModule.header.matrix.matrix;\n    const isPresent = headerMat && !isNullOrUndefined(headerMat[current[0]]);\n    const enterFrozen = this.parent.frozenRows !== 0 && action === 'enter';\n    const frozenSwap = (action === 'leftArrow' || action === 'shiftLeft' && this.getGridSeletion() || action === 'shiftTab') && current[1] === 0;\n    const swap = (action === 'downArrow' || enterFrozen) && current[0] === this.matrix.matrix.length - 1 || isPresent && frozenSwap;\n    const toFrozen = (action === 'downArrow' || enterFrozen) && current[0] === this.matrix.matrix.length - 1;\n    return {\n      swap: swap,\n      toHeader: frozenSwap,\n      toFrozenRight: toFrozen\n    };\n  }\n\n  getTable() {\n    return this.parent.getHeaderContent().querySelector('.e-frozen-right-header .e-table');\n  }\n\n  getNextCurrent(previous = [], swap, active, action) {\n    const current3 = [];\n\n    if (action === 'rightArrow' || action === 'shiftRight' && this.getGridSeletion() || action === 'tab') {\n      current3[0] = previous[0];\n      current3[1] = 0;\n    }\n\n    if (action === 'upArrow' || action === 'shiftEnter') {\n      current3[0] = this.matrix.matrix.length;\n      current3[1] = previous[1];\n    }\n\n    return current3;\n  }\n\n}\n\nvar __decorate$2 = undefined && undefined.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n/**\n * Configures the paging behavior of the Grid.\n */\n\n\nclass PageSettings extends ChildProperty {}\n\n__decorate$2([Property(12)], PageSettings.prototype, \"pageSize\", void 0);\n\n__decorate$2([Property(8)], PageSettings.prototype, \"pageCount\", void 0);\n\n__decorate$2([Property(1)], PageSettings.prototype, \"currentPage\", void 0);\n\n__decorate$2([Property()], PageSettings.prototype, \"totalRecordsCount\", void 0);\n\n__decorate$2([Property(false)], PageSettings.prototype, \"enableQueryString\", void 0);\n\n__decorate$2([Property(false)], PageSettings.prototype, \"pageSizes\", void 0);\n\n__decorate$2([Property(null)], PageSettings.prototype, \"template\", void 0);\n\nvar __decorate$3 = undefined && undefined.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n/**\n * Configures the column chooser behavior of the Grid.\n */\n\n\nclass ColumnChooserSettings extends ChildProperty {}\n\n__decorate$3([Property('startsWith')], ColumnChooserSettings.prototype, \"operator\", void 0);\n\n__decorate$3([Property(false)], ColumnChooserSettings.prototype, \"ignoreAccent\", void 0);\n/**\n * The `Selection` module is used to handle cell and row selection.\n */\n\n\nclass Selection {\n  /**\n   * Constructor for the Grid selection module\n   *\n   * @param {IGrid} parent - specifies the IGrid\n   * @param {SelectionSettings} selectionSettings - specifies the selectionsettings\n   * @param {ServiceLocator} locator - specifies the ServiceLocator\n   * @hidden\n   */\n  constructor(parent, selectionSettings, locator) {\n    //Internal letiables\n\n    /**\n     * @hidden\n     */\n    this.selectedRowIndexes = [];\n    /**\n     * @hidden\n     */\n\n    this.selectedRowCellIndexes = [];\n    /**\n     * @hidden\n     */\n\n    this.selectedRecords = [];\n    /**\n     * @hidden\n     */\n\n    this.preventFocus = false;\n    /**\n     *  @hidden\n     */\n\n    this.selectedColumnsIndexes = [];\n    this.checkBoxState = false;\n    this.isMultiShiftRequest = false;\n    this.isMultiCtrlRequest = false;\n    this.enableSelectMultiTouch = false;\n    this.clearRowCheck = false;\n    this.selectRowCheck = false;\n    this.selectedRowState = {};\n    this.totalRecordsCount = 0;\n    this.chkAllCollec = [];\n    this.isCheckedOnAdd = false;\n    this.persistSelectedData = [];\n    this.deSelectedData = [];\n    this.needColumnSelection = false;\n    this.isCancelDeSelect = false;\n    this.isPreventCellSelect = false;\n    this.disableUI = false;\n    this.isPersisted = false;\n    this.cmdKeyPressed = false;\n    this.cellselected = false;\n    this.isMultiSelection = false;\n    this.isAddRowsToSelection = false;\n    this.initialRowSelection = false;\n    this.isPrevRowSelection = false;\n    this.isKeyAction = false;\n    this.isRowDragSelected = false;\n    /**\n     * @hidden\n     */\n\n    this.autoFillRLselection = true;\n    this.bottom = '0 0 2px 0';\n    this.top = '2px 0 0 0';\n    /* eslint-disable */\n\n    this.right_bottom = '0 2px 2px 0';\n    this.bottom_left = '0 0 2px 2px';\n    this.top_right = '2px 2px 0 0';\n    this.top_left = '2px 0 0 2px';\n    this.top_bottom = '2px 0 2px 0';\n    this.top_right_bottom = '2px 2px 2px 0';\n    this.top_bottom_left = '2px 0 2px 2px';\n    this.top_right_left = '2px 2px 0 2px';\n    this.right_bottom_left = '0 2px 2px 2px';\n    this.all_border = '2px';\n    this.parent = parent;\n    this.selectionSettings = selectionSettings;\n    this.factory = locator.getService('rendererFactory');\n    this.focus = locator.getService('focus');\n    this.addEventListener();\n    this.wireEvents();\n  }\n\n  initializeSelection() {\n    this.parent.log('selection_key_missing');\n    this.render();\n  }\n  /**\n   * The function used to trigger onActionBegin\n   *\n   * @param {Object} args - specifies the args\n   * @param {string} type - specifies the type\n   * @returns {void}\n   * @hidden\n   */\n\n\n  onActionBegin(args, type) {\n    this.parent.trigger(type, this.fDataUpdate(args));\n  }\n\n  fDataUpdate(args) {\n    if (!this.isMultiSelection && (!isNullOrUndefined(args.cellIndex) || !isNullOrUndefined(args.rowIndex))) {\n      const rowObj = this.getRowObj(isNullOrUndefined(args.rowIndex) ? isNullOrUndefined(args.cellIndex) ? this.currentIndex : args.cellIndex.rowIndex : args.rowIndex);\n      args.foreignKeyData = rowObj.foreignKeyData;\n    }\n\n    return args;\n  }\n  /**\n   * The function used to trigger onActionComplete\n   *\n   * @param {Object} args - specifies the args\n   * @param {string} type - specifies the type\n   * @returns {void}\n   * @hidden\n   */\n\n\n  onActionComplete(args, type) {\n    this.parent.trigger(type, this.fDataUpdate(args));\n    this.isMultiSelection = false;\n  }\n  /**\n   * For internal use only - Get the module name.\n   *\n   * @returns {string} returns the module name\n   * @private\n   */\n\n\n  getModuleName() {\n    return 'selection';\n  }\n  /**\n   * To destroy the selection\n   *\n   * @returns {void}\n   * @hidden\n   */\n\n\n  destroy() {\n    const gridElement = this.parent.element;\n\n    if (!gridElement || !gridElement.querySelector('.' + gridHeader) && !gridElement.querySelector('.' + gridContent)) {\n      return;\n    }\n\n    this.hidePopUp();\n    this.clearSelection();\n    this.removeEventListener();\n    this.unWireEvents();\n    EventHandler.remove(this.parent.getContent(), 'mousedown', this.mouseDownHandler);\n    EventHandler.remove(this.parent.getHeaderContent(), 'mousedown', this.mouseDownHandler);\n  }\n\n  isEditing() {\n    return (this.parent.editSettings.mode === 'Normal' || this.parent.editSettings.mode === 'Batch' && this.parent.editModule && this.parent.editModule.formObj && !this.parent.editModule.formObj.validate()) && this.parent.isEdit && !this.parent.isPersistSelection;\n  }\n\n  getSelectedMovableRow(index) {\n    const gObj = this.parent;\n\n    if (gObj.isFrozenGrid() && this.parent.getContent().querySelector('.' + movableContent)) {\n      return gObj.getMovableRowByIndex(index);\n    }\n\n    return null;\n  }\n\n  getSelectedFrozenRightRow(index) {\n    const gObj = this.parent;\n\n    if (gObj.isFrozenGrid() && gObj.getFrozenMode() === leftRight && gObj.getFrozenRightContent()) {\n      return gObj.getFrozenRightRowByIndex(index);\n    }\n\n    return null;\n  }\n\n  getCurrentBatchRecordChanges() {\n    const gObj = this.parent;\n\n    if (gObj.editSettings.mode === 'Batch' && gObj.editModule) {\n      let currentRecords = iterateExtend(this.parent.getCurrentViewRecords());\n      currentRecords = gObj.editSettings.newRowPosition === 'Bottom' ? currentRecords.concat(this.parent.editModule.getBatchChanges()[addedRecords]) : this.parent.editModule.getBatchChanges()[addedRecords].concat(currentRecords);\n      const deletedRecords$$1 = this.parent.editModule.getBatchChanges()[deletedRecords];\n      const primaryKey = this.parent.getPrimaryKeyFieldNames()[0];\n\n      for (let i = 0; i < deletedRecords$$1.length; i++) {\n        for (let j = 0; j < currentRecords.length; j++) {\n          if (deletedRecords$$1[i][primaryKey] === currentRecords[j][primaryKey]) {\n            currentRecords.splice(j, 1);\n            break;\n          }\n        }\n      }\n\n      return currentRecords;\n    } else {\n      return gObj.getCurrentViewRecords();\n    }\n  }\n  /**\n   * Selects a row by the given index.\n   *\n   * @param  {number} index - Defines the row index.\n   * @param  {boolean} isToggle - If set to true, then it toggles the selection.\n   * @returns {void}\n   */\n\n\n  selectRow(index, isToggle) {\n    if (this.selectedRowIndexes.length && this.selectionSettings.enableSimpleMultiRowSelection) {\n      this.addRowsToSelection([index]);\n      return;\n    }\n\n    const gObj = this.parent;\n    const selectedRow = gObj.getRowByIndex(index);\n    const selectedMovableRow = this.getSelectedMovableRow(index);\n    const selectedFrozenRightRow = this.getSelectedFrozenRightRow(index);\n    let selectData;\n    const isRemoved = false;\n\n    if (gObj.enableVirtualization && index > -1) {\n      const e = {\n        selectedIndex: index,\n        isAvailable: true\n      };\n      this.parent.notify(selectVirtualRow, e);\n      const frozenData = gObj.isFrozenGrid() ? gObj.contentModule.getRowObjectByIndex(index) : null;\n\n      if (selectedRow && (gObj.getRowObjectFromUID(selectedRow.getAttribute('data-uid')) || frozenData)) {\n        selectData = frozenData ? frozenData : gObj.getRowObjectFromUID(selectedRow.getAttribute('data-uid')).data;\n      } else {\n        if (e.isAvailable && !gObj.selectionSettings.persistSelection) {\n          const prevSelectedData = this.parent.getSelectedRecords();\n\n          if (prevSelectedData.length > 0) {\n            this.clearRowSelection();\n          }\n        }\n\n        return;\n      }\n    } else {\n      selectData = this.getRowObj(index).data;\n    }\n\n    if (!this.isRowType() || !selectedRow || this.isEditing()) {\n      // if (this.isEditing()) {\n      //     gObj.selectedRowIndex = index;\n      // }\n      return;\n    }\n\n    const isRowSelected = selectedRow.hasAttribute('aria-selected');\n    this.activeTarget();\n    isToggle = !isToggle ? isToggle : !this.selectedRowIndexes.length ? false : this.selectedRowIndexes.length === 1 ? this.isKeyAction && this.parent.isCheckBoxSelection ? false : index === this.selectedRowIndexes[0] : false;\n    this.isKeyAction = false;\n    let args;\n    const can = 'cancel';\n\n    if (!isToggle) {\n      args = {\n        data: selectData,\n        rowIndex: index,\n        isCtrlPressed: this.isMultiCtrlRequest,\n        isShiftPressed: this.isMultiShiftRequest,\n        row: selectedRow,\n        previousRow: gObj.getRowByIndex(this.prevRowIndex),\n        previousRowIndex: this.prevRowIndex,\n        target: this.actualTarget,\n        cancel: false,\n        isInteracted: this.isInteracted,\n        isHeaderCheckboxClicked: this.isHeaderCheckboxClicked\n      };\n      args = this.addMovableArgs(args, selectedMovableRow, selectedFrozenRightRow);\n      this.parent.trigger(rowSelecting, this.fDataUpdate(args), this.rowSelectingCallBack(args, isToggle, index, selectData, isRemoved, isRowSelected, can));\n    } else {\n      this.rowSelectingCallBack(args, isToggle, index, selectData, isRemoved, isRowSelected, can)(args);\n    }\n  }\n\n  rowSelectingCallBack(args, isToggle, index, selectData, isRemoved, isRowSelected, can) {\n    return args => {\n      if (!isNullOrUndefined(args) && args[can] === true) {\n        this.disableInteracted();\n        return;\n      }\n\n      this.index = index;\n      this.toggle = isToggle;\n      this.data = selectData;\n      this.removed = isRemoved;\n\n      if (isRowSelected && this.selectionSettings.persistSelection && !(this.selectionSettings.checkboxMode === 'ResetOnRowClick')) {\n        this.clearSelectedRow(index);\n        this.selectRowCallBack();\n      } else if (!isRowSelected && this.selectionSettings.persistSelection && this.selectionSettings.checkboxMode !== 'ResetOnRowClick') {\n        this.selectRowCallBack();\n      }\n\n      if (this.selectionSettings.checkboxMode === 'ResetOnRowClick') {\n        this.clearSelection();\n      }\n\n      if (!this.selectionSettings.persistSelection || this.selectionSettings.checkboxMode === 'ResetOnRowClick' || !this.parent.isCheckBoxSelection && this.selectionSettings.persistSelection) {\n        this.selectRowCheck = true;\n        this.clearRow();\n      }\n    };\n  }\n\n  selectRowCallBack() {\n    const gObj = this.parent;\n    let args;\n    const index = this.index;\n    const isToggle = this.toggle;\n    const selectData = this.data;\n    const isRemoved = this.removed;\n    const selectedRow = gObj.getRowByIndex(index);\n    const selectedMovableRow = this.getSelectedMovableRow(index);\n    const selectedFrozenRightRow = this.getSelectedFrozenRightRow(index);\n\n    if (!isToggle && !isRemoved) {\n      if (this.selectedRowIndexes.indexOf(index) <= -1) {\n        this.updateRowSelection(selectedRow, index);\n        this.selectMovableRow(selectedMovableRow, selectedFrozenRightRow, index);\n      }\n\n      this.selectRowIndex(index);\n    }\n\n    if (!isToggle) {\n      args = {\n        data: selectData,\n        rowIndex: index,\n        row: selectedRow,\n        previousRow: gObj.getRowByIndex(this.prevRowIndex),\n        previousRowIndex: this.prevRowIndex,\n        target: this.actualTarget,\n        isInteracted: this.isInteracted,\n        isHeaderCheckBoxClicked: this.isHeaderCheckboxClicked\n      };\n      args = this.addMovableArgs(args, selectedMovableRow, selectedFrozenRightRow);\n      this.onActionComplete(args, rowSelected);\n    }\n\n    this.isInteracted = false;\n    this.updateRowProps(index);\n  }\n\n  selectMovableRow(selectedMovableRow, selectedFrozenRightRow, index) {\n    if (this.parent.isFrozenGrid()) {\n      this.updateRowSelection(selectedMovableRow, index);\n\n      if (this.parent.getFrozenMode() === leftRight && selectedFrozenRightRow) {\n        this.updateRowSelection(selectedFrozenRightRow, index);\n      }\n    }\n  }\n\n  addMovableArgs(targetObj, mRow, frRow) {\n    if (this.parent.isFrozenGrid()) {\n      const mObj = {\n        mRow: mRow,\n        previousMovRow: this.parent.getMovableRows()[this.prevRowIndex]\n      };\n      const frozenRightRow = 'frozenRightRow';\n      const previousFrozenRightRow = 'previousFrozenRightRow';\n\n      if (this.parent.getFrozenMode() === leftRight && frRow) {\n        mObj[frozenRightRow] = frRow;\n        mObj[previousFrozenRightRow] = this.parent.getFrozenRightDataRows()[this.prevRowIndex];\n      }\n\n      targetObj = Object.assign({}, targetObj, mObj);\n    }\n\n    return targetObj;\n  }\n  /**\n   * Selects a range of rows from start and end row indexes.\n   *\n   * @param  {number} startIndex - Specifies the start row index.\n   * @param  {number} endIndex - Specifies the end row index.\n   * @returns {void}\n   */\n\n\n  selectRowsByRange(startIndex, endIndex) {\n    this.selectRows(this.getCollectionFromIndexes(startIndex, endIndex));\n    this.selectRowIndex(endIndex);\n  }\n  /**\n   * Selects a collection of rows by index.\n   *\n   * @param  {number[]} rowIndexes - Specifies an array of row indexes.\n   * @returns {void}\n   */\n\n\n  selectRows(rowIndexes) {\n    const gObj = this.parent;\n    const rowIndex = !this.isSingleSel() ? rowIndexes[0] : rowIndexes[rowIndexes.length - 1];\n    this.isMultiSelection = true;\n    const selectedRows = [];\n    const foreignKeyData$$1 = [];\n    const selectedMovableRow = this.getSelectedMovableRow(rowIndex);\n    const selectedFrozenRightRow = this.getSelectedFrozenRightRow(rowIndex);\n    const can = 'cancel';\n    const selectedData = [];\n\n    if (!this.isRowType() || this.isEditing()) {\n      return;\n    }\n\n    for (let i = 0, len = rowIndexes.length; i < len; i++) {\n      const currentRow = this.parent.getDataRows()[rowIndexes[i]];\n      const rowObj = this.getRowObj(currentRow);\n\n      if (rowObj) {\n        selectedData.push(rowObj.data);\n        selectedRows.push(currentRow);\n        foreignKeyData$$1.push(rowObj.foreignKeyData);\n      }\n    }\n\n    this.activeTarget();\n    let args = {\n      cancel: false,\n      rowIndexes: rowIndexes,\n      row: selectedRows,\n      rowIndex: rowIndex,\n      target: this.actualTarget,\n      prevRow: gObj.getRows()[this.prevRowIndex],\n      previousRowIndex: this.prevRowIndex,\n      isInteracted: this.isInteracted,\n      isCtrlPressed: this.isMultiCtrlRequest,\n      isShiftPressed: this.isMultiShiftRequest,\n      data: selectedData,\n      isHeaderCheckboxClicked: this.isHeaderCheckboxClicked,\n      foreignKeyData: foreignKeyData$$1\n    };\n    args = this.addMovableArgs(args, selectedMovableRow, selectedFrozenRightRow);\n    this.parent.trigger(rowSelecting, this.fDataUpdate(args), args => {\n      if (!isNullOrUndefined(args) && args[can] === true) {\n        this.disableInteracted();\n        return;\n      }\n\n      this.clearRow();\n      this.selectRowIndex(rowIndexes.slice(-1)[0]);\n\n      const selectRowFn = index => {\n        this.updateRowSelection(gObj.getRowByIndex(index), index);\n\n        if (gObj.isFrozenGrid()) {\n          const rightEle = this.parent.getFrozenMode() === leftRight ? gObj.getFrozenRightRowByIndex(index) : undefined;\n          this.selectMovableRow(gObj.getMovableRowByIndex(index), rightEle, index);\n        }\n\n        this.updateRowProps(rowIndex);\n      };\n\n      if (!this.isSingleSel()) {\n        for (const rowIdx of rowIndexes) {\n          selectRowFn(rowIdx);\n        }\n      } else {\n        selectRowFn(rowIndex);\n      }\n\n      args = {\n        rowIndexes: rowIndexes,\n        row: selectedRows,\n        rowIndex: rowIndex,\n        target: this.actualTarget,\n        prevRow: gObj.getRows()[this.prevRowIndex],\n        previousRowIndex: this.prevRowIndex,\n        data: this.getSelectedRecords(),\n        isInteracted: this.isInteracted,\n        isHeaderCheckboxClicked: this.isHeaderCheckboxClicked,\n        foreignKeyData: foreignKeyData$$1\n      };\n      args = this.addMovableArgs(args, selectedMovableRow, selectedFrozenRightRow);\n\n      if (this.isRowSelected) {\n        this.onActionComplete(args, rowSelected);\n      }\n\n      this.isInteracted = false;\n    });\n  }\n  /**\n   * Select rows with existing row selection by passing row indexes.\n   *\n   * @param {number} rowIndexes - Specifies the row indexes.\n   * @returns {void}\n   * @hidden\n   */\n\n\n  addRowsToSelection(rowIndexes) {\n    const gObj = this.parent;\n    const can = 'cancel';\n    const target = this.target;\n    this.isMultiSelection = true;\n    const indexes = gObj.getSelectedRowIndexes().concat(rowIndexes);\n    const selectedRow = !this.isSingleSel() ? gObj.getRowByIndex(rowIndexes[0]) : gObj.getRowByIndex(rowIndexes[rowIndexes.length - 1]);\n    const selectedMovableRow = !this.isSingleSel() ? this.getSelectedMovableRow(rowIndexes[0]) : this.getSelectedMovableRow(rowIndexes[rowIndexes.length - 1]);\n    const selectedFrozenRightRow = !this.isSingleSel() ? this.getSelectedFrozenRightRow(rowIndexes[0]) : this.getSelectedFrozenRightRow(rowIndexes[rowIndexes.length - 1]);\n\n    if ((!this.isRowType() || this.isEditing()) && !this.selectionSettings.checkboxOnly) {\n      return;\n    }\n\n    let args;\n    const checkboxColumn = this.parent.getColumns().filter(col => col.type === 'checkbox');\n\n    for (const rowIndex of rowIndexes) {\n      const rowObj = this.getRowObj(rowIndex);\n      const isUnSelected = this.selectedRowIndexes.indexOf(rowIndex) > -1;\n      this.selectRowIndex(rowIndex);\n\n      if (isUnSelected && ((checkboxColumn.length ? true : this.selectionSettings.enableToggle) || this.isMultiCtrlRequest)) {\n        this.isAddRowsToSelection = true;\n        this.rowDeselect(rowDeselecting, [rowIndex], [rowObj.data], [selectedRow], [rowObj.foreignKeyData], target);\n\n        if (this.isCancelDeSelect) {\n          return;\n        }\n\n        this.selectedRowIndexes.splice(this.selectedRowIndexes.indexOf(rowIndex), 1);\n        this.selectedRecords.splice(this.selectedRecords.indexOf(selectedRow), 1);\n        this.selectRowIndex(this.selectedRowIndexes.length ? this.selectedRowIndexes[this.selectedRowIndexes.length - 1] : -1);\n        selectedRow.removeAttribute('aria-selected');\n        this.addRemoveClassesForRow(selectedRow, false, null, 'e-selectionbackground', 'e-active');\n\n        if (selectedMovableRow) {\n          this.selectedRecords.splice(this.selectedRecords.indexOf(selectedMovableRow), 1);\n          selectedMovableRow.removeAttribute('aria-selected');\n          this.addRemoveClassesForRow(selectedMovableRow, false, null, 'e-selectionbackground', 'e-active');\n        }\n\n        if (selectedFrozenRightRow) {\n          this.selectedRecords.splice(this.selectedRecords.indexOf(selectedFrozenRightRow), 1);\n          selectedFrozenRightRow.removeAttribute('aria-selected');\n          this.addRemoveClassesForRow(selectedFrozenRightRow, false, null, 'e-selectionbackground', 'e-active');\n        }\n\n        this.rowDeselect(rowDeselected, [rowIndex], [rowObj.data], [selectedRow], [rowObj.foreignKeyData], target, [selectedMovableRow], undefined, [selectedFrozenRightRow]);\n        this.isInteracted = false;\n        this.isMultiSelection = false;\n        this.isAddRowsToSelection = false;\n      } else {\n        this.activeTarget();\n        args = {\n          cancel: false,\n          data: rowObj.data,\n          rowIndex: rowIndex,\n          row: selectedRow,\n          target: this.actualTarget,\n          prevRow: gObj.getRows()[this.prevRowIndex],\n          previousRowIndex: this.prevRowIndex,\n          isCtrlPressed: this.isMultiCtrlRequest,\n          isShiftPressed: this.isMultiShiftRequest,\n          foreignKeyData: rowObj.foreignKeyData,\n          isInteracted: this.isInteracted,\n          isHeaderCheckboxClicked: this.isHeaderCheckboxClicked,\n          rowIndexes: indexes\n        };\n        args = this.addMovableArgs(args, selectedMovableRow, selectedFrozenRightRow);\n        this.parent.trigger(rowSelecting, this.fDataUpdate(args));\n\n        if (!isNullOrUndefined(args) && args[can] === true) {\n          this.disableInteracted();\n          return;\n        }\n\n        if (this.isSingleSel()) {\n          this.clearRow();\n        }\n\n        this.updateRowSelection(selectedRow, rowIndex);\n        this.selectMovableRow(selectedMovableRow, selectedFrozenRightRow, rowIndex);\n      }\n\n      if (!isUnSelected) {\n        args = {\n          data: rowObj.data,\n          rowIndex: rowIndex,\n          row: selectedRow,\n          target: this.actualTarget,\n          prevRow: gObj.getRows()[this.prevRowIndex],\n          previousRowIndex: this.prevRowIndex,\n          foreignKeyData: rowObj.foreignKeyData,\n          isInteracted: this.isInteracted,\n          isHeaderCheckboxClicked: this.isHeaderCheckboxClicked,\n          rowIndexes: indexes\n        };\n        args = this.addMovableArgs(args, selectedMovableRow, selectedFrozenRightRow);\n        this.onActionComplete(args, rowSelected);\n      }\n\n      this.isInteracted = false;\n      this.updateRowProps(rowIndex);\n\n      if (this.isSingleSel()) {\n        break;\n      }\n    }\n  }\n\n  getCollectionFromIndexes(startIndex, endIndex) {\n    const indexes = []; // eslint-disable-next-line prefer-const\n\n    let {\n      i,\n      max\n    } = startIndex <= endIndex ? {\n      i: startIndex,\n      max: endIndex\n    } : {\n      i: endIndex,\n      max: startIndex\n    };\n\n    for (; i <= max; i++) {\n      indexes.push(i);\n    }\n\n    if (startIndex > endIndex) {\n      indexes.reverse();\n    }\n\n    return indexes;\n  }\n\n  clearRow() {\n    this.clearRowCheck = true;\n    this.clearRowSelection();\n  }\n\n  clearRowCallBack() {\n    if (this.isCancelDeSelect && this.parent.checkAllRows !== 'Check') {\n      return;\n    }\n\n    this.selectedRowIndexes = [];\n    this.selectedRecords = [];\n    this.selectRowIndex(-1);\n\n    if (this.isSingleSel() && this.parent.isPersistSelection) {\n      this.selectedRowState = {};\n    }\n  }\n\n  clearSelectedRow(index) {\n    if (this.toggle) {\n      const selectedEle = this.parent.getRowByIndex(index);\n\n      if (!this.disableUI) {\n        selectedEle.removeAttribute('aria-selected');\n        this.addRemoveClassesForRow(selectedEle, false, true, 'e-selectionbackground', 'e-active');\n      }\n\n      this.removed = true;\n      this.updatePersistCollection(selectedEle, false);\n      this.updateCheckBoxes(selectedEle);\n      this.selectedRowIndexes.splice(this.selectedRowIndexes.indexOf(index), 1);\n      this.selectedRecords.splice(this.selectedRecords.indexOf(this.parent.getRowByIndex(index)), 1);\n    }\n  }\n\n  updateRowProps(startIndex) {\n    this.prevRowIndex = startIndex;\n    this.isRowSelected = this.selectedRowIndexes.length && true;\n  }\n\n  updatePersistCollection(selectedRow, chkState) {\n    if ((this.parent.isPersistSelection || this.parent.selectionSettings.persistSelection && this.parent.getPrimaryKeyFieldNames().length > 0) && !isNullOrUndefined(selectedRow)) {\n      if (!this.parent.isPersistSelection) {\n        this.ensureCheckboxFieldSelection();\n      }\n\n      const rowObj = this.getRowObj(selectedRow);\n      const pKey = rowObj.data ? rowObj.data[this.primaryKey] : null;\n\n      if (pKey === null) {\n        return;\n      }\n\n      rowObj.isSelected = chkState;\n\n      if (chkState) {\n        this.selectedRowState[pKey] = chkState;\n\n        if (!this.persistSelectedData.some(data => data[this.primaryKey] === pKey)) {\n          this.persistSelectedData.push(rowObj.data);\n        }\n      } else {\n        this.updatePersistDelete(pKey);\n      }\n    }\n  }\n\n  updatePersistDelete(pKey) {\n    delete this.selectedRowState[pKey];\n    let index;\n    const isPresent = this.persistSelectedData.some((data, i) => {\n      index = i;\n      return data[this.primaryKey] === pKey;\n    });\n\n    if (isPresent) {\n      this.persistSelectedData.splice(index, 1);\n    }\n  }\n\n  updateCheckBoxes(row$$1, chkState, rowIndex) {\n    if (!isNullOrUndefined(row$$1)) {\n      const chkBox = row$$1.querySelector('.e-checkselect');\n\n      if (!isNullOrUndefined(chkBox)) {\n        removeAddCboxClasses(chkBox.nextElementSibling, chkState);\n        setChecked(chkBox, chkState);\n\n        if (isNullOrUndefined(this.checkedTarget) || !isNullOrUndefined(this.checkedTarget) && !this.checkedTarget.classList.contains('e-checkselectall')) {\n          this.setCheckAllState(rowIndex);\n        }\n      }\n    }\n  }\n\n  updateRowSelection(selectedRow, startIndex) {\n    if (!selectedRow) {\n      return;\n    }\n\n    this.selectedRowIndexes.push(startIndex);\n    const len = this.selectedRowIndexes.length;\n\n    if (this.parent.isFrozenGrid() && len > 1) {\n      if (this.selectedRowIndexes[len - 2] === this.selectedRowIndexes[len - 1]) {\n        this.selectedRowIndexes.pop();\n      }\n    }\n\n    this.selectedRecords.push(selectedRow);\n    selectedRow.setAttribute('aria-selected', 'true');\n    this.updatePersistCollection(selectedRow, true);\n    this.updateCheckBoxes(selectedRow, true);\n    this.addRemoveClassesForRow(selectedRow, true, null, 'e-selectionbackground', 'e-active');\n\n    if (!this.preventFocus) {\n      let target = this.focus.getPrevIndexes().cellIndex ? selectedRow.cells[this.focus.getPrevIndexes().cellIndex] : selectedRow.querySelector('.e-selectionbackground:not(.e-hide):not(.e-detailrowcollapse):not(.e-detailrowexpand)');\n\n      if (this.parent.contextMenuModule && this.mouseButton === 2) {\n        target = this.parent.contextMenuModule.cell;\n      }\n\n      if (!target) {\n        return;\n      }\n\n      this.focus.onClick({\n        target\n      }, true);\n    }\n  }\n  /**\n   * Deselects the currently selected rows and cells.\n   *\n   * @returns {void}\n   */\n\n\n  clearSelection() {\n    this.checkSelectAllClicked = true;\n\n    if (this.selectionSettings.persistSelection && this.persistSelectedData.length) {\n      this.deSelectedData = iterateExtend(this.persistSelectedData);\n    }\n\n    if (!this.parent.isPersistSelection || this.parent.isPersistSelection && !this.parent.isEdit || !isNullOrUndefined(this.checkedTarget) && this.checkedTarget.classList.contains('e-checkselectall')) {\n      const span = this.parent.element.querySelector('.e-gridpopup').querySelector('span');\n\n      if (span.classList.contains('e-rowselect')) {\n        span.classList.remove('e-spanclicked');\n      }\n\n      if (this.parent.isPersistSelection) {\n        this.persistSelectedData = [];\n        this.selectedRowState = {};\n      }\n\n      this.clearRowSelection();\n      this.clearCellSelection();\n      this.clearColumnSelection();\n      this.prevRowIndex = undefined;\n      this.prevCIdxs = undefined;\n      this.prevECIdxs = undefined;\n      this.enableSelectMultiTouch = false;\n      this.isInteracted = false;\n      this.checkSelectAllClicked = false;\n    }\n  }\n  /**\n   * Deselects the currently selected rows.\n   *\n   * @returns {void}\n   */\n\n\n  clearRowSelection() {\n    if (this.isRowSelected) {\n      const gObj = this.parent;\n      const rows = this.parent.getDataRows();\n      const data = [];\n      const row$$1 = [];\n      const mRow = [];\n      const fRightRow = [];\n      const rowIndex = [];\n      const foreignKeyData$$1 = [];\n      const target = this.target;\n\n      for (let i = 0, len = this.selectedRowIndexes.length; i < len; i++) {\n        const currentRow = this.parent.editSettings.mode === 'Batch' ? this.parent.getRows()[this.selectedRowIndexes[i]] : this.parent.getDataRows()[this.selectedRowIndexes[i]];\n        const rowObj = this.getRowObj(currentRow);\n\n        if (rowObj) {\n          data.push(rowObj.data);\n          row$$1.push(currentRow);\n          rowIndex.push(this.selectedRowIndexes[i]);\n          foreignKeyData$$1.push(rowObj.foreignKeyData);\n        }\n\n        if (gObj.isFrozenGrid()) {\n          const mRows = gObj.getMovableRows();\n\n          if (mRows && mRows.length) {\n            mRow.push(mRows[this.selectedRowIndexes[i]]);\n          }\n\n          if (gObj.getFrozenMode() === leftRight) {\n            const frRows = gObj.getFrozenRightRows();\n\n            if (frRows && frRows.length) {\n              fRightRow.push(frRows[this.selectedRowIndexes[i]]);\n            }\n          }\n        }\n      }\n\n      if (this.selectionSettings.persistSelection && this.selectionSettings.checkboxMode !== 'ResetOnRowClick') {\n        this.isRowClicked = this.checkSelectAllClicked ? true : false;\n      }\n\n      this.rowDeselect(rowDeselecting, rowIndex, data, row$$1, foreignKeyData$$1, target, mRow, () => {\n        if (this.isCancelDeSelect && (this.isRowClicked || this.checkSelectAllClicked || this.isInteracted && !this.parent.isPersistSelection)) {\n          if (this.parent.isPersistSelection) {\n            if (this.getCheckAllStatus(this.parent.element.querySelector('.e-checkselectall')) === 'Intermediate') {\n              for (let i = 0; i < this.selectedRecords.length; i++) {\n                this.updatePersistCollection(this.selectedRecords[i], true);\n              }\n            } else {\n              this.parent.checkAllRows = 'Check';\n              this.updatePersistSelectedData(true);\n            }\n          }\n\n          if (this.clearRowCheck) {\n            this.clearRowCallBack();\n            this.clearRowCheck = false;\n\n            if (this.selectRowCheck) {\n              this.selectRowCallBack();\n              this.selectRowCheck = false;\n            }\n          }\n\n          return;\n        }\n\n        const element = [].slice.call(rows.filter(record => record.hasAttribute('aria-selected')));\n\n        for (let j = 0; j < element.length; j++) {\n          if (!this.disableUI) {\n            element[j].removeAttribute('aria-selected');\n            this.addRemoveClassesForRow(element[j], false, true, 'e-selectionbackground', 'e-active');\n          } // tslint:disable-next-line:align\n\n\n          if (!this.isPrevRowSelection) {\n            this.updatePersistCollection(element[j], false);\n          }\n\n          this.updateCheckBoxes(element[j]);\n        }\n\n        for (let i = 0, len = this.selectedRowIndexes.length; i < len; i++) {\n          const movableRow = this.getSelectedMovableRow(this.selectedRowIndexes[i]);\n\n          if (movableRow) {\n            if (!this.disableUI) {\n              movableRow.removeAttribute('aria-selected');\n              this.addRemoveClassesForRow(movableRow, false, true, 'e-selectionbackground', 'e-active');\n            }\n\n            this.updateCheckBoxes(movableRow);\n\n            if (!this.isPrevRowSelection) {\n              this.updatePersistCollection(movableRow, false);\n            }\n          }\n\n          const frRow = this.getSelectedFrozenRightRow(this.selectedRowIndexes[i]);\n\n          if (frRow) {\n            if (!this.disableUI) {\n              frRow.removeAttribute('aria-selected');\n              this.addRemoveClassesForRow(frRow, false, true, 'e-selectionbackground', 'e-active');\n            }\n\n            this.updateCheckBoxes(frRow);\n\n            if (!this.isPrevRowSelection) {\n              this.updatePersistCollection(frRow, false);\n            }\n          }\n        }\n\n        this.selectedRowIndexes = [];\n        this.selectedRecords = [];\n        this.isRowSelected = false;\n        this.selectRowIndex(-1);\n        this.isPrevRowSelection = false;\n        this.rowDeselect(rowDeselected, rowIndex, data, row$$1, foreignKeyData$$1, target, mRow, undefined, fRightRow);\n\n        if (this.clearRowCheck) {\n          this.clearRowCallBack();\n          this.clearRowCheck = false;\n\n          if (this.selectRowCheck) {\n            this.selectRowCallBack();\n            this.selectRowCheck = false;\n          }\n        }\n      }, fRightRow);\n    } else {\n      if (this.clearRowCheck) {\n        this.clearRowCallBack();\n        this.clearRowCheck = false;\n\n        if (this.selectRowCheck) {\n          this.selectRowCallBack();\n          this.selectRowCheck = false;\n        }\n      }\n    }\n  }\n\n  rowDeselect(type, rowIndex, data, row$$1, foreignKeyData$$1, target, mRow, rowDeselectCallBack, frozenRightRow) {\n    if (this.selectionSettings.persistSelection && (this.isRowClicked || this.checkSelectAllClicked) || !this.selectionSettings.persistSelection) {\n      const cancl = 'cancel';\n      const isSingleDeSel = rowIndex.length === 1 && this.deSelectedData.length === 1;\n      const rowDeselectObj = {\n        rowIndex: rowIndex[0],\n        data: this.selectionSettings.persistSelection && this.parent.checkAllRows === 'Uncheck' && !isSingleDeSel && this.selectionSettings.checkboxMode !== 'ResetOnRowClick' ? this.deSelectedData : data,\n        foreignKeyData: foreignKeyData$$1,\n        cancel: false,\n        isInteracted: this.isInteracted,\n        isHeaderCheckboxClicked: this.isHeaderCheckboxClicked\n      };\n\n      if (type === 'rowDeselected') {\n        delete rowDeselectObj.cancel;\n      }\n\n      const rowInString = 'row';\n      const target = 'target';\n      const rowidx = 'rowIndex';\n      const rowidxex = 'rowIndexes';\n      const dataTxt = 'data';\n      const foreignKey = 'foreignKeyData';\n      rowDeselectObj[rowInString] = row$$1;\n      rowDeselectObj[target] = this.actualTarget;\n      const isHeaderCheckBxClick = this.actualTarget && !isNullOrUndefined(closest(this.actualTarget, 'thead'));\n\n      if (isHeaderCheckBxClick || rowIndex.length > 1) {\n        rowDeselectObj[rowidx] = rowIndex[0];\n        rowDeselectObj[rowidxex] = rowIndex;\n      } else if (rowIndex.length === 1) {\n        rowDeselectObj[dataTxt] = rowDeselectObj[dataTxt][0];\n        rowDeselectObj[rowInString] = rowDeselectObj[rowInString][0];\n        rowDeselectObj[foreignKey] = rowDeselectObj[foreignKey][0];\n\n        if (this.isAddRowsToSelection) {\n          rowDeselectObj[rowidxex] = rowIndex;\n        }\n      }\n\n      this.parent.trigger(type, this.parent.isFrozenGrid() ? Object.assign({}, rowDeselectObj, {\n        mRow: mRow,\n        frozenRightRow: frozenRightRow\n      }) : rowDeselectObj, args => {\n        this.isCancelDeSelect = args[cancl];\n\n        if (!this.isCancelDeSelect || !this.isRowClicked && !this.isInteracted && !this.checkSelectAllClicked) {\n          this.updatePersistCollection(row$$1[0], false);\n          this.updateCheckBoxes(row$$1[0], undefined, rowIndex[0]);\n\n          if (mRow) {\n            this.updateCheckBoxes(mRow[0], undefined, rowIndex[0]);\n          }\n\n          if (frozenRightRow) {\n            this.updateCheckBoxes(frozenRightRow[0], undefined, rowIndex[0]);\n          }\n        }\n\n        if (rowDeselectCallBack !== undefined) {\n          rowDeselectCallBack();\n        }\n      });\n    } else if (this.selectionSettings.persistSelection && !this.isInteracted) {\n      if (rowDeselectCallBack !== undefined) {\n        rowDeselectCallBack();\n      }\n    }\n  }\n\n  getRowObj(row$$1 = this.currentIndex) {\n    if (isNullOrUndefined(row$$1)) {\n      return {};\n    }\n\n    if (typeof row$$1 === 'number') {\n      row$$1 = this.parent.getRowByIndex(row$$1);\n    }\n\n    if (row$$1) {\n      return this.parent.getRowObjectFromUID(row$$1.getAttribute('data-uid')) || {};\n    }\n\n    return {};\n  }\n\n  getSelectedMovableCell(cellIndex) {\n    const gObj = this.parent;\n    const col = gObj.getColumnByIndex(cellIndex.cellIndex);\n    const frzCols = gObj.isFrozenGrid();\n\n    if (frzCols) {\n      if (col.getFreezeTableName() === 'movable') {\n        return gObj.getMovableCellFromIndex(cellIndex.rowIndex, this.getColIndex(cellIndex.rowIndex, cellIndex.cellIndex));\n      }\n\n      return null;\n    }\n\n    return null;\n  }\n  /**\n   * Selects a cell by the given index.\n   *\n   * @param  {IIndex} cellIndex - Defines the row and column indexes.\n   * @param  {boolean} isToggle - If set to true, then it toggles the selection.\n   * @returns {void}\n   */\n\n\n  selectCell(cellIndex, isToggle) {\n    if (!this.isCellType()) {\n      return;\n    }\n\n    const gObj = this.parent;\n    let selectedCell = this.getSelectedMovableCell(cellIndex);\n    let args;\n\n    if (!selectedCell) {\n      selectedCell = gObj.getCellFromIndex(cellIndex.rowIndex, this.getColIndex(cellIndex.rowIndex, cellIndex.cellIndex));\n    }\n\n    this.currentIndex = cellIndex.rowIndex;\n    const selectedData = this.getCurrentBatchRecordChanges()[this.currentIndex];\n\n    if (!this.isCellType() || !selectedCell || this.isEditing()) {\n      return;\n    }\n\n    const isCellSelected = selectedCell.classList.contains('e-cellselectionbackground');\n    isToggle = !isToggle ? isToggle : !isUndefined(this.prevCIdxs) && cellIndex.rowIndex === this.prevCIdxs.rowIndex && cellIndex.cellIndex === this.prevCIdxs.cellIndex && isCellSelected;\n\n    if (!isToggle) {\n      args = {\n        data: selectedData,\n        cellIndex: cellIndex,\n        isCtrlPressed: this.isMultiCtrlRequest,\n        isShiftPressed: this.isMultiShiftRequest,\n        previousRowCell: this.prevECIdxs ? this.getCellIndex(this.prevECIdxs.rowIndex, this.prevECIdxs.cellIndex) : undefined,\n        cancel: false\n      };\n      const currentCell = 'currentCell';\n      args[currentCell] = selectedCell;\n      const previousRowCellIndex = 'previousRowCellIndex';\n      args[previousRowCellIndex] = this.prevECIdxs;\n      this.parent.trigger(cellSelecting, this.fDataUpdate(args), this.successCallBack(args, isToggle, cellIndex, selectedCell, selectedData));\n      this.cellselected = true;\n    } else {\n      this.successCallBack(args, isToggle, cellIndex, selectedCell, selectedData)(args);\n    }\n  }\n\n  successCallBack(cellSelectingArgs, isToggle, cellIndex, selectedCell, selectedData) {\n    return cellSelectingArgs => {\n      const cncl = 'cancel';\n      const currentCell = 'currentCell';\n\n      if (!isNullOrUndefined(cellSelectingArgs) && cellSelectingArgs[cncl] === true) {\n        return;\n      }\n\n      if (!isToggle) {\n        cellSelectingArgs[currentCell] = cellSelectingArgs[currentCell] ? cellSelectingArgs[currentCell] : selectedCell;\n      }\n\n      this.clearCell();\n\n      if (!isToggle) {\n        this.updateCellSelection(selectedCell, cellIndex.rowIndex, cellIndex.cellIndex);\n      }\n\n      if (!isToggle) {\n        const args = {\n          data: selectedData,\n          cellIndex: cellIndex,\n          currentCell: selectedCell,\n          selectedRowCellIndex: this.selectedRowCellIndexes,\n          previousRowCell: this.prevECIdxs ? this.getCellIndex(this.prevECIdxs.rowIndex, this.prevECIdxs.cellIndex) : undefined\n        };\n        const previousRowCellIndex = 'previousRowCellIndex';\n        args[previousRowCellIndex] = this.prevECIdxs;\n        this.updateCellProps(cellIndex, cellIndex);\n        this.onActionComplete(args, cellSelected);\n      }\n    };\n  }\n\n  getCellIndex(rIdx, cIdx) {\n    return this.parent.getFrozenColumns() ? cIdx >= this.parent.getFrozenColumns() ? this.parent.getMovableCellFromIndex(rIdx, cIdx) : this.parent.getCellFromIndex(rIdx, cIdx) : this.parent.getCellFromIndex(rIdx, cIdx);\n  }\n  /**\n   * Selects a range of cells from start and end indexes.\n   *\n   * @param  {IIndex} startIndex - Specifies the row and column's start index.\n   * @param  {IIndex} endIndex - Specifies the row and column's end index.\n   * @returns {void}\n   */\n\n\n  selectCellsByRange(startIndex, endIndex) {\n    if (!this.isCellType()) {\n      return;\n    }\n\n    const gObj = this.parent;\n    let selectedCell = this.getSelectedMovableCell(startIndex);\n    const frzCols = gObj.getFrozenColumns();\n\n    if (!selectedCell) {\n      selectedCell = gObj.getCellFromIndex(startIndex.rowIndex, startIndex.cellIndex);\n    }\n\n    let min;\n    let max;\n    const stIndex = startIndex;\n    const edIndex = endIndex = endIndex ? endIndex : startIndex;\n    let cellIndexes;\n    this.currentIndex = startIndex.rowIndex;\n    const cncl = 'cancel';\n    const selectedData = this.getCurrentBatchRecordChanges()[this.currentIndex];\n\n    if (this.isSingleSel() || !this.isCellType() || this.isEditing()) {\n      return;\n    }\n\n    const args = {\n      data: selectedData,\n      cellIndex: startIndex,\n      currentCell: selectedCell,\n      isCtrlPressed: this.isMultiCtrlRequest,\n      isShiftPressed: this.isMultiShiftRequest,\n      previousRowCell: this.prevECIdxs ? this.getCellIndex(this.prevECIdxs.rowIndex, this.prevECIdxs.cellIndex) : undefined\n    };\n    const previousRowCellIndex = 'previousRowCellIndex';\n    args[previousRowCellIndex] = this.prevECIdxs;\n    this.parent.trigger(cellSelecting, this.fDataUpdate(args), cellSelectingArgs => {\n      if (!isNullOrUndefined(cellSelectingArgs) && cellSelectingArgs[cncl] === true) {\n        return;\n      }\n\n      this.clearCell();\n\n      if (startIndex.rowIndex > endIndex.rowIndex) {\n        const temp = startIndex;\n        startIndex = endIndex;\n        endIndex = temp;\n      }\n\n      for (let i = startIndex.rowIndex; i <= endIndex.rowIndex; i++) {\n        if (this.selectionSettings.cellSelectionMode.indexOf('Box') < 0) {\n          min = i === startIndex.rowIndex ? startIndex.cellIndex : 0;\n          max = i === endIndex.rowIndex ? endIndex.cellIndex : this.getLastColIndex(i);\n        } else {\n          min = startIndex.cellIndex;\n          max = endIndex.cellIndex;\n        }\n\n        cellIndexes = [];\n\n        for (let j = min < max ? min : max, len = min > max ? min : max; j <= len; j++) {\n          if (frzCols) {\n            if (j < frzCols) {\n              selectedCell = gObj.getCellFromIndex(i, j);\n            } else {\n              selectedCell = gObj.getMovableCellFromIndex(i, j);\n            }\n          } else {\n            selectedCell = gObj.getCellFromIndex(i, j);\n          }\n\n          if (!selectedCell) {\n            continue;\n          }\n\n          cellIndexes.push(j);\n          this.updateCellSelection(selectedCell);\n          this.addAttribute(selectedCell);\n        }\n\n        this.selectedRowCellIndexes.push({\n          rowIndex: i,\n          cellIndexes: cellIndexes\n        });\n      }\n\n      const cellSelectedArgs = {\n        data: selectedData,\n        cellIndex: edIndex,\n        currentCell: gObj.getCellFromIndex(edIndex.rowIndex, edIndex.cellIndex),\n        selectedRowCellIndex: this.selectedRowCellIndexes,\n        previousRowCell: this.prevECIdxs ? this.getCellIndex(this.prevECIdxs.rowIndex, this.prevECIdxs.cellIndex) : undefined\n      };\n      const previousRowCellIndex = 'previousRowCellIndex';\n      cellSelectedArgs[previousRowCellIndex] = this.prevECIdxs;\n\n      if (!this.isDragged) {\n        this.onActionComplete(cellSelectedArgs, cellSelected);\n        this.cellselected = true;\n      }\n\n      this.updateCellProps(stIndex, edIndex);\n    });\n  }\n  /**\n   * Selects a collection of cells by row and column indexes.\n   *\n   * @param  {ISelectedCell[]} rowCellIndexes - Specifies the row and column indexes.\n   * @returns {void}\n   */\n\n\n  selectCells(rowCellIndexes) {\n    if (!this.isCellType()) {\n      return;\n    }\n\n    const gObj = this.parent;\n    let selectedCell = this.getSelectedMovableCell(rowCellIndexes[0]);\n    const frzCols = gObj.getFrozenColumns();\n\n    if (!selectedCell) {\n      selectedCell = gObj.getCellFromIndex(rowCellIndexes[0].rowIndex, rowCellIndexes[0].cellIndexes[0]);\n    }\n\n    this.currentIndex = rowCellIndexes[0].rowIndex;\n    const selectedData = this.getCurrentBatchRecordChanges()[this.currentIndex];\n\n    if (this.isSingleSel() || !this.isCellType() || this.isEditing()) {\n      return;\n    }\n\n    const cellSelectArgs = {\n      data: selectedData,\n      cellIndex: rowCellIndexes[0].cellIndexes[0],\n      currentCell: selectedCell,\n      isCtrlPressed: this.isMultiCtrlRequest,\n      isShiftPressed: this.isMultiShiftRequest,\n      previousRowCell: this.prevECIdxs ? this.getCellIndex(this.prevECIdxs.rowIndex, this.prevECIdxs.cellIndex) : undefined\n    };\n    const previousRowCellIndex = 'previousRowCellIndex';\n    cellSelectArgs[previousRowCellIndex] = this.prevECIdxs;\n    this.onActionBegin(cellSelectArgs, cellSelecting);\n\n    for (let i = 0, len = rowCellIndexes.length; i < len; i++) {\n      for (let j = 0, cellLen = rowCellIndexes[i].cellIndexes.length; j < cellLen; j++) {\n        if (frzCols) {\n          if (rowCellIndexes[i].cellIndexes[j] < frzCols) {\n            selectedCell = gObj.getCellFromIndex(rowCellIndexes[i].rowIndex, rowCellIndexes[i].cellIndexes[j]);\n          } else {\n            selectedCell = gObj.getMovableCellFromIndex(rowCellIndexes[i].rowIndex, rowCellIndexes[i].cellIndexes[j]);\n          }\n        } else {\n          selectedCell = gObj.getCellFromIndex(rowCellIndexes[i].rowIndex, rowCellIndexes[i].cellIndexes[j]);\n        }\n\n        if (!selectedCell) {\n          continue;\n        }\n\n        this.updateCellSelection(selectedCell);\n        this.addAttribute(selectedCell);\n        this.addRowCellIndex({\n          rowIndex: rowCellIndexes[i].rowIndex,\n          cellIndex: rowCellIndexes[i].cellIndexes[j]\n        });\n      }\n    }\n\n    this.updateCellProps({\n      rowIndex: rowCellIndexes[0].rowIndex,\n      cellIndex: rowCellIndexes[0].cellIndexes[0]\n    }, {\n      rowIndex: rowCellIndexes[0].rowIndex,\n      cellIndex: rowCellIndexes[0].cellIndexes[0]\n    });\n    const cellSelectedArgs = {\n      data: selectedData,\n      cellIndex: rowCellIndexes[0].cellIndexes[0],\n      currentCell: selectedCell,\n      selectedRowCellIndex: this.selectedRowCellIndexes,\n      previousRowCell: this.prevECIdxs ? this.getCellIndex(this.prevECIdxs.rowIndex, this.prevECIdxs.cellIndex) : undefined\n    };\n    const prvRowCellIndex = 'previousRowCellIndex';\n    cellSelectedArgs[prvRowCellIndex] = this.prevECIdxs;\n    this.onActionComplete(cellSelectedArgs, cellSelected);\n  }\n  /**\n   * Select cells with existing cell selection by passing row and column index.\n   *\n   * @param {IIndex} cellIndexes - Defines the collection of row and column index.\n   * @returns {void}\n   * @hidden\n   */\n\n\n  addCellsToSelection(cellIndexes) {\n    if (!this.isCellType()) {\n      return;\n    }\n\n    const gObj = this.parent;\n    let selectedCell;\n    let index;\n    this.currentIndex = cellIndexes[0].rowIndex;\n    const cncl = 'cancel';\n    const selectedData = this.getCurrentBatchRecordChanges()[this.currentIndex];\n    const left = gObj.getFrozenLeftCount();\n    const movable = gObj.getMovableColumnsCount();\n\n    if (this.isSingleSel() || !this.isCellType() || this.isEditing()) {\n      return;\n    }\n\n    this.hideAutoFill();\n    const col = gObj.getColumnByIndex(cellIndexes[0].cellIndex);\n    let rowObj;\n    gridActionHandler(this.parent, (tableName, rows) => {\n      rowObj = rows[cellIndexes[0].rowIndex];\n    }, [!col.getFreezeTableName() || col.getFreezeTableName() === frozenLeft ? gObj.getRowsObject() : [], col.getFreezeTableName() === 'movable' ? gObj.getMovableRowsObject() : [], col.getFreezeTableName() === frozenRight ? gObj.getFrozenRightRowsObject() : []]);\n    const foreignKeyData$$1 = [];\n\n    for (const cellIndex of cellIndexes) {\n      for (let i = 0, len = this.selectedRowCellIndexes.length; i < len; i++) {\n        if (this.selectedRowCellIndexes[i].rowIndex === cellIndex.rowIndex) {\n          index = i;\n          break;\n        }\n      }\n\n      selectedCell = this.getSelectedMovableCell(cellIndex);\n\n      if (!selectedCell) {\n        selectedCell = gObj.getCellFromIndex(cellIndex.rowIndex, this.getColIndex(cellIndex.rowIndex, cellIndex.cellIndex));\n      }\n\n      const idx = col.getFreezeTableName() === 'movable' ? cellIndex.cellIndex - left : col.getFreezeTableName() === frozenRight ? cellIndex.cellIndex - (left + movable) : cellIndex.cellIndex;\n      foreignKeyData$$1.push(rowObj.cells[idx].foreignKeyData);\n      const args = {\n        cancel: false,\n        data: selectedData,\n        cellIndex: cellIndexes[0],\n        isShiftPressed: this.isMultiShiftRequest,\n        currentCell: selectedCell,\n        isCtrlPressed: this.isMultiCtrlRequest,\n        previousRowCell: this.prevECIdxs ? gObj.getCellFromIndex(this.prevECIdxs.rowIndex, this.prevECIdxs.cellIndex) : undefined\n      };\n      const prvRowCellIndex = 'previousRowCellIndex';\n      args[prvRowCellIndex] = this.prevECIdxs;\n      let isUnSelected = index > -1;\n\n      if (isUnSelected) {\n        const selectedCellIdx = this.selectedRowCellIndexes[index].cellIndexes;\n\n        if (selectedCellIdx.indexOf(cellIndex.cellIndex) > -1) {\n          this.cellDeselect(cellDeselecting, [{\n            rowIndex: cellIndex.rowIndex,\n            cellIndexes: [cellIndex.cellIndex]\n          }], selectedData, [selectedCell], foreignKeyData$$1);\n          selectedCellIdx.splice(selectedCellIdx.indexOf(cellIndex.cellIndex), 1);\n\n          if (selectedCellIdx.length === 0) {\n            this.selectedRowCellIndexes.splice(index, 1);\n          }\n\n          selectedCell.classList.remove('e-cellselectionbackground');\n          selectedCell.removeAttribute('aria-selected');\n          this.cellDeselect(cellDeselected, [{\n            rowIndex: cellIndex.rowIndex,\n            cellIndexes: [cellIndex.cellIndex]\n          }], selectedData, [selectedCell], foreignKeyData$$1);\n        } else {\n          isUnSelected = false;\n          this.onActionBegin(args, cellSelecting);\n          this.addRowCellIndex({\n            rowIndex: cellIndex.rowIndex,\n            cellIndex: cellIndex.cellIndex\n          });\n          this.updateCellSelection(selectedCell);\n          this.addAttribute(selectedCell);\n        }\n      } else {\n        this.onActionBegin(args, cellSelecting);\n\n        if (!isNullOrUndefined(args) && args[cncl] === true) {\n          return;\n        }\n\n        this.updateCellSelection(selectedCell, cellIndex.rowIndex, cellIndex.cellIndex);\n      }\n\n      if (!isUnSelected) {\n        const cellSelectedArgs = {\n          data: selectedData,\n          cellIndex: cellIndexes[0],\n          currentCell: selectedCell,\n          previousRowCell: this.prevECIdxs ? this.getCellIndex(this.prevECIdxs.rowIndex, this.prevECIdxs.cellIndex) : undefined,\n          selectedRowCellIndex: this.selectedRowCellIndexes\n        };\n        cellSelectedArgs[prvRowCellIndex] = this.prevECIdxs;\n        this.onActionComplete(cellSelectedArgs, cellSelected);\n        this.cellselected = true;\n      }\n\n      this.updateCellProps(cellIndex, cellIndex);\n    }\n  }\n\n  getColIndex(rowIndex, index) {\n    const frzCols = this.parent.isFrozenGrid();\n    const col = this.parent.getColumnByIndex(index);\n    const cells = getCellsByTableName(this.parent, col, rowIndex);\n\n    if (cells) {\n      for (let m = 0; m < cells.length; m++) {\n        const colIndex = parseInt(cells[m].getAttribute(ariaColIndex), 10);\n\n        if (colIndex === index) {\n          if (frzCols) {\n            if (col.getFreezeTableName() === 'movable') {\n              m += this.parent.getFrozenLeftCount();\n            } else if (col.getFreezeTableName() === frozenRight) {\n              m += this.parent.getFrozenLeftColumnsCount() + this.parent.getMovableColumnsCount();\n            }\n          }\n\n          return m;\n        }\n      }\n    }\n\n    return -1;\n  }\n\n  getLastColIndex(rowIndex) {\n    const cells = this.parent.getFrozenColumns() ? this.parent.getMovableDataRows()[rowIndex].querySelectorAll('td.e-rowcell') : this.parent.getDataRows()[rowIndex].querySelectorAll('td.e-rowcell');\n    return parseInt(cells[cells.length - 1].getAttribute(ariaColIndex), 10);\n  }\n\n  clearCell() {\n    this.clearCellSelection();\n  }\n\n  cellDeselect(type, cellIndexes, data, cells, foreignKeyData$$1) {\n    const cancl = 'cancel';\n\n    if (cells[0] && cells[0].classList.contains(gridChkBox)) {\n      this.updateCheckBoxes(closest(cells[0], 'tr'));\n    }\n\n    const args = {\n      cells: cells,\n      data: data,\n      cellIndexes: cellIndexes,\n      foreignKeyData: foreignKeyData$$1,\n      cancel: false\n    };\n    this.parent.trigger(type, args);\n    this.isPreventCellSelect = args[cancl];\n  }\n\n  updateCellSelection(selectedCell, rowIndex, cellIndex) {\n    if (!isNullOrUndefined(rowIndex)) {\n      this.addRowCellIndex({\n        rowIndex: rowIndex,\n        cellIndex: cellIndex\n      });\n    }\n\n    selectedCell.classList.add('e-cellselectionbackground');\n\n    if (selectedCell.classList.contains(gridChkBox)) {\n      this.updateCheckBoxes(closest(selectedCell, 'tr'), true);\n    }\n\n    this.addAttribute(selectedCell);\n  }\n\n  addAttribute(cell) {\n    this.target = cell;\n\n    if (!isNullOrUndefined(cell)) {\n      cell.setAttribute('aria-selected', 'true');\n\n      if (!this.preventFocus) {\n        this.focus.onClick({\n          target: cell\n        }, true);\n      }\n    }\n  }\n\n  updateCellProps(startIndex, endIndex) {\n    this.prevCIdxs = startIndex;\n    this.prevECIdxs = endIndex;\n    this.isCellSelected = this.selectedRowCellIndexes.length && true;\n  }\n\n  addRowCellIndex(rowCellIndex) {\n    let isRowAvail;\n    let index;\n\n    for (let i = 0, len = this.selectedRowCellIndexes.length; i < len; i++) {\n      if (this.selectedRowCellIndexes[i].rowIndex === rowCellIndex.rowIndex) {\n        isRowAvail = true;\n        index = i;\n        break;\n      }\n    }\n\n    if (isRowAvail) {\n      if (this.selectedRowCellIndexes[index].cellIndexes.indexOf(rowCellIndex.cellIndex) < 0) {\n        this.selectedRowCellIndexes[index].cellIndexes.push(rowCellIndex.cellIndex);\n      }\n    } else {\n      this.selectedRowCellIndexes.push({\n        rowIndex: rowCellIndex.rowIndex,\n        cellIndexes: [rowCellIndex.cellIndex]\n      });\n    }\n  }\n  /**\n   * Deselects the currently selected cells.\n   *\n   * @returns {void}\n   */\n\n\n  clearCellSelection() {\n    if (this.isCellSelected) {\n      const gObj = this.parent;\n      const selectedCells = this.getSelectedCellsElement();\n      const rowCell$$1 = this.selectedRowCellIndexes;\n      const data = [];\n      const cells = [];\n      const foreignKeyData$$1 = [];\n      const currentViewData = this.getCurrentBatchRecordChanges();\n      const frzCols = gObj.isFrozenGrid();\n      this.hideAutoFill();\n\n      for (let i = 0, len = rowCell$$1.length; i < len; i++) {\n        data.push(currentViewData[rowCell$$1[i].rowIndex]);\n        const rowObj = this.getRowObj(rowCell$$1[i].rowIndex);\n\n        for (let j = 0, cLen = rowCell$$1[i].cellIndexes.length; j < cLen; j++) {\n          if (frzCols) {\n            const col = gObj.getColumnByIndex(rowCell$$1[i].cellIndexes[j]);\n            cells.push(getCellByColAndRowIndex(this.parent, col, rowCell$$1[i].rowIndex, rowCell$$1[i].cellIndexes[j]));\n          } else {\n            if (rowObj.cells) {\n              foreignKeyData$$1.push(rowObj.cells[rowCell$$1[i].cellIndexes[j]].foreignKeyData);\n            }\n\n            cells.push(gObj.getCellFromIndex(rowCell$$1[i].rowIndex, rowCell$$1[i].cellIndexes[j]));\n          }\n        }\n      }\n\n      this.cellDeselect(cellDeselecting, rowCell$$1, data, cells, foreignKeyData$$1);\n\n      if (this.isPreventCellSelect === true) {\n        return;\n      }\n\n      for (let i = 0, len = selectedCells.length; i < len; i++) {\n        selectedCells[i].classList.remove('e-cellselectionbackground');\n        selectedCells[i].removeAttribute('aria-selected');\n      }\n\n      if (this.bdrElement) {\n        this.showHideBorders('none');\n      }\n\n      this.selectedRowCellIndexes = [];\n      this.isCellSelected = false;\n\n      if (!this.isDragged && this.cellselected) {\n        this.cellDeselect(cellDeselected, rowCell$$1, data, cells, foreignKeyData$$1);\n      }\n    }\n  }\n\n  getSelectedCellsElement() {\n    const gObj = this.parent;\n    let rows = gObj.getDataRows();\n    let mRows;\n\n    if (gObj.isFrozenGrid()) {\n      mRows = gObj.getMovableDataRows();\n      rows = gObj.addMovableRows(rows, mRows);\n\n      if (gObj.getFrozenMode() === leftRight) {\n        rows = gObj.addMovableRows(rows, gObj.getFrozenRightDataRows());\n      }\n    }\n\n    let cells = [];\n\n    for (let i = 0, len = rows.length; i < len; i++) {\n      cells = cells.concat([].slice.call(rows[i].getElementsByClassName('e-cellselectionbackground')));\n    }\n\n    return cells;\n  }\n\n  mouseMoveHandler(e) {\n    e.preventDefault();\n    const gBRect = this.parent.element.getBoundingClientRect();\n    let x1 = this.x;\n    let y1 = this.y;\n    const position = getPosition(e);\n    let x2 = position.x - gBRect.left;\n    let y2 = position.y - gBRect.top;\n    let tmp;\n    let target = closest(e.target, 'tr');\n    this.isDragged = true;\n\n    if (!this.isCellDrag) {\n      if (!target) {\n        target = closest(document.elementFromPoint(this.parent.element.offsetLeft + 2, e.clientY), 'tr');\n      }\n\n      if (x1 > x2) {\n        tmp = x2;\n        x2 = x1;\n        x1 = tmp;\n      }\n\n      if (y1 > y2) {\n        tmp = y2;\n        y2 = y1;\n        y1 = tmp;\n      }\n\n      this.element.style.left = x1 + 'px';\n      this.element.style.top = y1 + 'px';\n      this.element.style.width = x2 - x1 + 'px';\n      this.element.style.height = y2 - y1 + 'px';\n    }\n\n    if (target && !e.ctrlKey && !e.shiftKey) {\n      const rowIndex = parseInt(target.getAttribute(ariaRowIndex), 10);\n\n      if (!this.isCellDrag) {\n        this.hideAutoFill();\n        this.selectRowsByRange(this.startDIndex, rowIndex);\n        this.isRowDragSelected = true;\n      } else {\n        const td = parentsUntil(e.target, rowCell);\n\n        if (td) {\n          this.startAFCell = this.startCell;\n          this.endAFCell = parentsUntil(e.target, rowCell);\n          this.selectLikeExcel(e, rowIndex, parseInt(td.getAttribute(ariaColIndex), 10));\n        }\n      }\n    }\n  }\n\n  selectLikeExcel(e, rowIndex, cellIndex) {\n    if (!this.isAutoFillSel) {\n      this.clearCellSelection();\n      this.selectCellsByRange({\n        rowIndex: this.startDIndex,\n        cellIndex: this.startDCellIndex\n      }, {\n        rowIndex: rowIndex,\n        cellIndex: cellIndex\n      });\n      this.drawBorders();\n    } else {\n      //Autofill\n      this.showAFBorders();\n      this.selectLikeAutoFill(e);\n    }\n  }\n\n  drawBorders() {\n    if (this.selectionSettings.cellSelectionMode === 'BoxWithBorder' && this.selectedRowCellIndexes.length && !this.parent.isEdit) {\n      this.parent.element.classList.add('e-enabledboxbdr');\n\n      if (!this.bdrElement) {\n        this.createBorders();\n      }\n\n      this.positionBorders();\n    } else {\n      this.showHideBorders('none');\n    }\n  }\n\n  isLastCell(cell) {\n    const cells = [].slice.call(cell.parentElement.querySelectorAll('.e-rowcell:not(.e-hide)'));\n    return cells[cells.length - 1] === cell;\n  }\n\n  isLastRow(cell) {\n    const rows = [].slice.call(closest(cell, tbody).querySelectorAll('.e-row:not(.e-hiddenrow)'));\n    return cell.parentElement === rows[rows.length - 1];\n  }\n\n  isFirstRow(cell) {\n    const rows = [].slice.call(closest(cell, tbody).querySelectorAll('.e-row:not(.e-hiddenrow)'));\n    return cell.parentElement === rows[0];\n  }\n\n  isFirstCell(cell) {\n    const cells = [].slice.call(cell.parentElement.querySelectorAll('.e-rowcell:not(.e-hide)'));\n    return cells[0] === cell;\n  }\n\n  setBorders(parentEle, border, bdrStr) {\n    const cells = [].slice.call(parentEle.getElementsByClassName('e-cellselectionbackground')).filter(ele => ele.style.display === '');\n\n    if (cells.length) {\n      const isFrozen = this.parent.isFrozenGrid();\n      const start = cells[0];\n      const end = cells[cells.length - 1];\n      const stOff = start.getBoundingClientRect();\n      const endOff = end.getBoundingClientRect();\n      const parentOff = start.offsetParent.getBoundingClientRect();\n      const rowHeight = this.isLastRow(end) && (bdrStr === '1' || bdrStr === '2' || bdrStr === '5') ? 2 : 0;\n      const topOffSet = this.parent.frozenRows && (bdrStr === '1' || bdrStr === '2') && this.isFirstRow(start) ? 1.5 : 0;\n      const leftOffset = isFrozen && (bdrStr === '2' || bdrStr === '4') && this.isFirstCell(start) ? 1 : 0;\n      const rightOffset = (this.parent.getFrozenMode() === 'Right' && (bdrStr === '1' || bdrStr === '3') || this.parent.getFrozenMode() === leftRight && (bdrStr === '5' || bdrStr === '6')) && this.isFirstCell(start) ? 1 : 0;\n\n      if (this.parent.enableRtl) {\n        border.style.right = parentOff.right - stOff.right - leftOffset + 'px';\n        border.style.width = stOff.right - endOff.left + leftOffset + 1 + 'px';\n      } else {\n        border.style.left = stOff.left - parentOff.left - leftOffset - rightOffset + 'px';\n        border.style.width = endOff.right - stOff.left + leftOffset - rightOffset + 1 + 'px';\n      }\n\n      border.style.top = stOff.top - parentOff.top - topOffSet + 'px';\n      border.style.height = endOff.top - stOff.top > 0 ? endOff.top - parentOff.top + endOff.height + 1 - (stOff.top - parentOff.top) - rowHeight + topOffSet + 'px' : endOff.height + topOffSet - rowHeight + 1 + 'px';\n      this.selectDirection += bdrStr;\n    } else {\n      border.style.display = 'none';\n    }\n  }\n\n  positionBorders() {\n    this.updateStartEndCells();\n\n    if (!this.startCell || !this.bdrElement || !this.selectedRowCellIndexes.length) {\n      return;\n    }\n\n    this.selectDirection = '';\n    this.showHideBorders('');\n    this.setBorders(this.parent.getContentTable(), this.bdrElement, '1');\n\n    if (this.parent.isFrozenGrid()) {\n      this.setBorders(this.parent.contentModule.getMovableContent(), this.mcBdrElement, '2');\n\n      if (this.parent.getFrozenMode() === leftRight) {\n        this.setBorders(this.parent.contentModule.getFrozenRightContent(), this.frcBdrElement, '5');\n      }\n    }\n\n    if (this.parent.frozenRows) {\n      this.setBorders(this.parent.getHeaderTable(), this.fhBdrElement, '3');\n\n      if (this.parent.isFrozenGrid()) {\n        this.setBorders(this.parent.headerModule.getMovableHeader(), this.mhBdrElement, '4');\n\n        if (this.parent.getFrozenMode() === leftRight) {\n          this.setBorders(this.parent.headerModule.getFrozenRightHeader(), this.frhBdrElement, '6');\n        }\n      }\n    }\n\n    this.applyBorders(this.selectDirection);\n  }\n  /* eslint-enable */\n\n\n  applyBothFrozenBorders(str) {\n    const rtl = this.parent.enableRtl;\n\n    switch (str.length) {\n      case 6:\n        {\n          this.bdrElement.style.borderWidth = rtl ? this.right_bottom : this.bottom_left;\n          this.mcBdrElement.style.borderWidth = this.bottom;\n          this.fhBdrElement.style.borderWidth = rtl ? this.top_right : this.top_left;\n          this.mhBdrElement.style.borderWidth = this.top;\n          this.frcBdrElement.style.borderWidth = rtl ? this.bottom_left : this.right_bottom;\n          this.frhBdrElement.style.borderWidth = rtl ? this.top_left : this.top_right;\n        }\n        break;\n\n      case 4:\n        {\n          if (str.includes('1') && str.includes('2') && str.includes('3') && str.includes('4')) {\n            this.fhBdrElement.style.borderWidth = rtl ? this.top_right : this.top_left;\n            this.mhBdrElement.style.borderWidth = rtl ? this.top_left : this.top_right;\n            this.bdrElement.style.borderWidth = rtl ? this.right_bottom : this.bottom_left;\n            this.mcBdrElement.style.borderWidth = rtl ? this.bottom_left : this.right_bottom;\n          }\n\n          if (str.includes('2') && str.includes('4') && str.includes('5') && str.includes('6')) {\n            this.mcBdrElement.style.borderWidth = rtl ? this.right_bottom : this.bottom_left;\n            this.mhBdrElement.style.borderWidth = rtl ? this.top_right : this.top_left;\n            this.frcBdrElement.style.borderWidth = rtl ? this.bottom_left : this.right_bottom;\n            this.frhBdrElement.style.borderWidth = rtl ? this.top_left : this.top_right;\n          }\n        }\n        break;\n\n      case 3:\n        {\n          this.bdrElement.style.borderWidth = rtl ? this.top_right_bottom : this.top_bottom_left;\n          this.mcBdrElement.style.borderWidth = this.top_bottom;\n          this.frcBdrElement.style.borderWidth = rtl ? this.top_bottom_left : this.top_right_bottom;\n\n          if (this.parent.frozenRows) {\n            this.fhBdrElement.style.borderWidth = rtl ? this.top_right_bottom : this.top_bottom_left;\n            this.mhBdrElement.style.borderWidth = this.top_bottom;\n            this.frcBdrElement.style.borderWidth = rtl ? this.top_bottom_left : this.top_right_bottom;\n          }\n        }\n        break;\n\n      case 2:\n        {\n          if (str.includes('1')) {\n            this.mcBdrElement.style.borderWidth = rtl ? this.top_bottom_left : this.top_right_bottom;\n\n            if (this.parent.frozenRows) {\n              this.fhBdrElement.style.borderWidth = this.top_right_left;\n            }\n          }\n\n          if (str.includes('2')) {\n            this.bdrElement.style.borderWidth = rtl ? this.top_right_bottom : this.top_bottom_left;\n            this.frcBdrElement.style.borderWidth = rtl ? this.top_bottom_left : this.top_right_bottom;\n\n            if (this.parent.frozenRows) {\n              this.mhBdrElement.style.borderWidth = this.top_right_left;\n            }\n          }\n\n          if (str.includes('3')) {\n            this.mhBdrElement.style.borderWidth = rtl ? this.top_bottom_left : this.top_right_bottom;\n            this.bdrElement.style.borderWidth = this.right_bottom_left;\n          }\n\n          if (str.includes('4')) {\n            this.fhBdrElement.style.borderWidth = rtl ? this.top_right_bottom : this.top_bottom_left;\n            this.frhBdrElement.style.borderWidth = rtl ? this.top_bottom_left : this.top_right_bottom;\n            this.mcBdrElement.style.borderWidth = this.right_bottom_left;\n          }\n\n          if (str.includes('5')) {\n            this.mcBdrElement.style.borderWidth = rtl ? this.top_right_bottom : this.top_bottom_left;\n\n            if (this.parent.frozenRows) {\n              this.frhBdrElement.style.borderWidth = this.top_right_left;\n            }\n          }\n\n          if (str.includes('6')) {\n            this.mhBdrElement.style.borderWidth = rtl ? this.top_right_bottom : this.top_bottom_left;\n            this.frcBdrElement.style.borderWidth = this.right_bottom_left;\n          }\n        }\n        break;\n\n      default:\n        this.bdrElement.style.borderWidth = this.all_border;\n        this.mcBdrElement.style.borderWidth = this.all_border;\n        this.frcBdrElement.style.borderWidth = this.all_border;\n\n        if (this.parent.frozenRows) {\n          this.fhBdrElement.style.borderWidth = this.all_border;\n          this.mhBdrElement.style.borderWidth = this.all_border;\n          this.frhBdrElement.style.borderWidth = this.all_border;\n        }\n\n        break;\n    }\n  }\n\n  applyBorders(str) {\n    const rtl = this.parent.enableRtl;\n\n    if (this.parent.getFrozenMode() === leftRight) {\n      this.applyBothFrozenBorders(str);\n    } else {\n      switch (str.length) {\n        case 4:\n          {\n            if (this.parent.getFrozenMode() === 'Right') {\n              this.bdrElement.style.borderWidth = rtl ? this.bottom_left : this.right_bottom;\n              this.mcBdrElement.style.borderWidth = rtl ? this.right_bottom : this.bottom_left;\n              this.fhBdrElement.style.borderWidth = rtl ? this.top_left : this.top_right;\n              this.mhBdrElement.style.borderWidth = rtl ? this.top_right : this.top_left;\n            } else {\n              this.bdrElement.style.borderWidth = rtl ? this.right_bottom : this.bottom_left;\n              this.mcBdrElement.style.borderWidth = rtl ? this.bottom_left : this.right_bottom;\n              this.fhBdrElement.style.borderWidth = rtl ? this.top_right : this.top_left;\n              this.mhBdrElement.style.borderWidth = rtl ? this.top_left : this.top_right;\n            }\n          }\n          break;\n\n        case 2:\n          {\n            if (this.parent.getFrozenMode() === 'Right') {\n              this.bdrElement.style.borderWidth = str.includes('2') ? rtl ? this.top_bottom_left : this.top_right_bottom : this.right_bottom_left;\n              this.mcBdrElement.style.borderWidth = str.includes('1') ? rtl ? this.top_right_bottom : this.top_bottom_left : this.right_bottom_left;\n\n              if (this.parent.frozenRows) {\n                this.fhBdrElement.style.borderWidth = str.includes('1') ? this.top_right_left : rtl ? this.top_bottom_left : this.top_right_bottom;\n                this.mhBdrElement.style.borderWidth = str.includes('2') ? this.top_right_left : rtl ? this.top_right_bottom : this.top_bottom_left;\n              }\n            } else {\n              this.bdrElement.style.borderWidth = str.includes('2') ? rtl ? this.top_right_bottom : this.top_bottom_left : this.right_bottom_left;\n\n              if (this.parent.isFrozenGrid()) {\n                this.mcBdrElement.style.borderWidth = str.includes('1') ? rtl ? this.top_bottom_left : this.top_right_bottom : this.right_bottom_left;\n              }\n\n              if (this.parent.frozenRows) {\n                this.fhBdrElement.style.borderWidth = str.includes('1') ? this.top_right_left : rtl ? this.top_right_bottom : this.top_bottom_left;\n\n                if (this.parent.isFrozenGrid()) {\n                  this.mhBdrElement.style.borderWidth = str.includes('2') ? this.top_right_left : rtl ? this.top_bottom_left : this.top_right_bottom;\n                }\n              }\n            }\n          }\n          break;\n\n        default:\n          this.bdrElement.style.borderWidth = this.all_border;\n\n          if (this.parent.isFrozenGrid()) {\n            this.mcBdrElement.style.borderWidth = this.all_border;\n          }\n\n          if (this.parent.frozenRows) {\n            this.fhBdrElement.style.borderWidth = this.all_border;\n\n            if (this.parent.isFrozenGrid()) {\n              this.mhBdrElement.style.borderWidth = this.all_border;\n            }\n          }\n\n          break;\n      }\n    }\n  }\n\n  createBorders() {\n    if (!this.bdrElement) {\n      this.bdrElement = this.parent.getContentTable().parentElement.appendChild(createElement('div', {\n        className: 'e-xlsel',\n        id: this.parent.element.id + '_bdr',\n        styles: 'width: 2px; border-width: 0;'\n      }));\n\n      if (this.parent.isFrozenGrid()) {\n        this.mcBdrElement = this.parent.contentModule.getMovableContent().appendChild(createElement('div', {\n          className: 'e-xlsel',\n          id: this.parent.element.id + '_mcbdr',\n          styles: 'height: 2px; border-width: 0;'\n        }));\n\n        if (this.parent.getFrozenMode() === leftRight) {\n          this.frcBdrElement = this.parent.contentModule.getFrozenRightContent().appendChild(createElement('div', {\n            className: 'e-xlsel',\n            id: this.parent.element.id + '_frcbdr',\n            styles: 'height: 2px; border-width: 0;'\n          }));\n        }\n      }\n\n      if (this.parent.frozenRows) {\n        this.fhBdrElement = this.parent.getHeaderTable().parentElement.appendChild(createElement('div', {\n          className: 'e-xlsel',\n          id: this.parent.element.id + '_fhbdr',\n          styles: 'height: 2px;'\n        }));\n      }\n\n      if (this.parent.frozenRows && this.parent.isFrozenGrid()) {\n        this.mhBdrElement = this.parent.headerModule.getMovableHeader().appendChild(createElement('div', {\n          className: 'e-xlsel',\n          id: this.parent.element.id + '_mhbdr',\n          styles: 'height: 2px;'\n        }));\n\n        if (this.parent.getFrozenMode() === leftRight) {\n          this.frhBdrElement = this.parent.headerModule.getFrozenRightHeader().appendChild(createElement('div', {\n            className: 'e-xlsel',\n            id: this.parent.element.id + '_frhbdr',\n            styles: 'height: 2px;'\n          }));\n        }\n      }\n    }\n  }\n\n  showHideBorders(display) {\n    if (this.bdrElement) {\n      this.bdrElement.style.display = display;\n\n      if (this.parent.isFrozenGrid()) {\n        this.mcBdrElement.style.display = display;\n\n        if (this.parent.getFrozenMode() === leftRight) {\n          this.frcBdrElement.style.display = display;\n        }\n      }\n\n      if (this.parent.frozenRows) {\n        this.fhBdrElement.style.display = display;\n      }\n\n      if (this.parent.frozenRows && this.parent.isFrozenGrid()) {\n        this.mhBdrElement.style.display = display;\n\n        if (this.parent.getFrozenMode() === leftRight) {\n          this.frhBdrElement.style.display = display;\n        }\n      }\n    }\n  }\n\n  drawAFBorders() {\n    if (!this.bdrAFBottom) {\n      this.createAFBorders();\n    }\n\n    this.positionAFBorders();\n  }\n\n  positionAFBorders() {\n    if (!this.startCell || !this.bdrAFLeft) {\n      return;\n    }\n\n    const stOff = this.startAFCell.getBoundingClientRect();\n    const endOff = this.endAFCell.getBoundingClientRect();\n    const top = endOff.top - stOff.top > 0 ? 1 : 0;\n    const firstCellTop = endOff.top - stOff.top >= 0 && (parentsUntil(this.startAFCell, movableContent) || parentsUntil(this.startAFCell, 'e-frozencontent')) && this.isFirstRow(this.startAFCell) ? 1.5 : 0;\n    const firstCellLeft = (parentsUntil(this.startAFCell, movableContent) || parentsUntil(this.startAFCell, movableHeader)) && this.isFirstCell(this.startAFCell) ? 1 : 0;\n    const rowHeight = this.isLastRow(this.endAFCell) && (parentsUntil(this.endAFCell, movableContent) || parentsUntil(this.endAFCell, 'e-frozencontent')) ? 2 : 0;\n    const parentOff = this.startAFCell.offsetParent.getBoundingClientRect();\n    const parentRect = this.parent.element.getBoundingClientRect();\n    const sTop = this.startAFCell.offsetParent.parentElement.scrollTop;\n    const sLeft = this.startAFCell.offsetParent.parentElement.scrollLeft;\n    let scrollTop = sTop - this.startAFCell.offsetTop;\n    let scrollLeft = sLeft - this.startAFCell.offsetLeft;\n    const totalHeight = this.parent.element.clientHeight;\n    const totalWidth = this.parent.element.clientWidth;\n    scrollTop = scrollTop > 0 ? Math.floor(scrollTop) - 1 : 0;\n    scrollLeft = scrollLeft > 0 ? scrollLeft : 0;\n    const left = stOff.left - parentRect.left;\n\n    if (!this.parent.enableRtl) {\n      this.bdrAFLeft.style.left = left - firstCellLeft + scrollLeft - 1 + 'px';\n      this.bdrAFRight.style.left = endOff.left - parentRect.left - 2 + endOff.width + 'px';\n      this.bdrAFRight.style.width = totalWidth <= parseInt(this.bdrAFRight.style.left, 10) ? '0px' : '2px';\n      this.bdrAFTop.style.left = left + scrollLeft - 0.5 + 'px';\n      this.bdrAFTop.style.width = parseInt(this.bdrAFRight.style.left, 10) - parseInt(this.bdrAFLeft.style.left, 10) - firstCellLeft + 1 + 'px';\n\n      if (totalWidth <= parseInt(this.bdrAFTop.style.width, 10) + parseInt(this.bdrAFTop.style.left, 10)) {\n        const leftRemove = parseInt(this.bdrAFTop.style.width, 10) + parseInt(this.bdrAFTop.style.left, 10) - totalWidth;\n        this.bdrAFTop.style.width = parseInt(this.bdrAFTop.style.width, 10) - leftRemove + 'px';\n      }\n    } else {\n      const scrolloffSet = parentsUntil(this.startAFCell, movableContent) || parentsUntil(this.startAFCell, movableHeader) ? stOff.right - this.startAFCell.offsetParent.parentElement.getBoundingClientRect().width - parentRect.left : 0;\n      this.bdrAFLeft.style.right = parentRect.right - endOff.right - 2 + endOff.width + 'px';\n      this.bdrAFLeft.style.width = totalWidth <= parseInt(this.bdrAFLeft.style.right, 10) ? '0px' : '2px';\n      this.bdrAFRight.style.right = parentRect.right - stOff.right - firstCellLeft + scrolloffSet - 1 + 'px';\n      this.bdrAFTop.style.left = endOff.left - parentRect.left - 0.5 + 'px';\n      this.bdrAFTop.style.width = parseInt(this.bdrAFLeft.style.right, 10) - parseInt(this.bdrAFRight.style.right, 10) - firstCellLeft + 1 + 'px';\n\n      if (parseInt(this.bdrAFTop.style.left, 10) < 0) {\n        this.bdrAFTop.style.width = parseInt(this.bdrAFTop.style.width, 10) + parseInt(this.bdrAFTop.style.left, 10) + 'px';\n        this.bdrAFTop.style.left = '0px';\n      }\n    }\n\n    this.bdrAFLeft.style.top = stOff.top - parentRect.top - firstCellTop + scrollTop + 'px';\n    this.bdrAFLeft.style.height = endOff.top - stOff.top > 0 ? endOff.top - parentOff.top + endOff.height + 1 - (stOff.top - parentOff.top) + firstCellTop - rowHeight - scrollTop + 'px' : endOff.height + firstCellTop - rowHeight - scrollTop + 'px';\n    this.bdrAFRight.style.top = this.bdrAFLeft.style.top;\n    this.bdrAFRight.style.height = parseInt(this.bdrAFLeft.style.height, 10) + 'px';\n    this.bdrAFTop.style.top = this.bdrAFRight.style.top;\n    this.bdrAFBottom.style.left = this.bdrAFTop.style.left;\n    this.bdrAFBottom.style.top = parseFloat(this.bdrAFLeft.style.top) + parseFloat(this.bdrAFLeft.style.height) - top - 1 + 'px';\n    this.bdrAFBottom.style.width = totalHeight <= parseFloat(this.bdrAFBottom.style.top) ? '0px' : this.bdrAFTop.style.width;\n\n    if (totalHeight <= parseInt(this.bdrAFLeft.style.height, 10) + parseInt(this.bdrAFLeft.style.top, 10)) {\n      const topRemove = parseInt(this.bdrAFLeft.style.height, 10) + parseInt(this.bdrAFLeft.style.top, 10) - totalHeight;\n      this.bdrAFLeft.style.height = parseInt(this.bdrAFLeft.style.height, 10) - topRemove + 'px';\n      this.bdrAFRight.style.height = parseInt(this.bdrAFLeft.style.height, 10) + 'px';\n    }\n  }\n\n  createAFBorders() {\n    if (!this.bdrAFLeft) {\n      this.bdrAFLeft = this.parent.element.appendChild(createElement('div', {\n        className: 'e-xlselaf',\n        id: this.parent.element.id + '_bdrafleft',\n        styles: 'width: 2px;'\n      }));\n      this.bdrAFRight = this.parent.element.appendChild(createElement('div', {\n        className: 'e-xlselaf',\n        id: this.parent.element.id + '_bdrafright',\n        styles: 'width: 2px;'\n      }));\n      this.bdrAFBottom = this.parent.element.appendChild(createElement('div', {\n        className: 'e-xlselaf',\n        id: this.parent.element.id + '_bdrafbottom',\n        styles: 'height: 2px;'\n      }));\n      this.bdrAFTop = this.parent.element.appendChild(createElement('div', {\n        className: 'e-xlselaf',\n        id: this.parent.element.id + '_bdraftop',\n        styles: 'height: 2px;'\n      }));\n    }\n  }\n\n  showAFBorders() {\n    if (this.bdrAFLeft) {\n      this.bdrAFLeft.style.display = '';\n      this.bdrAFRight.style.display = '';\n      this.bdrAFBottom.style.display = '';\n      this.bdrAFTop.style.display = '';\n    }\n  }\n\n  hideAFBorders() {\n    if (this.bdrAFLeft) {\n      this.bdrAFLeft.style.display = 'none';\n      this.bdrAFRight.style.display = 'none';\n      this.bdrAFBottom.style.display = 'none';\n      this.bdrAFTop.style.display = 'none';\n    }\n  }\n\n  updateValue(rIdx, cIdx, cell) {\n    const args = this.createBeforeAutoFill(rIdx, cIdx, cell);\n\n    if (!args.cancel) {\n      const col = this.parent.getColumnByIndex(cIdx);\n\n      if (this.parent.editModule && cell) {\n        if (col.type === 'number') {\n          this.parent.editModule.updateCell(rIdx, col.field, parseInt(args.value, 10));\n        } else {\n          this.parent.editModule.updateCell(rIdx, col.field, args.value);\n        }\n      }\n    }\n  }\n\n  createBeforeAutoFill(rowIndex, colIndex, cell) {\n    const col = this.parent.getColumnByIndex(colIndex);\n    const args = {\n      column: col,\n      value: cell.innerText\n    };\n    this.parent.trigger(beforeAutoFill, args);\n    return args;\n  } // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  getAutoFillCells(rowIndex, startCellIdx) {\n    const cls = '.e-cellselectionbackground';\n    let cells = [].slice.call(this.parent.getDataRows()[rowIndex].querySelectorAll(cls));\n\n    if (this.parent.isFrozenGrid()) {\n      cells = cells.concat([].slice.call(this.parent.getMovableDataRows()[rowIndex].querySelectorAll(cls)));\n\n      if (this.parent.getFrozenMode() === leftRight) {\n        cells = cells.concat([].slice.call(this.parent.getFrozenRightDataRows()[rowIndex].querySelectorAll(cls)));\n      }\n    }\n\n    return cells;\n  }\n\n  selectLikeAutoFill(e, isApply) {\n    const startrowIdx = parseInt(parentsUntil(this.startAFCell, row).getAttribute(ariaRowIndex), 10);\n    const startCellIdx = parseInt(this.startAFCell.getAttribute(ariaColIndex), 10);\n    let endrowIdx = parseInt(parentsUntil(this.endAFCell, row).getAttribute(ariaRowIndex), 10);\n    let endCellIdx = parseInt(this.endAFCell.getAttribute(ariaColIndex), 10);\n    const rowLen = this.selectedRowCellIndexes.length - 1;\n    const colLen = this.selectedRowCellIndexes[0].cellIndexes.length - 1;\n\n    switch (true) {\n      //direction\n      case !isApply && this.endAFCell.classList.contains('e-cellselectionbackground') && !!parentsUntil(e.target, rowCell):\n        this.startAFCell = this.parent.getCellFromIndex(startrowIdx, startCellIdx);\n        this.endAFCell = this.parent.getCellFromIndex(startrowIdx + rowLen, startCellIdx + colLen);\n        this.drawAFBorders();\n        break;\n\n      case this.autoFillRLselection && startCellIdx + colLen < endCellIdx && //right\n      endCellIdx - startCellIdx - colLen + 1 > endrowIdx - startrowIdx - rowLen // right bottom\n      && endCellIdx - startCellIdx - colLen + 1 > startrowIdx - endrowIdx:\n        //right top\n        this.endAFCell = this.parent.getCellFromIndex(startrowIdx + rowLen, endCellIdx);\n        endrowIdx = parseInt(parentsUntil(this.endAFCell, row).getAttribute(ariaRowIndex), 10);\n        endCellIdx = parseInt(this.endAFCell.getAttribute(ariaColIndex), 10);\n\n        if (!isApply) {\n          this.drawAFBorders();\n        } else {\n          const cellIdx = parseInt(this.endCell.getAttribute(ariaColIndex), 10);\n\n          for (let i = startrowIdx; i <= endrowIdx; i++) {\n            const cells = this.getAutoFillCells(i, startCellIdx);\n            let c = 0;\n\n            for (let j = cellIdx + 1; j <= endCellIdx; j++) {\n              if (c > colLen) {\n                c = 0;\n              }\n\n              this.updateValue(i, j, cells[c]);\n              c++;\n            }\n          }\n\n          this.selectCellsByRange({\n            rowIndex: startrowIdx,\n            cellIndex: this.startCellIndex\n          }, {\n            rowIndex: endrowIdx,\n            cellIndex: endCellIdx\n          });\n        }\n\n        break;\n\n      case this.autoFillRLselection && startCellIdx > endCellIdx && // left\n      startCellIdx - endCellIdx + 1 > endrowIdx - startrowIdx - rowLen && //left top\n      startCellIdx - endCellIdx + 1 > startrowIdx - endrowIdx:\n        // left bottom\n        this.startAFCell = this.parent.getCellFromIndex(startrowIdx, endCellIdx);\n        this.endAFCell = this.endCell;\n\n        if (!isApply) {\n          this.drawAFBorders();\n        } else {\n          for (let i = startrowIdx; i <= startrowIdx + rowLen; i++) {\n            const cells = this.getAutoFillCells(i, startCellIdx);\n            cells.reverse();\n            let c = 0;\n\n            for (let j = this.startCellIndex - 1; j >= endCellIdx; j--) {\n              if (c > colLen) {\n                c = 0;\n              }\n\n              this.updateValue(i, j, cells[c]);\n              c++;\n            }\n          }\n\n          this.selectCellsByRange({\n            rowIndex: startrowIdx,\n            cellIndex: endCellIdx\n          }, {\n            rowIndex: startrowIdx + rowLen,\n            cellIndex: this.startCellIndex + colLen\n          });\n        }\n\n        break;\n\n      case startrowIdx > endrowIdx:\n        //up\n        this.startAFCell = this.parent.getCellFromIndex(endrowIdx, startCellIdx);\n        this.endAFCell = this.endCell;\n\n        if (!isApply) {\n          this.drawAFBorders();\n        } else {\n          const trIdx = parseInt(this.endCell.parentElement.getAttribute(ariaRowIndex), 10);\n          let r = trIdx;\n\n          for (let i = startrowIdx - 1; i >= endrowIdx; i--) {\n            if (r === this.startIndex - 1) {\n              r = trIdx;\n            }\n\n            const cells = this.getAutoFillCells(r, startCellIdx);\n            let c = 0;\n            r--;\n\n            for (let j = this.startCellIndex; j <= this.startCellIndex + colLen; j++) {\n              this.updateValue(i, j, cells[c]);\n              c++;\n            }\n          }\n\n          this.selectCellsByRange({\n            rowIndex: endrowIdx,\n            cellIndex: startCellIdx + colLen\n          }, {\n            rowIndex: startrowIdx + rowLen,\n            cellIndex: startCellIdx\n          });\n        }\n\n        break;\n\n      default:\n        //down\n        this.endAFCell = this.parent.getCellFromIndex(endrowIdx, startCellIdx + colLen);\n\n        if (!isApply) {\n          this.drawAFBorders();\n        } else {\n          const trIdx = parseInt(this.endCell.parentElement.getAttribute(ariaRowIndex), 10);\n          let r = this.startIndex;\n\n          for (let i = trIdx + 1; i <= endrowIdx; i++) {\n            if (r === trIdx + 1) {\n              r = this.startIndex;\n            }\n\n            const cells = this.getAutoFillCells(r, startCellIdx);\n            r++;\n            let c = 0;\n\n            for (let m = this.startCellIndex; m <= this.startCellIndex + colLen; m++) {\n              this.updateValue(i, m, cells[c]);\n              c++;\n            }\n          }\n\n          this.selectCellsByRange({\n            rowIndex: trIdx - rowLen,\n            cellIndex: startCellIdx\n          }, {\n            rowIndex: endrowIdx,\n            cellIndex: startCellIdx + colLen\n          });\n        }\n\n        break;\n    }\n  }\n\n  mouseUpHandler(e) {\n    document.body.classList.remove('e-disableuserselect');\n\n    if (this.element) {\n      remove(this.element);\n    }\n\n    if (this.isDragged && this.selectedRowCellIndexes.length === 1 && this.selectedRowCellIndexes[0].cellIndexes.length === 1) {\n      this.mUPTarget = parentsUntil(e.target, rowCell);\n    } else {\n      this.mUPTarget = null;\n    }\n\n    if (this.isDragged && !this.isAutoFillSel && this.selectionSettings.mode === 'Cell' && e.target.classList.contains(rowCell)) {\n      const target = e.target;\n      const rowIndex = parseInt(target.parentElement.getAttribute(ariaRowIndex), 10);\n      const cellIndex = parseInt(target.getAttribute(ariaColIndex), 10);\n      this.isDragged = false;\n      this.clearCellSelection();\n      this.selectCellsByRange({\n        rowIndex: this.startDIndex,\n        cellIndex: this.startDCellIndex\n      }, {\n        rowIndex: rowIndex,\n        cellIndex: cellIndex\n      });\n    }\n\n    this.isDragged = false;\n    this.updateAutoFillPosition();\n\n    if (this.isAutoFillSel) {\n      const lastCell = parentsUntil(e.target, rowCell);\n      this.endAFCell = lastCell ? lastCell : this.endCell === this.endAFCell ? this.startAFCell : this.endAFCell;\n      this.startAFCell = this.startCell;\n      this.updateStartCellsIndex();\n      this.selectLikeAutoFill(e, true);\n      this.updateAutoFillPosition();\n      this.hideAFBorders();\n      this.positionBorders();\n      this.isAutoFillSel = false;\n    }\n\n    EventHandler.remove(this.parent.getContent(), 'mousemove', this.mouseMoveHandler);\n\n    if (this.parent.frozenRows) {\n      EventHandler.remove(this.parent.getHeaderContent(), 'mousemove', this.mouseMoveHandler);\n    }\n\n    EventHandler.remove(document, 'mouseup', this.mouseUpHandler);\n  }\n\n  hideAutoFill() {\n    if (this.autofill) {\n      this.autofill.style.display = 'none';\n    }\n  }\n  /**\n   * @returns {void}\n   * @hidden\n   */\n\n\n  updateAutoFillPosition() {\n    if (this.parent.enableAutoFill && !this.parent.isEdit && this.selectionSettings.cellSelectionMode.indexOf('Box') > -1 && !this.isRowType() && !this.isSingleSel() && this.selectedRowCellIndexes.length) {\n      const index = parseInt(this.target.getAttribute(ariaColIndex), 10);\n      const rindex = parseInt(this.target.getAttribute('index'), 10);\n      const rowIndex = this.selectedRowCellIndexes[this.selectedRowCellIndexes.length - 1].rowIndex;\n      const cells = this.getAutoFillCells(rowIndex, index).filter(ele => ele.style.display === '');\n      const col = this.parent.getColumnByIndex(index);\n      const isFrozenCol = col.getFreezeTableName() === 'movable';\n      const isFrozenRow = rindex < this.parent.frozenRows;\n      const isFrozenRight = this.parent.getFrozenMode() === leftRight && col.getFreezeTableName() === frozenRight;\n\n      if (!select('#' + this.parent.element.id + '_autofill', parentsUntil(this.target, table))) {\n        if (select('#' + this.parent.element.id + '_autofill', this.parent.element)) {\n          select('#' + this.parent.element.id + '_autofill', this.parent.element).remove();\n        }\n\n        this.autofill = createElement('div', {\n          className: 'e-autofill',\n          id: this.parent.element.id + '_autofill'\n        });\n        this.autofill.style.display = 'none';\n\n        if (!isFrozenRow) {\n          if (!isFrozenCol) {\n            this.parent.getContentTable().parentElement.appendChild(this.autofill);\n          } else {\n            this.parent.contentModule.getMovableContent().appendChild(this.autofill);\n          }\n        } else {\n          if (!isFrozenCol) {\n            this.parent.getHeaderTable().parentElement.appendChild(this.autofill);\n          } else {\n            this.parent.headerModule.getMovableHeader().appendChild(this.autofill);\n          }\n        }\n\n        if (isFrozenRight) {\n          if (isFrozenRow) {\n            this.parent.getFrozenRightHeader().appendChild(this.autofill);\n          } else {\n            this.parent.getFrozenRightContent().appendChild(this.autofill);\n          }\n        }\n      }\n\n      const cell = cells[cells.length - 1];\n\n      if (cell && cell.offsetParent) {\n        const clientRect = cell.getBoundingClientRect();\n        const parentOff = cell.offsetParent.getBoundingClientRect();\n        const colWidth = this.isLastCell(cell) ? 4 : 0;\n        const rowHeight = this.isLastRow(cell) ? 3 : 0;\n\n        if (!this.parent.enableRtl) {\n          this.autofill.style.left = clientRect.left - parentOff.left + clientRect.width - 4 - colWidth + 'px';\n        } else {\n          this.autofill.style.right = parentOff.right - clientRect.right + clientRect.width - 4 - colWidth + 'px';\n        }\n\n        this.autofill.style.top = clientRect.top - parentOff.top + clientRect.height - 5 - rowHeight + 'px';\n      }\n\n      this.autofill.style.display = '';\n    } else {\n      this.hideAutoFill();\n    }\n  }\n\n  mouseDownHandler(e) {\n    this.mouseButton = e.button;\n    const target = e.target;\n    const gObj = this.parent;\n    let isDrag;\n    const gridElement = parentsUntil(target, 'e-grid');\n\n    if (gridElement && gridElement.id !== gObj.element.id || parentsUntil(target, headerContent) && !this.parent.frozenRows || parentsUntil(target, 'e-editedbatchcell') || parentsUntil(target, editedRow)) {\n      return;\n    }\n\n    if (e.shiftKey || e.ctrlKey) {\n      e.preventDefault();\n    }\n\n    if (parentsUntil(target, rowCell) && !e.shiftKey && !e.ctrlKey) {\n      if (gObj.selectionSettings.cellSelectionMode.indexOf('Box') > -1 && !this.isRowType() && !this.isSingleSel()) {\n        this.isCellDrag = true;\n        isDrag = true;\n      } else if (gObj.allowRowDragAndDrop && !gObj.isEdit && !this.parent.selectionSettings.checkboxOnly) {\n        this.isRowDragSelected = false;\n\n        if (!this.isRowType() || this.isSingleSel() || closest(target, 'td').classList.contains('e-selectionbackground')) {\n          this.isDragged = false;\n          return;\n        }\n\n        isDrag = true;\n        this.element = this.parent.createElement('div', {\n          className: 'e-griddragarea'\n        });\n        gObj.getContent().appendChild(this.element);\n      }\n\n      if (isDrag) {\n        this.enableDrag(e, true);\n      }\n    }\n\n    this.updateStartEndCells();\n\n    if (target.classList.contains('e-autofill') || target.classList.contains('e-xlsel')) {\n      this.isCellDrag = true;\n      this.isAutoFillSel = true;\n      this.enableDrag(e);\n    }\n  }\n\n  updateStartEndCells() {\n    const cells = [].slice.call(this.parent.element.getElementsByClassName('e-cellselectionbackground'));\n    this.startCell = cells[0];\n    this.endCell = cells[cells.length - 1];\n\n    if (this.startCell) {\n      this.startIndex = parseInt(this.startCell.parentElement.getAttribute(ariaRowIndex), 10);\n      this.startCellIndex = parseInt(parentsUntil(this.startCell, rowCell).getAttribute(ariaColIndex), 10);\n    }\n  }\n\n  updateStartCellsIndex() {\n    if (this.startCell) {\n      this.startIndex = parseInt(this.startCell.parentElement.getAttribute(ariaRowIndex), 10);\n      this.startCellIndex = parseInt(parentsUntil(this.startCell, rowCell).getAttribute(ariaColIndex), 10);\n    }\n  }\n\n  enableDrag(e, isUpdate) {\n    const gObj = this.parent;\n\n    if (isUpdate) {\n      const tr = closest(e.target, 'tr');\n      this.startDIndex = parseInt(tr.getAttribute(ariaRowIndex), 10);\n      this.startDCellIndex = parseInt(parentsUntil(e.target, rowCell).getAttribute(ariaColIndex), 10);\n    }\n\n    document.body.classList.add('e-disableuserselect');\n    const gBRect = gObj.element.getBoundingClientRect();\n    const postion = getPosition(e);\n    this.x = postion.x - gBRect.left;\n    this.y = postion.y - gBRect.top;\n    EventHandler.add(gObj.getContent(), 'mousemove', this.mouseMoveHandler, this);\n\n    if (this.parent.frozenRows) {\n      EventHandler.add(gObj.getHeaderContent(), 'mousemove', this.mouseMoveHandler, this);\n    }\n\n    EventHandler.add(document, 'mouseup', this.mouseUpHandler, this);\n  }\n\n  clearSelAfterRefresh(e) {\n    const isInfiniteScroll = this.parent.enableInfiniteScrolling && e.requestType === 'infiniteScroll';\n\n    if (e.requestType !== 'virtualscroll' && !this.parent.isPersistSelection && !isInfiniteScroll) {\n      this.clearSelection();\n    }\n  }\n  /**\n   * @returns {void}\n   * @hidden\n   */\n\n\n  addEventListener() {\n    if (this.parent.isDestroyed) {\n      return;\n    }\n\n    this.evtHandlers = [{\n      event: uiUpdate,\n      handler: this.enableAfterRender\n    }, {\n      event: initialEnd,\n      handler: this.initializeSelection\n    }, {\n      event: rowSelectionComplete,\n      handler: this.onActionComplete\n    }, {\n      event: cellSelectionComplete,\n      handler: this.onActionComplete\n    }, {\n      event: inBoundModelChanged,\n      handler: this.onPropertyChanged\n    }, {\n      event: cellFocused,\n      handler: this.onCellFocused\n    }, {\n      event: beforeFragAppend,\n      handler: this.clearSelAfterRefresh\n    }, {\n      event: columnPositionChanged,\n      handler: this.columnPositionChanged\n    }, {\n      event: contentReady,\n      handler: this.initialEnd\n    }, {\n      event: rowsRemoved,\n      handler: this.rowsRemoved\n    }, {\n      event: headerRefreshed,\n      handler: this.refreshHeader\n    }, {\n      event: destroy,\n      handler: this.destroy\n    }];\n    addRemoveEventListener(this.parent, this.evtHandlers, true, this);\n    this.actionBeginFunction = this.actionBegin.bind(this);\n    this.actionCompleteFunction = this.actionComplete.bind(this);\n    this.parent.addEventListener(actionBegin, this.actionBeginFunction);\n    this.parent.addEventListener(actionComplete, this.actionCompleteFunction);\n    this.addEventListener_checkbox();\n  }\n  /**\n   * @returns {void}\n   * @hidden\n   */\n\n\n  removeEventListener() {\n    if (this.parent.isDestroyed) {\n      return;\n    }\n\n    addRemoveEventListener(this.parent, this.evtHandlers, false);\n    this.parent.removeEventListener(actionBegin, this.actionBeginFunction);\n    this.parent.removeEventListener(actionComplete, this.actionCompleteFunction);\n    this.removeEventListener_checkbox();\n  }\n\n  wireEvents() {\n    this.isMacOS = navigator.userAgent.indexOf('Mac OS') !== -1;\n\n    if (this.isMacOS) {\n      EventHandler.add(this.parent.element, 'keydown', this.keyDownHandler, this);\n      EventHandler.add(this.parent.element, 'keyup', this.keyUpHandler, this);\n    }\n  }\n\n  unWireEvents() {\n    if (this.isMacOS) {\n      EventHandler.remove(this.parent.element, 'keydown', this.keyDownHandler);\n      EventHandler.remove(this.parent.element, 'keyup', this.keyUpHandler);\n    }\n  }\n\n  columnPositionChanged() {\n    if (!this.parent.isPersistSelection) {\n      this.clearSelection();\n    }\n  }\n\n  refreshHeader() {\n    this.setCheckAllState();\n  }\n\n  rowsRemoved(e) {\n    for (let i = 0; i < e.records.length; i++) {\n      delete this.selectedRowState[e.records[i][this.primaryKey]];\n      --this.totalRecordsCount;\n    }\n\n    this.setCheckAllState();\n  }\n\n  beforeFragAppend(e) {\n    if (e.requestType !== 'virtualscroll' && !this.parent.isPersistSelection) {\n      this.clearSelection();\n    }\n  }\n\n  getCheckAllBox() {\n    return this.parent.getHeaderContent().querySelector('.e-checkselectall');\n  }\n\n  enableAfterRender(e) {\n    if (e.module === this.getModuleName() && e.enable) {\n      this.render();\n      this.initPerisistSelection();\n    }\n  } // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  render(e) {\n    EventHandler.add(this.parent.getContent(), 'mousedown', this.mouseDownHandler, this);\n    EventHandler.add(this.parent.getHeaderContent(), 'mousedown', this.mouseDownHandler, this);\n  }\n\n  onPropertyChanged(e) {\n    if (e.module !== this.getModuleName()) {\n      return;\n    }\n\n    const gObj = this.parent;\n\n    if (!isNullOrUndefined(e.properties.type) && this.selectionSettings.type === 'Single') {\n      if (this.selectedRowCellIndexes.length > 1) {\n        this.clearCellSelection();\n        this.prevCIdxs = undefined;\n      }\n\n      if (this.selectedRowIndexes.length > 1) {\n        this.clearRowSelection();\n        this.prevRowIndex = undefined;\n      }\n\n      if (this.selectedColumnsIndexes.length > 1) {\n        this.clearColumnSelection();\n        this.prevColIndex = undefined;\n      }\n\n      this.enableSelectMultiTouch = false;\n      this.hidePopUp();\n    }\n\n    if (!isNullOrUndefined(e.properties.mode) || !isNullOrUndefined(e.properties.cellSelectionMode)) {\n      this.clearSelection();\n      this.prevRowIndex = undefined;\n      this.prevCIdxs = undefined;\n      this.prevColIndex = undefined;\n    }\n\n    this.isPersisted = true;\n    this.checkBoxSelectionChanged();\n    this.isPersisted = false;\n\n    if (!this.parent.isCheckBoxSelection) {\n      this.initPerisistSelection();\n    }\n\n    const checkboxColumn = this.parent.getColumns().filter(col => col.type === 'checkbox');\n\n    if (checkboxColumn.length) {\n      gObj.isCheckBoxSelection = !(this.selectionSettings.checkboxMode === 'ResetOnRowClick');\n    }\n\n    this.drawBorders();\n  }\n\n  hidePopUp() {\n    if (this.parent.element.querySelector('.e-gridpopup').getElementsByClassName('e-rowselect').length) {\n      this.parent.element.querySelector('.e-gridpopup').style.display = 'none';\n    }\n  }\n\n  initialEnd(e) {\n    const isFrozen = this.parent.isFrozenGrid();\n    const isLeftRightFrozen = this.parent.getFrozenMode() === leftRight;\n\n    if ((!isFrozen || isFrozen && !isLeftRightFrozen && !e.args.isFrozen || isLeftRightFrozen && e.args.renderFrozenRightContent) && !this.selectedRowIndexes.length) {\n      this.parent.off(contentReady, this.initialEnd);\n      this.selectRow(this.parent.selectedRowIndex);\n    }\n  }\n\n  checkBoxSelectionChanged() {\n    const gobj = this.parent;\n    gobj.off(contentReady, this.checkBoxSelectionChanged);\n    const checkboxColumn = gobj.getColumns().filter(col => col.type === 'checkbox');\n\n    if (checkboxColumn.length > 0) {\n      gobj.isCheckBoxSelection = true;\n      this.chkField = checkboxColumn[0].field;\n      this.totalRecordsCount = this.parent.pageSettings.totalRecordsCount;\n\n      if (isNullOrUndefined(this.totalRecordsCount)) {\n        this.totalRecordsCount = this.getCurrentBatchRecordChanges().length;\n      }\n\n      if (this.isSingleSel()) {\n        gobj.selectionSettings.type = 'Multiple';\n        gobj.dataBind();\n      } else {\n        this.initPerisistSelection();\n      }\n    }\n\n    if (!gobj.isCheckBoxSelection && !this.isPersisted) {\n      this.chkField = null;\n      this.initPerisistSelection();\n    }\n  }\n\n  initPerisistSelection() {\n    const gobj = this.parent;\n\n    if (this.parent.selectionSettings.persistSelection && this.parent.getPrimaryKeyFieldNames().length > 0) {\n      gobj.isPersistSelection = true;\n      this.ensureCheckboxFieldSelection();\n    } else if (this.parent.getPrimaryKeyFieldNames().length > 0) {\n      gobj.isPersistSelection = false;\n      this.ensureCheckboxFieldSelection();\n    } else {\n      gobj.isPersistSelection = false;\n      this.selectedRowState = {};\n    }\n  }\n\n  ensureCheckboxFieldSelection() {\n    const gobj = this.parent;\n    this.primaryKey = this.parent.getPrimaryKeyFieldNames()[0];\n\n    if (!gobj.enableVirtualization && this.chkField && (gobj.isPersistSelection && Object.keys(this.selectedRowState).length === 0 || !gobj.isPersistSelection)) {\n      const data = this.parent.getDataModule();\n      const query = new Query().where(this.chkField, 'equal', true);\n\n      if (!query.params) {\n        query.params = this.parent.query.params;\n      }\n\n      const dataManager = data.getData({}, query); // eslint-disable-next-line @typescript-eslint/no-this-alias\n\n      const proxy = this;\n      this.parent.showSpinner();\n      dataManager.then(e => {\n        proxy.dataSuccess(e.result);\n        proxy.refreshPersistSelection();\n        proxy.parent.hideSpinner();\n      });\n    }\n  }\n\n  dataSuccess(res) {\n    for (let i = 0; i < res.length; i++) {\n      if (isNullOrUndefined(this.selectedRowState[res[i][this.primaryKey]]) && res[i][this.chkField]) {\n        this.selectedRowState[res[i][this.primaryKey]] = res[i][this.chkField];\n      }\n    }\n\n    this.persistSelectedData = res;\n  }\n\n  setRowSelection(state) {\n    if (!this.parent.getDataModule().isRemote()) {\n      if (state) {\n        if (this.parent.groupSettings.columns.length) {\n          for (const data of this.getData().records) {\n            this.selectedRowState[data[this.primaryKey]] = true;\n          }\n        } else {\n          for (const data of this.getData()) {\n            this.selectedRowState[data[this.primaryKey]] = true;\n          }\n        }\n      } else {\n        this.selectedRowState = {};\n      } // (this.getData()).forEach(function (data) {\n      //     this.selectedRowState[data[this.primaryKey]] = true;\n      // })\n\n    }\n  }\n\n  getData() {\n    return this.parent.getDataModule().dataManager.executeLocal(this.parent.getDataModule().generateQuery(true));\n  }\n\n  refreshPersistSelection() {\n    let rows = this.parent.getRows();\n\n    if (this.parent.isCheckBoxSelection && this.parent.isFrozenGrid()) {\n      const mtbody = this.parent.getMovableContentTbody();\n\n      if (mtbody.querySelector('.e-checkselect')) {\n        rows = this.parent.getMovableRows();\n      }\n\n      if (this.parent.getFrozenMode() === leftRight) {\n        const frtbody = this.parent.getFrozenRightContentTbody();\n\n        if (frtbody.querySelector('.e-checkselect')) {\n          rows = this.parent.getFrozenRightRows();\n        }\n      }\n    }\n\n    this.totalRecordsCount = this.parent.getCurrentViewRecords().length;\n\n    if (this.parent.allowPaging) {\n      this.totalRecordsCount = this.parent.pageSettings.totalRecordsCount;\n    }\n\n    if (rows !== null && rows.length > 0 && (this.parent.isPersistSelection || this.chkField)) {\n      const indexes = [];\n\n      for (let j = 0; j < rows.length; j++) {\n        const rowObj = this.getRowObj(rows[j]);\n        const pKey = rowObj ? rowObj.data ? rowObj.data[this.primaryKey] : null : null;\n\n        if (pKey === null) {\n          return;\n        }\n\n        let checkState;\n        const chkBox = rows[j].querySelector('.e-checkselect');\n\n        if (this.selectedRowState[pKey] || this.parent.checkAllRows === 'Check' && this.selectedRowState[pKey] && this.totalRecordsCount === Object.keys(this.selectedRowState).length && this.chkAllCollec.indexOf(pKey) < 0 || this.parent.checkAllRows === 'Uncheck' && this.chkAllCollec.indexOf(pKey) > 0 || this.parent.checkAllRows === 'Intermediate' && !isNullOrUndefined(this.chkField) && rowObj.data[this.chkField]) {\n          indexes.push(parseInt(rows[j].getAttribute(ariaRowIndex), 10));\n          checkState = true;\n        } else {\n          checkState = false;\n\n          if (this.checkedTarget !== chkBox && this.parent.isCheckBoxSelection) {\n            removeAddCboxClasses(chkBox.nextElementSibling, checkState);\n          }\n        }\n\n        this.updatePersistCollection(rows[j], checkState);\n      }\n\n      if (this.isSingleSel() && indexes.length > 0) {\n        this.selectRow(indexes[0], true);\n      } else {\n        this.selectRows(indexes);\n      }\n    }\n\n    if (this.parent.isCheckBoxSelection && this.getCurrentBatchRecordChanges().length > 0) {\n      this.setCheckAllState();\n    }\n  }\n\n  actionBegin(e) {\n    if (e.requestType === 'save' && this.parent.isPersistSelection) {\n      const editChkBox = this.parent.element.querySelector('.e-edit-checkselect');\n\n      if (!isNullOrUndefined(editChkBox)) {\n        let row$$1 = closest(editChkBox, '.' + editedRow);\n\n        if (row$$1) {\n          if (this.parent.editSettings.mode === 'Dialog') {\n            row$$1 = this.parent.element.querySelector('.e-dlgeditrow');\n          }\n\n          const rowObj = this.getRowObj(row$$1);\n\n          if (!rowObj) {\n            return;\n          }\n\n          this.selectedRowState[rowObj.data[this.primaryKey]] = rowObj.isSelected = editChkBox.checked;\n        } else {\n          this.isCheckedOnAdd = editChkBox.checked;\n        }\n      }\n    }\n  }\n\n  actionComplete(e) {\n    if (e.requestType === 'save' && this.parent.isPersistSelection) {\n      if (e.action === 'add' && this.isCheckedOnAdd) {\n        const rowObj = this.parent.getRowObjectFromUID(this.parent.getRows()[e.selectedRow].getAttribute('data-uid'));\n        this.selectedRowState[rowObj.data[this.primaryKey]] = rowObj.isSelected = this.isCheckedOnAdd;\n      }\n\n      this.refreshPersistSelection();\n    }\n\n    if (e.requestType === 'delete' && this.parent.isPersistSelection) {\n      const records = e.data;\n      const data = records.slice();\n\n      for (let i = 0; i < data.length; i++) {\n        if (!isNullOrUndefined(data[i][this.primaryKey])) {\n          this.updatePersistDelete(data[i][this.primaryKey]);\n        }\n      }\n\n      this.setCheckAllState();\n      this.totalRecordsCount = this.parent.pageSettings.totalRecordsCount;\n    }\n\n    if (e.requestType === 'paging') {\n      this.prevRowIndex = undefined;\n      this.prevCIdxs = undefined;\n      this.prevECIdxs = undefined;\n    }\n  }\n\n  onDataBound() {\n    if (!this.parent.enableVirtualization && this.parent.isPersistSelection) {\n      if (this.selectedRecords.length) {\n        this.isPrevRowSelection = true;\n      }\n\n      this.refreshPersistSelection();\n    }\n\n    if (this.parent.enableVirtualization) {\n      this.setCheckAllState();\n    }\n\n    this.initialRowSelection = this.isRowType() && this.parent.element.querySelectorAll('.e-selectionbackground') && this.parent.getSelectedRows().length ? true : false;\n\n    if (this.parent.isCheckBoxSelection && !this.initialRowSelection) {\n      const totalRecords = this.parent.getRowsObject();\n      const indexes = [];\n\n      for (let i = 0; i < totalRecords.length; i++) {\n        if (totalRecords[i].isSelected) {\n          indexes.push(i);\n        }\n      }\n\n      if (indexes.length) {\n        this.selectRows(indexes);\n      }\n\n      this.initialRowSelection = true;\n    }\n  }\n\n  updatePersistSelectedData(checkState) {\n    if (this.parent.isPersistSelection) {\n      const rows = this.parent.getRows();\n\n      for (let i = 0; i < rows.length; i++) {\n        this.updatePersistCollection(rows[i], checkState);\n      }\n\n      if (this.parent.checkAllRows === 'Uncheck') {\n        this.setRowSelection(false);\n        this.persistSelectedData = this.parent.getDataModule().isRemote() ? this.persistSelectedData : [];\n      } else if (this.parent.checkAllRows === 'Check') {\n        this.setRowSelection(true);\n        this.persistSelectedData = !this.parent.getDataModule().isRemote() ? this.parent.groupSettings.columns.length ? this.getData().records.slice() : this.getData().slice() : this.persistSelectedData;\n      }\n    }\n  }\n\n  checkSelectAllAction(checkState) {\n    const cRenderer = this.getRenderer();\n    const editForm = this.parent.element.querySelector('.e-gridform');\n    this.checkedTarget = this.getCheckAllBox();\n\n    if (checkState && this.getCurrentBatchRecordChanges().length) {\n      this.parent.checkAllRows = 'Check';\n      this.updatePersistSelectedData(checkState);\n      this.selectRowsByRange(cRenderer.getVirtualRowIndex(0), cRenderer.getVirtualRowIndex(this.getCurrentBatchRecordChanges().length - 1));\n    } else {\n      this.parent.checkAllRows = 'Uncheck';\n      this.updatePersistSelectedData(checkState);\n      this.clearSelection();\n    }\n\n    this.chkAllCollec = [];\n\n    if (!isNullOrUndefined(editForm)) {\n      const editChkBox = editForm.querySelector('.e-edit-checkselect');\n\n      if (!isNullOrUndefined(editChkBox)) {\n        removeAddCboxClasses(editChkBox.nextElementSibling, checkState);\n      }\n    }\n  }\n\n  checkSelectAll(checkBox) {\n    const stateStr = this.getCheckAllStatus(checkBox);\n    let state = stateStr === 'Check';\n    this.isHeaderCheckboxClicked = true;\n\n    if (stateStr === 'Intermediate') {\n      state = this.getCurrentBatchRecordChanges().some(data => data[this.primaryKey] in this.selectedRowState);\n    }\n\n    if (this.parent.isPersistSelection && this.parent.allowPaging) {\n      this.totalRecordsCount = this.parent.pageSettings.totalRecordsCount;\n    }\n\n    this.checkSelectAllAction(!state);\n    this.target = null;\n\n    if (this.getCurrentBatchRecordChanges().length > 0) {\n      this.setCheckAllState();\n    }\n\n    this.triggerChkChangeEvent(checkBox, !state);\n  }\n\n  getCheckAllStatus(ele) {\n    const classes = ele ? ele.nextElementSibling.classList : this.getCheckAllBox().nextElementSibling.classList;\n    let status;\n\n    if (classes.contains('e-check')) {\n      status = 'Check';\n    } else if (classes.contains('e-uncheck')) {\n      status = 'Uncheck';\n    } else if (classes.contains('e-stop')) {\n      status = 'Intermediate';\n    } else {\n      status = 'None';\n    }\n\n    return status;\n  }\n\n  checkSelect(checkBox) {\n    const target = closest(this.checkedTarget, '.' + rowCell);\n    const gObj = this.parent;\n    this.isMultiCtrlRequest = true;\n    let rIndex = 0;\n    this.isHeaderCheckboxClicked = false;\n\n    if (isGroupAdaptive(gObj)) {\n      const uid = target.parentElement.getAttribute('data-uid');\n      rIndex = gObj.getRows().map(m => m.getAttribute('data-uid')).indexOf(uid);\n    } else {\n      rIndex = parseInt(target.parentElement.getAttribute(ariaRowIndex), 10);\n    }\n\n    if (this.parent.isPersistSelection && this.parent.element.getElementsByClassName(addedRow).length > 0 && this.parent.editSettings.newRowPosition === 'Top') {\n      ++rIndex;\n    }\n\n    this.rowCellSelectionHandler(rIndex, parseInt(target.getAttribute(ariaColIndex), 10));\n    this.moveIntoUncheckCollection(closest(target, '.' + row));\n    this.setCheckAllState();\n    this.isMultiCtrlRequest = false;\n    this.triggerChkChangeEvent(checkBox, checkBox.nextElementSibling.classList.contains('e-check'));\n  }\n\n  moveIntoUncheckCollection(row$$1) {\n    if (this.parent.checkAllRows === 'Check' || this.parent.checkAllRows === 'Uncheck') {\n      const rowObj = this.getRowObj(row$$1);\n      const pKey = rowObj && rowObj.data ? rowObj.data[this.primaryKey] : null;\n\n      if (!pKey) {\n        return;\n      }\n\n      if (this.chkAllCollec.indexOf(pKey) < 0) {\n        this.chkAllCollec.push(pKey);\n      } else {\n        this.chkAllCollec.splice(this.chkAllCollec.indexOf(pKey), 1);\n      }\n    }\n  }\n\n  triggerChkChangeEvent(checkBox, checkState) {\n    this.parent.trigger(checkBoxChange, {\n      checked: checkState,\n      selectedRowIndexes: this.parent.getSelectedRowIndexes(),\n      target: checkBox\n    });\n\n    if (!this.parent.isEdit) {\n      this.checkedTarget = null;\n    }\n  }\n\n  updateSelectedRowIndex(index) {\n    if (this.parent.isCheckBoxSelection && (this.parent.enableVirtualization || this.parent.enableInfiniteScrolling) && !this.parent.getDataModule().isRemote()) {\n      if (this.parent.checkAllRows === 'Check') {\n        this.selectedRowIndexes = [];\n        const dataLength = this.getData().length;\n\n        for (let data = 0; data < dataLength; data++) {\n          this.selectedRowIndexes.push(data);\n        }\n      } else if (this.parent.checkAllRows === 'Uncheck') {\n        this.selectedRowIndexes = [];\n      } else {\n        const row$$1 = this.parent.getRowByIndex(index);\n\n        if (index && row$$1 && row$$1.getAttribute('aria-selected') === 'false') {\n          const selectedVal = this.selectedRowIndexes.indexOf(index);\n          this.selectedRowIndexes.splice(selectedVal, 1);\n        }\n      }\n    }\n  }\n\n  isAllSelected() {\n    const data = this.getData();\n\n    for (let i = 0; i < data.length; i++) {\n      const pKey = data[i][this.primaryKey];\n\n      if (!this.selectedRowState[pKey]) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  setCheckAllState(index, isInteraction) {\n    if (this.parent.isCheckBoxSelection || this.parent.selectionSettings.checkboxMode === 'ResetOnRowClick') {\n      let checkToSelectAll = true;\n      let checkedLen = Object.keys(this.selectedRowState).length;\n\n      if (!this.parent.isPersistSelection) {\n        checkedLen = this.selectedRowIndexes.length;\n        this.totalRecordsCount = this.getCurrentBatchRecordChanges().length;\n      }\n\n      if (this.parent.isPersistSelection && !this.parent.getDataModule().isRemote() && (this.parent.searchSettings.key.length || this.parent.filterSettings.columns.length)) {\n        checkToSelectAll = this.isAllSelected();\n      }\n\n      const input = this.getCheckAllBox();\n\n      if (input) {\n        const spanEle = input.nextElementSibling;\n        removeClass([spanEle], ['e-check', 'e-stop', 'e-uncheck']);\n        setChecked(input, false);\n        input.indeterminate = false;\n\n        if (checkToSelectAll && checkedLen === this.totalRecordsCount && this.totalRecordsCount || (this.parent.enableVirtualization || this.parent.enableInfiniteScrolling) && !this.parent.allowPaging && !this.parent.getDataModule().isRemote() && this.getData().length && checkedLen === this.getData().length) {\n          addClass([spanEle], ['e-check']);\n          setChecked(input, true);\n\n          if (isInteraction) {\n            this.getRenderer().setSelection(null, true, true);\n          }\n\n          this.parent.checkAllRows = 'Check';\n        } else if (!this.selectedRowIndexes.length || checkedLen === 0 && this.getCurrentBatchRecordChanges().length === 0) {\n          addClass([spanEle], ['e-uncheck']);\n\n          if (isInteraction) {\n            this.getRenderer().setSelection(null, false, true);\n          }\n\n          this.parent.checkAllRows = 'Uncheck';\n\n          if (checkedLen === 0 && this.getCurrentBatchRecordChanges().length === 0) {\n            addClass([spanEle.parentElement], ['e-checkbox-disabled']);\n          } else {\n            removeClass([spanEle.parentElement], ['e-checkbox-disabled']);\n          }\n        } else {\n          addClass([spanEle], ['e-stop']);\n          this.parent.checkAllRows = 'Intermediate';\n          input.indeterminate = true;\n        }\n\n        if ((this.parent.enableVirtualization || this.parent.enableInfiniteScrolling) && !this.parent.allowPaging && !this.parent.getDataModule().isRemote()) {\n          this.updateSelectedRowIndex(index);\n        }\n      }\n    }\n  }\n\n  keyDownHandler(e) {\n    // Below are keyCode for command key in MAC OS. Safari/Chrome(91-Left command, 93-Right Command), Opera(17), FireFox(224)\n    if ((Browser.info.name === 'chrome' || Browser.info.name === 'safari') && (e.keyCode === 91 || e.keyCode === 93) || Browser.info.name === 'opera' && e.keyCode === 17 || Browser.info.name === 'mozilla' && e.keyCode === 224) {\n      this.cmdKeyPressed = true;\n    }\n  }\n\n  keyUpHandler(e) {\n    if ((Browser.info.name === 'chrome' || Browser.info.name === 'safari') && (e.keyCode === 91 || e.keyCode === 93) || Browser.info.name === 'opera' && e.keyCode === 17 || Browser.info.name === 'mozilla' && e.keyCode === 224) {\n      this.cmdKeyPressed = false;\n    }\n  }\n\n  clickHandler(e) {\n    let target = e.target;\n    this.actualTarget = target;\n\n    if (this.selectionSettings.persistSelection) {\n      this.deSelectedData = iterateExtend(this.persistSelectedData);\n    }\n\n    if (parentsUntil(target, row) || parentsUntil(target, 'e-headerchkcelldiv') || this.selectionSettings.allowColumnSelection && target.classList.contains('e-headercell')) {\n      this.isInteracted = true;\n    }\n\n    this.isMultiCtrlRequest = e.ctrlKey || this.enableSelectMultiTouch || this.isMacOS && this.cmdKeyPressed;\n    this.isMultiShiftRequest = e.shiftKey;\n    this.popUpClickHandler(e);\n    let chkSelect = false;\n    this.preventFocus = true;\n    let checkBox;\n    const checkWrap = parentsUntil(target, 'e-checkbox-wrapper');\n    this.checkSelectAllClicked = checkWrap && checkWrap.getElementsByClassName('e-checkselectall') || this.selectionSettings.persistSelection && parentsUntil(target, row) ? true : false;\n\n    if (checkWrap && checkWrap.querySelectorAll('.e-checkselect,.e-checkselectall').length > 0) {\n      checkBox = checkWrap.querySelector('input[type=\"checkbox\"]');\n      chkSelect = true;\n    }\n\n    this.drawBorders();\n    this.updateAutoFillPosition();\n    target = parentsUntil(target, rowCell);\n\n    if ((target && target.parentElement.classList.contains(row) && !this.parent.selectionSettings.checkboxOnly || chkSelect) && !this.isRowDragSelected) {\n      if (this.parent.isCheckBoxSelection) {\n        this.isMultiCtrlRequest = true;\n      }\n\n      this.target = target;\n\n      if (!isNullOrUndefined(checkBox)) {\n        this.checkedTarget = checkBox;\n\n        if (checkBox.classList.contains('e-checkselectall')) {\n          this.checkSelectAll(checkBox);\n        } else {\n          this.checkSelect(checkBox);\n        }\n      } else {\n        const gObj = this.parent;\n        let rIndex = 0;\n\n        if (isGroupAdaptive(gObj)) {\n          const uid = target.parentElement.getAttribute('data-uid');\n          rIndex = gObj.getRows().map(m => m.getAttribute('data-uid')).indexOf(uid);\n        } else {\n          rIndex = parseInt(target.parentElement.getAttribute(ariaRowIndex), 10);\n        }\n\n        if (this.parent.isPersistSelection && this.parent.element.getElementsByClassName(addedRow).length > 0) {\n          ++rIndex;\n        }\n\n        if (!this.mUPTarget || !this.mUPTarget.isEqualNode(target)) {\n          this.rowCellSelectionHandler(rIndex, parseInt(target.getAttribute(ariaColIndex), 10));\n        }\n\n        this.parent.hoverFrozenRows(e);\n\n        if (this.parent.isCheckBoxSelection) {\n          this.moveIntoUncheckCollection(closest(target, '.' + row));\n          this.setCheckAllState();\n        }\n      }\n\n      if (!this.parent.isCheckBoxSelection && Browser.isDevice && !this.isSingleSel()) {\n        this.showPopup(e);\n      }\n    } else if (e.target.classList.contains('e-headercell') && !e.target.classList.contains('e-stackedheadercell')) {\n      const uid = e.target.querySelector('.e-headercelldiv').getAttribute('e-mappinguid');\n      this.headerSelectionHandler(this.parent.getColumnIndexByUid(uid));\n    }\n\n    this.isMultiCtrlRequest = false;\n    this.isMultiShiftRequest = false;\n\n    if (isNullOrUndefined(closest(e.target, '.e-unboundcell'))) {\n      this.preventFocus = false;\n    }\n  }\n\n  popUpClickHandler(e) {\n    const target = e.target;\n\n    if (closest(target, '.e-headercell') || e.target.classList.contains(rowCell) || closest(target, '.e-gridpopup')) {\n      if (target.classList.contains('e-rowselect')) {\n        if (!target.classList.contains('e-spanclicked')) {\n          target.classList.add('e-spanclicked');\n          this.enableSelectMultiTouch = true;\n        } else {\n          target.classList.remove('e-spanclicked');\n          this.enableSelectMultiTouch = false;\n          this.parent.element.querySelector('.e-gridpopup').style.display = 'none';\n        }\n      }\n    } else {\n      this.parent.element.querySelector('.e-gridpopup').style.display = 'none';\n    }\n  }\n\n  showPopup(e) {\n    if (!this.selectionSettings.enableSimpleMultiRowSelection) {\n      setCssInGridPopUp(this.parent.element.querySelector('.e-gridpopup'), e, 'e-rowselect e-icons e-icon-rowselect' + (!this.isSingleSel() && (this.selectedRecords.length > (this.parent.getFrozenColumns() ? 2 : 1) || this.selectedRowCellIndexes.length > 1) ? ' e-spanclicked' : ''));\n    }\n  }\n\n  rowCellSelectionHandler(rowIndex, cellIndex) {\n    if (!this.isMultiCtrlRequest && !this.isMultiShiftRequest || this.isSingleSel()) {\n      if (!this.isDragged) {\n        this.selectRow(rowIndex, this.selectionSettings.enableToggle);\n      }\n\n      this.selectCell({\n        rowIndex: rowIndex,\n        cellIndex: cellIndex\n      }, this.selectionSettings.enableToggle);\n\n      if (this.selectedRowCellIndexes.length) {\n        this.updateAutoFillPosition();\n      }\n\n      this.drawBorders();\n    } else if (this.isMultiShiftRequest) {\n      if (this.parent.isCheckBoxSelection || !this.parent.isCheckBoxSelection && !closest(this.target, '.' + rowCell).classList.contains(gridChkBox)) {\n        this.selectRowsByRange(isUndefined(this.prevRowIndex) ? rowIndex : this.prevRowIndex, rowIndex);\n      } else {\n        this.addRowsToSelection([rowIndex]);\n      }\n\n      this.selectCellsByRange(isUndefined(this.prevCIdxs) ? {\n        rowIndex: rowIndex,\n        cellIndex: cellIndex\n      } : this.prevCIdxs, {\n        rowIndex: rowIndex,\n        cellIndex: cellIndex\n      });\n      this.updateAutoFillPosition();\n      this.drawBorders();\n    } else {\n      this.addRowsToSelection([rowIndex]);\n      this.addCellsToSelection([{\n        rowIndex: rowIndex,\n        cellIndex: cellIndex\n      }]);\n      this.showHideBorders('none');\n    }\n\n    this.isDragged = false;\n  }\n\n  onCellFocused(e) {\n    if (this.parent.frozenRows && e.container.isHeader && e.byKey) {\n      if (e.keyArgs.action === 'upArrow') {\n        if (this.parent.allowFiltering) {\n          e.isJump = e.element.tagName === 'INPUT' ? true : false;\n        } else {\n          e.isJump = e.element.tagName === 'TH' ? true : false;\n        }\n      } else {\n        if (e.keyArgs.action === 'downArrow') {\n          const rIdx = Number(e.element.parentElement.getAttribute(ariaRowIndex));\n          e.isJump = rIdx === 0 ? true : false;\n        } else {\n          if (e.keyArgs.action === 'ctrlHome') {\n            e.isJump = true;\n          }\n        }\n      }\n    }\n\n    const clear = this.parent.isFrozenGrid() ? (e.container.isHeader && e.element.tagName !== 'TD' && e.isJump && !this.selectionSettings.allowColumnSelection || (e.container.isContent || e.element.tagName === 'TD') && !(e.container.isSelectable || e.element.tagName === 'TD')) && !(e.byKey && e.keyArgs.action === 'space') : (e.container.isHeader && e.isJump || e.container.isContent && !e.container.isSelectable) && !(e.byKey && e.keyArgs.action === 'space') && !(e.element.classList.contains('e-detailrowexpand') || e.element.classList.contains('e-detailrowcollapse'));\n    const headerAction = e.container.isHeader && e.element.tagName !== 'TD' && !closest(e.element, '.' + rowCell) && !(e.byKey && e.keyArgs.action === 'space');\n\n    if (!e.byKey || clear) {\n      if (clear && !this.parent.isCheckBoxSelection) {\n        this.clearSelection();\n      }\n\n      return;\n    }\n\n    let [rowIndex, cellIndex] = e.container.isContent ? e.container.indexes : e.indexes;\n    const prev = this.focus.getPrevIndexes();\n\n    if (this.parent.frozenRows) {\n      if (e.container.isHeader && (e.element.tagName === 'TD' || closest(e.element, '.' + rowCell))) {\n        const thLen = this.parent.getHeaderTable().querySelector('thead').childElementCount;\n        rowIndex -= thLen;\n        prev.rowIndex = !isNullOrUndefined(prev.rowIndex) ? prev.rowIndex - thLen : null;\n      } else {\n        rowIndex += this.parent.frozenRows;\n        prev.rowIndex = prev.rowIndex === 0 || !isNullOrUndefined(prev.rowIndex) ? prev.rowIndex + this.parent.frozenRows : null;\n      }\n    }\n\n    if (this.parent.isFrozenGrid()) {\n      const cIdx = Number(e.element.getAttribute(ariaColIndex));\n      const selectedIndexes = this.parent.getSelectedRowCellIndexes();\n\n      if (selectedIndexes.length && prev.cellIndex === 0) {\n        prev.cellIndex = selectedIndexes[selectedIndexes.length - 1].cellIndexes[0];\n      }\n\n      prev.cellIndex = !isNullOrUndefined(prev.cellIndex) ? prev.cellIndex === cellIndex ? cIdx : cIdx - 1 : null;\n      cellIndex = cIdx;\n    }\n\n    if (this.parent.enableInfiniteScrolling && this.parent.infiniteScrollSettings.enableCache) {\n      rowIndex = parseInt(e.element.parentElement.getAttribute('aria-rowindex'), 10);\n    }\n\n    if ((headerAction || ['ctrlPlusA', 'escape'].indexOf(e.keyArgs.action) === -1 && e.keyArgs.action !== 'space' && rowIndex === prev.rowIndex && cellIndex === prev.cellIndex) && !this.selectionSettings.allowColumnSelection) {\n      return;\n    }\n\n    this.preventFocus = true;\n    const columnIndex = this.getKeyColIndex(e);\n\n    if (this.needColumnSelection) {\n      cellIndex = columnIndex;\n    }\n\n    switch (e.keyArgs.action) {\n      case 'downArrow':\n      case 'upArrow':\n      case 'enter':\n      case 'shiftEnter':\n        this.target = e.element;\n        this.isKeyAction = true;\n        this.applyDownUpKey(rowIndex, cellIndex);\n        break;\n\n      case 'rightArrow':\n      case 'leftArrow':\n        this.applyRightLeftKey(rowIndex, cellIndex);\n        break;\n\n      case 'shiftDown':\n      case 'shiftUp':\n        this.shiftDownKey(rowIndex, cellIndex);\n        break;\n\n      case 'shiftLeft':\n      case 'shiftRight':\n        this.applyShiftLeftRightKey(rowIndex, cellIndex);\n        break;\n\n      case 'home':\n      case 'end':\n        cellIndex = e.keyArgs.action === 'end' ? this.getLastColIndex(rowIndex) : 0;\n        this.applyHomeEndKey(rowIndex, cellIndex);\n        break;\n\n      case 'ctrlHome':\n      case 'ctrlEnd':\n        this.applyCtrlHomeEndKey(rowIndex, cellIndex);\n        break;\n\n      case 'escape':\n        this.clearSelection();\n        break;\n\n      case 'ctrlPlusA':\n        this.ctrlPlusA();\n        break;\n\n      case 'space':\n        this.applySpaceSelection(e.element);\n        break;\n\n      case 'tab':\n        if (this.parent.editSettings.allowNextRowEdit) {\n          this.selectRow(rowIndex);\n        }\n\n        break;\n    }\n\n    this.needColumnSelection = false;\n    this.preventFocus = false;\n    this.positionBorders();\n    this.updateAutoFillPosition();\n  }\n\n  getKeyColIndex(e) {\n    let uid;\n    let index = null;\n    const stackedHeader = e.element.querySelector('.e-stackedheadercelldiv');\n\n    if (this.selectionSettings.allowColumnSelection && parentsUntil(e.element, 'e-columnheader')) {\n      this.needColumnSelection = e.container.isHeader ? true : false;\n\n      if (stackedHeader) {\n        if (e.keyArgs.action === 'rightArrow' || e.keyArgs.action === 'leftArrow') {\n          return index;\n        }\n\n        uid = stackedHeader.getAttribute('e-mappinguid');\n        const innerColumn = this.getstackedColumns(this.parent.getColumnByUid(uid).columns);\n        const lastIndex = this.parent.getColumnIndexByUid(innerColumn[innerColumn.length - 1].uid);\n        const firstIndex = this.parent.getColumnIndexByUid(innerColumn[0].uid);\n        index = this.prevColIndex >= lastIndex ? firstIndex : lastIndex;\n      } else {\n        index = this.parent.getColumnIndexByUid(e.element.querySelector('.e-headercelldiv').getAttribute('e-mappinguid'));\n      }\n    }\n\n    return index;\n  }\n  /**\n   * Apply ctrl + A key selection\n   *\n   * @returns {void}\n   * @hidden\n   */\n\n\n  ctrlPlusA() {\n    if (this.isRowType() && !this.isSingleSel()) {\n      this.selectRowsByRange(0, this.getCurrentBatchRecordChanges().length - 1);\n    }\n\n    if (this.isCellType() && !this.isSingleSel()) {\n      this.selectCellsByRange({\n        rowIndex: 0,\n        cellIndex: 0\n      }, {\n        rowIndex: this.parent.getRows().length - 1,\n        cellIndex: this.parent.getColumns().length - 1\n      });\n    }\n  }\n\n  applySpaceSelection(target) {\n    if (target.classList.contains('e-checkselectall')) {\n      this.checkedTarget = target;\n      this.checkSelectAll(this.checkedTarget);\n    } else {\n      if (target.classList.contains('e-checkselect')) {\n        this.checkedTarget = target;\n        this.checkSelect(this.checkedTarget);\n      }\n    }\n  }\n\n  applyDownUpKey(rowIndex, cellIndex) {\n    const gObj = this.parent;\n\n    if (this.parent.isCheckBoxSelection && this.parent.checkAllRows === 'Check' && !this.selectionSettings.persistSelection) {\n      this.checkSelectAllAction(false);\n      this.checkedTarget = null;\n    }\n\n    if (this.isRowType()) {\n      if (this.parent.frozenRows) {\n        this.selectRow(rowIndex, true);\n        this.applyUpDown(gObj.selectedRowIndex);\n      } else {\n        this.selectRow(rowIndex, true);\n        this.applyUpDown(gObj.selectedRowIndex);\n      }\n    }\n\n    if (this.isCellType()) {\n      this.selectCell({\n        rowIndex,\n        cellIndex\n      }, true);\n    }\n\n    if (this.selectionSettings.allowColumnSelection && this.needColumnSelection) {\n      this.selectColumn(cellIndex);\n    }\n  }\n\n  applyUpDown(rowIndex) {\n    if (rowIndex < 0) {\n      return;\n    }\n\n    if (!this.target) {\n      this.target = this.parent.getRows()[0].children[this.parent.groupSettings.columns.length || 0];\n    }\n\n    const cIndex = parseInt(this.target.getAttribute(ariaColIndex), 10);\n    const frzCols = this.parent.getFrozenColumns();\n\n    if (frzCols) {\n      if (cIndex >= frzCols) {\n        this.target = this.contentRenderer.getMovableRowByIndex(rowIndex).getElementsByClassName(rowCell)[cIndex - frzCols];\n      } else {\n        this.target = this.contentRenderer.getRowByIndex(rowIndex).getElementsByClassName(rowCell)[cIndex];\n      }\n    } else {\n      const row$$1 = this.contentRenderer.getRowByIndex(rowIndex);\n\n      if (row$$1) {\n        this.target = row$$1.getElementsByClassName(rowCell)[cIndex];\n      }\n    }\n\n    this.addAttribute(this.target);\n  }\n\n  applyRightLeftKey(rowIndex, cellIndex) {\n    if (this.selectionSettings.allowColumnSelection && this.needColumnSelection) {\n      this.selectColumn(cellIndex);\n    } else if (this.isCellType()) {\n      this.selectCell({\n        rowIndex,\n        cellIndex\n      }, true);\n      this.addAttribute(this.target);\n    }\n  }\n\n  applyHomeEndKey(rowIndex, cellIndex) {\n    if (this.isCellType()) {\n      this.selectCell({\n        rowIndex,\n        cellIndex\n      }, true);\n    } else {\n      this.addAttribute(this.parent.getCellFromIndex(rowIndex, cellIndex));\n    }\n  }\n  /**\n   * Apply shift+down key selection\n   *\n   * @param {number} rowIndex - specfies the rowIndex\n   * @param {number} cellIndex - specifies the CellIndex\n   * @returns {void}\n   * @hidden\n   */\n\n\n  shiftDownKey(rowIndex, cellIndex) {\n    this.isMultiShiftRequest = true;\n\n    if (this.isRowType() && !this.isSingleSel()) {\n      if (!isUndefined(this.prevRowIndex)) {\n        this.selectRowsByRange(this.prevRowIndex, rowIndex);\n        this.applyUpDown(rowIndex);\n      } else {\n        this.selectRow(0, true);\n      }\n    }\n\n    if (this.isCellType() && !this.isSingleSel()) {\n      this.selectCellsByRange(this.prevCIdxs || {\n        rowIndex: 0,\n        cellIndex: 0\n      }, {\n        rowIndex,\n        cellIndex\n      });\n    }\n\n    this.isMultiShiftRequest = false;\n  }\n\n  applyShiftLeftRightKey(rowIndex, cellIndex) {\n    this.isMultiShiftRequest = true;\n\n    if (this.selectionSettings.allowColumnSelection && this.needColumnSelection) {\n      this.selectColumnsByRange(this.prevColIndex, cellIndex);\n    } else {\n      this.selectCellsByRange(this.prevCIdxs, {\n        rowIndex,\n        cellIndex\n      });\n    }\n\n    this.isMultiShiftRequest = false;\n  }\n\n  getstackedColumns(column) {\n    const innerColumnIndexes = [];\n\n    for (let i = 0, len = column.length; i < len; i++) {\n      if (column[i].columns) {\n        this.getstackedColumns(column[i].columns);\n      } else {\n        innerColumnIndexes.push(column[i]);\n      }\n    }\n\n    return innerColumnIndexes;\n  }\n\n  applyCtrlHomeEndKey(rowIndex, cellIndex) {\n    if (this.isRowType()) {\n      this.selectRow(rowIndex, true);\n      this.addAttribute(this.parent.getCellFromIndex(rowIndex, cellIndex));\n    }\n\n    if (this.isCellType()) {\n      this.selectCell({\n        rowIndex,\n        cellIndex\n      }, true);\n    }\n  }\n\n  addRemoveClassesForRow(row$$1, isAdd, clearAll, ...args) {\n    if (row$$1) {\n      const cells = [].slice.call(row$$1.getElementsByClassName(rowCell));\n      const detailIndentCell = row$$1.querySelector('.e-detailrowcollapse') || row$$1.querySelector('.e-detailrowexpand');\n      const dragdropIndentCell = row$$1.querySelector('.e-rowdragdrop');\n\n      if (detailIndentCell) {\n        cells.push(detailIndentCell);\n      }\n\n      if (dragdropIndentCell) {\n        cells.push(dragdropIndentCell);\n      }\n\n      addRemoveActiveClasses(cells, isAdd, ...args);\n    }\n\n    this.getRenderer().setSelection(row$$1 ? row$$1.getAttribute('data-uid') : null, isAdd, clearAll);\n  }\n\n  isRowType() {\n    return this.selectionSettings.mode === 'Row' || this.selectionSettings.mode === 'Both';\n  }\n\n  isCellType() {\n    return this.selectionSettings.mode === 'Cell' || this.selectionSettings.mode === 'Both';\n  }\n\n  isSingleSel() {\n    return this.selectionSettings.type === 'Single';\n  }\n\n  getRenderer() {\n    if (isNullOrUndefined(this.contentRenderer)) {\n      this.contentRenderer = this.factory.getRenderer(RenderType.Content);\n    }\n\n    return this.contentRenderer;\n  }\n  /**\n   * Gets the collection of selected records.\n   *\n   * @returns {Object[]} returns the Object\n   */\n\n\n  getSelectedRecords() {\n    let selectedData = [];\n\n    if (!this.selectionSettings.persistSelection) {\n      selectedData = this.parent.getRowsObject().filter(row$$1 => row$$1.isSelected).map(m => m.data);\n    } else {\n      selectedData = this.persistSelectedData;\n    }\n\n    return selectedData;\n  }\n  /**\n   * Select the column by passing start column index\n   *\n   * @param {number} index - specifies the index\n   * @returns {void}\n   */\n\n\n  selectColumn(index) {\n    const gObj = this.parent;\n\n    if (isNullOrUndefined(gObj.getColumns()[index])) {\n      return;\n    }\n\n    const column = gObj.getColumnByIndex(index);\n    const selectedCol = gObj.getColumnHeaderByUid(column.uid);\n    const isColSelected = selectedCol.classList.contains('e-columnselection');\n\n    if (!gObj.selectionSettings.allowColumnSelection) {\n      return;\n    }\n\n    const isMultiColumns = this.selectedColumnsIndexes.length > 1 && this.selectedColumnsIndexes.indexOf(index) > -1;\n    this.clearColDependency();\n\n    if (!isColSelected || !this.selectionSettings.enableToggle || isMultiColumns) {\n      const args = {\n        columnIndex: index,\n        headerCell: selectedCol,\n        column: column,\n        cancel: false,\n        target: this.actualTarget,\n        isInteracted: this.isInteracted,\n        previousColumnIndex: this.prevColIndex,\n        isCtrlPressed: this.isMultiCtrlRequest,\n        isShiftPressed: this.isMultiShiftRequest\n      };\n      this.onActionBegin(args, columnSelecting);\n\n      if (args.cancel) {\n        this.disableInteracted();\n        return;\n      }\n\n      if (!(gObj.selectionSettings.enableToggle && index === this.prevColIndex && isColSelected) || isMultiColumns) {\n        this.updateColSelection(selectedCol, index);\n      }\n\n      const selectedArgs = {\n        columnIndex: index,\n        headerCell: selectedCol,\n        column: column,\n        target: this.actualTarget,\n        isInteracted: this.isInteracted,\n        previousColumnIndex: this.prevColIndex\n      };\n      this.onActionComplete(selectedArgs, columnSelected);\n    }\n\n    this.updateColProps(index);\n  }\n  /**\n   * Select the columns by passing start and end column index\n   *\n   * @param  {number} startIndex - specifies the start index\n   * @param  {number} endIndex - specifies the end index\n   * @returns {void}\n   */\n\n\n  selectColumnsByRange(startIndex, endIndex) {\n    const gObj = this.parent;\n\n    if (isNullOrUndefined(gObj.getColumns()[startIndex])) {\n      return;\n    }\n\n    const indexes = [];\n\n    if (gObj.selectionSettings.type === 'Single' || isNullOrUndefined(endIndex)) {\n      indexes[0] = startIndex;\n    } else {\n      const min = startIndex < endIndex;\n\n      for (let i = startIndex; min ? i <= endIndex : i >= endIndex; min ? i++ : i--) {\n        indexes.push(i);\n      }\n    }\n\n    this.selectColumns(indexes);\n  }\n  /**\n   * Select the columns by passing column indexes\n   *\n   * @param  {number[]} columnIndexes - specifies the columnIndexes\n   * @returns {void}\n   */\n\n\n  selectColumns(columnIndexes) {\n    const gObj = this.parent;\n    let selectedCol = this.getselectedCols();\n\n    if (gObj.selectionSettings.type === 'Single') {\n      columnIndexes = [columnIndexes[0]];\n    }\n\n    if (!gObj.selectionSettings.allowColumnSelection) {\n      return;\n    }\n\n    this.clearColDependency();\n    const selectingArgs = {\n      columnIndex: columnIndexes[0],\n      headerCell: selectedCol,\n      columnIndexes: columnIndexes,\n      column: gObj.getColumnByIndex(columnIndexes[0]),\n      cancel: false,\n      target: this.actualTarget,\n      isInteracted: this.isInteracted,\n      previousColumnIndex: this.prevColIndex,\n      isCtrlPressed: this.isMultiCtrlRequest,\n      isShiftPressed: this.isMultiShiftRequest\n    };\n    this.onActionBegin(selectingArgs, columnSelecting);\n\n    if (selectingArgs.cancel) {\n      this.disableInteracted();\n      return;\n    }\n\n    for (let i = 0, len = columnIndexes.length; i < len; i++) {\n      this.updateColSelection(gObj.getColumnHeaderByUid(gObj.getColumnByIndex(columnIndexes[i]).uid), columnIndexes[i]);\n    }\n\n    selectedCol = this.getselectedCols();\n    const selectedArgs = {\n      columnIndex: columnIndexes[0],\n      headerCell: selectedCol,\n      columnIndexes: columnIndexes,\n      column: gObj.getColumnByIndex(columnIndexes[0]),\n      target: this.actualTarget,\n      isInteracted: this.isInteracted,\n      previousColumnIndex: this.prevColIndex\n    };\n    this.onActionComplete(selectedArgs, columnSelected);\n    this.updateColProps(columnIndexes[0]);\n  }\n  /**\n   * Select the column with existing column by passing column index\n   *\n   * @param  {number} startIndex - specifies the start index\n   * @returns {void}\n   */\n\n\n  selectColumnWithExisting(startIndex) {\n    const gObj = this.parent;\n\n    if (isNullOrUndefined(gObj.getColumns()[startIndex])) {\n      return;\n    }\n\n    const newCol = gObj.getColumnHeaderByUid(gObj.getColumnByIndex(startIndex).uid);\n    let selectedCol = this.getselectedCols();\n\n    if (gObj.selectionSettings.type === 'Single') {\n      this.clearColDependency();\n    }\n\n    if (!gObj.selectionSettings.allowColumnSelection) {\n      return;\n    }\n\n    if (this.selectedColumnsIndexes.indexOf(startIndex) > -1) {\n      this.clearColumnSelection(startIndex);\n    } else {\n      const selectingArgs = {\n        columnIndex: startIndex,\n        headerCell: selectedCol,\n        columnIndexes: this.selectedColumnsIndexes,\n        column: gObj.getColumnByIndex(startIndex),\n        cancel: false,\n        target: this.actualTarget,\n        isInteracted: this.isInteracted,\n        previousColumnIndex: this.prevColIndex,\n        isCtrlPressed: this.isMultiCtrlRequest,\n        isShiftPressed: this.isMultiShiftRequest\n      };\n      this.onActionBegin(selectingArgs, columnSelecting);\n\n      if (selectingArgs.cancel) {\n        this.disableInteracted();\n        return;\n      }\n\n      this.updateColSelection(newCol, startIndex);\n      selectedCol = this.getselectedCols();\n      const selectedArgs = {\n        columnIndex: startIndex,\n        headerCell: selectedCol,\n        column: gObj.getColumnByIndex(startIndex),\n        columnIndexes: this.selectedColumnsIndexes,\n        target: this.actualTarget,\n        isInteracted: this.isInteracted,\n        previousColumnIndex: this.prevColIndex\n      };\n      this.onActionComplete(selectedArgs, columnSelected);\n    }\n\n    this.updateColProps(startIndex);\n  }\n  /**\n   * Clear the column selection\n   *\n   * @param {number} clearIndex - specifies the clearIndex\n   * @returns {void}\n   */\n\n\n  clearColumnSelection(clearIndex) {\n    if (this.isColumnSelected) {\n      const gObj = this.parent;\n\n      if (!isNullOrUndefined(clearIndex) && this.selectedColumnsIndexes.indexOf(clearIndex) === -1) {\n        return;\n      }\n\n      const index = !isNullOrUndefined(clearIndex) ? clearIndex : this.selectedColumnsIndexes[this.selectedColumnsIndexes.length - 1];\n      const col = gObj.getColumnByIndex(index);\n      let selectedCol;\n      const column = gObj.getColumnByIndex(index);\n\n      if (col.getFreezeTableName() === frozenRight) {\n        selectedCol = gObj.getFrozenRightColumnHeaderByIndex(index);\n      } else if (col.getFreezeTableName() === 'movable') {\n        selectedCol = gObj.getMovableColumnHeaderByIndex(index);\n      } else {\n        selectedCol = gObj.getColumnHeaderByUid(column.uid);\n      }\n\n      const deselectedArgs = {\n        columnIndex: index,\n        headerCell: selectedCol,\n        columnIndexes: this.selectedColumnsIndexes,\n        column: column,\n        cancel: false,\n        target: this.actualTarget,\n        isInteracted: this.isInteracted\n      };\n      const isCanceled = this.columnDeselect(deselectedArgs, columnDeselecting);\n\n      if (isCanceled) {\n        this.disableInteracted();\n        return;\n      }\n\n      const selectedHeader = !isNullOrUndefined(clearIndex) ? [selectedCol] : [].slice.call(gObj.getHeaderContent().getElementsByClassName('e-columnselection'));\n      const selectedCells = this.getSelectedColumnCells(clearIndex);\n\n      for (let i = 0, len = selectedHeader.length; i < len; i++) {\n        addRemoveActiveClasses([selectedHeader[i]], false, 'e-columnselection');\n      }\n\n      for (let i = 0, len = selectedCells.length; i < len; i++) {\n        addRemoveActiveClasses([selectedCells[i]], false, 'e-columnselection');\n      }\n\n      if (!isNullOrUndefined(clearIndex)) {\n        this.selectedColumnsIndexes.splice(this.selectedColumnsIndexes.indexOf(clearIndex), 1);\n        this.parent.getColumns()[clearIndex].isSelected = false;\n      } else {\n        this.columnDeselect(deselectedArgs, columnDeselected);\n        this.selectedColumnsIndexes = [];\n        this.isColumnSelected = false;\n        this.parent.getColumns().filter(col => col.isSelected = false);\n      }\n    }\n  }\n\n  getselectedCols() {\n    const gObj = this.parent;\n    let selectedCol;\n\n    if (this.selectedColumnsIndexes.length > 1) {\n      selectedCol = [];\n\n      for (let i = 0; i < this.selectedColumnsIndexes.length; i++) {\n        selectedCol.push(gObj.getColumnHeaderByUid(gObj.getColumnByIndex(this.selectedColumnsIndexes[i]).uid));\n      }\n    } else {\n      selectedCol = gObj.getColumnHeaderByUid(gObj.getColumnByIndex(this.selectedColumnsIndexes[0]).uid);\n    }\n\n    return selectedCol;\n  }\n\n  getSelectedColumnCells(clearIndex) {\n    const gObj = this.parent;\n    const isRowTemplate = !isNullOrUndefined(this.parent.rowTemplate);\n    let rows = isRowTemplate ? gObj.getRows() : gObj.getDataRows();\n    let movableRows;\n    let frRows;\n\n    if (gObj.isFrozenGrid() && gObj.getContent().querySelector('.' + movableContent)) {\n      movableRows = isRowTemplate ? gObj.getMovableRows() : gObj.getMovableDataRows();\n      rows = gObj.addMovableRows(rows, movableRows);\n\n      if (gObj.getFrozenMode() === leftRight) {\n        frRows = isRowTemplate ? gObj.getFrozenRightRows() : gObj.getFrozenRightDataRows();\n        rows = gObj.addMovableRows(rows, frRows);\n      }\n    }\n\n    let seletedcells = [];\n    const selectionString = !isNullOrUndefined(clearIndex) ? '[aria-colindex=\"' + clearIndex + '\"]' : '.e-columnselection';\n\n    for (let i = 0, len = rows.length; i < len; i++) {\n      seletedcells = seletedcells.concat([].slice.call(rows[i].querySelectorAll(selectionString)));\n    }\n\n    return seletedcells;\n  }\n\n  columnDeselect(args, event) {\n    if (event === 'columnDeselected') {\n      delete args.cancel;\n    }\n\n    this.onActionComplete(args, event);\n    return args.cancel;\n  }\n\n  updateColProps(startIndex) {\n    this.prevColIndex = startIndex;\n    this.isColumnSelected = this.selectedColumnsIndexes.length && true;\n  }\n\n  clearColDependency() {\n    this.clearColumnSelection();\n    this.selectedColumnsIndexes = [];\n  }\n\n  updateColSelection(selectedCol, startIndex) {\n    if (isNullOrUndefined(this.parent.getColumns()[startIndex])) {\n      return;\n    }\n\n    const left = this.parent.getFrozenLeftCount();\n    const movable = this.parent.getMovableColumnsCount();\n    const col = this.parent.getColumnByIndex(startIndex);\n    const isRowTemplate = !isNullOrUndefined(this.parent.rowTemplate);\n    let rows;\n    this.selectedColumnsIndexes.push(startIndex);\n    this.parent.getColumns()[startIndex].isSelected = true;\n\n    if (col.getFreezeTableName() === frozenRight) {\n      startIndex = startIndex - (left + movable);\n      rows = isRowTemplate ? this.parent.getFrozenRightRows() : this.parent.getFrozenRightDataRows();\n    } else if (col.getFreezeTableName() === 'movable') {\n      startIndex = startIndex - left;\n      rows = isRowTemplate ? this.parent.getMovableRows() : this.parent.getMovableDataRows();\n    } else {\n      startIndex = startIndex + this.parent.getIndentCount();\n      rows = isRowTemplate ? this.parent.getRows() : this.parent.getDataRows();\n    }\n\n    addRemoveActiveClasses([selectedCol], true, 'e-columnselection');\n\n    for (let j = 0, len = rows.length; j < len; j++) {\n      if (rows[j].classList.contains(row)) {\n        if ((rows[j].classList.contains(editedRow) || rows[j].classList.contains(addedRow)) && this.parent.editSettings.mode === 'Normal' && !isNullOrUndefined(rows[j].querySelector('tr').childNodes[startIndex])) {\n          addRemoveActiveClasses([rows[j].querySelector('tr').childNodes[startIndex]], true, 'e-columnselection');\n        } else if (!isNullOrUndefined(rows[j].childNodes[startIndex])) {\n          addRemoveActiveClasses([rows[j].childNodes[startIndex]], true, 'e-columnselection');\n        }\n      }\n    }\n  }\n\n  headerSelectionHandler(colIndex) {\n    if (!this.isMultiCtrlRequest && !this.isMultiShiftRequest || this.isSingleSel()) {\n      this.selectColumn(colIndex);\n    } else if (this.isMultiShiftRequest) {\n      this.selectColumnsByRange(isUndefined(this.prevColIndex) ? colIndex : this.prevColIndex, colIndex);\n    } else {\n      this.selectColumnWithExisting(colIndex);\n    }\n  } // eslint-disable-next-line camelcase\n\n\n  addEventListener_checkbox() {\n    this.parent.on(dataReady, this.dataReady, this);\n    this.onDataBoundFunction = this.onDataBound.bind(this);\n    this.parent.addEventListener(dataBound, this.onDataBoundFunction);\n    this.parent.on(refreshInfinitePersistSelection, this.onDataBoundFunction);\n    this.parent.on(contentReady, this.checkBoxSelectionChanged, this);\n    this.parent.on(beforeRefreshOnDataChange, this.initPerisistSelection, this);\n    this.parent.on(onEmpty, this.setCheckAllForEmptyGrid, this);\n    this.actionCompleteFunc = this.actionCompleteHandler.bind(this);\n    this.parent.addEventListener(actionComplete, this.actionCompleteFunc);\n    this.parent.on(click, this.clickHandler, this);\n\n    this.resizeEndFn = () => {\n      this.updateAutoFillPosition();\n      this.drawBorders();\n    };\n\n    this.resizeEndFn.bind(this);\n    this.parent.addEventListener(resizeStop, this.resizeEndFn);\n  } // eslint-disable-next-line camelcase\n\n\n  removeEventListener_checkbox() {\n    this.parent.off(dataReady, this.dataReady);\n    this.parent.removeEventListener(dataBound, this.onDataBoundFunction);\n    this.parent.removeEventListener(actionComplete, this.actionCompleteFunc);\n    this.parent.off(refreshInfinitePersistSelection, this.onDataBoundFunction);\n    this.parent.off(onEmpty, this.setCheckAllForEmptyGrid);\n    this.parent.off(click, this.clickHandler);\n    this.parent.off(beforeRefreshOnDataChange, this.initPerisistSelection);\n  }\n\n  setCheckAllForEmptyGrid() {\n    const checkAllBox = this.getCheckAllBox();\n\n    if (checkAllBox) {\n      this.parent.isCheckBoxSelection = true;\n      const spanEle = checkAllBox.nextElementSibling;\n      removeClass([spanEle], ['e-check', 'e-stop', 'e-uncheck']);\n    }\n  }\n\n  dataReady(e) {\n    this.isHeaderCheckboxClicked = false;\n    const isInfinitecroll = this.parent.enableInfiniteScrolling && e.requestType === 'infiniteScroll';\n\n    if (e.requestType !== 'virtualscroll' && !this.parent.isPersistSelection && !isInfinitecroll) {\n      this.disableUI = !this.parent.enableImmutableMode;\n      this.clearSelection();\n      this.setCheckAllState();\n      this.disableUI = false;\n    }\n  }\n\n  actionCompleteHandler(e) {\n    if (e.requestType === 'save' && this.parent.isPersistSelection) {\n      this.refreshPersistSelection();\n    }\n  }\n\n  selectRowIndex(index) {\n    this.parent.isSelectedRowIndexUpdating = true;\n    this.parent.selectedRowIndex = index;\n  }\n\n  disableInteracted() {\n    this.isInteracted = false;\n  }\n\n  activeTarget() {\n    this.actualTarget = this.isInteracted ? this.actualTarget : null;\n  }\n\n}\n/**\n * The `Search` module is used to handle search action.\n */\n\n\nclass Search {\n  /**\n   * Constructor for Grid search module.\n   *\n   * @param {IGrid} parent - specifies the IGrid\n   * @hidden\n   */\n  constructor(parent) {\n    this.parent = parent;\n    this.addEventListener();\n  }\n  /**\n   * Searches Grid records by given key.\n   *\n   * > You can customize the default search action by using [`searchSettings`](grid/#searchsettings/).\n   *\n   * @param  {string} searchString - Defines the key.\n   * @returns {void}\n   */\n\n\n  search(searchString) {\n    const gObj = this.parent;\n    searchString = isNullOrUndefined(searchString) ? '' : searchString;\n\n    if (isActionPrevent(gObj)) {\n      gObj.notify(preventBatch, {\n        instance: this,\n        handler: this.search,\n        arg1: searchString\n      });\n      return;\n    }\n\n    if (searchString !== gObj.searchSettings.key) {\n      gObj.searchSettings.key = searchString.toString();\n      gObj.dataBind();\n    } else if (this.refreshSearch) {\n      gObj.refresh();\n    }\n  }\n  /**\n   * @returns {void}\n   * @hidden\n   */\n\n\n  addEventListener() {\n    if (this.parent.isDestroyed) {\n      return;\n    }\n\n    this.parent.on(inBoundModelChanged, this.onPropertyChanged, this);\n    this.parent.on(searchComplete, this.onSearchComplete, this);\n    this.parent.on(destroy, this.destroy, this);\n    this.actionCompleteFunc = this.onActionComplete.bind(this);\n    this.parent.addEventListener(actionComplete, this.actionCompleteFunc);\n    this.parent.on(cancelBegin, this.cancelBeginEvent, this);\n  }\n  /**\n   * @returns {void}\n   * @hidden\n   */\n\n\n  removeEventListener() {\n    if (this.parent.isDestroyed) {\n      return;\n    }\n\n    this.parent.off(inBoundModelChanged, this.onPropertyChanged);\n    this.parent.off(searchComplete, this.onSearchComplete);\n    this.parent.off(destroy, this.destroy);\n    this.parent.removeEventListener(actionComplete, this.actionCompleteFunc);\n    this.parent.off(cancelBegin, this.cancelBeginEvent);\n  }\n  /**\n   * To destroy the print\n   *\n   * @returns {void}\n   * @hidden\n   */\n\n\n  destroy() {\n    this.removeEventListener();\n  }\n  /**\n   * @param {NotifyArgs} e - specfies the NotifyArgs\n   * @returns {void}\n   * @hidden\n   */\n\n\n  onPropertyChanged(e) {\n    if (e.module !== this.getModuleName()) {\n      return;\n    }\n\n    if (!isNullOrUndefined(e.properties.key)) {\n      this.parent.notify(modelChanged, {\n        requestType: 'searching',\n        type: actionBegin,\n        searchString: this.parent.searchSettings.key\n      });\n    } else {\n      this.parent.notify(modelChanged, {\n        requestType: 'searching',\n        type: actionBegin\n      });\n    }\n  }\n  /**\n   * The function used to trigger onActionComplete\n   *\n   * @param {NotifyArgs} e - specifies the NotifyArgs\n   * @returns {void}\n   * @hidden\n   */\n\n\n  onSearchComplete(e) {\n    this.parent.trigger(actionComplete, extend(e, {\n      searchString: this.parent.searchSettings.key,\n      requestType: 'searching',\n      type: actionComplete\n    }));\n  }\n  /**\n   * The function used to store the requestType\n   *\n   * @param {NotifyArgs} e - specifies the NotifyArgs\n   * @returns {void}\n   * @hidden\n   */\n\n\n  onActionComplete(e) {\n    this.refreshSearch = e.requestType !== 'searching';\n  }\n\n  cancelBeginEvent(e) {\n    if (e.requestType === 'searching') {\n      this.parent.setProperties({\n        searchSettings: {\n          key: ''\n        }\n      }, true);\n    }\n  }\n  /**\n   * For internal use only - Get the module name.\n   *\n   * @returns {string} returns the module name\n   * @private\n   */\n\n\n  getModuleName() {\n    return 'search';\n  }\n\n}\n/**\n * The `ShowHide` module is used to control column visibility.\n */\n\n\nclass ShowHide {\n  /**\n   * Constructor for the show hide module.\n   *\n   * @param {IGrid} parent - specifies the IGrid\n   * @hidden\n   */\n  constructor(parent) {\n    this.parent = parent;\n  }\n  /**\n   * Shows a column by column name.\n   *\n   * @param  {string|string[]} columnName - Defines a single or collection of column names to show.\n   * @param  {string} showBy - Defines the column key either as field name or header text.\n   * @returns {void}\n   */\n\n\n  show(columnName, showBy) {\n    const keys = this.getToggleFields(columnName);\n    const columns = this.getColumns(keys, showBy);\n    this.parent.notify(tooltipDestroy, {\n      module: 'edit'\n    });\n\n    for (let i = 0; i < columns.length; i++) {\n      columns[i].visible = true;\n    }\n\n    this.setVisible(columns);\n  }\n  /**\n   * Hides a column by column name.\n   *\n   * @param  {string|string[]} columnName - Defines a single or collection of column names to hide.\n   * @param  {string} hideBy - Defines the column key either as field name or header text.\n   * @returns {void}\n   */\n\n\n  hide(columnName, hideBy) {\n    const keys = this.getToggleFields(columnName);\n    const columns = this.getColumns(keys, hideBy);\n    this.parent.notify(tooltipDestroy, {\n      module: 'edit'\n    });\n\n    for (let i = 0; i < columns.length; i++) {\n      columns[i].visible = false;\n    }\n\n    this.setVisible(columns);\n  }\n\n  getToggleFields(key) {\n    let finalized = [];\n\n    if (typeof key === 'string') {\n      finalized = [key];\n    } else {\n      finalized = key;\n    }\n\n    return finalized;\n  }\n\n  getColumns(keys, getKeyBy) {\n    const columns = iterateArrayOrObject(keys, key => {\n      return iterateArrayOrObject(this.parent.columnModel, item => {\n        if (item[getKeyBy] === key) {\n          return item;\n        }\n\n        return undefined;\n      })[0];\n    });\n    return columns;\n  }\n  /**\n   * Shows or hides columns by given column collection.\n   *\n   * @private\n   * @param {Column[]} columns - Specifies the columns.\n   * @param {Column[]} changedStateColumns - specifies the changedStateColumns\n   * @returns {void}\n   */\n\n\n  setVisible(columns, changedStateColumns = []) {\n    changedStateColumns = changedStateColumns.length > 0 ? changedStateColumns : columns;\n    const args = {\n      requestType: 'columnstate',\n      cancel: false,\n      columns: changedStateColumns\n    };\n    const cancel = 'cancel';\n    this.parent.trigger(actionBegin, args, showHideArgs => {\n      const currentViewCols = this.parent.getColumns();\n      columns = isNullOrUndefined(columns) ? currentViewCols : columns;\n\n      if (showHideArgs[cancel]) {\n        this.parent.notify(resetColumns, {\n          showHideArgs: showHideArgs\n        });\n\n        if (columns.length > 0) {\n          columns[0].visible = true;\n        }\n\n        return;\n      }\n\n      if (isGroupAdaptive(this.parent)) {\n        this.parent.contentModule.emptyVcRows();\n      }\n\n      if (this.parent.allowSelection && this.parent.getSelectedRecords().length && !this.parent.selectionSettings.persistSelection) {\n        this.parent.clearSelection();\n      }\n\n      if (this.parent.enableColumnVirtualization) {\n        const colsInCurrentView = columns.filter(col1 => currentViewCols.some(col2 => col1.field === col2.field));\n\n        if (colsInCurrentView.length) {\n          this.parent.notify(columnVisibilityChanged, columns);\n        }\n      } else {\n        this.parent.notify(columnVisibilityChanged, columns);\n      }\n\n      const params = {\n        requestType: 'columnstate',\n        columns: changedStateColumns\n      };\n      this.parent.trigger(actionComplete, params);\n\n      if (this.parent.columnQueryMode !== 'All') {\n        this.parent.refresh();\n      }\n    });\n  }\n\n}\n/**\n * The `Scroll` module is used to handle scrolling behaviour.\n */\n\n\nclass Scroll {\n  /**\n   * Constructor for the Grid scrolling.\n   *\n   * @param {IGrid} parent - specifies the IGrid\n   * @hidden\n   */\n  constructor(parent) {\n    //To maintain scroll state on grid actions.\n    this.previousValues = {\n      top: 0,\n      left: 0\n    };\n    this.oneTimeReady = true;\n    this.parent = parent;\n    this.widthService = new ColumnWidthService(parent);\n    this.addEventListener();\n  }\n  /**\n   * For internal use only - Get the module name.\n   *\n   * @returns {string} returns the module name\n   * @private\n   */\n\n\n  getModuleName() {\n    return 'scroll';\n  }\n  /**\n   * @param {boolean} uiupdate - specifies the uiupdate\n   * @returns {void}\n   * @hidden\n   */\n\n\n  setWidth(uiupdate) {\n    this.parent.element.style.width = formatUnit(this.parent.width);\n\n    if (uiupdate) {\n      this.widthService.setWidthToColumns();\n    }\n\n    if (this.parent.toolbarModule && this.parent.toolbarModule.toolbar && this.parent.toolbarModule.toolbar.element) {\n      this.parent.toolbarModule.toolbar.refreshOverflow();\n    }\n  }\n  /**\n   * @returns {void}\n   * @hidden\n   */\n\n\n  setHeight() {\n    let mHdrHeight = 0;\n    const content$$1 = this.parent.getContent().querySelector('.' + content);\n    let height = this.parent.height;\n\n    if (this.parent.isFrozenGrid() && this.parent.height !== 'auto' && this.parent.height.toString().indexOf('%') < 0) {\n      height = parseInt(height, 10) - Scroll.getScrollBarWidth();\n    }\n\n    if (!this.parent.enableVirtualization && this.parent.frozenRows && this.parent.height !== 'auto') {\n      const tbody$$1 = this.parent.getHeaderContent().querySelector(tbody);\n      mHdrHeight = tbody$$1 ? tbody$$1.offsetHeight : 0;\n\n      if (tbody$$1 && mHdrHeight) {\n        const add = tbody$$1.getElementsByClassName(addedRow).length;\n        const height = add * this.parent.getRowHeight();\n        mHdrHeight -= height;\n      }\n\n      content$$1.style.height = formatUnit(height - mHdrHeight);\n    } else {\n      content$$1.style.height = formatUnit(height);\n    }\n\n    this.ensureOverflow(content$$1);\n\n    if (this.parent.isFrozenGrid()) {\n      this.refresh();\n    }\n  }\n  /**\n   * @returns {void}\n   * @hidden\n   */\n\n\n  setPadding() {\n    const content$$1 = this.parent.getHeaderContent();\n    const scrollWidth = Scroll.getScrollBarWidth() - this.getThreshold();\n    const cssProps = this.getCssProperties();\n    const padding = this.parent.getFrozenMode() === 'Right' || this.parent.getFrozenMode() === leftRight ? '0.5px' : '1px';\n    content$$1.querySelector('.' + headerContent).style[cssProps.border] = scrollWidth > 0 ? padding : '0px';\n    content$$1.style[cssProps.padding] = scrollWidth > 0 ? scrollWidth + 'px' : '0px';\n  }\n  /**\n   * @param {boolean} rtl - specifies the rtl\n   * @returns {void}\n   * @hidden\n   */\n\n\n  removePadding(rtl) {\n    const cssProps = this.getCssProperties(rtl);\n    const hDiv = this.parent.getHeaderContent().querySelector('.' + headerContent);\n    hDiv.style[cssProps.border] = '';\n    hDiv.parentElement.style[cssProps.padding] = '';\n    const footerDiv = this.parent.getFooterContent();\n\n    if (footerDiv && footerDiv.classList.contains('e-footerpadding')) {\n      footerDiv.classList.remove('e-footerpadding');\n    }\n  }\n  /**\n   * Refresh makes the Grid adoptable with the height of parent container.\n   *\n   * > The [`height`](grid/#height/) must be set to 100%.\n   *\n   * @returns {void}\n   */\n\n\n  refresh() {\n    if (this.parent.height !== '100%') {\n      return;\n    }\n\n    const content$$1 = this.parent.getContent();\n    this.parent.element.style.height = '100%';\n    const height = this.widthService.getSiblingsHeight(content$$1);\n    content$$1.style.height = 'calc(100% - ' + height + 'px)'; //Set the height to the  '.' + literals.gridContent;\n\n    if (this.parent.isFrozenGrid()) {\n      content$$1.firstElementChild.style.height = 'calc(100% - ' + getScrollBarWidth() + 'px)';\n    }\n  }\n\n  getThreshold() {\n    /* Some browsers places the scroller outside the content,\n     * hence the padding should be adjusted.*/\n    const appName = Browser.info.name;\n\n    if (appName === 'mozilla') {\n      return 0.5;\n    }\n\n    return 1;\n  }\n  /**\n   * @returns {void}\n   * @hidden\n   */\n\n\n  addEventListener() {\n    if (this.parent.isDestroyed) {\n      return;\n    }\n\n    this.parent.on(onEmpty, this.wireEvents, this);\n    this.parent.on(contentReady, this.wireEvents, this);\n    this.parent.on(uiUpdate, this.onPropertyChanged, this);\n    this.parent.on(textWrapRefresh, this.wireEvents, this);\n    this.parent.on(headerRefreshed, this.setScrollLeft, this);\n  }\n  /**\n   * @returns {void}\n   * @hidden\n   */\n\n\n  removeEventListener() {\n    if (this.parent.isDestroyed) {\n      return;\n    }\n\n    this.parent.off(onEmpty, this.wireEvents);\n    this.parent.off(contentReady, this.wireEvents);\n    this.parent.off(uiUpdate, this.onPropertyChanged);\n    this.parent.off(textWrapRefresh, this.wireEvents);\n    this.parent.off(headerRefreshed, this.setScrollLeft);\n  }\n\n  setScrollLeft() {\n    if (this.parent.isFrozenGrid()) {\n      this.parent.headerModule.getMovableHeader().scrollLeft = this.previousValues.left;\n    } else {\n      this.parent.getHeaderContent().querySelector('.' + headerContent).scrollLeft = this.previousValues.left;\n    }\n  }\n\n  onFrozenContentScroll() {\n    return e => {\n      if (this.content.querySelector(tbody) === null || this.parent.isPreventScrollEvent) {\n        return;\n      }\n\n      if (!isNullOrUndefined(this.parent.infiniteScrollModule) && this.parent.enableInfiniteScrolling) {\n        this.parent.notify(infiniteScrollHandler, e);\n      }\n\n      this.previousValues.top = e.target.scrollTop;\n    };\n  }\n\n  onContentScroll(scrollTarget) {\n    const element = scrollTarget;\n    const isHeader = element.classList.contains(headerContent);\n    return e => {\n      if (this.content.querySelector(tbody) === null || this.parent.isPreventScrollEvent) {\n        return;\n      }\n\n      const target = e.target;\n      const left = target.scrollLeft;\n\n      if (!isNullOrUndefined(this.parent.infiniteScrollModule) && this.parent.enableInfiniteScrolling) {\n        this.parent.notify(infiniteScrollHandler, {\n          target: e.target,\n          isLeft: this.previousValues.left !== left\n        });\n      }\n\n      if (this.parent.groupSettings.columns.length && this.parent.groupSettings.enableLazyLoading) {\n        const isDown = this.previousValues.top < this.parent.getContent().firstElementChild.scrollTop;\n        this.parent.notify(lazyLoadScrollHandler, {\n          scrollDown: isDown\n        });\n      }\n\n      this.parent.notify(virtualScrollEdit, {});\n      const isFooter = target.classList.contains('e-summarycontent');\n\n      if (this.previousValues.left === left) {\n        this.previousValues.top = !isHeader ? this.previousValues.top : target.scrollTop;\n        return;\n      }\n\n      this.parent.notify(closeFilterDialog, e);\n      element.scrollLeft = left;\n\n      if (isFooter) {\n        this.header.scrollLeft = left;\n      }\n\n      this.previousValues.left = left;\n      this.parent.notify(scroll, {\n        left: left\n      });\n    };\n  }\n\n  onCustomScrollbarScroll(mCont, mHdr) {\n    const content$$1 = mCont;\n    const header = mHdr;\n    return e => {\n      if (this.content.querySelector(tbody) === null) {\n        return;\n      }\n\n      const target = e.target;\n      const left = target.scrollLeft;\n\n      if (this.previousValues.left === left) {\n        return;\n      }\n\n      content$$1.scrollLeft = left;\n      header.scrollLeft = left;\n      this.previousValues.left = left;\n      this.parent.notify(scroll, {\n        left: left\n      });\n\n      if (this.parent.isDestroyed) {\n        return;\n      }\n    };\n  }\n\n  onTouchScroll(scrollTarget) {\n    const element = scrollTarget;\n    return e => {\n      if (e.pointerType === 'mouse') {\n        return;\n      }\n\n      const isFrozen = this.parent.isFrozenGrid();\n      const pageXY = this.getPointXY(e);\n      const left = element.scrollLeft + (this.pageXY.x - pageXY.x);\n      const mHdr = isFrozen ? this.parent.getHeaderContent().querySelector('.' + movableHeader) : this.parent.getHeaderContent().querySelector('.' + headerContent);\n      const mCont = isFrozen ? this.parent.getContent().querySelector('.' + movableContent) : this.parent.getContent().querySelector('.' + content);\n\n      if (this.previousValues.left === left || left < 0 || mHdr.scrollWidth - mHdr.clientWidth < left) {\n        return;\n      }\n\n      e.preventDefault();\n      mHdr.scrollLeft = left;\n      mCont.scrollLeft = left;\n\n      if (isFrozen) {\n        const scrollBar = this.parent.getContent().querySelector('.e-movablescrollbar');\n        scrollBar.scrollLeft = left;\n      }\n\n      this.pageXY.x = pageXY.x;\n      this.previousValues.left = left;\n    };\n  }\n\n  setPageXY() {\n    return e => {\n      if (e.pointerType === 'mouse') {\n        return;\n      }\n\n      this.pageXY = this.getPointXY(e);\n    };\n  }\n\n  getPointXY(e) {\n    const pageXY = {\n      x: 0,\n      y: 0\n    };\n\n    if (e.touches && e.touches.length) {\n      pageXY.x = e.touches[0].pageX;\n      pageXY.y = e.touches[0].pageY;\n    } else {\n      pageXY.x = e.pageX;\n      pageXY.y = e.pageY;\n    }\n\n    return pageXY;\n  }\n\n  getScrollbleParent(node) {\n    if (node === null) {\n      return null;\n    }\n\n    const parent = isNullOrUndefined(node.tagName) ? node.scrollingElement : node;\n    const overflowY = document.defaultView.getComputedStyle(parent, null).overflowY;\n\n    if (parent.scrollHeight > parent.clientHeight && overflowY !== 'hidden' && overflowY !== 'visible' || node.tagName === \"HTML\" || node.tagName === \"BODY\") {\n      return node;\n    } else {\n      return this.getScrollbleParent(node.parentNode);\n    }\n  }\n  /**\n   * @param {boolean} isAdd - specifies whether adding/removing the event\n   * @returns {void}\n   * @hidden\n   */\n\n\n  addStickyListener(isAdd) {\n    if (isAdd) {\n      this.parentElement = this.getScrollbleParent(this.parent.element.parentElement);\n\n      if (this.parentElement) {\n        EventHandler.add(this.parentElement.tagName === 'HTML' || this.parentElement.tagName === 'BODY' ? document : this.parentElement, 'scroll', this.makeStickyHeader, this);\n      }\n    } else {\n      EventHandler.remove(this.parentElement, 'scroll', this.makeStickyHeader);\n    }\n  }\n\n  wireEvents() {\n    if (this.oneTimeReady) {\n      const frzCols = this.parent.isFrozenGrid();\n      this.content = this.parent.getContent().querySelector('.' + content);\n      this.header = this.parent.getHeaderContent().querySelector('.' + headerContent);\n      const mCont = this.content.querySelector('.' + movableContent);\n      const mHdr = this.header.querySelector('.' + movableHeader);\n      const mScrollBar = this.parent.getContent().querySelector('.e-movablescrollbar');\n\n      if (this.parent.frozenRows) {\n        EventHandler.add(frzCols ? mHdr : this.header, 'touchstart pointerdown', this.setPageXY(), this);\n        EventHandler.add(frzCols ? mHdr : this.header, 'touchmove pointermove', this.onTouchScroll(frzCols ? mCont : this.content), this);\n      }\n\n      if (this.parent.isFrozenGrid()) {\n        EventHandler.add(mScrollBar, 'scroll', this.onCustomScrollbarScroll(mCont, mHdr), this);\n        EventHandler.add(mCont, 'scroll', this.onCustomScrollbarScroll(mScrollBar, mHdr), this);\n        EventHandler.add(mHdr, 'scroll', this.onCustomScrollbarScroll(mScrollBar, mCont), this);\n        EventHandler.add(this.content, 'scroll', this.onFrozenContentScroll(), this);\n        EventHandler.add(mHdr, 'touchstart pointerdown', this.setPageXY(), this);\n        EventHandler.add(mHdr, 'touchmove pointermove', this.onTouchScroll(mCont), this);\n        EventHandler.add(mCont, 'touchstart pointerdown', this.setPageXY(), this);\n\n        if (!(/macintosh|ipad/.test(Browser.userAgent.toLowerCase()) && Browser.isDevice)) {\n          EventHandler.add(mCont, 'touchmove pointermove', this.onTouchScroll(mHdr), this);\n        }\n      } else {\n        EventHandler.add(this.content, 'scroll', this.onContentScroll(this.header), this);\n        EventHandler.add(this.header, 'scroll', this.onContentScroll(this.content), this);\n      }\n\n      if (this.parent.aggregates.length) {\n        EventHandler.add(this.parent.getFooterContent().firstChild, 'scroll', this.onContentScroll(this.content), this);\n      }\n\n      if (this.parent.enableStickyHeader) {\n        this.addStickyListener(true);\n      }\n\n      this.refresh();\n      this.oneTimeReady = false;\n    }\n\n    const table$$1 = this.parent.getContentTable();\n    let sLeft;\n    let sHeight;\n    let clientHeight;\n    getUpdateUsingRaf(() => {\n      sLeft = this.header.scrollLeft;\n      sHeight = table$$1.scrollHeight;\n      clientHeight = this.parent.getContent().clientHeight;\n    }, () => {\n      const args = {\n        cancel: false\n      };\n      this.parent.notify(checkScrollReset, args);\n\n      if (!this.parent.enableVirtualization && !this.parent.enableInfiniteScrolling) {\n        if (sHeight < clientHeight) {\n          addClass(table$$1.querySelectorAll('tr:last-child td'), 'e-lastrowcell');\n\n          if (this.parent.isFrozenGrid()) {\n            addClass(this.parent.getContent().querySelector('.' + movableContent).querySelectorAll('tr:last-child td'), 'e-lastrowcell');\n\n            if (this.parent.getFrozenRightColumnsCount()) {\n              addClass(this.parent.getContent().querySelector('.e-frozen-right-content').querySelectorAll('tr:last-child td'), 'e-lastrowcell');\n            }\n          }\n        }\n\n        if (!args.cancel) {\n          if ((this.parent.frozenRows > 0 || this.parent.isFrozenGrid()) && this.header.querySelector('.' + movableHeader)) {\n            this.header.querySelector('.' + movableHeader).scrollLeft = this.previousValues.left;\n          } else {\n            this.header.scrollLeft = this.previousValues.left;\n          }\n\n          this.content.scrollLeft = this.previousValues.left;\n          this.content.scrollTop = this.previousValues.top;\n        }\n      }\n\n      if (!this.parent.enableColumnVirtualization) {\n        this.content.scrollLeft = sLeft;\n      }\n\n      if (this.parent.isFrozenGrid() && this.header.querySelector('.' + movableHeader)) {\n        this.header.querySelector('.' + movableHeader).scrollLeft = this.content.querySelector('.' + movableContent).scrollLeft;\n      }\n    });\n    this.parent.isPreventScrollEvent = false;\n  }\n  /**\n   * @param {boolean} rtl - specifies the rtl\n   * @returns {ScrollCss} returns the ScrollCss\n   * @hidden\n   */\n\n\n  getCssProperties(rtl) {\n    const css = {};\n    const enableRtl = isNullOrUndefined(rtl) ? this.parent.enableRtl : rtl;\n    css.border = enableRtl ? 'borderLeftWidth' : 'borderRightWidth';\n    css.padding = enableRtl ? 'paddingLeft' : 'paddingRight';\n    return css;\n  }\n\n  ensureOverflow(content$$1) {\n    content$$1.style.overflowY = this.parent.height === 'auto' ? 'auto' : 'scroll';\n  }\n\n  onPropertyChanged(e) {\n    if (e.module !== this.getModuleName()) {\n      return;\n    }\n\n    this.setPadding();\n    this.oneTimeReady = true;\n\n    if (this.parent.height === 'auto') {\n      this.removePadding();\n    }\n\n    this.wireEvents();\n    this.setHeight();\n    const width = 'width';\n    this.setWidth(!isNullOrUndefined(e.properties[width]));\n  }\n\n  makeStickyHeader() {\n    if (this.parent.enableStickyHeader && this.parent.element && this.parent.getContent()) {\n      const contentRect = this.parent.getContent().getClientRects()[0];\n\n      if (contentRect) {\n        const headerEle = this.parent.getHeaderContent();\n        const toolbarEle = this.parent.element.querySelector('.e-toolbar');\n        const groupHeaderEle = this.parent.element.querySelector('.e-groupdroparea');\n        const height = headerEle.offsetHeight + (toolbarEle ? toolbarEle.offsetHeight : 0) + (groupHeaderEle ? groupHeaderEle.offsetHeight : 0);\n        const parentTop = this.parentElement.getClientRects()[0].top;\n        const top = contentRect.top - (parentTop < 0 ? 0 : parentTop);\n        const left = contentRect.left;\n\n        if (top < height && contentRect.bottom > 0) {\n          headerEle.classList.add('e-sticky');\n          let elemTop = 0;\n\n          if (groupHeaderEle) {\n            this.setSticky(groupHeaderEle, elemTop, contentRect.width, left, true);\n            elemTop += groupHeaderEle.getClientRects()[0].height;\n          }\n\n          if (toolbarEle) {\n            this.setSticky(toolbarEle, elemTop, contentRect.width, left, true);\n            elemTop += toolbarEle.getClientRects()[0].height;\n          }\n\n          this.setSticky(headerEle, elemTop, contentRect.width, left, true);\n        } else {\n          if (headerEle.classList.contains('e-sticky')) {\n            this.setSticky(headerEle, null, null, null, false);\n\n            if (toolbarEle) {\n              this.setSticky(toolbarEle, null, null, null, false);\n            }\n\n            if (groupHeaderEle) {\n              this.setSticky(groupHeaderEle, null, null, null, false);\n            }\n\n            const ccDlg = this.parent.element.querySelector('.e-ccdlg');\n\n            if (ccDlg) {\n              ccDlg.classList.remove('e-sticky');\n            }\n          }\n        }\n\n        this.parent.notify(stickyScrollComplete, {});\n      }\n    }\n  }\n\n  setSticky(ele, top, width, left, isAdd) {\n    if (isAdd) {\n      ele.style.width = width + 'px';\n      ele.classList.add('e-sticky');\n    } else {\n      ele.classList.remove('e-sticky');\n    }\n\n    ele.style.top = top != null ? top + 'px' : '';\n    ele.style.left = left !== null ? parseInt(ele.style.left, 10) !== left ? left + 'px' : ele.style.left : '';\n  }\n  /**\n   * @returns {void}\n   * @hidden\n   */\n\n\n  destroy() {\n    const gridElement = this.parent.element;\n\n    if (!gridElement || !gridElement.querySelector('.' + gridHeader) && !gridElement.querySelector('.' + gridContent)) {\n      return;\n    }\n\n    this.removeEventListener(); //Remove padding\n\n    this.removePadding();\n    const cont = this.parent.getContent().querySelector('.' + content);\n    removeClass([this.parent.getHeaderContent().querySelector('.' + headerContent)], headerContent);\n    removeClass([cont], content); //Remove height\n\n    cont.style.height = ''; //Remove width\n\n    this.parent.element.style.width = ''; //Remove Dom event\n\n    EventHandler.remove(cont, 'scroll', this.onContentScroll);\n\n    if (this.parent.enableStickyHeader) {\n      this.addStickyListener(false);\n    }\n  }\n  /**\n   * Function to get the scrollbar width of the browser.\n   *\n   * @returns {number} return the width\n   * @hidden\n   */\n\n\n  static getScrollBarWidth() {\n    return getScrollBarWidth();\n  }\n\n}\n\nvar __decorate$4 = undefined && undefined.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n/**\n * Configures the Grid's aggregate column.\n */\n\n\nclass AggregateColumn extends ChildProperty {\n  constructor() {\n    super(...arguments);\n    this.templateFn = {};\n  }\n  /**\n   * @param {Function} value - specifies the value\n   * @returns {void}\n   * @hidden\n   */\n\n\n  setFormatter(value) {\n    this.formatFn = value;\n  }\n  /**\n   * @returns {Function} returns the Function\n   * @hidden\n   */\n\n\n  getFormatter() {\n    return this.formatFn;\n  }\n  /**\n   * @param {Object} helper - specifies the helper\n   * @returns {void}\n   * @hidden\n   */\n\n\n  setTemplate(helper = {}) {\n    if (this.footerTemplate !== undefined) {\n      this.templateFn[getEnumValue(CellType, CellType.Summary)] = {\n        fn: compile(this.footerTemplate, helper),\n        property: 'footerTemplate'\n      };\n    }\n\n    if (this.groupFooterTemplate !== undefined) {\n      this.templateFn[getEnumValue(CellType, CellType.GroupSummary)] = {\n        fn: compile(this.groupFooterTemplate, helper),\n        property: 'groupFooterTemplate'\n      };\n    }\n\n    if (this.groupCaptionTemplate !== undefined) {\n      this.templateFn[getEnumValue(CellType, CellType.CaptionSummary)] = {\n        fn: compile(this.groupCaptionTemplate, helper),\n        property: 'groupCaptionTemplate'\n      };\n    }\n  }\n  /**\n   * @param {CellType} type - specifies the cell type\n   * @returns {Object} returns the object\n   * @hidden\n   */\n\n\n  getTemplate(type) {\n    return this.templateFn[getEnumValue(CellType, type)];\n  }\n  /**\n   * @param {Object} prop - returns the Object\n   * @returns {void}\n   * @hidden\n   */\n\n\n  setPropertiesSilent(prop) {\n    this.setProperties(prop, true);\n  }\n\n}\n\n__decorate$4([Property()], AggregateColumn.prototype, \"type\", void 0);\n\n__decorate$4([Property()], AggregateColumn.prototype, \"field\", void 0);\n\n__decorate$4([Property()], AggregateColumn.prototype, \"columnName\", void 0);\n\n__decorate$4([Property()], AggregateColumn.prototype, \"format\", void 0);\n\n__decorate$4([Property()], AggregateColumn.prototype, \"footerTemplate\", void 0);\n\n__decorate$4([Property()], AggregateColumn.prototype, \"groupFooterTemplate\", void 0);\n\n__decorate$4([Property()], AggregateColumn.prototype, \"groupCaptionTemplate\", void 0);\n\n__decorate$4([Property()], AggregateColumn.prototype, \"customAggregate\", void 0);\n/**\n * Configures the aggregate rows.\n */\n\n\nclass AggregateRow extends ChildProperty {}\n\n__decorate$4([Collection([], AggregateColumn)], AggregateRow.prototype, \"columns\", void 0);\n/**\n * The `Clipboard` module is used to handle clipboard copy action.\n */\n\n\nclass Clipboard {\n  /**\n   * Constructor for the Grid clipboard module\n   *\n   * @param {IGrid} parent - specifies the IGrid\n   * @hidden\n   */\n  constructor(parent) {\n    this.copyContent = '';\n    this.isSelect = false;\n    this.parent = parent;\n    this.addEventListener();\n  }\n  /**\n   * @returns {void}\n   * @hidden\n   */\n\n\n  addEventListener() {\n    if (this.parent.isDestroyed) {\n      return;\n    }\n\n    this.parent.on(contentReady, this.initialEnd, this);\n    this.parent.on(keyPressed, this.keyDownHandler, this);\n    this.parent.on(click, this.clickHandler, this);\n    EventHandler.add(this.parent.element, 'keydown', this.pasteHandler, this);\n  }\n  /**\n   * @returns {void}\n   * @hidden\n   */\n\n\n  removeEventListener() {\n    if (this.parent.isDestroyed) {\n      return;\n    }\n\n    this.parent.off(keyPressed, this.keyDownHandler);\n    this.parent.off(contentReady, this.initialEnd);\n    this.parent.off(click, this.clickHandler);\n    EventHandler.remove(this.parent.element, 'keydown', this.pasteHandler);\n  }\n\n  clickHandler(e) {\n    let target = e.target; // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n    target = parentsUntil(target, 'e-rowcell');\n  }\n\n  pasteHandler(e) {\n    const grid = this.parent;\n    const isMacLike = /(Mac)/i.test(navigator.platform);\n\n    if (e.keyCode === 67 && isMacLike && e.metaKey && !grid.isEdit) {\n      this.copy();\n    }\n\n    if (e.keyCode === 86 && (e.ctrlKey || isMacLike && e.metaKey) && !grid.isEdit) {\n      const target = closest(document.activeElement, '.' + rowCell);\n\n      if (!target || !grid.editSettings.allowEditing || grid.editSettings.mode !== 'Batch' || grid.selectionSettings.mode !== 'Cell' || grid.selectionSettings.cellSelectionMode === 'Flow') {\n        return;\n      }\n\n      this.activeElement = document.activeElement;\n      this.clipBoardTextArea.value = '';\n      const x = window.scrollX;\n      const y = window.scrollY;\n      this.clipBoardTextArea.focus();\n      setTimeout(() => {\n        this.activeElement.focus();\n        window.scrollTo(x, y);\n        this.paste(this.clipBoardTextArea.value, this.parent.getSelectedRowCellIndexes()[0].rowIndex, this.parent.getSelectedRowCellIndexes()[0].cellIndexes[0]);\n      }, 10);\n    }\n  }\n  /**\n   * Paste data from clipboard to selected cells.\n   *\n   * @param {boolean} data - Specifies the date for paste.\n   * @param {boolean} rowIndex - Specifies the row index.\n   * @param {boolean} colIndex - Specifies the column index.\n   * @returns {void}\n   */\n\n\n  paste(data, rowIndex, colIndex) {\n    const grid = this.parent;\n    let cIdx = colIndex;\n    let rIdx = rowIndex;\n    let col;\n    let value;\n    let isAvail;\n\n    if (!grid.editSettings.allowEditing || grid.editSettings.mode !== 'Batch' || grid.selectionSettings.mode !== 'Cell' || grid.selectionSettings.cellSelectionMode === 'Flow') {\n      return;\n    }\n\n    const rows = data.split('\\n');\n    let cols;\n    const dataRows = grid.getDataRows();\n    let mRows;\n    let frRows;\n    const isFrozen = this.parent.isFrozenGrid();\n\n    if (isFrozen) {\n      mRows = grid.getMovableDataRows();\n\n      if (grid.getFrozenRightColumnsCount()) {\n        frRows = grid.getFrozenRightDataRows();\n      }\n    }\n\n    for (let r = 0; r < rows.length; r++) {\n      cols = rows[r].split('\\t');\n      cIdx = colIndex;\n\n      if (r === rows.length - 1 && rows[r] === '' || isUndefined(grid.getRowByIndex(rIdx))) {\n        cIdx++;\n        break;\n      }\n\n      for (let c = 0; c < cols.length; c++) {\n        isAvail = grid.getCellFromIndex(rIdx, cIdx);\n\n        if (isFrozen) {\n          const fTr = dataRows[rIdx];\n          const mTr = mRows[rIdx];\n          isAvail = !fTr.querySelector('[aria-colindex=\"' + cIdx + '\"]') ? mTr.querySelector('[aria-colindex=\"' + cIdx + '\"]') : true;\n\n          if (frRows && !isAvail) {\n            const frTr = frRows[rIdx];\n            isAvail = frTr.querySelector('[aria-colindex=\"' + cIdx + '\"]');\n          }\n        }\n\n        if (!isAvail) {\n          cIdx++;\n          break;\n        }\n\n        col = grid.getColumnByIndex(cIdx);\n        value = col.getParser() ? col.getParser()(cols[c]) : cols[c];\n\n        if (col.allowEditing && !col.isPrimaryKey && !col.template) {\n          const args = {\n            column: col,\n            data: value,\n            rowIndex: rIdx\n          };\n          this.parent.trigger(beforePaste, args);\n          rIdx = args.rowIndex;\n\n          if (!args.cancel) {\n            if (grid.editModule) {\n              if (col.type === 'number') {\n                this.parent.editModule.updateCell(rIdx, col.field, parseFloat(args.data));\n              } else {\n                grid.editModule.updateCell(rIdx, col.field, args.data);\n              }\n            }\n          }\n        }\n\n        cIdx++;\n      }\n\n      rIdx++;\n    }\n\n    grid.selectionModule.selectCellsByRange({\n      rowIndex: rowIndex,\n      cellIndex: colIndex\n    }, {\n      rowIndex: rIdx - 1,\n      cellIndex: cIdx - 1\n    });\n    const cell = this.parent.getCellFromIndex(rIdx - 1, cIdx - 1);\n\n    if (cell) {\n      classList(cell, ['e-focus', 'e-focused'], []);\n    }\n  }\n\n  initialEnd() {\n    this.parent.off(contentReady, this.initialEnd);\n    this.clipBoardTextArea = this.parent.createElement('textarea', {\n      className: 'e-clipboard',\n      styles: 'opacity: 0',\n      attrs: {\n        tabindex: '-1',\n        'aria-label': 'clipboard'\n      }\n    });\n    this.parent.element.appendChild(this.clipBoardTextArea);\n  }\n\n  keyDownHandler(e) {\n    if (e.action === 'ctrlPlusC') {\n      this.copy();\n    } else if (e.action === 'ctrlShiftPlusH') {\n      this.copy(true);\n    }\n  }\n\n  setCopyData(withHeader) {\n    if (window.getSelection().toString() === '') {\n      const isFrozen = this.parent.isFrozenGrid();\n      this.clipBoardTextArea.value = this.copyContent = '';\n      let mRows;\n      let frRows;\n      const rows = this.parent.getRows();\n\n      if (isFrozen) {\n        mRows = this.parent.getMovableDataRows();\n\n        if (this.parent.getFrozenMode() === leftRight) {\n          frRows = this.parent.getFrozenRightRows();\n        }\n      }\n\n      if (this.parent.selectionSettings.mode !== 'Cell') {\n        const selectedIndexes = this.parent.getSelectedRowIndexes().sort((a, b) => {\n          return a - b;\n        });\n\n        if (withHeader) {\n          const headerTextArray = [];\n\n          for (let i = 0; i < this.parent.getVisibleColumns().length; i++) {\n            headerTextArray[i] = this.parent.getVisibleColumns()[i].headerText;\n          }\n\n          this.getCopyData(headerTextArray, false, '\\t', withHeader);\n          this.copyContent += '\\n';\n        }\n\n        for (let i = 0; i < selectedIndexes.length; i++) {\n          if (i > 0) {\n            this.copyContent += '\\n';\n          }\n\n          const cells = [].slice.call(rows[selectedIndexes[i]].querySelectorAll('.e-rowcell:not(.e-hide)'));\n\n          if (isFrozen) {\n            cells.push(...[].slice.call(mRows[selectedIndexes[i]].querySelectorAll('.e-rowcell:not(.e-hide)')));\n\n            if (frRows) {\n              cells.push(...[].slice.call(frRows[selectedIndexes[i]].querySelectorAll('.e-rowcell:not(.e-hide)')));\n            }\n          }\n\n          this.getCopyData(cells, false, '\\t', withHeader);\n        }\n      } else {\n        const obj = this.checkBoxSelection();\n\n        if (obj.status) {\n          if (withHeader) {\n            const headers = [];\n\n            for (let i = 0; i < obj.colIndexes.length; i++) {\n              headers.push(this.parent.getColumnHeaderByIndex(obj.colIndexes[i]));\n            }\n\n            this.getCopyData(headers, false, '\\t', withHeader);\n            this.copyContent += '\\n';\n          }\n\n          for (let i = 0; i < obj.rowIndexes.length; i++) {\n            if (i > 0) {\n              this.copyContent += '\\n';\n            }\n\n            const cells = [].slice.call(rows[obj.rowIndexes[i]].getElementsByClassName('e-cellselectionbackground'));\n\n            if (isFrozen) {\n              cells.push(...[].slice.call(mRows[obj.rowIndexes[i]].getElementsByClassName('e-cellselectionbackground')));\n\n              if (frRows) {\n                cells.push(...[].slice.call(frRows[obj.rowIndexes[i]].getElementsByClassName('e-cellselectionbackground')));\n              }\n            }\n\n            this.getCopyData(cells, false, '\\t', withHeader);\n          }\n        } else {\n          this.getCopyData([].slice.call(this.parent.element.getElementsByClassName('e-cellselectionbackground')), true, '\\n', withHeader);\n        }\n      }\n\n      const args = {\n        data: this.copyContent,\n        cancel: false\n      };\n      this.parent.trigger(beforeCopy, args);\n\n      if (args.cancel) {\n        return;\n      }\n\n      this.clipBoardTextArea.value = this.copyContent = args.data;\n\n      if (!Browser.userAgent.match(/ipad|ipod|iphone/i)) {\n        this.clipBoardTextArea.select();\n      } else {\n        this.clipBoardTextArea.setSelectionRange(0, this.clipBoardTextArea.value.length);\n      }\n\n      this.isSelect = true;\n    }\n  }\n\n  getCopyData(cells, isCell, splitKey, withHeader) {\n    const isElement = typeof cells[0] !== 'string';\n\n    for (let j = 0; j < cells.length; j++) {\n      if (withHeader && isCell) {\n        const colIdx = parseInt(cells[j].getAttribute(ariaColIndex), 10);\n        this.copyContent += this.parent.getColumns()[colIdx].headerText + '\\n';\n      }\n\n      if (isElement) {\n        if (!cells[j].classList.contains('e-hide')) {\n          this.copyContent += cells[j].innerText;\n        }\n      } else {\n        this.copyContent += cells[j];\n      }\n\n      if (j < cells.length - 1) {\n        this.copyContent += splitKey;\n      }\n    }\n  }\n  /**\n   * Copy selected rows or cells data into clipboard.\n   *\n   * @returns {void}\n   * @param {boolean} withHeader - Specifies whether the column header data need to be copied or not.\n   */\n\n\n  copy(withHeader) {\n    if (document.queryCommandSupported('copy')) {\n      this.setCopyData(withHeader);\n      document.execCommand('copy');\n      this.clipBoardTextArea.blur();\n    }\n\n    if (this.isSelect) {\n      window.getSelection().removeAllRanges();\n      this.isSelect = false;\n    }\n  }\n  /**\n   * For internal use only - Get the module name.\n   *\n   * @returns {string} returns the module name\n   * @private\n   */\n\n\n  getModuleName() {\n    return 'clipboard';\n  }\n  /**\n   * To destroy the clipboard\n   *\n   * @returns {void}\n   * @hidden\n   */\n\n\n  destroy() {\n    this.removeEventListener();\n\n    if (this.clipBoardTextArea) {\n      remove(this.clipBoardTextArea);\n    }\n  }\n\n  checkBoxSelection() {\n    const gridObj = this.parent;\n    let obj = {\n      status: false\n    };\n\n    if (gridObj.selectionSettings.mode === 'Cell') {\n      const rowCellIndxes = gridObj.getSelectedRowCellIndexes();\n      let str;\n      const rowIndexes = [];\n      let i;\n\n      for (i = 0; i < rowCellIndxes.length; i++) {\n        if (rowCellIndxes[i].cellIndexes.length) {\n          rowIndexes.push(rowCellIndxes[i].rowIndex);\n        }\n\n        if (rowCellIndxes[i].cellIndexes.length) {\n          if (!str) {\n            str = JSON.stringify(rowCellIndxes[i].cellIndexes.sort());\n          }\n\n          if (str !== JSON.stringify(rowCellIndxes[i].cellIndexes.sort())) {\n            break;\n          }\n        }\n      }\n\n      rowIndexes.sort((a, b) => {\n        return a - b;\n      });\n\n      if (i === rowCellIndxes.length && rowIndexes[rowIndexes.length - 1] - rowIndexes[0] === rowIndexes.length - 1) {\n        obj = {\n          status: true,\n          rowIndexes: rowIndexes,\n          colIndexes: rowCellIndxes[0].cellIndexes\n        };\n      }\n    }\n\n    return obj;\n  }\n\n}\n\nvar __decorate$1 = undefined && undefined.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nvar Grid_1;\n/**\n * Represents the field name and direction of sort column.\n */\n\nclass SortDescriptor extends ChildProperty {}\n\n__decorate$1([Property()], SortDescriptor.prototype, \"field\", void 0);\n\n__decorate$1([Property()], SortDescriptor.prototype, \"direction\", void 0);\n\n__decorate$1([Property(false)], SortDescriptor.prototype, \"isFromGroup\", void 0);\n/**\n * Configures the sorting behavior of Grid.\n */\n\n\nclass SortSettings extends ChildProperty {}\n\n__decorate$1([Collection([], SortDescriptor)], SortSettings.prototype, \"columns\", void 0);\n\n__decorate$1([Property(true)], SortSettings.prototype, \"allowUnsort\", void 0);\n/**\n * Represents the predicate for the filter column.\n */\n\n\nclass Predicate$1 extends ChildProperty {}\n\n__decorate$1([Property()], Predicate$1.prototype, \"field\", void 0);\n\n__decorate$1([Property()], Predicate$1.prototype, \"operator\", void 0);\n\n__decorate$1([Property()], Predicate$1.prototype, \"value\", void 0);\n\n__decorate$1([Property()], Predicate$1.prototype, \"matchCase\", void 0);\n\n__decorate$1([Property(false)], Predicate$1.prototype, \"ignoreAccent\", void 0);\n\n__decorate$1([Property()], Predicate$1.prototype, \"predicate\", void 0);\n\n__decorate$1([Property({})], Predicate$1.prototype, \"actualFilterValue\", void 0);\n\n__decorate$1([Property({})], Predicate$1.prototype, \"actualOperator\", void 0);\n\n__decorate$1([Property()], Predicate$1.prototype, \"type\", void 0);\n\n__decorate$1([Property()], Predicate$1.prototype, \"ejpredicate\", void 0);\n\n__decorate$1([Property()], Predicate$1.prototype, \"uid\", void 0);\n\n__decorate$1([Property()], Predicate$1.prototype, \"isForeignKey\", void 0);\n/**\n * Configures the infinite scroll behavior of Grid.\n */\n\n\nclass InfiniteScrollSettings extends ChildProperty {}\n\n__decorate$1([Property(false)], InfiniteScrollSettings.prototype, \"enableCache\", void 0);\n\n__decorate$1([Property(3)], InfiniteScrollSettings.prototype, \"maxBlocks\", void 0);\n\n__decorate$1([Property(3)], InfiniteScrollSettings.prototype, \"initialBlocks\", void 0);\n/**\n * Configures the filtering behavior of the Grid.\n */\n\n\nclass FilterSettings extends ChildProperty {}\n\n__decorate$1([Collection([], Predicate$1)], FilterSettings.prototype, \"columns\", void 0);\n\n__decorate$1([Property('FilterBar')], FilterSettings.prototype, \"type\", void 0);\n\n__decorate$1([Property()], FilterSettings.prototype, \"mode\", void 0);\n\n__decorate$1([Property(true)], FilterSettings.prototype, \"showFilterBarStatus\", void 0);\n\n__decorate$1([Property(1500)], FilterSettings.prototype, \"immediateModeDelay\", void 0);\n\n__decorate$1([Property()], FilterSettings.prototype, \"operators\", void 0);\n\n__decorate$1([Property(false)], FilterSettings.prototype, \"ignoreAccent\", void 0);\n\n__decorate$1([Property(false)], FilterSettings.prototype, \"enableCaseSensitivity\", void 0);\n\n__decorate$1([Property(false)], FilterSettings.prototype, \"showFilterBarOperator\", void 0);\n/**\n * Configures the selection behavior of the Grid.\n */\n\n\nclass SelectionSettings extends ChildProperty {}\n\n__decorate$1([Property('Row')], SelectionSettings.prototype, \"mode\", void 0);\n\n__decorate$1([Property('Flow')], SelectionSettings.prototype, \"cellSelectionMode\", void 0);\n\n__decorate$1([Property('Single')], SelectionSettings.prototype, \"type\", void 0);\n\n__decorate$1([Property(false)], SelectionSettings.prototype, \"checkboxOnly\", void 0);\n\n__decorate$1([Property(false)], SelectionSettings.prototype, \"persistSelection\", void 0);\n\n__decorate$1([Property('Default')], SelectionSettings.prototype, \"checkboxMode\", void 0);\n\n__decorate$1([Property(false)], SelectionSettings.prototype, \"enableSimpleMultiRowSelection\", void 0);\n\n__decorate$1([Property(true)], SelectionSettings.prototype, \"enableToggle\", void 0);\n\n__decorate$1([Property(false)], SelectionSettings.prototype, \"allowColumnSelection\", void 0);\n/**\n * Configures the search behavior of the Grid.\n */\n\n\nclass SearchSettings extends ChildProperty {}\n\n__decorate$1([Property([])], SearchSettings.prototype, \"fields\", void 0);\n\n__decorate$1([Property('')], SearchSettings.prototype, \"key\", void 0);\n\n__decorate$1([Property('contains')], SearchSettings.prototype, \"operator\", void 0);\n\n__decorate$1([Property(true)], SearchSettings.prototype, \"ignoreCase\", void 0);\n\n__decorate$1([Property(false)], SearchSettings.prototype, \"ignoreAccent\", void 0);\n/**\n * Configures the row drop settings of the Grid.\n */\n\n\nclass RowDropSettings extends ChildProperty {}\n\n__decorate$1([Property()], RowDropSettings.prototype, \"targetID\", void 0);\n/**\n * Configures the text wrap settings of the Grid.\n */\n\n\nclass TextWrapSettings extends ChildProperty {}\n\n__decorate$1([Property('Both')], TextWrapSettings.prototype, \"wrapMode\", void 0);\n/**\n * Configures the resize behavior of the Grid.\n */\n\n\nclass ResizeSettings extends ChildProperty {}\n\n__decorate$1([Property('Normal')], ResizeSettings.prototype, \"mode\", void 0);\n/**\n * Configures the group behavior of the Grid.\n */\n\n\nclass GroupSettings extends ChildProperty {}\n\n__decorate$1([Property(true)], GroupSettings.prototype, \"showDropArea\", void 0);\n\n__decorate$1([Property(false)], GroupSettings.prototype, \"allowReordering\", void 0);\n\n__decorate$1([Property(false)], GroupSettings.prototype, \"showToggleButton\", void 0);\n\n__decorate$1([Property(false)], GroupSettings.prototype, \"showGroupedColumn\", void 0);\n\n__decorate$1([Property(true)], GroupSettings.prototype, \"showUngroupButton\", void 0);\n\n__decorate$1([Property(false)], GroupSettings.prototype, \"disablePageWiseAggregates\", void 0);\n\n__decorate$1([Property([])], GroupSettings.prototype, \"columns\", void 0);\n\n__decorate$1([Property()], GroupSettings.prototype, \"captionTemplate\", void 0);\n\n__decorate$1([Property(false)], GroupSettings.prototype, \"enableLazyLoading\", void 0);\n/**\n * Configures the edit behavior of the Grid.\n */\n\n\nclass EditSettings extends ChildProperty {}\n\n__decorate$1([Property(false)], EditSettings.prototype, \"allowAdding\", void 0);\n\n__decorate$1([Property(false)], EditSettings.prototype, \"allowEditing\", void 0);\n\n__decorate$1([Property(false)], EditSettings.prototype, \"allowDeleting\", void 0);\n\n__decorate$1([Property('Normal')], EditSettings.prototype, \"mode\", void 0);\n\n__decorate$1([Property(true)], EditSettings.prototype, \"allowEditOnDblClick\", void 0);\n\n__decorate$1([Property(true)], EditSettings.prototype, \"showConfirmDialog\", void 0);\n\n__decorate$1([Property(false)], EditSettings.prototype, \"showDeleteConfirmDialog\", void 0);\n\n__decorate$1([Property('')], EditSettings.prototype, \"template\", void 0);\n\n__decorate$1([Property('')], EditSettings.prototype, \"headerTemplate\", void 0);\n\n__decorate$1([Property('')], EditSettings.prototype, \"footerTemplate\", void 0);\n\n__decorate$1([Property('Top')], EditSettings.prototype, \"newRowPosition\", void 0);\n\n__decorate$1([Property({})], EditSettings.prototype, \"dialog\", void 0);\n\n__decorate$1([Property(false)], EditSettings.prototype, \"allowNextRowEdit\", void 0);\n/**\n * Represents the Grid component.\n * ```html\n * <div id=\"grid\"></div>\n * <script>\n *  var gridObj = new Grid({ allowPaging: true });\n *  gridObj.appendTo(\"#grid\");\n * </script>\n * ```\n */\n\n\nlet Grid = Grid_1 = class Grid extends Component {\n  /**\n   * Constructor for creating the component\n   *\n   * @param {GridModel} options - specifies the options\n   * @param {string | HTMLElement} element - specifies the element\n   * @hidden\n   */\n  constructor(options, element) {\n    super(options, element);\n    this.isPreventScrollEvent = false;\n    this.inViewIndexes = [];\n    this.keyA = false;\n    this.frozenRightCount = 0;\n    this.frozenLeftCount = 0;\n    this.tablesCount = 1;\n    this.movableCount = 0;\n    this.visibleFrozenLeft = 0;\n    this.visibleFrozenRight = 0;\n    this.visibleMovable = 0;\n    this.frozenLeftColumns = [];\n    this.frozenRightColumns = [];\n    this.movableColumns = [];\n    this.media = {};\n    this.isFreezeRefresh = false;\n    /** @hidden */\n\n    this.tableIndex = 0;\n    this.componentRefresh = Component.prototype.refresh;\n    /** @hidden */\n\n    this.isVirtualAdaptive = false;\n    /** @hidden */\n\n    this.vRows = [];\n    /** @hidden */\n\n    this.vcRows = [];\n    /** @hidden */\n\n    this.vGroupOffsets = {};\n    /** @hidden */\n\n    this.rowUid = 0;\n    /**\n     * Gets the currently visible records of the Grid.\n     */\n\n    this.currentViewData = [];\n    /** @hidden */\n\n    this.isManualRefresh = false;\n    /** @hidden */\n\n    this.enableDeepCompare = false;\n    /** @hidden */\n\n    this.lockcolPositionCount = 0;\n    /** @hidden */\n\n    this.prevPageMoving = false;\n    /** @hidden */\n\n    this.pageTemplateChange = false;\n    /** @hidden */\n\n    this.isAutoGen = false;\n    this.mediaBindInstance = {};\n    /** @hidden */\n\n    this.commandDelIndex = undefined;\n    /** @hidden */\n\n    this.asyncTimeOut = 50;\n    /** @hidden */\n\n    this.isExportGrid = false; // enable/disable logger for MVC & Core\n\n    this.enableLogger = true;\n    this.needsID = true;\n    Grid_1.Inject(Selection);\n    setValue('mergePersistData', this.mergePersistGridData, this);\n  }\n  /**\n   * Get the properties to be maintained in the persisted state.\n   *\n   * @returns {string} returns the persist data\n   */\n\n\n  getPersistData() {\n    const keyEntity = ['pageSettings', 'sortSettings', 'filterSettings', 'groupSettings', 'columns', 'searchSettings', 'selectedRowIndex', 'scrollPosition'];\n    const ignoreOnPersist = {\n      pageSettings: ['template', 'pageSizes', 'enableQueryString', 'totalRecordsCount', 'pageCount'],\n      filterSettings: ['type', 'mode', 'showFilterBarStatus', 'immediateModeDelay', 'ignoreAccent'],\n      groupSettings: ['showDropArea', 'showToggleButton', 'showGroupedColumn', 'showUngroupButton', 'disablePageWiseAggregates', 'hideCaptionCount'],\n      searchSettings: ['fields', 'operator', 'ignoreCase'],\n      sortSettings: [],\n      columns: [],\n      selectedRowIndex: [],\n      scrollPosition: []\n    };\n\n    for (let i = 0; i < keyEntity.length; i++) {\n      const currentObject = this[keyEntity[i]];\n\n      for (const val of ignoreOnPersist[keyEntity[i]]) {\n        delete currentObject[val];\n      }\n    }\n\n    const temp = this.pageSettings.template;\n    const settings = Object.assign({\n      template: undefined\n    }, this.pageSettings);\n    this.setProperties({\n      pageSettings: settings\n    }, true); // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n    if (this.isAngular) {\n      delete this.groupSettings['properties']['captionTemplate'];\n    }\n\n    this.pageTemplateChange = !isNullOrUndefined(this.pagerTemplate);\n    const persistData = this.addOnPersist(keyEntity);\n    settings.template = temp;\n    this.setProperties({\n      pageSettings: settings\n    }, true);\n    return persistData;\n  }\n  /**\n   * To provide the array of modules needed for component rendering\n   *\n   * @returns {ModuleDeclaration[]} Returns the module Declaration\n   * @hidden\n   */\n\n\n  requiredModules() {\n    this.setFrozenCount();\n    this.enableInfiniteAggrgate();\n    const modules = [];\n\n    if (this.isDestroyed) {\n      return modules;\n    }\n\n    if (this.allowFiltering) {\n      modules.push({\n        member: 'filter',\n        args: [this, this.filterSettings, this.serviceLocator]\n      });\n    }\n\n    if (this.allowExcelExport) {\n      modules.push({\n        member: 'ExcelExport',\n        args: [this, this.serviceLocator]\n      });\n    }\n\n    if (this.allowPdfExport) {\n      modules.push({\n        member: 'PdfExport',\n        args: [this]\n      });\n    }\n\n    if (this.allowSorting) {\n      modules.push({\n        member: 'sort',\n        args: [this, this.sortSettings, this.sortedColumns, this.serviceLocator]\n      });\n    }\n\n    if (this.allowPaging) {\n      modules.push({\n        member: 'pager',\n        args: [this, this.pageSettings]\n      });\n    }\n\n    if (this.allowSelection) {\n      modules.push({\n        member: 'selection',\n        args: [this, this.selectionSettings, this.serviceLocator]\n      });\n    }\n\n    modules.push({\n      member: 'resize',\n      args: [this]\n    });\n\n    if (this.allowReordering) {\n      modules.push({\n        member: 'reorder',\n        args: [this]\n      });\n    }\n\n    if (this.allowRowDragAndDrop) {\n      modules.push({\n        member: 'rowDragAndDrop',\n        args: [this]\n      });\n    }\n\n    if (this.allowGrouping) {\n      modules.push({\n        member: 'group',\n        args: [this, this.groupSettings, this.sortedColumns, this.serviceLocator]\n      });\n    }\n\n    if (this.aggregates.length) {\n      modules.push({\n        member: 'aggregate',\n        args: [this, this.serviceLocator]\n      });\n    }\n\n    if (this.isDetail()) {\n      modules.push({\n        member: 'detailRow',\n        args: [this, this.serviceLocator]\n      });\n    }\n\n    if (this.toolbar || this.toolbarTemplate) {\n      modules.push({\n        member: 'toolbar',\n        args: [this, this.serviceLocator]\n      });\n    }\n\n    if (this.enableVirtualization || this.enableColumnVirtualization) {\n      modules.push({\n        member: 'virtualscroll',\n        args: [this, this.serviceLocator]\n      });\n    }\n\n    if (this.getFrozenColumns() || this.frozenRows || this.frozenRightCount || this.frozenLeftCount) {\n      modules.push({\n        member: 'freeze',\n        args: [this, this.serviceLocator]\n      });\n    }\n\n    if (this.isCommandColumn(this.columns)) {\n      modules.push({\n        member: 'commandColumn',\n        args: [this, this.serviceLocator]\n      });\n    }\n\n    if (this.editSettings.allowAdding || this.editSettings.allowDeleting || this.editSettings.allowEditing) {\n      modules.push({\n        member: 'edit',\n        args: [this, this.serviceLocator]\n      });\n    }\n\n    this.extendRequiredModules(modules);\n    return modules;\n  }\n\n  extendRequiredModules(modules) {\n    if (this.enableInfiniteScrolling) {\n      modules.push({\n        member: 'infiniteScroll',\n        args: [this, this.serviceLocator]\n      });\n    }\n\n    if (this.groupSettings.enableLazyLoading) {\n      modules.push({\n        member: 'lazyLoadGroup',\n        args: [this, this.serviceLocator]\n      });\n    }\n\n    if (this.contextMenuItems) {\n      modules.push({\n        member: 'contextMenu',\n        args: [this, this.serviceLocator]\n      });\n    }\n\n    if (this.showColumnMenu) {\n      modules.push({\n        member: 'columnMenu',\n        args: [this, this.serviceLocator]\n      });\n    }\n\n    if (this.showColumnChooser) {\n      modules.push({\n        member: 'columnChooser',\n        args: [this, this.serviceLocator]\n      });\n    }\n\n    if (this.isForeignKeyEnabled(this.columns)) {\n      modules.push({\n        member: 'foreignKey',\n        args: [this, this.serviceLocator]\n      });\n    }\n\n    if (this.enableLogger) {\n      modules.push({\n        member: 'logger',\n        args: [this]\n      });\n    }\n  }\n  /**\n   * For internal use only - Initialize the event handler;\n   *\n   * @returns {void}\n   * @private\n   */\n\n\n  preRender() {\n    this.serviceLocator = new ServiceLocator();\n    this.initProperties();\n    this.initializeServices();\n  }\n\n  initProperties() {\n    this.isInitial = true;\n    this.sortedColumns = [];\n    this.inViewIndexes = [];\n    this.mediaCol = [];\n    this.isInitialLoad = false;\n    this.allowServerDataBinding = false;\n    this.ignoreCollectionWatch = true;\n    this.mergeCells = {};\n    this.isEdit = false;\n    this.checkAllRows = 'None';\n    this.isCheckBoxSelection = false;\n    this.isPersistSelection = false;\n    this.componentRefresh = Component.prototype.refresh;\n    this.filterOperators = {\n      contains: 'contains',\n      endsWith: 'endswith',\n      equal: 'equal',\n      greaterThan: 'greaterthan',\n      greaterThanOrEqual: 'greaterthanorequal',\n      lessThan: 'lessthan',\n      lessThanOrEqual: 'lessthanorequal',\n      notEqual: 'notequal',\n      startsWith: 'startswith'\n    };\n    this.defaultLocale = {\n      EmptyRecord: 'No records to display',\n      True: 'true',\n      False: 'false',\n      InvalidFilterMessage: 'Invalid Filter Data',\n      GroupDropArea: 'Drag a column header here to group its column',\n      UnGroup: 'Click here to ungroup',\n      UnGroupButton: 'Click here to ungroup',\n      GroupDisable: 'Grouping is disabled for this column',\n      FilterbarTitle: '\\'s filter bar cell',\n      EmptyDataSourceError: 'DataSource must not be empty at initial load since columns are generated from dataSource in AutoGenerate Column Grid',\n      // Toolbar Items\n      Add: 'Add',\n      Edit: 'Edit',\n      Cancel: 'Cancel',\n      Update: 'Update',\n      Delete: 'Delete',\n      Print: 'Print',\n      Pdfexport: 'PDF Export',\n      Excelexport: 'Excel Export',\n      Wordexport: 'Word Export',\n      Csvexport: 'CSV Export',\n      Search: 'Search',\n      Columnchooser: 'Columns',\n      Save: 'Save',\n      Item: 'item',\n      Items: 'items',\n      EditOperationAlert: 'No records selected for edit operation',\n      DeleteOperationAlert: 'No records selected for delete operation',\n      SaveButton: 'Save',\n      OKButton: 'OK',\n      CancelButton: 'Cancel',\n      EditFormTitle: 'Details of ',\n      AddFormTitle: 'Add New Record',\n      BatchSaveConfirm: 'Are you sure you want to save changes?',\n      BatchSaveLostChanges: 'Unsaved changes will be lost. Are you sure you want to continue?',\n      ConfirmDelete: 'Are you sure you want to Delete Record?',\n      CancelEdit: 'Are you sure you want to Cancel the changes?',\n      ChooseColumns: 'Choose Column',\n      SearchColumns: 'search columns',\n      Matchs: 'No matches found',\n      FilterButton: 'Filter',\n      ClearButton: 'Clear',\n      StartsWith: 'Starts With',\n      EndsWith: 'Ends With',\n      Contains: 'Contains',\n      Equal: 'Equal',\n      NotEqual: 'Not Equal',\n      LessThan: 'Less Than',\n      LessThanOrEqual: 'Less Than Or Equal',\n      GreaterThan: 'Greater Than',\n      GreaterThanOrEqual: 'Greater Than Or Equal',\n      ChooseDate: 'Choose a Date',\n      EnterValue: 'Enter the value',\n      Copy: 'Copy',\n      Group: 'Group by this column',\n      Ungroup: 'Ungroup by this column',\n      autoFitAll: 'Autofit all columns',\n      autoFit: 'Autofit this column',\n      AutoFitAll: 'Autofit all columns',\n      AutoFit: 'Autofit this column',\n      Export: 'Export',\n      FirstPage: 'First Page',\n      LastPage: 'Last Page',\n      PreviousPage: 'Previous Page',\n      NextPage: 'Next Page',\n      SortAscending: 'Sort Ascending',\n      SortDescending: 'Sort Descending',\n      EditRecord: 'Edit Record',\n      DeleteRecord: 'Delete Record',\n      FilterMenu: 'Filter',\n      SelectAll: 'Select All',\n      Blanks: 'Blanks',\n      FilterTrue: 'True',\n      FilterFalse: 'False',\n      NoResult: 'No matches found',\n      ClearFilter: 'Clear Filter',\n      Clear: 'Clear',\n      NumberFilter: 'Number Filters',\n      TextFilter: 'Text Filters',\n      DateFilter: 'Date Filters',\n      DateTimeFilter: 'DateTime Filters',\n      MatchCase: 'Match Case',\n      Between: 'Between',\n      CustomFilter: 'Custom Filter',\n      CustomFilterPlaceHolder: 'Enter the value',\n      CustomFilterDatePlaceHolder: 'Choose a date',\n      AND: 'AND',\n      OR: 'OR',\n      ShowRowsWhere: 'Show rows where:',\n      FilterMenuDialogARIA: 'Filter menu dialog',\n      ExcelFilterDialogARIA: 'Excel filter dialog',\n      DialogEditARIA: 'Edit dialog',\n      ColumnChooserDialogARIA: 'Column chooser dialog',\n      ColumnMenuDialogARIA: 'Column menu dialog',\n      CustomFilterDialogARIA: 'Customer filter dialog',\n      SortAtoZ: 'Sort A to Z',\n      SortZtoA: 'Sort Z to A',\n      SortByOldest: 'Sort by Oldest',\n      SortByNewest: 'Sort by Newest',\n      SortSmallestToLargest: 'Sort Smallest to Largest',\n      SortLargestToSmallest: 'Sort Largest to Smallest',\n      Sort: 'Sort'\n    };\n    this.keyConfigs = {\n      downArrow: 'downarrow',\n      upArrow: 'uparrow',\n      rightArrow: 'rightarrow',\n      leftArrow: 'leftarrow',\n      shiftDown: 'shift+downarrow',\n      shiftUp: 'shift+uparrow',\n      shiftRight: 'shift+rightarrow',\n      shiftLeft: 'shift+leftarrow',\n      home: 'home',\n      end: 'end',\n      escape: 'escape',\n      ctrlHome: 'ctrl+home',\n      ctrlEnd: 'ctrl+end',\n      pageUp: 'pageup',\n      pageDown: 'pagedown',\n      ctrlAltPageUp: 'ctrl+alt+pageup',\n      ctrlAltPageDown: 'ctrl+alt+pagedown',\n      altPageUp: 'alt+pageup',\n      altPageDown: 'alt+pagedown',\n      altDownArrow: 'alt+downarrow',\n      altUpArrow: 'alt+uparrow',\n      ctrlDownArrow: 'ctrl+downarrow',\n      ctrlUpArrow: 'ctrl+uparrow',\n      ctrlPlusA: 'ctrl+A',\n      ctrlPlusP: 'ctrl+P',\n      insert: 'insert',\n      delete: 'delete',\n      f2: 'f2',\n      enter: 'enter',\n      ctrlEnter: 'ctrl+enter',\n      shiftEnter: 'shift+enter',\n      tab: 'tab',\n      shiftTab: 'shift+tab',\n      space: 'space',\n      ctrlPlusC: 'ctrl+C',\n      ctrlShiftPlusH: 'ctrl+shift+H',\n      ctrlSpace: 'ctrl+space',\n      ctrlLeftArrow: 'ctrl+leftarrow',\n      ctrlRightArrow: 'ctrl+rightarrow'\n    };\n  }\n  /**\n   * For internal use only - To Initialize the component rendering.\n   *\n   * @returns {void}\n   * @private\n   */\n\n\n  render() {\n    this.log(['module_missing', 'promise_enabled', 'locale_missing', 'check_datasource_columns']);\n    this.ariaService.setOptions(this.element, {\n      role: 'grid'\n    });\n    createSpinner({\n      target: this.element\n    }, this.createElement);\n    this.renderModule = new Render(this, this.serviceLocator);\n    this.searchModule = new Search(this);\n    this.scrollModule = new Scroll(this);\n    this.notify(initialLoad, {});\n\n    if (this.getDataModule().dataManager.dataSource.offline === true || this.getDataModule().dataManager.dataSource.url === undefined) {\n      this.isVirtualAdaptive = true;\n    }\n\n    this.trigger(load);\n    prepareColumns(this.columns, this.enableColumnVirtualization, this);\n\n    if (this.enablePersistence) {\n      this.notify(columnsPrepared, {});\n    }\n\n    this.getMediaColumns();\n    setColumnIndex(this.columns);\n    this.checkLockColumns(this.columns);\n    this.getColumns();\n    this.processModel();\n    this.gridRender();\n    this.wireEvents();\n    this.addListener();\n    this.updateDefaultCursor();\n    this.updateStackedFilter();\n    this.showSpinner();\n    this.notify(initialEnd, {});\n  }\n  /**\n   * By default, grid shows the spinner for all its actions. You can use this method to show spinner at your needed time.\n   *\n   * @returns {void}\n   */\n\n\n  showSpinner() {\n    if (!this.isExportGrid) {\n      showSpinner(this.element);\n    }\n  }\n  /**\n   * By default, grid shows the spinner for all its actions. You can use this method to show spinner at your needed time.\n   *\n   * @returns {void}\n   */\n\n\n  hideSpinner() {\n    if (!this.isExportGrid) {\n      hideSpinner(this.element);\n    }\n  }\n\n  updateStackedFilter() {\n    if (this.allowFiltering && this.filterSettings.type === 'FilterBar' && this.getHeaderContent().getElementsByClassName('e-stackedheadercell').length) {\n      this.getHeaderContent().classList.add('e-stackedfilter');\n    } else {\n      this.getHeaderContent().classList.remove('e-stackedfilter');\n    }\n  }\n\n  getMediaColumns() {\n    if (!this.enableColumnVirtualization) {\n      const gcol = this.getColumns();\n      this.getShowHideService = this.serviceLocator.getService('showHideService');\n\n      if (!isNullOrUndefined(gcol)) {\n        for (let index = 0; index < gcol.length; index++) {\n          if (!isNullOrUndefined(gcol[index].hideAtMedia) && (isNullOrUndefined(gcol[index].visible) || gcol[index].visible)) {\n            this.pushMediaColumn(gcol[index], index);\n          }\n        }\n      }\n    }\n  }\n\n  pushMediaColumn(col, index) {\n    this.mediaCol.push(col);\n    this.media[col.uid] = window.matchMedia(col.hideAtMedia);\n    this.mediaQueryUpdate(index, this.media[col.uid]);\n    this.mediaBindInstance[index] = this.mediaQueryUpdate.bind(this, index);\n    this.media[col.uid].addListener(this.mediaBindInstance[index]);\n  }\n  /**\n   * @param {Column} col - specifies the column\n   * @returns {void}\n   * @hidden\n   */\n\n\n  updateMediaColumns(col) {\n    if (!this.enableColumnVirtualization) {\n      const index = this.getColumnIndexByUid(col.uid);\n\n      for (let i = 0; i < this.mediaCol.length; i++) {\n        if (col.uid === this.mediaCol[i].uid) {\n          this.mediaCol.splice(i, 1);\n          return;\n        }\n      }\n\n      this.pushMediaColumn(col, index);\n    }\n  }\n  /**\n   * @param {number} columnIndex - specifies the column index\n   * @param {MediaQueryList} e - specifies the MediaQueryList\n   * @returns {void}\n   * @hidden\n   */\n\n\n  mediaQueryUpdate(columnIndex, e) {\n    const col = this.getColumns()[columnIndex];\n\n    if (this.mediaCol.some(mediaColumn => mediaColumn.uid === col.uid)) {\n      col.visible = e.matches;\n\n      if (this.isInitialLoad) {\n        this.invokedFromMedia = true;\n\n        if (col.visible) {\n          this.showHider.show(col.headerText, 'headerText');\n        } else {\n          this.showHider.hide(col.headerText, 'headerText');\n        }\n      }\n    }\n  }\n\n  refreshMediaCol() {\n    this.isInitialLoad = true;\n    const footerContent = this.element.querySelector('.' + gridFooter);\n\n    if (this.aggregates.length && this.element.scrollHeight > this.height && footerContent) {\n      addClass([footerContent], ['e-footerpadding']);\n    }\n\n    const checkboxColumn = this.getColumns().filter(col => col.type === 'checkbox');\n\n    if (checkboxColumn.length && this.selectionSettings.checkboxMode === 'ResetOnRowClick') {\n      this.isCheckBoxSelection = false;\n    }\n\n    if (this.rowRenderingMode === 'Vertical') {\n      if (this.enableHover) {\n        this.setProperties({\n          enableAdaptiveUI: true,\n          enableHover: false\n        }, true);\n        removeClass([this.element], 'e-gridhover');\n      }\n    }\n\n    if (this.enableAdaptiveUI && this.scrollModule) {\n      this.scrollModule.refresh();\n    }\n  }\n\n  removeMediaListener() {\n    for (let i = 0; i < this.mediaCol.length; i++) {\n      this.media[this.mediaCol[i].uid].removeListener(this.mediaBindInstance[this.mediaCol[i].index]);\n    }\n  }\n  /**\n   * For internal use only - Initialize the event handler\n   *\n   * @returns {void}\n   * @private\n   */\n\n\n  eventInitializer() {//eventInitializer\n  }\n  /**\n   * Destroys the component (detaches/removes all event handlers, attributes, classes, and empties the component element).\n   *\n   * @function destroy\n   * @returns {void}\n   */\n\n\n  destroy() {\n    const gridElement = this.element;\n\n    if (!gridElement) {\n      return;\n    }\n\n    const hasGridChild = gridElement.querySelector('.' + gridHeader) && gridElement.querySelector('.' + gridContent) ? true : false;\n\n    if (hasGridChild) {\n      this.unwireEvents();\n    }\n\n    this.removeListener();\n    this.removeMediaListener();\n    this.notify(destroy, {});\n    this.destroyDependentModules();\n\n    if (this.isReact || this.isVue) {\n      this.destroyTemplate(['template']);\n    }\n\n    if (hasGridChild) {\n      super.destroy();\n    }\n\n    this.toolTipObj.destroy();\n    const modules = ['renderModule', 'headerModule', 'contentModule', 'valueFormatterService', 'serviceLocator', 'ariaService', 'keyboardModule', 'widthService', 'searchModule', 'showHider', 'scrollModule', 'printModule', 'clipboardModule', 'focusModule'];\n\n    for (let i = 0; i < modules.length; i++) {\n      if (this[modules[i]]) {\n        this[modules[i]] = null;\n      }\n    }\n\n    this.element.innerHTML = '';\n    classList(this.element, [], ['e-rtl', 'e-gridhover', 'e-responsive', 'e-default', 'e-device', 'e-grid-min-height']);\n    this.isFreezeRefresh = false;\n  }\n\n  destroyDependentModules() {\n    const gridElement = this.element;\n\n    if (!gridElement || !gridElement.querySelector('.' + gridHeader) && !gridElement.querySelector('.' + gridContent)) {\n      return;\n    }\n\n    this.scrollModule.destroy();\n    this.keyboardModule.destroy();\n    this.focusModule.destroy();\n    this.clipboardModule.destroy();\n    this.printModule.destroy();\n  }\n  /**\n   * For internal use only - Get the module name.\n   *\n   * @returns {string} returns the module name\n   * @private\n   */\n\n\n  getModuleName() {\n    return 'grid';\n  }\n\n  enableBoxSelection() {\n    if (this.enableAutoFill) {\n      this.selectionSettings.cellSelectionMode = 'BoxWithBorder';\n      this.element.classList.add('e-afenabled');\n    } else {\n      this.element.classList.remove('e-afenabled');\n    }\n  }\n  /**\n   * Called internally if any of the property value changed.\n   *\n   * @param {GridModel} newProp - Defines new properties\n   * @param {GridModel} oldProp - Defines old properties\n   * @returns {void}\n   * @hidden\n   */\n\n\n  onPropertyChanged(newProp, oldProp) {\n    let requireRefresh = false;\n    let requireGridRefresh = false;\n    let freezeRefresh$$1 = false;\n    let checkCursor;\n    const args = {\n      requestType: 'refresh'\n    };\n\n    if (this.isDestroyed) {\n      return;\n    }\n\n    this.log('module_missing');\n\n    if (this.isEllipsisTooltip()) {\n      this.toolTipObj.close();\n    }\n\n    const properties = Object.keys(newProp);\n\n    if (properties.indexOf('columns') > -1) {\n      if (this.enableColumnVirtualization) {\n        this.columnModel = [];\n      }\n\n      this.updateColumnObject();\n      requireGridRefresh = true;\n    }\n\n    for (const prop of properties) {\n      switch (prop) {\n        case 'allowPaging':\n          this.notify(uiUpdate, {\n            module: 'pager',\n            enable: this.allowPaging\n          });\n          requireRefresh = true;\n          break;\n\n        case 'pageSettings':\n          if (this.pageTemplateChange) {\n            this.pageTemplateChange = false;\n            this.notify(inBoundModelChanged, {\n              module: 'pager',\n              properties: newProp.pageSettings\n            });\n            break;\n          }\n\n          this.notify(inBoundModelChanged, {\n            module: 'pager',\n            properties: newProp.pageSettings\n          });\n\n          if (isNullOrUndefined(newProp.pageSettings.currentPage) && isNullOrUndefined(newProp.pageSettings.pageSize) && isNullOrUndefined(newProp.pageSettings.totalRecordsCount) || !isNullOrUndefined(oldProp.pageSettings) && newProp.pageSettings.currentPage !== oldProp.pageSettings.currentPage && !this.enableColumnVirtualization && !this.enableVirtualization && this.pageSettings.totalRecordsCount <= this.pageSettings.pageSize) {\n            requireRefresh = true;\n          }\n\n          break;\n\n        case 'allowSorting':\n          this.notify(uiUpdate, {\n            module: 'sort',\n            enable: this.allowSorting\n          });\n          requireRefresh = true;\n          checkCursor = true;\n          break;\n\n        case 'allowFiltering':\n          this.updateStackedFilter();\n          this.notify(uiUpdate, {\n            module: 'filter',\n            enable: this.allowFiltering\n          });\n          requireRefresh = true;\n\n          if (this.filterSettings.type !== 'FilterBar') {\n            this.refreshHeader();\n          }\n\n          break;\n\n        case 'height':\n        case 'width':\n          this.notify(uiUpdate, {\n            module: 'scroll',\n            properties: {\n              width: newProp.width,\n              height: newProp.height\n            }\n          });\n          break;\n\n        case 'allowReordering':\n          this.headerModule.refreshUI();\n          checkCursor = true;\n          break;\n\n        case 'allowRowDragAndDrop':\n          this.notify(uiUpdate, {\n            module: 'rowDragAndDrop',\n            enable: this.allowRowDragAndDrop\n          });\n          this.renderModule.refresh();\n          this.headerModule.refreshUI();\n          break;\n\n        case 'allowSelection':\n          this.notify(uiUpdate, {\n            module: 'selection',\n            enable: this.allowSelection\n          });\n          break;\n\n        case 'enableAutoFill':\n          if (this.selectionModule) {\n            this.enableBoxSelection();\n            this.selectionModule.updateAutoFillPosition();\n          }\n\n          break;\n\n        case 'rowTemplate':\n          this.rowTemplateFn = templateCompiler(this.rowTemplate);\n          requireRefresh = true;\n          break;\n\n        case 'detailTemplate':\n          this.detailTemplateFn = templateCompiler(this.detailTemplate);\n          requireRefresh = true;\n          break;\n\n        case 'allowGrouping':\n          this.notify(uiUpdate, {\n            module: 'group',\n            enable: this.allowGrouping\n          });\n          this.headerModule.refreshUI();\n          requireRefresh = true;\n          checkCursor = true;\n          break;\n\n        case 'enableInfiniteScrolling':\n        case 'childGrid':\n          requireRefresh = true;\n          break;\n\n        case 'toolbar':\n          this.notify(uiUpdate, {\n            module: 'toolbar'\n          });\n          break;\n\n        case 'groupSettings':\n          this.notify(inBoundModelChanged, {\n            module: 'group',\n            properties: newProp.groupSettings,\n            oldProperties: oldProp.groupSettings\n          });\n          break;\n\n        case 'aggregates':\n          if (!this.aggregates.length && this.allowGrouping && this.groupSettings.columns.length) {\n            requireRefresh = true;\n          }\n\n          this.notify(uiUpdate, {\n            module: 'aggregate',\n            properties: newProp\n          });\n          break;\n\n        case 'frozenColumns':\n        case 'frozenRows':\n        case 'enableVirtualization':\n        case 'currencyCode':\n        case 'locale':\n          this.log('frozen_rows_columns');\n          freezeRefresh$$1 = true;\n          requireGridRefresh = true;\n          break;\n\n        case 'query':\n          if (!this.getDataModule().isQueryInvokedFromData) {\n            requireRefresh = true;\n          }\n\n          this.getDataModule().isQueryInvokedFromData = false;\n          break;\n\n        default:\n          this.extendedPropertyChange(prop, newProp, requireGridRefresh);\n      }\n    }\n\n    if (checkCursor) {\n      this.updateDefaultCursor();\n    }\n\n    if (requireGridRefresh) {\n      if (freezeRefresh$$1 || this.getFrozenColumns() || this.frozenRows) {\n        this.freezeRefresh();\n      } else {\n        this.refresh();\n      }\n    } else if (requireRefresh) {\n      this.notify(modelChanged, args);\n      requireRefresh = false;\n      this.maintainSelection(newProp.selectedRowIndex);\n    }\n  }\n\n  extendedPropertyChange(prop, newProp, requireGridRefresh) {\n    switch (prop) {\n      case 'enableRtl':\n        this.updateRTL();\n\n        if (this.allowPaging) {\n          this.element.querySelector('.e-gridpager').ej2_instances[0].enableRtl = newProp.enableRtl;\n          this.element.querySelector('.e-gridpager').ej2_instances[0].dataBind();\n        }\n\n        if (this.height !== 'auto') {\n          this.scrollModule.removePadding(!newProp.enableRtl);\n          this.scrollModule.setPadding();\n        }\n\n        if (this.toolbar && this.toolbarModule) {\n          this.toolbarModule.getToolbar().ej2_instances[0].enableRtl = newProp.enableRtl;\n          this.toolbarModule.getToolbar().ej2_instances[0].dataBind();\n        }\n\n        if (this.contextMenuItems && this.contextMenuModule) {\n          this.contextMenuModule.getContextMenu().ej2_instances[0].enableRtl = newProp.enableRtl;\n          this.contextMenuModule.getContextMenu().ej2_instances[0].dataBind();\n        }\n\n        if (this.showColumnMenu && this.columnMenuModule) {\n          this.columnMenuModule.getColumnMenu().ej2_instances[0].enableRtl = newProp.enableRtl;\n          this.columnMenuModule.getColumnMenu().ej2_instances[0].dataBind();\n        }\n\n        if (this.filterSettings.type === 'FilterBar' && this.filterSettings.showFilterBarOperator) {\n          this.refreshHeader();\n        }\n\n        this.notify(rtlUpdated, {});\n        break;\n\n      case 'enableAltRow':\n        this.renderModule.refresh();\n        break;\n\n      case 'allowResizing':\n        this.headerModule.refreshUI();\n        this.updateResizeLines();\n        break;\n\n      case 'rowHeight':\n        if (this.rowHeight) {\n          addClass([this.element], 'e-grid-min-height');\n        } else {\n          removeClass([this.element], 'e-grid-min-height');\n        }\n\n        this.renderModule.refresh();\n        this.headerModule.refreshUI();\n        break;\n\n      case 'gridLines':\n        this.updateGridLines();\n        break;\n\n      case 'showColumnMenu':\n        this.headerModule.refreshUI();\n        this.notify(uiUpdate, {\n          module: 'columnMenu',\n          enable: true\n        });\n        break;\n\n      case 'columnMenuItems':\n        this.notify(uiUpdate, {\n          module: 'columnMenu',\n          enable: this.columnMenuItems\n        });\n        break;\n\n      case 'contextMenuItems':\n        this.notify(uiUpdate, {\n          module: 'contextMenu',\n          enable: this.contextMenuItems\n        });\n        break;\n\n      case 'showColumnChooser':\n        this.notify(uiUpdate, {\n          module: 'columnChooser',\n          enable: this.showColumnChooser\n        });\n        break;\n\n      case 'filterSettings':\n        this.updateStackedFilter();\n        this.notify(inBoundModelChanged, {\n          module: 'filter',\n          properties: newProp.filterSettings\n        });\n        break;\n\n      case 'searchSettings':\n        this.notify(inBoundModelChanged, {\n          module: 'search',\n          properties: newProp.searchSettings\n        });\n        break;\n\n      case 'sortSettings':\n        this.notify(inBoundModelChanged, {\n          module: 'sort'\n        });\n        break;\n\n      case 'selectionSettings':\n        this.notify(inBoundModelChanged, {\n          module: 'selection',\n          properties: newProp.selectionSettings\n        });\n        break;\n\n      case 'editSettings':\n        this.notify(inBoundModelChanged, {\n          module: 'edit',\n          properties: newProp.editSettings\n        });\n        break;\n\n      case 'allowTextWrap':\n      case 'textWrapSettings':\n        if (this.allowTextWrap) {\n          this.applyTextWrap();\n        } else {\n          this.removeTextWrap();\n        }\n\n        this.notify(freezeRender, {\n          case: 'textwrap',\n          isModeChg: prop === 'textWrapSettings'\n        });\n        break;\n\n      case 'dataSource':\n        // eslint-disable-next-line no-case-declarations\n        const pending = this.getDataModule().getState();\n\n        if (Object.getPrototypeOf(newProp).deepWatch) {\n          const pKeyField = this.getPrimaryKeyFieldNames()[0];\n\n          for (let i = 0, props = Object.keys(newProp.dataSource); i < props.length; i++) {\n            this.setRowData(getValue(pKeyField, this.dataSource[props[i]]), this.dataSource[props[i]]);\n          }\n        } else if (pending.isPending) {\n          let gResult = !isNullOrUndefined(this.dataSource) ? this.dataSource.result : [];\n          const names = pending.group || [];\n\n          for (let i = 0; i < names.length; i++) {\n            gResult = DataUtil.group(gResult, names[i], pending.aggregates || []);\n          }\n\n          this.dataSource = {\n            result: gResult,\n            count: this.dataSource.count,\n            aggregates: this.dataSource.aggregates\n          };\n          this.getDataModule().setState({});\n          pending.resolver(this.dataSource);\n        } else {\n          this.getDataModule().setState({\n            isDataChanged: false\n          });\n          this.notify(dataSourceModified, {});\n\n          if (!requireGridRefresh) {\n            this.renderModule.refresh();\n\n            if (this.isCheckBoxSelection) {\n              this.notify(beforeRefreshOnDataChange, {});\n            }\n          }\n        }\n\n        this.scrollRefresh();\n        break;\n\n      case 'enableHover':\n        // eslint-disable-next-line no-case-declarations\n        const action = newProp.enableHover ? addClass : removeClass;\n        action([this.element], 'e-gridhover');\n        break;\n\n      case 'selectedRowIndex':\n        if (!this.isSelectedRowIndexUpdating) {\n          this.selectRow(newProp.selectedRowIndex);\n        }\n\n        this.isSelectedRowIndexUpdating = false;\n        break;\n\n      case 'resizeSettings':\n        this.widthService.setWidthToTable();\n        break;\n\n      case 'enableAdaptiveUI':\n        this.notify(setFullScreenDialog, {});\n        break;\n\n      case 'rowRenderingMode':\n        this.enableVerticalRendering();\n        this.notify(rowModeChange, {});\n        this.refresh();\n        break;\n\n      case 'enableStickyHeader':\n        this.scrollModule.addStickyListener(newProp.enableStickyHeader);\n        break;\n    }\n  }\n\n  maintainSelection(index) {\n    if (index !== -1) {\n      const fn = () => {\n        this.selectRow(index);\n        this.off(contentReady, fn);\n      };\n\n      this.on(contentReady, fn, this);\n    }\n  }\n  /**\n   * @param {Object} prop - Defines the property\n   * @param {boolean} muteOnChange - Defines the mute on change\n   * @returns {void}\n   * @private\n   */\n\n\n  setProperties(prop, muteOnChange) {\n    super.setProperties(prop, muteOnChange);\n    const filterSettings = 'filterSettings';\n\n    if (prop[filterSettings] && this.filterModule && muteOnChange) {\n      this.filterModule.refreshFilter();\n    }\n  }\n  /**\n   * @hidden\n   * @returns {void}\n   */\n\n\n  setTablesCount() {\n    const frozenCols = this.getFrozenColumns();\n    const frozenLeft$$1 = this.getFrozenLeftColumnsCount();\n    const frozenRight$$1 = this.getFrozenRightColumnsCount();\n\n    if (frozenCols && !frozenLeft$$1 && !frozenRight$$1) {\n      this.tablesCount = 2;\n    } else if (!frozenCols && (frozenLeft$$1 || frozenRight$$1)) {\n      if (frozenLeft$$1 && !frozenRight$$1 || frozenRight$$1 && !frozenLeft$$1) {\n        this.tablesCount = 2;\n      } else if (frozenLeft$$1 && frozenRight$$1) {\n        this.tablesCount = 3;\n      }\n    }\n  }\n  /**\n   * @hidden\n   * @returns {number} - Returns the tables count\n   */\n\n\n  getTablesCount() {\n    return this.tablesCount;\n  }\n  /**\n   * @hidden\n   * @returns {void}\n   */\n\n\n  updateDefaultCursor() {\n    let headerCells = [].slice.call(this.getHeaderContent().querySelectorAll('.e-headercell:not(.e-stackedheadercell)'));\n    const stdHdrCell = [].slice.call(this.getHeaderContent().getElementsByClassName('e-stackedheadercell'));\n    const cols = this.getColumns();\n\n    if (this.enableColumnVirtualization && this.getFrozenColumns()) {\n      const cells = this.contentModule.getHeaderCells();\n      headerCells = cells.length ? cells : headerCells;\n    }\n\n    for (let i = 0; i < headerCells.length; i++) {\n      const cell = headerCells[i];\n\n      if (this.allowGrouping || this.allowReordering || this.allowSorting) {\n        if (!cols[i].allowReordering || !cols[i].allowSorting || !cols[i].allowGrouping) {\n          cell.classList.add('e-defaultcursor');\n        } else {\n          cell.classList.add('e-mousepointer');\n        }\n      }\n    }\n\n    for (let count = 0; count < stdHdrCell.length; count++) {\n      if (this.allowReordering) {\n        stdHdrCell[count].classList.add('e-mousepointer');\n      }\n    }\n  }\n\n  updateColumnModel(columns) {\n    for (let i = 0, len = columns.length; i < len; i++) {\n      if (columns[i].columns) {\n        this.updateColumnModel(columns[i].columns);\n      } else {\n        this.columnModel.push(columns[i]);\n      }\n    }\n\n    this.updateColumnLevelFrozen();\n    this.updateFrozenColumns();\n    this.updateLockableColumns();\n  }\n\n  updateColumnLevelFrozen() {\n    const cols = this.columnModel;\n    const leftCols = [];\n    const rightCols = [];\n    const movableCols = [];\n\n    if (this.frozenLeftCount || this.frozenRightCount) {\n      for (let i = 0, len = cols.length; i < len; i++) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const col = cols[i];\n\n        if (col.freeze === 'Left') {\n          col.freezeTable = frozenLeft;\n          leftCols.push(col);\n        } else if (col.freeze === 'Right') {\n          col.freezeTable = frozenRight;\n          rightCols.push(col);\n        } else {\n          col.freezeTable = 'movable';\n          movableCols.push(col);\n        }\n      }\n\n      this.columnModel = leftCols.concat(movableCols).concat(rightCols);\n    }\n  }\n\n  updateFrozenColumns() {\n    if (this.frozenLeftCount || this.frozenRightCount) {\n      return;\n    }\n\n    const cols = this.columnModel;\n    const directFrozenCount = this.frozenColumns;\n    const totalFrozenCount = this.getFrozenColumns();\n    let count = 0;\n\n    for (let i = 0, len = cols.length; i < len; i++) {\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      const col = cols[i];\n\n      if (directFrozenCount) {\n        if (i < directFrozenCount) {\n          col.freezeTable = frozenLeft;\n        } else {\n          col.freezeTable = 'movable';\n        }\n      }\n\n      if (col.isFrozen && i >= directFrozenCount) {\n        col.freezeTable = frozenLeft;\n        cols.splice(this.frozenColumns + count, 0, cols.splice(i, 1)[0]);\n        count++;\n      } else if (totalFrozenCount && !directFrozenCount) {\n        col.freezeTable = 'movable';\n      }\n    }\n  }\n\n  getFrozenLeftCount() {\n    return this.getFrozenColumns() || this.getFrozenLeftColumnsCount();\n  }\n\n  isFrozenGrid() {\n    return this.getFrozenColumns() !== 0 || this.getFrozenLeftColumnsCount() !== 0 || this.getFrozenRightColumnsCount() !== 0;\n  }\n\n  getFrozenMode() {\n    return this.frozenName;\n  }\n\n  updateLockableColumns() {\n    const cols = this.columnModel;\n    let frozenCount = 0;\n    let movableCount = 0;\n    const frozenColumns = this.getFrozenColumns();\n\n    for (let i = 0; i < cols.length; i++) {\n      if (cols[i].lockColumn) {\n        if (i < frozenColumns) {\n          cols.splice(frozenCount, 0, cols.splice(i, 1)[0]);\n          frozenCount++;\n        } else {\n          cols.splice(frozenColumns + movableCount, 0, cols.splice(i, 1)[0]);\n          movableCount++;\n        }\n      }\n    }\n  }\n\n  checkLockColumns(cols) {\n    for (let i = 0; i < cols.length; i++) {\n      if (cols[i].columns) {\n        this.checkLockColumns(cols[i].columns);\n      } else if (cols[i].lockColumn) {\n        this.lockcolPositionCount++;\n      }\n    }\n  }\n  /**\n   * Gets the columns from the Grid.\n   *\n   * @param {boolean} isRefresh - Defines the boolean whether to refresh\n   * @returns {Column[]} - returns the column\n   */\n\n\n  getColumns(isRefresh) {\n    const inview = this.inViewIndexes.map(v => v - this.groupSettings.columns.length).filter(v => v > -1);\n    const vLen = inview.length;\n\n    if (!this.enableColumnVirtualization || isNullOrUndefined(this.columnModel) || this.columnModel.length === 0 || isRefresh) {\n      this.columnModel = [];\n      this.updateColumnModel(this.columns);\n    }\n\n    let columns = vLen === 0 ? this.columnModel : this.columnModel.slice(inview[0], inview[vLen - 1] + 1);\n\n    if (this.contentModule && this.enableColumnVirtualization && this.isFrozenGrid() && inview.length && inview[0] > 0) {\n      const frozenCols = this.contentModule.ensureFrozenCols(columns);\n      columns = frozenCols;\n    }\n\n    return columns;\n  }\n  /**\n   * @private\n   * @param {string} stackedHeader - Defines the stacked header\n   * @param {Column[]} col - Defines the column\n   * @returns {Column} Returns the Column\n   */\n\n\n  getStackedHeaderColumnByHeaderText(stackedHeader, col) {\n    for (let i = 0; i < col.length; i++) {\n      const individualColumn = col[i];\n\n      if (individualColumn.field === stackedHeader || individualColumn.headerText === stackedHeader) {\n        this.stackedColumn = individualColumn;\n        break;\n      } else if (individualColumn.columns) {\n        this.getStackedHeaderColumnByHeaderText(stackedHeader, individualColumn.columns);\n      }\n    }\n\n    return this.stackedColumn;\n  }\n  /**\n   * @private\n   * @returns {number[]} Returns the column indexes\n   */\n\n\n  getColumnIndexesInView() {\n    return this.inViewIndexes;\n  }\n  /**\n   * @private\n   * @returns {Query} - returns the query\n   */\n\n\n  getQuery() {\n    return this.query;\n  }\n  /**\n   * @private\n   * @returns {object} - returns the locale constants\n   */\n\n\n  getLocaleConstants() {\n    return this.defaultLocale;\n  }\n  /**\n   * @param {number[]} indexes - specifies the indexes\n   * @returns {void}\n   * @private\n   */\n\n\n  setColumnIndexesInView(indexes) {\n    this.inViewIndexes = indexes;\n  }\n  /**\n   * Gets the visible columns from the Grid.\n   *\n   * @returns {Column[]} returns the column\n   */\n\n\n  getVisibleColumns() {\n    return this.getCurrentVisibleColumns();\n  }\n  /**\n   * Gets the header div of the Grid.\n   *\n   * @returns {Element} - Returns the element\n   */\n\n\n  getHeaderContent() {\n    return this.headerModule.getPanel();\n  }\n  /**\n   * Sets the header div of the Grid to replace the old header.\n   *\n   * @param  {Element} element - Specifies the Grid header.\n   * @returns {void}\n   */\n\n\n  setGridHeaderContent(element) {\n    this.headerModule.setPanel(element);\n  }\n  /**\n   * Gets the content table of the Grid.\n   *\n   * @returns {Element} - Returns the element\n   */\n\n\n  getContentTable() {\n    return this.contentModule.getTable();\n  }\n  /**\n   * Sets the content table of the Grid to replace the old content table.\n   *\n   * @param  {Element} element - Specifies the Grid content table.\n   * @returns {void}\n   */\n\n\n  setGridContentTable(element) {\n    this.contentModule.setTable(element);\n  }\n  /**\n   * Gets the content div of the Grid.\n   *\n   * @returns {Element} Returns the element\n   */\n\n\n  getContent() {\n    return this.contentModule.getPanel();\n  }\n  /**\n   * Sets the content div of the Grid to replace the old Grid content.\n   *\n   * @param  {Element} element - Specifies the Grid content.\n   * @returns {void}\n   */\n\n\n  setGridContent(element) {\n    this.contentModule.setPanel(element);\n  }\n  /**\n   * Gets the header table element of the Grid.\n   *\n   * @returns {Element} returns the element\n   */\n\n\n  getHeaderTable() {\n    return this.headerModule.getTable();\n  }\n  /**\n   * Sets the header table of the Grid to replace the old one.\n   *\n   * @param  {Element} element - Specifies the Grid header table.\n   * @returns {void}\n   */\n\n\n  setGridHeaderTable(element) {\n    this.headerModule.setTable(element);\n  }\n  /**\n   * Gets the footer div of the Grid.\n   *\n   * @returns {Element} returns the element\n   */\n\n\n  getFooterContent() {\n    this.footerElement = this.element.getElementsByClassName(gridFooter)[0];\n    return this.footerElement;\n  }\n  /**\n   * Gets the footer table element of the Grid.\n   *\n   * @returns {Element} returns the element\n   */\n\n\n  getFooterContentTable() {\n    this.footerElement = this.element.getElementsByClassName(gridFooter)[0];\n    return this.footerElement.firstChild.firstChild;\n  }\n  /**\n   * Gets the pager of the Grid.\n   *\n   * @returns {Element} returns the element\n   */\n\n\n  getPager() {\n    return this.gridPager; //get element from pager\n  }\n  /**\n   * Sets the pager of the Grid to replace the old pager.\n   *\n   * @param  {Element} element - Specifies the Grid pager.\n   * @returns {void}\n   */\n\n\n  setGridPager(element) {\n    this.gridPager = element;\n  }\n  /**\n   * Gets a row by index.\n   *\n   * @param  {number} index - Specifies the row index.\n   * @returns {Element} returns the element\n   */\n\n\n  getRowByIndex(index) {\n    return this.contentModule.getRowByIndex(index);\n  }\n  /**\n   * Gets a movable tables row by index.\n   *\n   * @param  {number} index - Specifies the row index.\n   * @returns {Element} returns the element\n   */\n\n\n  getMovableRowByIndex(index) {\n    return this.contentModule.getMovableRowByIndex(index);\n  }\n  /**\n   * Gets a frozen tables row by index.\n   *\n   * @param  {number} index - Specifies the row index.\n   * @returns {Element} returns the element\n   */\n\n\n  getFrozenRowByIndex(index) {\n    return this.getFrozenDataRows()[index];\n  }\n  /**\n   * Gets all the data rows of the Grid.\n   *\n   * @returns {Element[]} returns the element\n   */\n\n\n  getRows() {\n    return this.contentModule.getRowElements();\n  }\n  /**\n   * Gets a frozen right tables row element by index.\n   *\n   * @param  {number} index - Specifies the row index.\n   * @returns {Element} returns the element\n   */\n\n\n  getFrozenRightRowByIndex(index) {\n    return this.contentModule.getFrozenRightRowByIndex(index);\n  }\n  /**\n   * Get a row information based on cell\n   *\n   * @param {Element | EventTarget} target - specifies the element\n   * @returns {RowInfo} returns the row info\n   */\n\n\n  getRowInfo(target) {\n    const ele = target;\n    let args = {\n      target: target\n    };\n\n    if (!isNullOrUndefined(target) && isNullOrUndefined(parentsUntil(ele, 'e-detailrowcollapse') && isNullOrUndefined(parentsUntil(ele, 'e-recordplusexpand')))) {\n      const cell = closest(ele, '.' + rowCell);\n\n      if (!cell) {\n        const row$$1 = closest(ele, '.' + row);\n\n        if (!isNullOrUndefined(row$$1) && !row$$1.classList.contains('e-addedrow')) {\n          const rowObj = this.getRowObjectFromUID(row$$1.getAttribute('data-uid'));\n          const rowIndex = parseInt(row$$1.getAttribute(ariaRowIndex), 10);\n          args = {\n            row: row$$1,\n            rowData: rowObj.data,\n            rowIndex: rowIndex\n          };\n        }\n\n        return args;\n      }\n\n      const cellIndex = parseInt(cell.getAttribute(ariaColIndex), 10);\n\n      if (!isNullOrUndefined(cell) && !isNaN(cellIndex)) {\n        const row$$1 = closest(cell, '.' + row);\n        const rowIndex = parseInt(row$$1.getAttribute(ariaRowIndex), 10);\n        const frzCols = this.getFrozenColumns();\n        const tableName = this.columnModel[cellIndex].getFreezeTableName();\n        let rows = this.contentModule.getRows();\n        let index = cellIndex + this.getIndentCount();\n\n        if (this.isFrozenGrid()) {\n          if (tableName === frozenLeft) {\n            rows = this.contentModule.getRows();\n          } else if (tableName === 'movable') {\n            index = cellIndex - frzCols - this.frozenLeftCount;\n            rows = this.contentModule.getMovableRows();\n          } else if (tableName === frozenRight) {\n            index = cellIndex - (this.frozenLeftCount + this.movableCount);\n            rows = this.contentModule.getFrozenRightRows();\n          }\n        }\n\n        const rowsObject = rows.filter(r => r.uid === row$$1.getAttribute('data-uid'));\n        let rowData = {};\n        let column;\n\n        if (Object.keys(rowsObject).length) {\n          rowData = rowsObject[0].data;\n          column = rowsObject[0].cells[index].column;\n        }\n\n        args = {\n          cell: cell,\n          cellIndex: cellIndex,\n          row: row$$1,\n          rowIndex: rowIndex,\n          rowData: rowData,\n          column: column,\n          target: target\n        };\n      }\n    }\n\n    return args;\n  }\n  /**\n   * Gets the Grid's movable content rows from frozen grid.\n   *\n   * @returns {Element[]} returns the element\n   */\n\n\n  getMovableRows() {\n    return this.contentModule.getMovableRowElements();\n  }\n  /**\n   * Gets the Grid's frozen right content rows from frozen grid.\n   *\n   * @returns {Element[]} returns the element\n   */\n\n\n  getFrozenRightRows() {\n    return this.contentModule.getFrozenRightRowElements();\n  }\n  /**\n   * Gets all the Grid's data rows.\n   *\n   * @returns {Element[]} returns the element\n   */\n\n\n  getDataRows() {\n    return this.getAllDataRows();\n  }\n  /**\n   * @param {boolean} includeAdd - specifies includeAdd\n   * @returns {Element[]} returns the element\n   * @hidden\n   */\n\n\n  getAllDataRows(includeAdd) {\n    if (isNullOrUndefined(this.getContentTable().querySelector(tbody))) {\n      return [];\n    }\n\n    const tbody$$1 = this.isFrozenGrid() ? this.getFrozenLeftContentTbody() : this.getContentTable().querySelector(tbody);\n    let rows = [].slice.call(tbody$$1.children);\n\n    if (this.frozenRows) {\n      const hdrTbody = this.isFrozenGrid() ? this.getHeaderContent().querySelector('.' + frozenHeader).querySelector(tbody) : this.getHeaderTable().querySelector(tbody);\n      const freezeRows = [].slice.call(hdrTbody.children);\n      rows = this.addMovableRows(freezeRows, rows);\n    }\n\n    const dataRows = this.generateDataRows(rows, includeAdd);\n    return dataRows;\n  }\n  /**\n   * @param {HTMLElement[]} fRows - Defines the frozen Rows\n   * @param {HTMLElement[]} mrows - Defines the movable Rows\n   * @returns {HTMLElement[]} Returns the element\n   * @hidden\n   */\n\n\n  addMovableRows(fRows, mrows) {\n    for (let i = 0, len = mrows.length; i < len; i++) {\n      fRows.push(mrows[i]);\n    }\n\n    return fRows;\n  }\n\n  generateDataRows(rows, includAdd) {\n    const dRows = [];\n\n    for (let i = 0, len = rows.length; i < len; i++) {\n      if (rows[i].classList.contains(row) && (!rows[i].classList.contains('e-hiddenrow') || includAdd)) {\n        if (this.isCollapseStateEnabled()) {\n          dRows[parseInt(rows[i].getAttribute('aria-rowindex'), 10)] = rows[i];\n        } else {\n          dRows.push(rows[i]);\n        }\n      }\n    }\n\n    return dRows;\n  }\n  /**\n   * Gets all the Grid's movable table data rows.\n   *\n   * @returns {Element[]} Returns the element\n   */\n\n\n  getMovableDataRows() {\n    return this.getAllMovableDataRows();\n  }\n  /**\n   * @param {boolean} includeAdd Defines the include add in boolean\n   * @returns {Element[]} Returns the element\n   * @hidden\n   */\n\n\n  getAllMovableDataRows(includeAdd) {\n    if (!this.isFrozenGrid()) {\n      return [];\n    }\n\n    let rows = [].slice.call(this.getContent().querySelector('.' + movableContent).querySelector(tbody).children);\n\n    if (this.frozenRows) {\n      const freezeRows = [].slice.call(this.getHeaderContent().querySelector('.' + movableHeader).querySelector(tbody).children);\n      rows = this.addMovableRows(freezeRows, rows);\n    }\n\n    const dataRows = this.generateDataRows(rows, includeAdd);\n    return dataRows;\n  }\n  /**\n   * Gets all the Grid's frozen table data rows.\n   *\n   * @returns {Element[]} returns the element\n   */\n\n\n  getFrozenDataRows() {\n    return this.getAllFrozenDataRows();\n  }\n  /**\n   * @param {boolean} includeAdd Defines the include add in boolean\n   * @returns {Element[]} Returns the element\n   * @hidden\n   */\n\n\n  getAllFrozenDataRows(includeAdd) {\n    let rows = [].slice.call(this.getContent().querySelector('.' + frozenContent).querySelector(tbody).children);\n\n    if (this.frozenRows) {\n      const freezeRows = [].slice.call(this.getHeaderContent().querySelector('.' + frozenHeader).querySelector(tbody).children);\n      rows = this.addMovableRows(freezeRows, rows);\n    }\n\n    const dataRows = this.generateDataRows(rows, includeAdd);\n    return dataRows;\n  }\n  /**\n   * Gets all the Grid's frozen right table data rows.\n   *\n   * @returns {Element[]} Returns the Element\n   */\n\n\n  getFrozenRightDataRows() {\n    return this.getAllFrozenRightDataRows();\n  }\n  /**\n   * @param {boolean} includeAdd Defines the include add in boolean\n   * @returns {Element[]} Returns the element\n   * @hidden\n   */\n\n\n  getAllFrozenRightDataRows(includeAdd) {\n    if (this.getFrozenMode() !== 'Right' && this.getFrozenMode() !== 'Left-Right') {\n      return [];\n    }\n\n    let rows = [].slice.call(this.getContent().querySelector('.e-frozen-right-content').querySelector(tbody).children);\n\n    if (this.frozenRows) {\n      const freezeRows = [].slice.call(this.getHeaderContent().querySelector('.e-frozen-right-header').querySelector(tbody).children);\n      rows = this.addMovableRows(freezeRows, rows);\n    }\n\n    const dataRows = this.generateDataRows(rows, includeAdd);\n    return dataRows;\n  }\n  /**\n   * Updates particular cell value based on the given primary key value.\n   * > Primary key column must be specified using `columns.isPrimaryKey` property.\n   *\n   * @param {string| number} key - Specifies the PrimaryKey value of dataSource.\n   * @param {string } field - Specifies the field name which you want to update.\n   * @param {string | number | boolean | Date} value - To update new value for the particular cell.\n   * @returns {void}\n   */\n\n\n  setCellValue(key, field, value) {\n    const cells = 'cells';\n    const rowData = 'data';\n    const rowIdx = 'index';\n    const rowuID = 'uid';\n    const isRight = this.getFrozenMode() === 'Right';\n    const pkName = this.getPrimaryKeyFieldNames()[0];\n    const cell = new CellRenderer(this, this.serviceLocator);\n    let fieldIdx = this.getColumnIndexByField(field);\n    const col = this.getColumnByField(field);\n    const rowObjects = col.getFreezeTableName() === 'movable' ? this.contentModule.getMovableRows() : col.getFreezeTableName() === 'frozen-right' ? this.getFrozenRightRowsObject() : this.contentModule.getRows();\n    const selectedRow = rowObjects.filter(r => getValue(pkName, r.data) === key)[0];\n    const tr = selectedRow ? this.element.querySelector('[data-uid=' + selectedRow[rowuID] + ']') : null;\n\n    if (!isNullOrUndefined(tr)) {\n      setValue(field, value, selectedRow[rowData]);\n      let left = this.getFrozenLeftColumnsCount() || this.getFrozenColumns();\n      const movable = this.getMovableColumnsCount();\n\n      if (this.isRowDragable() && !isRight) {\n        left++;\n      }\n\n      const frIdx = left + movable;\n      const td = this.getCellFromIndex(selectedRow[rowIdx], fieldIdx);\n\n      if (!isNullOrUndefined(td)) {\n        const Idx = col.getFreezeTableName() === 'movable' ? left : col.getFreezeTableName() === 'frozen-right' ? frIdx : 0;\n\n        if (this.groupSettings.columns.length) {\n          fieldIdx = fieldIdx + this.groupSettings.columns.length;\n        }\n\n        if (this.childGrid || this.detailTemplate) {\n          fieldIdx++;\n        }\n\n        if (this.isRowDragable() && !isRight) {\n          fieldIdx++;\n        }\n\n        const sRow = selectedRow[cells][fieldIdx - Idx];\n        cell.refreshTD(td, sRow, selectedRow[rowData], {\n          index: selectedRow[rowIdx]\n        });\n\n        if (this.aggregates.length > 0) {\n          this.notify(refreshFooterRenderer, {});\n\n          if (this.groupSettings.columns.length > 0) {\n            this.notify(groupAggregates, {});\n          }\n        }\n        /* tslint:disable:no-string-literal */\n\n\n        if (!isNullOrUndefined(selectedRow) && !isNullOrUndefined(selectedRow['changes'])) {\n          selectedRow['changes'][field] = value;\n        }\n        /* tslint:disable:no-string-literal */\n\n\n        this.trigger(queryCellInfo, {\n          cell: td,\n          column: col,\n          data: selectedRow[rowData]\n        });\n      }\n    } else {\n      return;\n    }\n  }\n  /**\n   * @param {string} columnUid - Defines column uid\n   * @returns {void}\n   * @hidden\n   */\n\n\n  refreshReactColumnTemplateByUid(columnUid) {\n    if (this.isReact) {\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      this.clearTemplate(['columnTemplate'], undefined, () => {\n        const cells = 'cells';\n        const rowIdx = 'index';\n        const rowsObj = this.getRowsObject();\n        const indent = this.getIndentCount();\n        const cellIndex = this.getNormalizedColumnIndex(columnUid);\n\n        for (let j = 0; j < rowsObj.length; j++) {\n          if (rowsObj[j].isDataRow && !isNullOrUndefined(rowsObj[j].index)) {\n            const cell = rowsObj[j][cells][cellIndex];\n            const cellRenderer = new CellRenderer(this, this.serviceLocator);\n            const td = this.getCellFromIndex(rowsObj[j].index, cellIndex - indent);\n            cellRenderer.refreshTD(td, cell, rowsObj[j].data, {\n              index: rowsObj[j][rowIdx]\n            });\n          }\n        }\n      });\n    }\n  }\n  /**\n   * @param {string} columnUid - Defines column uid\n   * @returns {void}\n   * @hidden\n   */\n\n\n  refreshReactHeaderTemplateByUid(columnUid) {\n    if (this.isReact) {\n      const cells = 'cells';\n      const rowsObj = this.headerModule.rows;\n      const cellIndex = this.getNormalizedColumnIndex(columnUid);\n\n      for (let j = 0; j < rowsObj.length; j++) {\n        const cell = rowsObj[j][cells][cellIndex];\n\n        if (cell && cell.column.uid === columnUid) {\n          const headerCellRenderer = new HeaderCellRenderer(this, this.serviceLocator);\n          const td = parentsUntil(this.element.querySelectorAll('[e-mappinguid=' + columnUid + ']')[0], 'e-templatecell');\n          headerCellRenderer.refresh(cell, td);\n        }\n      }\n    }\n  }\n  /**\n   * Updates and refresh the particular row values based on the given primary key value.\n   * > Primary key column must be specified using `columns.isPrimaryKey` property.\n   *\n   * @param {string| number} key - Specifies the PrimaryKey value of dataSource.\n   * @param {Object} rowData - To update new data for the particular row.\n   * @returns {void}\n   */\n\n\n  setRowData(key, rowData) {\n    const rowuID = 'uid';\n    let rowObjects = this.contentModule.getRows();\n    const pkName = this.getPrimaryKeyFieldNames()[0];\n    const rowRenderer = new RowRenderer(this.serviceLocator, null, this);\n\n    if (this.groupSettings.columns.length > 0 && this.aggregates.length > 0) {\n      rowObjects = rowObjects.filter(row$$1 => row$$1.isDataRow);\n    }\n\n    const selectedRow = rowObjects.filter(r => getValue(pkName, r.data) === key)[0];\n\n    if (!isNullOrUndefined(selectedRow) && this.element.querySelectorAll('[data-uid=' + selectedRow[rowuID] + ']').length) {\n      selectedRow.changes = rowData;\n      refreshForeignData(selectedRow, this.getForeignKeyColumns(), selectedRow.changes);\n      rowRenderer.refresh(selectedRow, this.getColumns(), true);\n\n      if (this.aggregates.length > 0) {\n        this.notify(refreshFooterRenderer, {});\n\n        if (this.groupSettings.columns.length > 0) {\n          this.notify(groupAggregates, {});\n        }\n      }\n    } else {\n      return;\n    }\n  }\n  /**\n   * Gets a cell by row and column index.\n   *\n   * @param  {number} rowIndex - Specifies the row index.\n   * @param  {number} columnIndex - Specifies the column index.\n   * @returns {Element} Returns the Element\n   */\n\n\n  getCellFromIndex(rowIndex, columnIndex) {\n    const col = this.getColumnByIndex(columnIndex);\n    return getCellByColAndRowIndex(this, col, rowIndex, columnIndex);\n  }\n  /**\n   * Gets a movable table cell by row and column index.\n   *\n   * @param  {number} rowIndex - Specifies the row index.\n   * @param  {number} columnIndex - Specifies the column index.\n   * @returns {Element} Returns the Element\n   */\n\n\n  getMovableCellFromIndex(rowIndex, columnIndex) {\n    if (this.frozenName === 'Left-Right' && columnIndex >= this.movableCount) {\n      return undefined;\n    }\n\n    const index = this.getFrozenColumns() || this.getFrozenLeftColumnsCount();\n    return this.getMovableDataRows()[rowIndex] && this.getMovableDataRows()[rowIndex].getElementsByClassName(rowCell)[columnIndex - index];\n  }\n  /**\n   * Gets a frozen right table cell by row and column index.\n   *\n   * @param  {number} rowIndex - Specifies the row index.\n   * @param  {number} columnIndex - Specifies the column index.\n   * @returns {Element} Returns the Element\n   */\n\n\n  getFrozenRightCellFromIndex(rowIndex, columnIndex) {\n    const index = this.getFrozenLeftColumnsCount() + this.getMovableColumnsCount();\n    const rows = this.getFrozenRightDataRows();\n    return rows[rowIndex] && rows[rowIndex].getElementsByClassName(rowCell)[columnIndex - index];\n  }\n  /**\n   * Gets a column header by column index.\n   *\n   * @param  {number} index - Specifies the column index.\n   * @returns {Element} Returns the Element\n   */\n\n\n  getColumnHeaderByIndex(index) {\n    return this.getHeaderTable().getElementsByClassName('e-headercell')[index];\n  }\n  /**\n   * Gets a movable column header by column index.\n   *\n   * @param  {number} index - Specifies the column index.\n   * @returns {Element} Returns the Element\n   */\n\n\n  getMovableColumnHeaderByIndex(index) {\n    const left = this.getFrozenColumns() || this.getFrozenLeftColumnsCount();\n    return this.getMovableVirtualHeader().getElementsByClassName('e-headercell')[index - left];\n  }\n  /**\n   * Gets a frozen right column header by column index.\n   *\n   * @param  {number} index - Specifies the column index.\n   * @returns {Element} Returns the Element\n   */\n\n\n  getFrozenRightColumnHeaderByIndex(index) {\n    const left = this.getFrozenLeftColumnsCount() + this.getMovableColumnsCount();\n    return this.getFrozenRightHeader().getElementsByClassName('e-headercell')[index - left];\n  }\n  /**\n   * Gets a frozen left column header by column index.\n   *\n   * @param  {number} index - Specifies the column index.\n   * @returns {Element} Returns the Element\n   */\n\n\n  getFrozenLeftColumnHeaderByIndex(index) {\n    return this.getFrozenVirtualHeader().getElementsByClassName('e-headercell')[index];\n  }\n  /**\n   * @param {string} uid - Defines the uid\n   * @param {boolean} isMovable - Defines isMovable\n   * @param {boolean} isFrozenRight - Defines isFrozenRight\n   * @returns {Row<Column>} Returns the row object\n   * @hidden\n   */\n\n\n  getRowObjectFromUID(uid, isMovable, isFrozenRight) {\n    const rows = this.contentModule.getRows();\n    let row$$1 = this.rowObject(rows, uid);\n\n    if (this.isFrozenGrid()) {\n      if (!row$$1 || isMovable || isFrozenRight) {\n        row$$1 = this.rowObject(this.contentModule.getMovableRows(), uid);\n\n        if (!row$$1 && this.getFrozenMode() === 'Left-Right' || isFrozenRight) {\n          row$$1 = this.rowObject(this.contentModule.getFrozenRightRows(), uid);\n        }\n\n        return row$$1;\n      }\n    }\n\n    if (isNullOrUndefined(row$$1) && this.enableVirtualization && this.groupSettings.columns.length > 0) {\n      row$$1 = this.rowObject(this.vRows, uid);\n      return row$$1;\n    }\n\n    return row$$1;\n  }\n\n  rowObject(rows, uid) {\n    for (const row$$1 of rows) {\n      if (row$$1.uid === uid) {\n        return row$$1;\n      }\n    }\n\n    return null;\n  }\n  /**\n   * @hidden\n   * @returns {Row<Column>[]} Returns the Row object\n   */\n\n\n  getRowsObject() {\n    return this.contentModule.getRows();\n  }\n  /**\n   * @hidden\n   * @returns {Row<Column>[]} Returns the Row object\n   */\n\n\n  getMovableRowsObject() {\n    let rows = [];\n\n    if (this.isFrozenGrid()) {\n      rows = this.contentModule.getMovableRows();\n    }\n\n    return rows;\n  }\n  /**\n   * @hidden\n   * @returns {Row<Column>[]} Returns the Row object\n   */\n\n\n  getFrozenRightRowsObject() {\n    let rows = [];\n\n    if (this.getFrozenMode() === 'Right' || this.getFrozenMode() === 'Left-Right') {\n      rows = this.contentModule.getFrozenRightRows();\n    }\n\n    return rows;\n  }\n  /**\n   * Gets a column header by column name.\n   *\n   * @param  {string} field - Specifies the column name.\n   * @returns {Element} - Returns the element\n   */\n\n\n  getColumnHeaderByField(field) {\n    const column = this.getColumnByField(field);\n    return column ? this.getColumnHeaderByUid(column.uid) : undefined;\n  }\n  /**\n   * Gets a column header by UID.\n   *\n   * @param {string} uid - Specifies the column uid.\n   * @returns {Element} - Returns the element\n   */\n\n\n  getColumnHeaderByUid(uid) {\n    const element = this.getHeaderContent().querySelector('[e-mappinguid=' + uid + ']');\n    return element ? element.parentElement : undefined;\n  }\n  /**\n   * @hidden\n   * @param {number} index - Defines the index\n   * @returns {Column} Returns the column\n   */\n\n\n  getColumnByIndex(index) {\n    let column;\n    this.getColumns().some((col, i) => {\n      column = col;\n      return i === index;\n    });\n    return column;\n  }\n  /**\n   * Gets a Column by column name.\n   *\n   * @param  {string} field - Specifies the column name.\n   * @returns {Column} Returns the column\n   */\n\n\n  getColumnByField(field) {\n    return iterateArrayOrObject(this.getColumns(), item => {\n      if (item.field === field) {\n        return item;\n      }\n\n      return undefined;\n    })[0];\n  }\n  /**\n   * Gets a column index by column name.\n   *\n   * @param  {string} field - Specifies the column name.\n   * @returns {number} Returns the index by field\n   */\n\n\n  getColumnIndexByField(field) {\n    const cols = this.getColumns();\n\n    for (let i = 0; i < cols.length; i++) {\n      if (cols[i].field === field) {\n        return i;\n      }\n    }\n\n    return -1;\n  }\n  /**\n   * Gets a column by UID.\n   *\n   * @param  {string} uid - Specifies the column UID.\n   * @returns {Column} Returns the column\n   */\n\n\n  getColumnByUid(uid) {\n    return iterateArrayOrObject([...this.getColumns(), ...this.getStackedColumns(this.columns)], item => {\n      if (item.uid === uid) {\n        return item;\n      }\n\n      return undefined;\n    })[0];\n  }\n  /**\n   * @param {Column[]} columns - Defines the columns\n   * @param {Column[]} stackedColumn - Defines the stacked columns\n   * @returns {Column[]} Returns the columns\n   * @hidden\n   */\n\n\n  getStackedColumns(columns, stackedColumn = []) {\n    for (const column of columns) {\n      if (column.columns) {\n        stackedColumn.push(column);\n        this.getStackedColumns(column.columns, stackedColumn);\n      }\n    }\n\n    return stackedColumn;\n  }\n  /**\n   * Gets a column index by UID.\n   *\n   * @param  {string} uid - Specifies the column UID.\n   * @returns {number} Returns the column by index\n   */\n\n\n  getColumnIndexByUid(uid) {\n    const index = iterateArrayOrObject(this.getColumns(), (item, index) => {\n      if (item.uid === uid) {\n        return index;\n      }\n\n      return undefined;\n    })[0];\n    return !isNullOrUndefined(index) ? index : -1;\n  }\n  /**\n   * Gets UID by column name.\n   *\n   * @param  {string} field - Specifies the column name.\n   * @returns {string} Returns the column by field\n   */\n\n\n  getUidByColumnField(field) {\n    return iterateArrayOrObject(this.getColumns(), item => {\n      if (item.field === field) {\n        return item.uid;\n      }\n\n      return undefined;\n    })[0];\n  }\n  /**\n   * Gets column index by column uid value.\n   *\n   * @private\n   * @param  {string} uid - Specifies the column uid.\n   * @returns {number} Returns the column by field\n   */\n\n\n  getNormalizedColumnIndex(uid) {\n    const index = this.getColumnIndexByUid(uid);\n    return index + this.getIndentCount();\n  }\n  /**\n   * Gets indent cell count.\n   *\n   * @private\n   * @returns {number} Returns the indent count\n   */\n\n\n  getIndentCount() {\n    let index = 0;\n\n    if (this.allowGrouping) {\n      index += this.groupSettings.columns.length;\n    }\n\n    if (this.isDetail()) {\n      index++;\n    }\n\n    if (this.isRowDragable() && isNullOrUndefined(this.rowDropSettings.targetID)) {\n      index++;\n    }\n    /**\n     * TODO: index normalization based on the stacked header, grouping and detailTemplate\n     * and frozen should be handled here\n     */\n\n\n    return index;\n  }\n  /**\n   * Gets the collection of column fields.\n   *\n   * @returns {string[]} Returns the Field names\n   */\n\n\n  getColumnFieldNames() {\n    const columnNames = [];\n    let column;\n\n    for (let i = 0, len = this.getColumns().length; i < len; i++) {\n      column = this.getColumns()[i];\n\n      if (column.visible) {\n        columnNames.push(column.field);\n      }\n    }\n\n    return columnNames;\n  }\n  /**\n   * Gets a compiled row template.\n   *\n   * @returns {Function} Returns the row TEmplate\n   * @private\n   */\n\n\n  getRowTemplate() {\n    return this.rowTemplateFn;\n  }\n  /**\n   * Gets a compiled detail row template.\n   *\n   * @private\n   * @returns {Function} Returns the Detail template\n   */\n\n\n  getDetailTemplate() {\n    return this.detailTemplateFn;\n  }\n  /**\n   * Gets a compiled detail row template.\n   *\n   * @private\n   * @returns {Function}Returns the Edit template\n   */\n\n\n  getEditTemplate() {\n    return this.editTemplateFn;\n  }\n  /**\n   * Gets a compiled dialog edit header template.\n   *\n   * @private\n   * @returns {Function} returns template function\n   */\n\n\n  getEditHeaderTemplate() {\n    return this.editHeaderTemplateFn;\n  }\n  /**\n   * Gets a compiled dialog edit footer template.\n   *\n   * @private\n   * @returns {Function} Returns the Footer template\n   */\n\n\n  getEditFooterTemplate() {\n    return this.editFooterTemplateFn;\n  }\n  /**\n   * Get the names of the primary key columns of the Grid.\n   *\n   * @returns {string[]} Returns the field names\n   */\n\n\n  getPrimaryKeyFieldNames() {\n    const keys = [];\n\n    for (let k = 0; k < this.columnModel.length; k++) {\n      if (this.columnModel[k].isPrimaryKey) {\n        keys.push(this.columnModel[k].field);\n      }\n    }\n\n    return keys;\n  }\n  /**\n   * Refreshes the Grid header and content.\n   *\n   * @returns {void}\n   */\n\n\n  refresh() {\n    if (!this.isDestroyed) {\n      this.isManualRefresh = true;\n      this.headerModule.refreshUI();\n      this.updateStackedFilter();\n      this.renderModule.refresh();\n    }\n  }\n  /**\n   * Refreshes the Grid header.\n   *\n   * @returns {void}\n   */\n\n\n  refreshHeader() {\n    this.headerModule.refreshUI();\n  }\n  /**\n   * Gets the collection of selected rows.\n   *\n   * @returns {Element[]} Returns the element\n   */\n\n\n  getSelectedRows() {\n    return this.selectionModule ? this.selectionModule.selectedRecords : [];\n  }\n  /**\n   * Gets the collection of selected row indexes.\n   *\n   * @returns {number[]} Returns the Selected row indexes\n   */\n\n\n  getSelectedRowIndexes() {\n    return this.selectionModule ? this.selectionModule.selectedRowIndexes : [];\n  }\n  /**\n   * Gets the collection of selected row and cell indexes.\n   *\n   * @returns {number[]} Returns the Selected row cell indexes\n   */\n\n\n  getSelectedRowCellIndexes() {\n    return this.selectionModule ? this.selectionModule.selectedRowCellIndexes : [];\n  }\n  /**\n   * Gets the collection of selected records.\n   *\n   * @returns {Object[]} Returns the selected records\n   * @isGenericType true\n   */\n\n\n  getSelectedRecords() {\n    return this.selectionModule ? this.selectionModule.getSelectedRecords() : [];\n  }\n  /**\n   * Gets the collection of selected columns uid.\n   *\n   * @returns {string[]} Returns the selected column uid\n   * @isGenericType true\n   */\n\n\n  getSelectedColumnsUid() {\n    const uid = [];\n\n    if (this.selectionModule) {\n      this.selectionModule.selectedColumnsIndexes.filter(i => uid.push(this.getColumns()[i].uid));\n    }\n\n    return uid;\n  }\n  /**\n   * Gets the data module.\n   *\n   * @returns {Data} Returns the data\n   */\n\n\n  getDataModule() {\n    return this.renderModule.data;\n  }\n  /**\n   * Shows a column by its column name.\n   *\n   * @param  {string|string[]} keys - Defines a single or collection of column names.\n   * @param  {string} showBy - Defines the column key either as field name or header text.\n   * @returns {void}\n   */\n\n\n  showColumns(keys, showBy) {\n    showBy = showBy ? showBy : 'headerText';\n    this.showHider.show(keys, showBy);\n  }\n  /**\n   * Hides a column by column name.\n   *\n   * @param  {string|string[]} keys - Defines a single or collection of column names.\n   * @param  {string} hideBy - Defines the column key either as field name or header text.\n   * @returns {void}\n   */\n\n\n  hideColumns(keys, hideBy) {\n    hideBy = hideBy ? hideBy : 'headerText';\n    this.showHider.hide(keys, hideBy);\n  }\n  /**\n   * @hidden\n   * @returns {number} Returns the Frozen column\n   */\n\n\n  getFrozenColumns() {\n    return this.frozenColumns + this.getFrozenCount(this.columns, 0, 0);\n  }\n  /**\n   * @hidden\n   * @returns {number} Returns the Frozen Right column count\n   */\n\n\n  getFrozenRightColumnsCount() {\n    return this.frozenRightCount;\n  }\n  /**\n   * @hidden\n   * @returns {number} Returns the Frozen Left column\n   */\n\n\n  getFrozenLeftColumnsCount() {\n    return this.frozenLeftCount;\n  }\n  /**\n   * @hidden\n   * @returns {number} Returns the movable column count\n   */\n\n\n  getMovableColumnsCount() {\n    return this.movableCount;\n  }\n  /**\n   * @hidden\n   * @returns {void}\n   */\n\n\n  setFrozenCount() {\n    this.frozenLeftCount = this.frozenRightCount = this.movableCount = 0;\n    this.visibleFrozenLeft = this.visibleFrozenRight = this.visibleMovable = 0;\n    this.frozenLeftColumns = [];\n    this.frozenRightColumns = [];\n    this.movableColumns = [];\n    this.splitFrozenCount(this.columns);\n\n    if (this.frozenColumns && (this.frozenLeftCount || this.frozenRightCount)) {\n      this.setProperties({\n        frozenColumns: 0\n      }, true);\n    }\n\n    this.setTablesCount();\n\n    if (this.frozenLeftCount && !this.frozenRightCount) {\n      this.frozenName = 'Left';\n    } else if (this.frozenRightCount && !this.frozenLeftCount) {\n      this.frozenName = 'Right';\n    } else if (this.frozenLeftCount && this.frozenRightCount) {\n      this.frozenName = 'Left-Right';\n    }\n  }\n  /**\n   * @hidden\n   * @returns {number} Returns the visible Frozen left count\n   */\n\n\n  getVisibleFrozenLeftCount() {\n    return this.visibleFrozenLeft;\n  }\n  /**\n   * @hidden\n   * @returns {number} Returns the visible Frozen Right count\n   */\n\n\n  getVisibleFrozenRightCount() {\n    return this.visibleFrozenRight;\n  }\n  /**\n   * @hidden\n   * @returns {number} Returns the visible movable count\n   */\n\n\n  getVisibleMovableCount() {\n    return this.visibleMovable;\n  }\n  /**\n   * @hidden\n   * @returns {Column[]} Returns the column\n   */\n\n\n  getFrozenRightColumns() {\n    return this.frozenRightColumns;\n  }\n  /**\n   * @hidden\n   * @returns {Column[]} Returns the column\n   */\n\n\n  getFrozenLeftColumns() {\n    return this.frozenLeftColumns;\n  }\n  /**\n   * @hidden\n   * @returns {Column[]} Returns the column\n   */\n\n\n  getMovableColumns() {\n    return this.movableColumns;\n  }\n\n  splitFrozenCount(columns) {\n    for (let i = 0; i < columns.length; i++) {\n      if (columns[i].columns) {\n        this.splitFrozenCount(columns[i].columns);\n      } else {\n        if (columns[i].freeze === 'Right') {\n          if (columns[i].visible !== false) {\n            this.visibleFrozenRight++;\n          }\n\n          this.frozenRightColumns.push(columns[i]);\n          this.frozenRightCount++;\n        } else if (columns[i].freeze === 'Left') {\n          if (columns[i].visible !== false) {\n            this.visibleFrozenLeft++;\n          }\n\n          this.frozenLeftColumns.push(columns[i]);\n          this.frozenLeftCount++;\n        } else {\n          if (columns[i].visible !== false) {\n            this.visibleMovable++;\n          }\n\n          this.movableColumns.push(columns[i]);\n          this.movableCount++;\n        }\n      }\n    }\n  }\n  /**\n   * @hidden\n   * @returns {number} Returns the visible frozen columns count\n   */\n\n\n  getVisibleFrozenColumns() {\n    return this.getVisibleFrozenColumnsCount() + this.getVisibleFrozenCount(this.columns, 0);\n  }\n  /**\n   * Get the current Filter operator and field.\n   *\n   * @returns {FilterUI} Returns the filter UI\n   */\n\n\n  getFilterUIInfo() {\n    return this.filterModule ? this.filterModule.getFilterUIInfo() : {};\n  }\n\n  getVisibleFrozenColumnsCount() {\n    let visibleFrozenColumns = 0;\n    const columns = this.columnModel;\n\n    for (let i = 0; i < this.frozenColumns; i++) {\n      if (columns[i].visible) {\n        visibleFrozenColumns++;\n      }\n    }\n\n    if (this.frozenLeftCount || this.frozenRightCount) {\n      for (let i = 0; i < columns.length; i++) {\n        if (columns[i].visible && (columns[i].freeze === 'Left' || columns[i].freeze === 'Right')) {\n          visibleFrozenColumns++;\n        }\n      }\n    }\n\n    return visibleFrozenColumns;\n  }\n\n  getVisibleFrozenCount(cols, cnt) {\n    if (!this.frozenLeftCount && !this.frozenRightCount) {\n      for (let i = 0, len = cols.length; i < len; i++) {\n        if (cols[i].columns) {\n          cnt = this.getVisibleFrozenCount(cols[i].columns, cnt);\n        } else {\n          if (cols[i].isFrozen && cols[i].visible) {\n            cnt++;\n          }\n        }\n      }\n    }\n\n    return cnt;\n  }\n\n  getFrozenCount(cols, cnt, index) {\n    for (let i = 0, len = cols.length; i < len; i++) {\n      if (cols[i].columns) {\n        cnt = this.getFrozenCount(cols[i].columns, cnt, index);\n      } else {\n        if (cols[i].isFrozen && index > this.frozenColumns - 1) {\n          cnt++;\n        }\n\n        index++;\n      }\n    }\n\n    return cnt;\n  }\n  /**\n   * Navigates to the specified target page.\n   *\n   * @param  {number} pageNo - Defines the page number to navigate.\n   * @returns {void}\n   */\n\n\n  goToPage(pageNo) {\n    if (this.pagerModule) {\n      this.pagerModule.goToPage(pageNo);\n    }\n  }\n  /**\n   * Defines the text of external message.\n   *\n   * @param  {string} message - Defines the message to update.\n   * @returns {void}\n   */\n\n\n  updateExternalMessage(message) {\n    if (this.pagerModule) {\n      this.pagerModule.updateExternalMessage(message);\n    }\n  }\n  /**\n   * Sorts a column with the given options.\n   *\n   * @param {string} columnName - Defines the column name to be sorted.\n   * @param {SortDirection} direction - Defines the direction of sorting field.\n   * @param {boolean} isMultiSort - Specifies whether the previous sorted columns are to be maintained.\n   * @returns {void}\n   */\n\n\n  sortColumn(columnName, direction, isMultiSort) {\n    if (this.sortModule) {\n      this.sortModule.sortColumn(columnName, direction, isMultiSort);\n    }\n  }\n  /**\n   * Clears all the sorted columns of the Grid.\n   *\n   * @returns {void}\n   */\n\n\n  clearSorting() {\n    if (this.sortModule) {\n      this.sortModule.clearSorting();\n    }\n  }\n  /**\n   * Remove sorted column by field name.\n   *\n   * @param {string} field - Defines the column field name to remove sort.\n   * @returns {void}\n   * @hidden\n   */\n\n\n  removeSortColumn(field) {\n    if (this.sortModule) {\n      this.sortModule.removeSortColumn(field);\n    }\n  }\n  /**\n  * @hidden\n  * @returns {void}\n  */\n\n\n  clearGridActions() {\n    this.setProperties({\n      sortSettings: {\n        columns: []\n      }\n    }, true);\n    this.setProperties({\n      filterSettings: {\n        columns: []\n      }\n    }, true);\n    this.setProperties({\n      searchSettings: {\n        key: ''\n      }\n    }, true);\n\n    if (this.allowGrouping) {\n      this.setProperties({\n        groupSettings: {\n          columns: []\n        }\n      }, false);\n    } else {\n      this.freezeRefresh();\n    }\n  }\n  /**\n   * Filters grid row by column name with the given options.\n   *\n   * @param  {string} fieldName - Defines the field name of the column.\n   * @param  {string} filterOperator - Defines the operator to filter records.\n   * @param  {string | number | Date | boolean} filterValue - Defines the value used to filter records.\n   * @param  {string} predicate - Defines the relationship between one filter query and another by using AND or OR predicate.\n   * @param  {boolean} matchCase - If match case is set to true, the grid filters the records with exact match. if false, it filters case\n   * insensitive records (uppercase and lowercase letters treated the same).\n   * @param  {boolean} ignoreAccent - If ignoreAccent set to true,\n   * then filter ignores the diacritic characters or accents while filtering.\n   * @param  {string} actualFilterValue - Defines the actual filter value for the filter column.\n   * @param  {string} actualOperator - Defines the actual filter operator for the filter column.\n   * @returns {void}\n   */\n\n\n  filterByColumn(fieldName, filterOperator, filterValue, predicate, matchCase, ignoreAccent, actualFilterValue, actualOperator) {\n    if (this.filterModule) {\n      this.filterModule.filterByColumn(fieldName, filterOperator, filterValue, predicate, matchCase, ignoreAccent, actualFilterValue, actualOperator);\n    }\n  }\n  /**\n   * Clears all the filtered rows of the Grid.\n   *\n   * @param {string[]} fields - Defines the Fields\n   * @returns {void}\n   */\n\n\n  clearFiltering(fields) {\n    if (this.filterModule) {\n      this.filterModule.clearFiltering(fields);\n    }\n  }\n  /**\n   * Removes filtered column by field name.\n   *\n   * @param  {string} field - Defines column field name to remove filter.\n   * @param  {boolean} isClearFilterBar -  Specifies whether the filter bar value needs to be cleared.\n   * @returns {void}\n   * @hidden\n   */\n\n\n  removeFilteredColsByField(field, isClearFilterBar) {\n    if (this.filterModule) {\n      this.filterModule.removeFilteredColsByField(field, isClearFilterBar);\n    }\n  }\n  /**\n   * Selects a row by given index.\n   *\n   * @param  {number} index - Defines the row index.\n   * @param  {boolean} isToggle - If set to true, then it toggles the selection.\n   * @returns {void}\n   */\n\n\n  selectRow(index, isToggle) {\n    if (this.selectionModule) {\n      this.selectionModule.selectRow(index, isToggle);\n    }\n  }\n  /**\n   * Selects a collection of rows by indexes.\n   *\n   * @param  {number[]} rowIndexes - Specifies the row indexes.\n   * @returns {void}\n   */\n\n\n  selectRows(rowIndexes) {\n    if (this.selectionModule) {\n      this.selectionModule.selectRows(rowIndexes);\n    }\n  }\n  /**\n   * Deselects the current selected rows and cells.\n   *\n   * @returns {void}\n   */\n\n\n  clearSelection() {\n    if (this.selectionModule) {\n      this.selectionModule.clearSelection();\n    }\n  }\n  /**\n   * Selects a cell by the given index.\n   *\n   * @param  {IIndex} cellIndex - Defines the row and column indexes.\n   * @param  {boolean} isToggle - If set to true, then it toggles the selection.\n   * @returns {void}\n   */\n\n\n  selectCell(cellIndex, isToggle) {\n    if (this.selectionModule) {\n      this.selectionModule.selectCell(cellIndex, isToggle);\n    }\n  }\n  /**\n   * Selects a range of cells from start and end indexes.\n   *\n   * @param  {IIndex} startIndex - Specifies the row and column's start index.\n   * @param  {IIndex} endIndex - Specifies the row and column's end index.\n   * @returns {void}\n   */\n\n\n  selectCellsByRange(startIndex, endIndex) {\n    this.selectionModule.selectCellsByRange(startIndex, endIndex);\n  }\n  /**\n   * Searches Grid records using the given key.\n   * You can customize the default search option by using the\n   * [`searchSettings`](./#searchsettings/).\n   *\n   * @param  {string} searchString - Defines the key.\n   * @returns {void}\n   */\n\n\n  search(searchString) {\n    if (this.searchModule) {\n      this.searchModule.search(searchString);\n    }\n  }\n  /**\n   * By default, prints all the pages of the Grid and hides the pager.\n   * > You can customize print options using the\n   * [`printMode`](./#printmode).\n   *\n   * @returns {void}\n   */\n\n\n  print() {\n    if (this.printModule) {\n      this.printModule.print();\n    }\n  }\n  /**\n   * Delete a record with Given options. If fieldname and data is not given then grid will delete the selected record.\n   * > `editSettings.allowDeleting` should be true.\n   *\n   * @param {string} fieldname - Defines the primary key field, 'Name of the column'.\n   * @param {Object} data - Defines the JSON data of the record to be deleted.\n   * @returns {void}\n   */\n\n\n  deleteRecord(fieldname, data) {\n    if (this.editModule) {\n      this.editModule.deleteRecord(fieldname, data);\n    }\n  }\n  /**\n   * Starts edit the selected row. At least one row must be selected before invoking this method.\n   * `editSettings.allowEditing` should be true.\n   * {% codeBlock src='grid/startEdit/index.md' %}{% endcodeBlock %}\n   *\n   * @returns {void}\n   */\n\n\n  startEdit() {\n    if (this.editModule) {\n      this.editModule.startEdit();\n    }\n  }\n  /**\n   * If Grid is in editable state, you can save a record by invoking endEdit.\n   *\n   * @returns {void}\n   */\n\n\n  endEdit() {\n    if (this.editModule) {\n      this.editModule.endEdit();\n    }\n  }\n  /**\n   * Cancels edited state.\n   *\n   * @returns {void}\n   */\n\n\n  closeEdit() {\n    if (this.editModule) {\n      this.editModule.closeEdit();\n    }\n  }\n  /**\n   * Adds a new record to the Grid. Without passing parameters, it adds empty rows.\n   * > `editSettings.allowEditing` should be true.\n   *\n   * @param {Object} data - Defines the new add record data.\n   * @param {number} index - Defines the row index to be added\n   * @returns {void}\n   */\n\n\n  addRecord(data, index) {\n    if (this.editModule) {\n      this.editModule.addRecord(data, index);\n    }\n  }\n  /**\n   * Delete any visible row by TR element.\n   *\n   * @param {HTMLTableRowElement} tr - Defines the table row element.\n   * @returns {void}\n   */\n\n\n  deleteRow(tr) {\n    if (this.editModule) {\n      this.editModule.deleteRow(tr);\n    }\n  }\n  /**\n   * Changes a particular cell into edited state based on the row index and field name provided in the `batch` mode.\n   *\n   * @param {number} index - Defines row index to edit a particular cell.\n   * @param {string} field - Defines the field name of the column to perform batch edit.\n   * @returns {void}\n   */\n\n\n  editCell(index, field) {\n    if (this.editModule) {\n      this.editModule.editCell(index, field);\n    }\n  }\n  /**\n   * Saves the cell that is currently edited. It does not save the value to the DataSource.\n   *\n   * @returns {void}\n   * {% codeBlock src='grid/saveCell/index.md' %}{% endcodeBlock %}\n   */\n\n\n  saveCell() {\n    if (this.editModule) {\n      this.editModule.saveCell();\n    }\n  }\n  /**\n   * To update the specified cell by given value without changing into edited state.\n   *\n   * @param {number} rowIndex Defines the row index.\n   * @param {string} field Defines the column field.\n   * @param {string | number | boolean | Date} value - Defines the value to be changed.\n   * @returns {void}\n   */\n\n\n  updateCell(rowIndex, field, value) {\n    if (this.editModule) {\n      this.editModule.updateCell(rowIndex, field, value);\n    }\n  }\n  /**\n   * To update the specified row by given values without changing into edited state.\n   *\n   * @param {number} index Defines the row index.\n   * @param {Object} data Defines the data object to be updated.\n   *\n   * {% codeBlock src='grid/updateRow/index.md' %}{% endcodeBlock %}\n   *\n   * @returns {void}\n   */\n\n\n  updateRow(index, data) {\n    if (this.editModule) {\n      this.editModule.updateRow(index, data);\n    }\n  }\n  /**\n   * Gets the added, edited,and deleted data before bulk save to the DataSource in batch mode.\n   *\n   * @returns {Object} Returns the batch changes\n   */\n\n\n  getBatchChanges() {\n    if (this.editModule) {\n      return this.editModule.getBatchChanges();\n    }\n\n    return {};\n  }\n  /**\n   * Enables or disables ToolBar items.\n   *\n   * @param {string[]} items - Defines the collection of itemID of ToolBar items.\n   * @param {boolean} isEnable - Defines the items to be enabled or disabled.\n   * @returns {void}\n   */\n\n\n  enableToolbarItems(items, isEnable) {\n    if (this.toolbarModule) {\n      this.toolbarModule.enableItems(items, isEnable);\n    }\n  }\n  /**\n   * Copy the selected rows or cells data into clipboard.\n   *\n   * @param {boolean} withHeader - Specifies whether the column header text needs to be copied along with rows or cells.\n   * @returns {void}\n   */\n\n\n  copy(withHeader) {\n    if (this.clipboardModule) {\n      this.clipboardModule.copy(withHeader);\n    }\n  }\n  /**\n   * @hidden\n   * @returns {void}\n   */\n\n\n  recalcIndentWidth() {\n    if (!this.getHeaderTable().querySelector('.e-emptycell')) {\n      return;\n    }\n\n    if (!this.groupSettings.columns.length && !this.isDetail() && !this.isRowDragable() || this.getHeaderTable().querySelector('.e-emptycell').getAttribute('indentRefreshed') || !this.getContentTable()) {\n      return;\n    }\n\n    let indentWidth = this.getHeaderTable().querySelector('.e-emptycell').parentElement.offsetWidth;\n    const headerCol = [].slice.call(this.getHeaderTable().querySelector(colGroup).childNodes);\n    const contentCol = [].slice.call(this.getContentTable().querySelector(colGroup).childNodes);\n    const perPixel = indentWidth / 30;\n    let i = this.getFrozenMode() === 'Right' ? this.frozenRightCount : 0;\n    const parentOffset = this.element.offsetWidth;\n\n    const applyWidth = (index, width) => {\n      if (ispercentageWidth(this)) {\n        const newWidth = (width / parentOffset * 100).toFixed(1) + '%';\n        headerCol[index].style.width = newWidth;\n        contentCol[index].style.width = newWidth;\n      } else {\n        headerCol[index].style.width = width + 'px';\n        contentCol[index].style.width = width + 'px';\n      }\n\n      this.notify(columnWidthChanged, {\n        index: index,\n        width: width\n      });\n    };\n\n    if (perPixel >= 1) {\n      indentWidth = 30 / perPixel;\n    }\n\n    if (indentWidth < 1) {\n      indentWidth = 1;\n    }\n\n    if (this.enableColumnVirtualization || this.isAutoGen) {\n      indentWidth = 30;\n    }\n\n    while (i < this.groupSettings.columns.length) {\n      applyWidth(i, indentWidth);\n      i++;\n    }\n\n    if (this.isDetail()) {\n      applyWidth(i, indentWidth);\n      i++;\n    }\n\n    if (this.isRowDragable()) {\n      applyWidth(i, indentWidth);\n    }\n\n    this.isAutoGen = false;\n    this.getHeaderTable().querySelector('.e-emptycell').setAttribute('indentRefreshed', 'true');\n  }\n  /**\n   * @hidden\n   * @returns {void}\n   */\n\n\n  resetIndentWidth() {\n    if (ispercentageWidth(this)) {\n      this.getHeaderTable().querySelector('.e-emptycell').removeAttribute('indentRefreshed');\n      this.widthService.setWidthToColumns();\n      this.recalcIndentWidth();\n    }\n\n    if ((this.width === 'auto' || typeof this.width === 'string' && this.width.indexOf('%') !== -1) && this.getColumns().filter(col => (!col.width || col.width === 'auto') && col.minWidth).length > 0) {\n      const tgridWidth = this.widthService.getTableWidth(this.getColumns());\n      this.widthService.setMinwidthBycalculation(tgridWidth);\n    }\n\n    if (this.isFrozenGrid() && this.widthService) {\n      this.widthService.refreshFrozenScrollbar();\n    }\n\n    if (this.allowTextWrap && this.textWrapSettings.wrapMode !== 'Content') {\n      this.notify(refreshHandlers, {});\n    }\n  }\n  /**\n   * @hidden\n   * @returns {boolean} Returns isRowDragable\n   */\n\n\n  isRowDragable() {\n    return this.allowRowDragAndDrop && !this.rowDropSettings.targetID;\n  }\n  /**\n   * Changes the Grid column positions by field names.\n   *\n   * @param  {string} fromFName - Defines the origin field name.\n   * @param  {string} toFName - Defines the destination field name.\n   * @returns {void}\n   */\n\n\n  reorderColumns(fromFName, toFName) {\n    if (this.reorderModule) {\n      this.reorderModule.reorderColumns(fromFName, toFName);\n    }\n  }\n  /**\n   * Changes the Grid column positions by field index. If you invoke reorderColumnByIndex multiple times,\n   * then you won't get the same results every time.\n   *\n   * @param  {number} fromIndex - Defines the origin field index.\n   * @param  {number} toIndex - Defines the destination field index.\n   * @returns {void}\n   */\n\n\n  reorderColumnByIndex(fromIndex, toIndex) {\n    if (this.reorderModule) {\n      this.reorderModule.reorderColumnByIndex(fromIndex, toIndex);\n    }\n  }\n  /**\n   * Changes the Grid column positions by field index. If you invoke reorderColumnByTargetIndex multiple times,\n   * then you will get the same results every time.\n   *\n   * @param  {string} fieldName - Defines the field name.\n   * @param  {number} toIndex - Defines the destination field index.\n   * @returns {void}\n   */\n\n\n  reorderColumnByTargetIndex(fieldName, toIndex) {\n    if (this.reorderModule) {\n      this.reorderModule.reorderColumnByTargetIndex(fieldName, toIndex);\n    }\n  }\n  /**\n   * Changes the Grid Row position with given indexes.\n   *\n   * @param  {number} fromIndexes - Defines the origin Indexes.\n   * @param  {number} toIndex - Defines the destination Index.\n   * @returns {void}\n   */\n\n\n  reorderRows(fromIndexes, toIndex) {\n    if (this.rowDragAndDropModule) {\n      this.rowDragAndDropModule.reorderRows(fromIndexes, toIndex);\n    }\n  }\n  /**\n   * @param {ReturnType} e - Defines the Return type\n   * @returns {void}\n   * @hidden\n   */\n\n\n  refreshDataSource(e) {\n    this.notify('refreshdataSource', e);\n  }\n  /**\n   * @param {boolean} enable -Defines the enable\n   * @returns {void}\n   * @hidden\n   */\n\n\n  disableRowDD(enable) {\n    const headerTable = this.getHeaderTable();\n    const contentTable = this.getContentTable();\n    const headerRows = headerTable.querySelectorAll('th.e-rowdragheader, th.e-mastercell');\n    const rows = this.getRows();\n    const disValue = enable ? 'none' : '';\n    setStyleAttribute(headerTable.querySelector(colGroup).childNodes[0], {\n      'display': disValue\n    });\n    setStyleAttribute(contentTable.querySelector(colGroup).childNodes[0], {\n      'display': disValue\n    });\n\n    for (let i = 0; i < this.getRows().length; i++) {\n      const ele = rows[i].firstElementChild;\n\n      if (enable) {\n        addClass([ele], 'e-hide');\n      } else {\n        removeClass([ele], ['e-hide']);\n      }\n    }\n\n    for (let j = 0; j < headerTable.querySelectorAll('th.e-rowdragheader, th.e-mastercell').length; j++) {\n      const ele = headerRows[j];\n\n      if (enable) {\n        addClass([ele], 'e-hide');\n      } else {\n        removeClass([ele], ['e-hide']);\n      }\n    }\n  }\n  /**\n   * Changes the column width to automatically fit its content to ensure that the width shows the content without wrapping/hiding.\n   * > * This method ignores the hidden columns.\n   * > * Uses the `autoFitColumns` method in the `dataBound` event to resize at initial rendering.\n   *\n   * @param  {string |string[]} fieldNames - Defines the column names.\n   * @returns {void}\n   *\n   *\n   * ```typescript\n   * <div id=\"Grid\"></div>\n   * <script>\n   * let gridObj: Grid = new Grid({\n   *     dataSource: employeeData,\n   *     columns: [\n   *         { field: 'OrderID', headerText: 'Order ID', width:100 },\n   *         { field: 'EmployeeID', headerText: 'Employee ID' }],\n   *     dataBound: () => gridObj.autoFitColumns('EmployeeID')\n   * });\n   * gridObj.appendTo('#Grid');\n   * </script>\n   * ```\n   *\n   */\n\n\n  autoFitColumns(fieldNames) {\n    if (this.resizeModule) {\n      this.resizeModule.autoFitColumns(fieldNames);\n    }\n  }\n  /**\n   * @param {number} x - Defines the number\n   * @param {number} y - Defines the number\n   * @param {Element} target - Defines the Element\n   * @returns {void}\n   * @hidden\n   */\n\n\n  createColumnchooser(x, y, target) {\n    if (this.columnChooserModule) {\n      this.columnChooserModule.renderColumnChooser(x, y, target);\n    }\n  }\n\n  initializeServices() {\n    this.serviceLocator.register('widthService', this.widthService = new ColumnWidthService(this));\n    this.serviceLocator.register('cellRendererFactory', new CellRendererFactory());\n    this.serviceLocator.register('rendererFactory', new RendererFactory());\n    this.serviceLocator.register('localization', this.localeObj = new L10n(this.getModuleName(), this.defaultLocale, this.locale));\n    this.serviceLocator.register('valueFormatter', this.valueFormatterService = new ValueFormatter(this.locale));\n    this.serviceLocator.register('showHideService', this.showHider = new ShowHide(this));\n    this.serviceLocator.register('ariaService', this.ariaService = new AriaService());\n    this.serviceLocator.register('focus', this.focusModule = new FocusStrategy(this));\n  }\n\n  processModel() {\n    const gCols = this.groupSettings.columns;\n    const sCols = this.sortSettings.columns;\n    let flag;\n    let j;\n\n    if (this.allowGrouping) {\n      for (let i = 0, len = gCols.length; i < len; i++) {\n        j = 0;\n\n        for (let sLen = sCols.length; j < sLen; j++) {\n          if (sCols[j].field === gCols[i]) {\n            flag = true;\n            break;\n          }\n        }\n\n        if (!flag) {\n          sCols.push({\n            field: gCols[i],\n            direction: 'Ascending',\n            isFromGroup: true\n          });\n        } else {\n          if (this.allowSorting) {\n            this.sortedColumns.push(sCols[j].field);\n          } else {\n            sCols[j].direction = 'Ascending';\n          }\n        }\n\n        if (!this.groupSettings.showGroupedColumn) {\n          const column = this.enableColumnVirtualization ? this.columns.filter(c => c.field === gCols[i])[0] : this.getColumnByField(gCols[i]);\n\n          if (column) {\n            column.visible = false;\n          } else {\n            this.log('initial_action', {\n              moduleName: 'group',\n              columnName: gCols[i]\n            });\n          }\n        }\n      }\n    }\n\n    if (!gCols.length) {\n      for (let i = 0; i < sCols.length; i++) {\n        this.sortedColumns.push(sCols[i].field);\n      }\n    }\n\n    this.rowTemplateFn = templateCompiler(this.rowTemplate);\n    this.detailTemplateFn = templateCompiler(this.detailTemplate);\n    this.editTemplateFn = templateCompiler(this.editSettings.template);\n    this.editHeaderTemplateFn = templateCompiler(this.editSettings.headerTemplate);\n    this.editFooterTemplateFn = templateCompiler(this.editSettings.footerTemplate);\n\n    if (!isNullOrUndefined(this.parentDetails)) {\n      const value = isNullOrUndefined(this.parentDetails.parentKeyFieldValue) ? 'undefined' : this.parentDetails.parentKeyFieldValue;\n      this.query.where(this.queryString, 'equal', value, true);\n    }\n\n    this.initForeignColumn();\n  }\n\n  initForeignColumn() {\n    if (this.isForeignKeyEnabled(this.getColumns())) {\n      this.notify(initForeignKeyColumn, this.getForeignKeyColumns());\n    }\n  }\n\n  enableVerticalRendering() {\n    if (this.rowRenderingMode === 'Vertical') {\n      this.element.classList.add('e-row-responsive');\n    } else {\n      this.element.classList.remove('e-row-responsive');\n    }\n  }\n\n  gridRender() {\n    this.updateRTL();\n\n    if (this.rowRenderingMode === 'Vertical') {\n      this.element.classList.add('e-row-responsive');\n    }\n\n    if (this.enableHover) {\n      this.element.classList.add('e-gridhover');\n    }\n\n    if (Browser.isDevice) {\n      this.element.classList.add('e-device');\n    }\n\n    if (this.rowHeight) {\n      this.element.classList.add('e-grid-min-height');\n    }\n\n    classList(this.element, ['e-responsive', 'e-default'], []);\n    const rendererFactory = this.serviceLocator.getService('rendererFactory');\n    this.headerModule = rendererFactory.getRenderer(RenderType.Header);\n    this.contentModule = rendererFactory.getRenderer(RenderType.Content);\n    this.printModule = new Print(this, this.scrollModule);\n    this.clipboardModule = new Clipboard(this);\n    this.renderModule.render();\n    this.eventInitializer();\n    this.createGridPopUpElement();\n    this.widthService.setWidthToColumns();\n    this.updateGridLines();\n    this.applyTextWrap();\n    this.createTooltip(); //for clip mode ellipsis\n\n    this.enableBoxSelection();\n  }\n\n  dataReady() {\n    this.scrollModule.setWidth();\n    this.scrollModule.setHeight();\n\n    if (this.height !== 'auto') {\n      this.scrollModule.setPadding();\n    }\n  }\n\n  updateRTL() {\n    if (this.enableRtl) {\n      this.element.classList.add('e-rtl');\n    } else {\n      this.element.classList.remove('e-rtl');\n    }\n  }\n\n  createGridPopUpElement() {\n    const popup = this.createElement('div', {\n      className: 'e-gridpopup',\n      styles: 'display:none;'\n    });\n    const content$$1 = this.createElement('div', {\n      className: content,\n      attrs: {\n        tabIndex: '-1'\n      }\n    });\n    append([content$$1, this.createElement('div', {\n      className: 'e-uptail e-tail'\n    })], popup);\n    content$$1.appendChild(this.createElement('span'));\n    append([content$$1, this.createElement('div', {\n      className: 'e-downtail e-tail'\n    })], popup);\n    this.element.appendChild(popup);\n  }\n\n  updateGridLines() {\n    classList(this.element, [], ['e-verticallines', 'e-horizontallines', 'e-hidelines', 'e-bothlines']);\n\n    switch (this.gridLines) {\n      case 'Horizontal':\n        this.element.classList.add('e-horizontallines');\n        break;\n\n      case 'Vertical':\n        this.element.classList.add('e-verticallines');\n        break;\n\n      case 'None':\n        this.element.classList.add('e-hidelines');\n        break;\n\n      case 'Both':\n        this.element.classList.add('e-bothlines');\n        break;\n    }\n\n    this.updateResizeLines();\n  }\n\n  updateResizeLines() {\n    if (this.allowResizing && !(this.gridLines === 'Vertical' || this.gridLines === 'Both')) {\n      this.element.classList.add('e-resize-lines');\n    } else {\n      this.element.classList.remove('e-resize-lines');\n    }\n  }\n  /**\n   * The function is used to apply text wrap\n   *\n   * @returns {void}\n   * @hidden\n   */\n\n\n  applyTextWrap() {\n    if (this.allowTextWrap) {\n      const headerRows = [].slice.call(this.element.getElementsByClassName('e-columnheader'));\n\n      switch (this.textWrapSettings.wrapMode) {\n        case 'Header':\n          wrap(this.element, false);\n          wrap(this.getContent(), false);\n          wrap(headerRows, true);\n          break;\n\n        case 'Content':\n          wrap(this.getContent(), true);\n          wrap(this.element, false);\n          wrap(headerRows, false);\n          break;\n\n        default:\n          wrap(this.element, true);\n          wrap(this.getContent(), false);\n          wrap(headerRows, false);\n      }\n\n      if (this.textWrapSettings.wrapMode !== 'Content') {\n        this.notify(refreshHandlers, {});\n      }\n    }\n  }\n  /**\n   * The function is used to remove text wrap\n   *\n   * @returns {void}\n   * @hidden\n   */\n\n\n  removeTextWrap() {\n    wrap(this.element, false);\n    const headerRows = [].slice.call(this.element.getElementsByClassName('e-columnheader'));\n    wrap(headerRows, false);\n    wrap(this.getContent(), false);\n\n    if (this.textWrapSettings.wrapMode !== 'Content') {\n      this.notify(refreshHandlers, {});\n    }\n  }\n  /**\n   * The function is used to add Tooltip to the grid cell that has ellipsiswithtooltip clip mode.\n   *\n   * @returns {void}\n   * @hidden\n   */\n\n\n  createTooltip() {\n    this.toolTipObj = new Tooltip({\n      opensOn: 'custom',\n      content: ''\n    }, this.element);\n  }\n  /** @hidden\n   * @returns {void}\n   */\n\n\n  freezeRefresh() {\n    this.isFreezeRefresh = true;\n\n    if (this.enableVirtualization) {\n      this.pageSettings.currentPage = 1;\n    }\n\n    this.componentRefresh();\n  }\n\n  getTooltipStatus(element) {\n    const headerTable = this.getHeaderTable();\n    const headerDivTag = 'e-gridheader';\n    const htable = this.createTable(headerTable, headerDivTag, 'header');\n    const ctable = this.createTable(headerTable, headerDivTag, 'content');\n    const table$$1 = element.classList.contains('e-headercell') ? htable : ctable;\n    const ele = element.classList.contains('e-headercell') ? 'th' : 'tr';\n    table$$1.querySelector(ele).className = element.className;\n    table$$1.querySelector(ele).innerHTML = element.innerHTML;\n    const width = table$$1.querySelector(ele).getBoundingClientRect().width;\n    document.body.removeChild(htable);\n    document.body.removeChild(ctable);\n\n    if (width > element.getBoundingClientRect().width) {\n      return true;\n    }\n\n    return false;\n  }\n\n  mouseMoveHandler(e) {\n    if (this.isEllipsisTooltip()) {\n      const element = parentsUntil(e.target, 'e-ellipsistooltip');\n\n      if (this.prevElement !== element || e.type === 'mouseout') {\n        this.toolTipObj.close();\n      }\n\n      const tagName = e.target.tagName;\n      const elemNames = ['A', 'BUTTON', 'INPUT'];\n\n      if (element && e.type !== 'mouseout' && !(Browser.isDevice && elemNames.indexOf(tagName) !== -1)) {\n        if (element.getAttribute('aria-describedby')) {\n          return;\n        }\n\n        if (this.getTooltipStatus(element)) {\n          if (element.getElementsByClassName('e-headertext').length) {\n            this.toolTipObj.content = element.getElementsByClassName('e-headertext')[0].innerText;\n          } else {\n            this.toolTipObj.content = element.innerText;\n          }\n\n          this.prevElement = element;\n          const col = this.getColumns()[parseInt(element.getAttribute(ariaColIndex), 10)];\n\n          if (col.disableHtmlEncode) {\n            this.toolTipObj.enableHtmlParse = false;\n          }\n\n          this.toolTipObj.open(element);\n        }\n      }\n    }\n\n    this.hoverFrozenRows(e);\n  }\n  /**\n   * @param {MouseEvent} e - Defines the mouse event\n   * @returns {void}\n   * @hidden\n   */\n\n\n  hoverFrozenRows(e) {\n    if (this.isFrozenGrid()) {\n      const row$$1 = parentsUntil(e.target, row);\n\n      if ([].slice.call(this.element.getElementsByClassName('e-frozenhover')).length && e.type === 'mouseout') {\n        const rows = [].slice.call(this.element.getElementsByClassName('e-frozenhover'));\n\n        for (let i = 0; i < rows.length; i++) {\n          rows[i].classList.remove('e-frozenhover');\n        }\n      } else if (row$$1) {\n        const rows = [].slice.call(this.element.querySelectorAll('tr[aria-rowindex=\"' + row$$1.getAttribute(ariaRowIndex) + '\"]'));\n        rows.splice(rows.indexOf(row$$1), 1);\n\n        for (let i = 0; i < rows.length; i++) {\n          if (row$$1.getAttribute('aria-selected') !== 'true' && rows[i]) {\n            rows[i].classList.add('e-frozenhover');\n          } else if (rows[i]) {\n            rows[i].classList.remove('e-frozenhover');\n          }\n        }\n      }\n    }\n  }\n\n  isEllipsisTooltip() {\n    const cols = this.getColumns();\n\n    if (this.clipMode === 'EllipsisWithTooltip') {\n      return true;\n    }\n\n    for (let i = 0; i < cols.length; i++) {\n      if (cols[i].clipMode === 'EllipsisWithTooltip') {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  scrollHandler() {\n    if (this.isEllipsisTooltip()) {\n      this.toolTipObj.close();\n    }\n  }\n  /**\n   * To create table for ellipsiswithtooltip\n   *\n   * @param {Element} table - Defines the table\n   * @param {string} tag - Defines the tag\n   * @param {string} type - Defines the type\n   * @returns {HTMLDivElement} Returns the HTML div ELement\n   * @hidden\n   */\n\n\n  createTable(table$$1, tag, type) {\n    const myTableDiv = this.createElement('div');\n    myTableDiv.className = this.element.className;\n    myTableDiv.style.cssText = 'display: inline-block;visibility:hidden;position:absolute';\n    const mySubDiv = this.createElement('div');\n    mySubDiv.className = tag;\n    const myTable = this.createElement('table');\n    myTable.className = table$$1.className;\n    myTable.style.cssText = 'table-layout: auto;width: auto';\n    const ele = type === 'header' ? 'th' : 'td';\n    const myTr = this.createElement('tr');\n    const mytd = this.createElement(ele);\n    myTr.appendChild(mytd);\n    myTable.appendChild(myTr);\n    mySubDiv.appendChild(myTable);\n    myTableDiv.appendChild(mySubDiv);\n    document.body.appendChild(myTableDiv);\n    return myTableDiv;\n  }\n\n  onKeyPressed(e) {\n    if (e.action === 'tab' || e.action === 'shiftTab') {\n      this.toolTipObj.close();\n    }\n  }\n  /**\n   * Binding events to the element while component creation.\n   *\n   * @hidden\n   * @returns {void}\n   */\n\n\n  wireEvents() {\n    EventHandler.add(this.element, 'click', this.mouseClickHandler, this);\n    EventHandler.add(this.element, 'touchend', this.mouseClickHandler, this);\n    EventHandler.add(this.element, 'focusout', this.focusOutHandler, this);\n    EventHandler.add(this.element, 'dblclick', this.dblClickHandler, this);\n    EventHandler.add(this.element, 'keydown', this.keyPressHandler, this); // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n    EventHandler.add(window, 'resize', this.resetIndentWidth, this);\n\n    if (this.allowKeyboard) {\n      this.element.tabIndex = this.element.tabIndex === -1 ? 0 : this.element.tabIndex;\n    }\n\n    this.keyboardModule = new KeyboardEvents(this.element, {\n      keyAction: this.keyActionHandler.bind(this),\n      keyConfigs: this.keyConfigs,\n      eventName: 'keydown'\n    });\n    EventHandler.add(this.getContent().firstElementChild, 'scroll', this.scrollHandler, this);\n    EventHandler.add(this.element, 'mousemove', this.mouseMoveHandler, this);\n    EventHandler.add(this.element, 'mouseout', this.mouseMoveHandler, this);\n    EventHandler.add(this.getContent(), 'touchstart', this.tapEvent, this);\n    EventHandler.add(document.body, 'keydown', this.keyDownHandler, this);\n  }\n  /**\n   * Unbinding events from the element while component destroy.\n   *\n   * @hidden\n   * @returns {void}\n   */\n\n\n  unwireEvents() {\n    EventHandler.remove(this.element, 'click', this.mouseClickHandler);\n    EventHandler.remove(this.element, 'touchend', this.mouseClickHandler);\n    EventHandler.remove(this.element, 'focusout', this.focusOutHandler);\n    EventHandler.remove(this.element, 'dblclick', this.dblClickHandler);\n    EventHandler.remove(this.getContent().firstElementChild, 'scroll', this.scrollHandler);\n    EventHandler.remove(this.element, 'mousemove', this.mouseMoveHandler);\n    EventHandler.remove(this.element, 'mouseout', this.mouseMoveHandler);\n    EventHandler.remove(this.element, 'keydown', this.keyPressHandler);\n    EventHandler.remove(this.getContent(), 'touchstart', this.tapEvent);\n    EventHandler.remove(document.body, 'keydown', this.keyDownHandler); // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n    EventHandler.remove(window, 'resize', this.resetIndentWidth);\n  }\n  /**\n   * @hidden\n   * @returns {void}\n   */\n\n\n  addListener() {\n    if (this.isDestroyed) {\n      return;\n    }\n\n    this.on(dataReady, this.dataReady, this);\n    this.on(contentReady, this.recalcIndentWidth, this);\n    this.on(headerRefreshed, this.recalcIndentWidth, this);\n    this.dataBoundFunction = this.refreshMediaCol.bind(this);\n    this.addEventListener(dataBound, this.dataBoundFunction);\n    this.on(keyPressed, this.onKeyPressed, this);\n  }\n  /**\n   * @hidden\n   * @returns {void}\n   */\n\n\n  removeListener() {\n    if (this.isDestroyed) {\n      return;\n    }\n\n    this.off(dataReady, this.dataReady);\n    this.off(contentReady, this.recalcIndentWidth);\n    this.off(headerRefreshed, this.recalcIndentWidth);\n    this.removeEventListener(dataBound, this.dataBoundFunction);\n    this.off(keyPressed, this.onKeyPressed);\n  }\n  /**\n   * Get current visible data of grid.\n   *\n   * @returns {Object[]} Returns the current view records\n   * @isGenericType true\n   */\n\n\n  getCurrentViewRecords() {\n    if (isGroupAdaptive(this)) {\n      return isNullOrUndefined(this.currentViewData.records) ? this.currentViewData : this.currentViewData.records;\n    }\n\n    if (this.groupSettings.enableLazyLoading) {\n      return this.currentViewData;\n    }\n\n    return this.allowGrouping && this.groupSettings.columns.length && this.currentViewData.length && this.currentViewData.records ? this.currentViewData.records : this.currentViewData;\n  }\n\n  mouseClickHandler(e) {\n    if (this.isChildGrid(e) || parentsUntil(e.target, 'e-gridpopup') && e.touches || this.element.getElementsByClassName('e-cloneproperties').length || this.checkEdit(e)) {\n      return;\n    }\n\n    if ((!this.allowRowDragAndDrop && (parentsUntil(e.target, gridContent) || e.target.tagName === 'TD') || !(this.allowGrouping || this.allowReordering) && parentsUntil(e.target, 'e-gridheader')) && e.touches) {\n      return;\n    }\n\n    if (parentsUntil(e.target, 'e-gridheader') && this.allowRowDragAndDrop && !parentsUntil(e.target, 'e-filterbarcell')) {\n      e.preventDefault();\n    }\n\n    const args = this.getRowInfo(e.target);\n    const cancel = 'cancel';\n    args[cancel] = false;\n    let isDataRow = false;\n    const tr = closest(e.target, 'tr');\n\n    if (tr && tr.getAttribute('data-uid')) {\n      const rowObj = this.getRowObjectFromUID(tr.getAttribute('data-uid'));\n      isDataRow = rowObj ? rowObj.isDataRow : false;\n    }\n\n    if (isDataRow) {\n      this.trigger(recordClick, args);\n    }\n\n    this.notify(click, e);\n  }\n\n  checkEdit(e) {\n    const tr = parentsUntil(e.target, row);\n    const isEdit = this.editSettings.mode !== 'Batch' && this.isEdit && tr && (tr.classList.contains(editedRow) || tr.classList.contains(addedRow));\n    return !parentsUntil(e.target, 'e-unboundcelldiv') && (isEdit || parentsUntil(e.target, rowCell) && parentsUntil(e.target, rowCell).classList.contains('e-editedbatchcell'));\n  }\n\n  dblClickHandler(e) {\n    const grid = parentsUntil(e.target, 'e-grid');\n\n    if (isNullOrUndefined(grid) || grid.id !== this.element.id || closest(e.target, '.e-unboundcelldiv')) {\n      return;\n    }\n\n    let dataRow = false;\n    const tr = closest(e.target, 'tr');\n\n    if (tr && tr.getAttribute('data-uid')) {\n      const rowObj = this.getRowObjectFromUID(tr.getAttribute('data-uid'));\n      dataRow = rowObj ? rowObj.isDataRow : false;\n    }\n\n    const args = this.getRowInfo(e.target);\n    args.target = e.target;\n\n    if (dataRow) {\n      this.trigger(recordDoubleClick, args);\n    }\n\n    this.notify(dblclick, e);\n  }\n\n  focusOutHandler(e) {\n    if (this.isChildGrid(e)) {\n      return;\n    }\n\n    if (!parentsUntil(e.target, 'e-grid')) {\n      this.element.querySelector('.e-gridpopup').style.display = 'None';\n    }\n\n    const filterClear = this.element.querySelector('.e-cancel:not(.e-hide)');\n\n    if (filterClear) {\n      filterClear.classList.add('e-hide');\n    }\n\n    const relatedTarget = e.relatedTarget;\n    const ariaOwns = relatedTarget ? relatedTarget.getAttribute('aria-owns') : null;\n\n    if ((!relatedTarget || !parentsUntil(relatedTarget, 'e-grid') && (!isNullOrUndefined(ariaOwns) && ariaOwns) !== e.target.getAttribute('aria-owns')) && !this.keyPress && this.isEdit && !Browser.isDevice) {\n      if (this.editSettings.mode === 'Batch' && !((parentsUntil(relatedTarget, 'e-ddl') || parentsUntil(relatedTarget, 'e-ddt')) && parentsUntil(relatedTarget, 'e-input-group'))) {\n        this.editModule.saveCell();\n        this.notify(editNextValCell, {});\n      }\n\n      if (this.editSettings.mode === 'Normal') {\n        this.editModule.editFormValidate();\n      }\n    }\n\n    this.keyPress = false;\n  }\n\n  isChildGrid(e) {\n    const gridElement = parentsUntil(e.target, 'e-grid');\n\n    if (gridElement && gridElement.id !== this.element.id || parentsUntil(e.target, 'e-unboundcelldiv') && isNullOrUndefined(gridElement)) {\n      return true;\n    }\n\n    return false;\n  }\n  /**\n   * @param {Object} persistedData - Defines the persisted data\n   * @returns {void}\n   * @hidden\n   */\n\n\n  mergePersistGridData(persistedData) {\n    const data = this.getLocalData();\n\n    if (!(isNullOrUndefined(data) || data === '') || !isNullOrUndefined(persistedData)) {\n      const dataObj = !isNullOrUndefined(persistedData) ? persistedData : JSON.parse(data);\n\n      if (this.enableVirtualization) {\n        dataObj.pageSettings.currentPage = 1;\n      }\n\n      const keys = Object.keys(dataObj);\n      this.isProtectedOnChange = true;\n\n      for (const key of keys) {\n        if (typeof this[key] === 'object' && !isNullOrUndefined(this[key])) {\n          if (Array.isArray(this[key]) && key === 'columns') {\n            setColumnIndex(this[key]);\n            this.mergeColumns(dataObj[key], this[key]);\n            this[key] = dataObj[key];\n          } else {\n            extend(this[key], dataObj[key]);\n          }\n        } else {\n          this[key] = dataObj[key];\n        }\n      }\n\n      this.isProtectedOnChange = false;\n    }\n  }\n\n  mergeColumns(storedColumn, columns) {\n    const storedColumns = storedColumn;\n\n    for (let i = 0; i < storedColumns.length; i++) {\n      const localCol = columns.filter(tCol => tCol.index === storedColumns[i].index)[0];\n\n      if (!isNullOrUndefined(localCol)) {\n        if (localCol.columns && localCol.columns.length) {\n          this.mergeColumns(storedColumns[i].columns, localCol.columns);\n          storedColumns[i] = extend(localCol, storedColumns[i], {}, true);\n        } else {\n          storedColumns[i] = extend(localCol, storedColumns[i], {}, true);\n        }\n      }\n    }\n  }\n  /**\n   * @hidden\n   * @returns {boolean} Returns the isDetail\n   */\n\n\n  isDetail() {\n    return !isNullOrUndefined(this.detailTemplate) || !isNullOrUndefined(this.childGrid);\n  }\n\n  isCommandColumn(columns) {\n    return columns.some(col => {\n      if (col.columns) {\n        return this.isCommandColumn(col.columns);\n      }\n\n      return !!(col.commands || col.commandsTemplate);\n    });\n  }\n\n  isForeignKeyEnabled(columns) {\n    return columns.some(col => {\n      if (col.columns) {\n        return this.isForeignKeyEnabled(col.columns);\n      }\n\n      return !!(col.dataSource && col.foreignKeyValue);\n    });\n  }\n\n  keyPressHandler(e) {\n    const presskey = extend(e, {\n      cancel: false\n    });\n    this.trigger('keyPressed', presskey);\n\n    if (presskey.cancel === true) {\n      e.stopImmediatePropagation();\n    }\n  }\n\n  keyDownHandler(e) {\n    if (e.altKey) {\n      if (e.keyCode === 74) {\n        //alt j\n        if (this.keyA) {\n          //alt A J\n          this.notify(groupCollapse, {\n            target: e.target,\n            collapse: false\n          });\n          this.keyA = false;\n        } else {\n          this.focusModule.focusHeader();\n          this.focusModule.addOutline();\n        }\n      }\n\n      if (e.keyCode === 87) {\n        //alt w\n        this.focusModule.focusContent();\n        this.focusModule.addOutline();\n      }\n\n      if (e.keyCode === 65) {\n        //alt A\n        this.keyA = true;\n      }\n\n      if (e.keyCode === 72 && this.keyA) {\n        //alt A H\n        this.notify(groupCollapse, {\n          target: e.target,\n          collapse: true\n        });\n        this.keyA = false;\n      }\n    }\n\n    if (e.keyCode === 13) {\n      this.notify(enterKeyHandler, e);\n    }\n  }\n\n  keyActionHandler(e) {\n    if (this.isChildGrid(e) || this.isEdit && e.action !== 'escape' && e.action !== 'enter' && e.action !== 'shiftEnter' && e.action !== 'tab' && e.action !== 'shiftTab') {\n      return;\n    } else {\n      this.keyPress = true;\n    }\n\n    if (this.allowKeyboard) {\n      if (e.action === 'ctrlPlusP') {\n        e.preventDefault();\n        this.print();\n      }\n\n      this.notify(keyPressed, e);\n    }\n  }\n  /**\n   * @param {Function[]} modules - Defines the modules\n   * @returns {void}\n   * @hidden\n   */\n\n\n  setInjectedModules(modules) {\n    this.injectedModules = modules;\n  }\n\n  updateColumnObject() {\n    prepareColumns(this.columns, this.enableColumnVirtualization, this);\n    setColumnIndex(this.columns);\n    this.initForeignColumn();\n    this.notify(autoCol, {});\n  }\n  /**\n   * Gets the foreign columns from Grid.\n   *\n   * @returns {Column[]} Returns Foreign key column\n   */\n\n\n  getForeignKeyColumns() {\n    return this.getColumns().filter(col => {\n      return col.isForeignColumn();\n    });\n  }\n  /**\n   * @hidden\n   * @returns {number} Returns row height\n   */\n\n\n  getRowHeight() {\n    return this.rowHeight ? this.rowHeight : getRowHeight(this.element);\n  }\n  /**\n   * Refreshes the Grid column changes.\n   *\n   * @returns {void}\n   */\n\n\n  refreshColumns() {\n    this.setFrozenCount();\n    const fCnt = this.getContent().querySelector('.e-frozen-left-content');\n    const frCnt = this.getContent().querySelector('.e-frozen-right-content');\n    const isColFrozen = !this.frozenRightCount && !this.frozenLeftCount;\n    const isFrozen = this.getFrozenColumns() !== 0;\n\n    if (!isFrozen && (!fCnt && this.frozenLeftCount || !frCnt && this.frozenRightCount || fCnt && !this.frozenLeftCount || frCnt && !this.frozenRightCount)) {\n      this.tableIndex = 0;\n      this.tablesCount = 1;\n\n      if (this.enableColumnVirtualization) {\n        this.columnModel = [];\n        this.updateColumnModel(this.columns);\n      }\n\n      this.freezeRefresh();\n    } else if (isColFrozen && (this.getFrozenColumns() === 1 && !fCnt || this.getFrozenColumns() === 0 && fCnt)) {\n      this.tableIndex = 0;\n      this.tablesCount = 1;\n\n      if (this.enableColumnVirtualization) {\n        this.columnModel = [];\n        this.updateColumnModel(this.columns);\n      }\n\n      this.freezeRefresh();\n    } else {\n      this.isPreventScrollEvent = true;\n      this.updateColumnObject();\n      this.checkLockColumns(this.getColumns());\n      this.refresh();\n\n      if (this.isFrozenGrid()) {\n        const mTbl = this.contentModule.getMovableContent().querySelector('.' + table);\n        remove(mTbl.querySelector(colGroup));\n        const colGroup$$1 = this.getHeaderContent().querySelector('.' + movableHeader).querySelector(colGroup).cloneNode(true);\n        mTbl.insertBefore(colGroup$$1, mTbl.querySelector(tbody));\n\n        if (this.getFrozenMode() === 'Left-Right') {\n          const frTbl = this.contentModule.getFrozenRightContent().querySelector('.' + table);\n          remove(frTbl.querySelector(colGroup));\n          const colGrp = this.getHeaderContent().querySelector('.e-frozen-right-header').querySelector(colGroup).cloneNode(true);\n          frTbl.insertBefore(colGrp, frTbl.querySelector(tbody));\n        }\n      }\n    }\n\n    if (this.isFrozenGrid()) {\n      const left = this.getContent().querySelector('.e-movablescrollbar').scrollLeft;\n      this.headerModule.getMovableHeader().scrollLeft = left;\n      this.contentModule.getMovableContent().scrollLeft = left;\n    }\n  }\n  /**\n   * Export Grid data to Excel file(.xlsx).\n   *\n   * @param  {ExcelExportProperties} excelExportProperties - Defines the export properties of the Grid.\n   * @param  {boolean} isMultipleExport - Define to enable multiple export.\n   * @param  {Workbook} workbook - Defines the Workbook if multiple export is enabled.\n   * @param  {boolean} isBlob - If 'isBlob' set to true, then it will be returned as blob data.\n   * @returns {Promise<any>} Returns the excelexport\n   */\n\n\n  excelExport(excelExportProperties, isMultipleExport, // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  workbook, isBlob) {\n    return this.excelExportModule ? this.excelExportModule.Map(this, excelExportProperties, isMultipleExport, workbook, false, isBlob) : null;\n  }\n  /**\n   * Export Grid data to CSV file.\n   *\n   * @param  {ExcelExportProperties} excelExportProperties - Defines the export properties of the Grid.\n   * @param  {boolean} isMultipleExport - Define to enable multiple export.\n   * @param  {Workbook} workbook - Defines the Workbook if multiple export is enabled.\n   * @param  {boolean} isBlob - If 'isBlob' set to true, then it will be returned as blob data.\n   * @returns {Promise<any>} Returns csv export\n   */\n\n\n  csvExport(excelExportProperties, // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  isMultipleExport, workbook, isBlob) {\n    return this.excelExportModule ? this.excelExportModule.Map(this, excelExportProperties, isMultipleExport, workbook, true, isBlob) : null;\n  }\n  /**\n   * Export Grid data to PDF document.\n   *\n   * @param {pdfExportProperties} pdfExportProperties - Defines the export properties of the Grid.\n   * @param {isMultipleExport} isMultipleExport - Define to enable multiple export.\n   * @param {pdfDoc} pdfDoc - Defined the Pdf Document if multiple export is enabled.\n   * @param {boolean} isBlob - If 'isBlob' set to true, then it will be returned as blob data.\n   * @returns {Promise<any>} Returns pdfexport\n   */\n\n\n  pdfExport(pdfExportProperties, isMultipleExport, pdfDoc, isBlob) {\n    return this.pdfExportModule ? this.pdfExportModule.Map(this, pdfExportProperties, isMultipleExport, pdfDoc, isBlob) : null;\n  }\n  /**\n   * Groups a column by column name.\n   *\n   * @param  {string} columnName - Defines the column name to group.\n   * @returns {void}\n   */\n\n\n  groupColumn(columnName) {\n    if (this.groupModule) {\n      this.groupModule.groupColumn(columnName);\n    }\n  }\n  /**\n   * Expands all the grouped rows of the Grid.\n   *\n   * @returns {void}\n   */\n\n\n  groupExpandAll() {\n    if (this.groupModule) {\n      this.groupModule.expandAll();\n    }\n  }\n  /**\n   * Collapses all the grouped rows of the Grid.\n   *\n   * @returns {void}\n   */\n\n\n  groupCollapseAll() {\n    if (this.groupModule) {\n      this.groupModule.collapseAll();\n    }\n  }\n  /**\n   * Expands or collapses grouped rows by target element.\n   *\n   * @param  {Element} target - Defines the target element of the grouped row.\n   * @returns {void}\n   */\n  // public expandCollapseRows(target: Element): void {\n  //     if (this.groupModule) {\n  //         this.groupModule.expandCollapseRows(target);\n  //     }\n  // }\n\n  /**\n   * Clears all the grouped columns of the Grid.\n   *\n   * @returns {void}\n   */\n\n\n  clearGrouping() {\n    if (this.groupModule) {\n      this.groupModule.clearGrouping();\n    }\n  }\n  /**\n   * Ungroups a column by column name.\n   *\n   * @param  {string} columnName - Defines the column name to ungroup.\n   *\n   * {% codeBlock src='grid/ungroupColumn/index.md' %}{% endcodeBlock %}\n   *\n   * @returns {void}\n   */\n\n\n  ungroupColumn(columnName) {\n    if (this.groupModule) {\n      this.groupModule.ungroupColumn(columnName);\n    }\n  }\n  /**\n   * Column chooser can be displayed on screen by given position(X and Y axis).\n   *\n   * @param {number} x - Defines the X axis.\n   * @param {number} y - Defines the Y axis.\n   * @returns {void}\n   */\n\n\n  openColumnChooser(x, y) {\n    if (this.columnChooserModule) {\n      this.columnChooserModule.openColumnChooser(x, y);\n    }\n  }\n\n  scrollRefresh() {\n    const refresh = () => {\n      this.scrollModule.refresh();\n      this.off(contentReady, refresh);\n    };\n\n    this.on(contentReady, refresh, this);\n  }\n  /**\n   * Collapses a detail row with the given target.\n   *\n   * @param  {Element} target - Defines the expanded element to collapse.\n   * @returns {void}\n   */\n  // public detailCollapse(target: number | Element): void {\n  //     if (this.detailRowModule) {\n  //         this.detailRowModule.collapse(target);\n  //     }\n  // }\n\n  /**\n   * Collapses all the detail rows of the Grid.\n   *\n   * @returns {void}\n   */\n\n\n  detailCollapseAll() {\n    if (this.detailRowModule) {\n      this.detailRowModule.collapseAll();\n    }\n  }\n  /**\n   * Expands a detail row with the given target.\n   *\n   * @param  {Element} target - Defines the collapsed element to expand.\n   * @returns {void}\n   */\n  // public detailExpand(target: number | Element): void {\n  //     if (this.detailRowModule) {\n  //         this.detailRowModule.expand(target);\n  //     }\n  // }\n\n  /**\n   * Expands all the detail rows of the Grid.\n   *\n   * @returns {void}\n   */\n\n\n  detailExpandAll() {\n    if (this.detailRowModule) {\n      this.detailRowModule.expandAll();\n    }\n  }\n  /**\n   * Deselects the currently selected cells.\n   *\n   * @returns {void}\n   */\n\n\n  clearCellSelection() {\n    if (this.selectionModule) {\n      this.selectionModule.clearCellSelection();\n    }\n  }\n  /**\n   * Deselects the currently selected rows.\n   *\n   * @returns {void}\n   */\n\n\n  clearRowSelection() {\n    if (this.selectionModule) {\n      this.selectionModule.clearRowSelection();\n    }\n  }\n  /**\n   * Selects a collection of cells by row and column indexes.\n   *\n   * @param  {ISelectedCell[]} rowCellIndexes - Specifies the row and column indexes.\n   * @returns {void}\n   */\n\n\n  selectCells(rowCellIndexes) {\n    if (this.selectionModule) {\n      this.selectionModule.selectCells(rowCellIndexes);\n    }\n  }\n  /**\n   * Selects a range of rows from start and end row indexes.\n   *\n   * @param  {number} startIndex - Specifies the start row index.\n   * @param  {number} endIndex - Specifies the end row index.\n   * @returns {void}\n   */\n\n\n  selectRowsByRange(startIndex, endIndex) {\n    if (this.selectionModule) {\n      this.selectionModule.selectRowsByRange(startIndex, endIndex);\n    }\n  }\n  /**\n   * @hidden\n   * @returns {boolean} Returns whether context menu is open or not\n   */\n\n\n  isContextMenuOpen() {\n    return this.contextMenuModule && this.contextMenuModule.isOpen;\n  }\n  /**\n   * @param {Function} module - Defines the module\n   * @returns {boolean} return the injected modules\n   * @hidden\n   */\n\n\n  ensureModuleInjected(module) {\n    return this.getInjectedModules().indexOf(module) >= 0;\n  }\n  /**\n   * Destroys the given template reference.\n   *\n   * @param {string[]} propertyNames - Defines the collection of template name.\n   * @param {any} index - specifies the index\n   */\n  // eslint-disable-next-line\n\n\n  destroyTemplate(propertyNames, index) {\n    this.clearTemplate(propertyNames, index);\n  }\n  /**\n   * @param {string | string[]} type - Defines the type\n   * @param {Object} args - Defines the arguments\n   * @returns {void}\n   * @hidden\n   * @private\n   */\n\n\n  log(type, args) {\n    // eslint-disable-next-line\n    this.loggerModule ? this.loggerModule.log(type, args) : (() => 0)();\n  }\n  /**\n   * @param {Element} element - Defines the element\n   * @returns {void}\n   * @hidden\n   */\n\n\n  applyBiggerTheme(element) {\n    if (this.element.classList.contains('e-bigger')) {\n      element.classList.add('e-bigger');\n    }\n  }\n  /**\n   * @hidden\n   * @returns {Object} Returns the previous row data\n   */\n\n\n  getPreviousRowData() {\n    const previousRowData = this.getRowsObject()[this.getRows().length - 1].data;\n    return previousRowData;\n  }\n  /**\n   * Hides the scrollbar placeholder of Grid content when grid content is not overflown.\n   *\n   * @returns {void}\n   */\n\n\n  hideScroll() {\n    const content$$1 = this.getContent().querySelector('.' + content);\n    const scrollBar = this.getContent().querySelector('.e-scrollbar');\n\n    if (content$$1.scrollHeight <= content$$1.clientHeight) {\n      this.scrollModule.removePadding();\n      content$$1.style.overflowY = 'auto';\n    }\n\n    if (this.isFrozenGrid() && scrollBar) {\n      const mvblScrollBar = this.getContent().querySelector('.e-movablescrollbar');\n      const mvblChild = this.getContent().querySelector('.e-movablechild');\n      scrollBar.style.display = 'flex';\n\n      if (mvblScrollBar.offsetWidth >= mvblChild.offsetWidth) {\n        scrollBar.style.display = 'none';\n        this.notify(frozenHeight, 0);\n      }\n    }\n  }\n  /**\n   * Get row index by primary key or row data.\n   *\n   * @param  {string | Object} value - Defines the primary key value.\n   * @returns {number} Returns the index\n   */\n\n\n  getRowIndexByPrimaryKey(value) {\n    const pkName = this.getPrimaryKeyFieldNames()[0];\n    value = typeof value === 'object' ? value[pkName] : value;\n    const rows = this.getRowsObject();\n\n    for (let i = 0; i < rows.length; i++) {\n      if (rows[i].isDetailRow || rows[i].isCaptionRow) {\n        continue;\n      }\n\n      let pKvalue = rows[i].data[pkName];\n\n      if (pkName.split('.').length > 1) {\n        pKvalue = performComplexDataOperation(pkName, rows[i].data);\n      }\n\n      if (pKvalue === value) {\n        return rows[i].index;\n      }\n    }\n\n    return -1;\n  }\n  /**\n   * @param {string} field - Defines the field name\n   * @returns {Column} returns the column\n   * @hidden\n   */\n  // Need to have all columns while filtering with ColumnVirtualization.\n\n\n  grabColumnByFieldFromAllCols(field) {\n    let column;\n    this.columnModel = [];\n    this.updateColumnModel(this.columns);\n    const gCols = this.columnModel;\n\n    for (let i = 0; i < gCols.length; i++) {\n      if (field === gCols[i].field) {\n        column = gCols[i];\n      }\n    }\n\n    return column;\n  }\n  /**\n   * @param {string} uid - Defines the uid\n   * @returns {Column} returns the column\n   * @hidden\n   */\n  // Need to have all columns while filtering with ColumnVirtualization.\n\n\n  grabColumnByUidFromAllCols(uid) {\n    let column;\n    this.columnModel = [];\n    this.updateColumnModel(this.columns);\n    const gCols = this.columnModel;\n\n    for (let i = 0; i < gCols.length; i++) {\n      if (uid === gCols[i].uid) {\n        column = gCols[i];\n      }\n    }\n\n    return column;\n  }\n  /**\n   * Get all filtered records from the Grid and it returns array of objects for the local dataSource, returns a promise object if the Grid has remote data.\n   *\n   * @returns {Object[] | Promise<Object>} Returns the filtered records\n   */\n\n\n  getFilteredRecords() {\n    if (this.allowFiltering && this.filterSettings.columns.length) {\n      const query = this.renderModule.data.generateQuery(true);\n\n      if (this.dataSource && this.renderModule.data.isRemote() && this.dataSource instanceof DataManager) {\n        return this.renderModule.data.getData(this.dataSource, query);\n      } else {\n        if (this.dataSource instanceof DataManager) {\n          return this.dataSource.executeLocal(query);\n        } else {\n          return new DataManager(this.dataSource, query).executeLocal(query);\n        }\n      }\n    }\n\n    return [];\n  }\n\n  getUserAgent() {\n    const userAgent = Browser.userAgent.toLowerCase();\n    return /iphone|ipod|ipad/.test(userAgent);\n  }\n  /**\n   * @param {TouchEventArgs} e - Defines the TouchEventArgs\n   * @returns {void}\n   * @hidden\n   */\n  // Need to have all columns while filtering with ColumnVirtualization.\n  // eslint-disable-next-line\n\n\n  tapEvent(e) {\n    if (this.getUserAgent()) {\n      if (!Global.timer) {\n        Global.timer = setTimeout(() => {\n          Global.timer = null;\n        }, 300);\n      } else {\n        clearTimeout(Global.timer);\n        Global.timer = null;\n        this.dblClickHandler(e);\n        this.notify(doubleTap, e);\n      }\n    }\n  }\n  /**\n   * @param {string} prefix - specifies the prefix\n   * @returns {string} returns the row uid\n   * @hidden\n   */\n\n\n  getRowUid(prefix) {\n    return `${prefix}${this.rowUid++}`;\n  }\n  /**\n   * @hidden\n   * @returns {Element} returns the element\n   */\n\n\n  getMovableVirtualContent() {\n    return this.getContent().querySelector('.' + movableContent);\n  }\n  /**\n   * @hidden\n   * @returns {Element} returns the element\n   */\n\n\n  getFrozenVirtualContent() {\n    return this.getContent().querySelector('.' + frozenContent);\n  }\n  /**\n   * @hidden\n   * @returns {Element} returns the element\n   */\n\n\n  getMovableVirtualHeader() {\n    return this.getHeaderContent().querySelector('.' + movableHeader);\n  }\n  /**\n   * @hidden\n   * @returns {Element} returns the element\n   */\n\n\n  getFrozenVirtualHeader() {\n    return this.getHeaderContent().querySelector('.' + frozenHeader);\n  }\n  /**\n   * @param {string} uid - specifies the uid\n   * @returns {Element} returns the element\n   * @hidden\n   */\n\n\n  getRowElementByUID(uid) {\n    let rowEle;\n    let rows = [];\n\n    if (this.isFrozenGrid()) {\n      const fRows = [].slice.call(this.getFrozenVirtualContent().querySelector(tbody).children);\n      const mRows = [].slice.call(this.getMovableVirtualContent().querySelector(tbody).children);\n      let frozenRigtRows = [];\n\n      if (this.tablesCount === 3) {\n        frozenRigtRows = [].slice.call(this.getContent().querySelector('.e-frozen-right-content').querySelector(tbody).children);\n      }\n\n      if (this.frozenRows) {\n        rows = [].slice.call(this.getFrozenVirtualHeader().querySelector(tbody).children);\n        rows = rows.concat([].slice.call(this.getMovableVirtualHeader().querySelector(tbody).children));\n\n        if (this.tablesCount === 3) {\n          const frHdr = this.getHeaderContent().querySelector('.e-frozen-right-header');\n          rows = rows.concat([].slice.call(frHdr.querySelector(tbody).children)).concat(frozenRigtRows);\n        }\n\n        rows = rows.concat(fRows).concat(mRows);\n      } else {\n        rows = fRows.concat(mRows).concat(frozenRigtRows);\n      }\n    } else {\n      const cntRows = [].slice.call(this.getContent().querySelector(tbody).children);\n\n      if (this.frozenRows) {\n        rows = [].slice.call(this.getHeaderContent().querySelector(tbody).children);\n        rows = rows.concat(cntRows);\n      } else {\n        rows = cntRows;\n      }\n    }\n\n    for (const row$$1 of rows) {\n      if (row$$1.getAttribute('data-uid') === uid) {\n        rowEle = row$$1;\n        break;\n      }\n    }\n\n    return rowEle;\n  }\n  /**\n   * Gets the hidden columns from the Grid.\n   *\n   * @returns {Column[]} Returns the Column\n   */\n\n\n  getHiddenColumns() {\n    const cols = [];\n\n    for (const col of this.columnModel) {\n      if (col.visible === false) {\n        cols.push(col);\n      }\n    }\n\n    return cols;\n  }\n  /**\n   * calculatePageSizeByParentHeight\n   *\n   * @param {number | string } containerHeight - specifies the container height\n   * @returns {number} returns the page size\n   */\n\n\n  calculatePageSizeByParentHeight(containerHeight) {\n    if (this.allowPaging) {\n      if (this.allowTextWrap && this.textWrapSettings.wrapMode === 'Header' || !this.allowTextWrap) {\n        let pagesize = 0;\n\n        if (containerHeight.indexOf('%') !== -1) {\n          containerHeight = parseInt(containerHeight, 10) / 100 * this.element.clientHeight;\n        }\n\n        const nonContentHeight = this.getNoncontentHeight() + this.getRowHeight();\n\n        if (containerHeight > nonContentHeight) {\n          let contentHeight = 0;\n          contentHeight = containerHeight - this.getNoncontentHeight();\n          pagesize = contentHeight / this.getRowHeight();\n        }\n\n        if (pagesize > 0) {\n          return Math.floor(pagesize);\n        }\n      }\n    }\n\n    return 0;\n  }\n\n  getNoncontentHeight() {\n    let height = 0;\n\n    if (!isNullOrUndefined(this.getHeaderContent().clientHeight)) {\n      height += this.getHeaderContent().clientHeight;\n    }\n\n    if (this.toolbar && !isNullOrUndefined(this.element.querySelector('.e-toolbar').clientHeight)) {\n      height += this.element.querySelector('.e-toolbar').clientHeight;\n    }\n\n    if (this.allowPaging && !isNullOrUndefined(this.element.querySelector('.e-gridpager').clientHeight)) {\n      height += this.element.querySelector('.e-gridpager').clientHeight;\n    }\n\n    if (this.showColumnChooser && !isNullOrUndefined(this.element.querySelector('.e-columnheader').clientHeight)) {\n      height += this.element.querySelector('.e-columnheader').clientHeight;\n    }\n\n    if (this.allowGrouping && this.groupSettings.showDropArea && !isNullOrUndefined(this.element.querySelector('.e-groupdroparea').clientHeight)) {\n      height += this.element.querySelector('.e-groupdroparea').clientHeight;\n    }\n\n    if (this.aggregates.length > 0 && !isNullOrUndefined(this.element.querySelector('.e-summaryrow').clientHeight)) {\n      for (let i = 0; i < this.element.getElementsByClassName('e-summaryrow').length; i++) {\n        height += this.element.getElementsByClassName('e-summaryrow')[i].clientHeight;\n      }\n    }\n\n    return height;\n  }\n  /**\n   *To perform aggregate operation on a column.\n   *\n   * @param  {AggregateColumnModel} summaryCol - Pass Aggregate Column details.\n   * @param  {Object} summaryData - Pass JSON Array for which its field values to be calculated.\n   * @returns {number} returns the summary values\n   */\n\n\n  getSummaryValues(summaryCol, summaryData) {\n    return DataUtil.aggregates[summaryCol.type.toLowerCase()](summaryData, summaryCol.field);\n  }\n  /**\n   * Sends a Post request to export Grid to Excel file in server side.\n   *\n   * @param  {string} url - Pass Url for server side excel export action.\n   * @returns {void}\n   */\n\n\n  serverExcelExport(url) {\n    this.isExcel = true;\n    this.exportGrid(url);\n  }\n  /**\n   * Sends a Post request to export Grid to Pdf file in server side.\n   *\n   * @param  {string} url - Pass Url for server side pdf export action.\n   * @returns {void}\n   */\n\n\n  serverPdfExport(url) {\n    this.isExcel = false;\n    this.exportGrid(url);\n  }\n  /**\n   * Sends a Post request to export Grid to CSV file in server side.\n   *\n   * @param  {string} url - Pass Url for server side pdf export action.\n   * @returns {void}\n   */\n\n\n  serverCsvExport(url) {\n    this.isExcel = true;\n    this.exportGrid(url);\n  }\n  /**\n   * @param {string} url - Defines exporting url\n   * @returns {void}\n   * @hidden\n   */\n\n\n  exportGrid(url) {\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    const grid = this;\n    const query = grid.getDataModule().generateQuery(true);\n    const state = new UrlAdaptor().processQuery(new DataManager({\n      url: ''\n    }), query);\n    const queries = JSON.parse(state.data); // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n    const gridModel = JSON.parse(this.addOnPersist(['allowGrouping', 'allowPaging', 'pageSettings', 'sortSettings', 'allowPdfExport', 'allowExcelExport', 'aggregates', 'filterSettings', 'groupSettings', 'columns', 'locale', 'searchSettings']));\n    const include = ['field', 'headerText', 'type', 'format', 'visible', 'foreignKeyValue', 'foreignKeyField', 'template', 'index', 'width', 'textAlign', 'headerTextAlign', 'columns'];\n    gridModel.filterSettings.columns = queries.where;\n    gridModel.searchSettings.fields = queries.search && queries.search[0]['fields'] || [];\n    gridModel.sortSettings.columns = queries.sorted;\n    gridModel.columns = this.setHeaderText(gridModel.columns, include);\n    const form = this.createElement('form', {\n      id: 'ExportForm',\n      styles: 'display:none;'\n    });\n    const gridInput = this.createElement('input', {\n      id: 'gridInput',\n      attrs: {\n        name: 'gridModel'\n      }\n    });\n    gridInput.value = JSON.stringify(gridModel);\n    form.method = 'POST';\n    form.action = url;\n    form.appendChild(gridInput);\n    document.body.appendChild(form);\n    form.submit();\n    form.remove();\n  }\n  /**\n   * @param {Column[]} columns - Defines array of columns\n   * @param {string[]} include - Defines array of sting\n   * @returns {Column[]} returns array of columns\n   * @hidden\n   */\n\n\n  setHeaderText(columns, include) {\n    for (let i = 0; i < columns.length; i++) {\n      const column = this.getColumnByUid(columns[i].uid);\n      columns[i].headerText = column.headerText;\n\n      if (!isNullOrUndefined(column.template)) {\n        columns[i].template = 'true';\n      }\n\n      if (columns[i].format) {\n        columns[i].format = getNumberFormat(this.getFormat(columns[i].format), columns[i].type, this.isExcel);\n      }\n\n      if (columns[i].columns) {\n        this.setHeaderText(columns[i].columns, include);\n      }\n\n      const keys = Object.keys(columns[i]);\n\n      for (let j = 0; j < keys.length; j++) {\n        if (include.indexOf(keys[j]) < 0) {\n          delete columns[i][keys[j]];\n        }\n      }\n    }\n\n    return columns;\n  }\n\n  getFormat(format) {\n    return typeof format === 'object' ? !isNullOrUndefined(format.format) ? format.format : format.skeleton : format;\n  }\n  /**\n   * @hidden\n   * @returns {boolean} returns the isCollapseStateEnabled\n   */\n\n\n  isCollapseStateEnabled() {\n    const isExpanded = 'isExpanded';\n    return this[isExpanded] === false;\n  }\n  /**\n   * @param {number} key - Defines the primary key value.\n   * @param {Object} rowData - Defines the rowData\n   * @returns {void}\n   */\n\n\n  updateRowValue(key, rowData) {\n    const args = {\n      requestType: 'save',\n      data: rowData\n    };\n    this.showSpinner();\n    this.notify(updateData, args);\n    this.refresh();\n  }\n  /**\n   * @hidden\n   * @returns {void}\n   */\n\n\n  setForeignKeyData() {\n    this.dataBind();\n    const colpending = this.getDataModule().getForeignKeyDataState();\n\n    if (colpending.isPending) {\n      this.getDataModule().setForeignKeyDataState({});\n      colpending.resolver();\n    } else {\n      this.getDataModule().setForeignKeyDataState({\n        isDataChanged: false\n      });\n\n      if (this.contentModule || this.headerModule) {\n        this.renderModule.render();\n      }\n    }\n  }\n  /**\n   * @param {string} field - specifies the field\n   * @returns {void}\n   * @hidden\n   */\n\n\n  resetFilterDlgPosition(field) {\n    const header = this.getColumnHeaderByField(field);\n\n    if (header) {\n      const target = header.querySelector('.e-filtermenudiv');\n      const filterDlg = this.element.querySelector('.e-filter-popup');\n\n      if (target && filterDlg) {\n        const gClient = this.element.getBoundingClientRect();\n        const fClient = target.getBoundingClientRect();\n\n        if (filterDlg) {\n          filterDlg.style.left = (fClient.right - gClient.left).toString() + 'px';\n        }\n      }\n    }\n  }\n  /**\n   * @hidden\n   * @returns {void}\n   */\n\n\n  renderTemplates() {\n    const portals = 'portals';\n    this.notify('reactTemplateRender', this[portals]);\n    this.renderReactTemplates();\n  }\n  /**\n   * Apply the changes to the Grid without refreshing the rows.\n   *\n   * @param  {BatchChanges} changes - Defines changes to be updated.\n   * @returns {void}\n   */\n\n\n  batchUpdate(changes) {\n    this.processRowChanges(changes);\n  }\n  /**\n   * Apply the changes to the Grid in one batch after 50ms without refreshing the rows.\n   *\n   * @param  {BatchChanges} changes - Defines changes to be updated.\n   * @returns {void}\n   */\n\n\n  batchAsyncUpdate(changes) {\n    this.processBulkRowChanges(changes);\n  }\n\n  processBulkRowChanges(changes) {\n    if (!this.dataToBeUpdated) {\n      this.dataToBeUpdated = Object.assign({\n        addedRecords: [],\n        changedRecords: [],\n        deletedRecords: []\n      }, changes);\n      setTimeout(() => {\n        this.processRowChanges(this.dataToBeUpdated);\n        this.dataToBeUpdated = null;\n      }, this.asyncTimeOut);\n    } else {\n      const loopstring = [addedRecords, changedRecords, deletedRecords];\n      const keyField = this.getPrimaryKeyFieldNames()[0];\n\n      for (let i = 0; i < loopstring.length; i++) {\n        if (changes[loopstring[i]]) {\n          compareChanges(this, changes, loopstring[i], keyField);\n        }\n      }\n    }\n  }\n\n  processRowChanges(changes) {\n    const keyField = this.getPrimaryKeyFieldNames()[0];\n    changes = Object.assign({\n      addedRecords: [],\n      changedRecords: [],\n      deletedRecords: []\n    }, changes);\n    const promise = this.getDataModule().saveChanges(changes, keyField, {}, this.getDataModule().generateQuery().requiresCount());\n\n    if (this.getDataModule().isRemote()) {\n      promise.then(() => {\n        this.setNewData();\n      });\n    } else {\n      this.setNewData();\n    }\n  }\n\n  setNewData() {\n    const oldValues = JSON.parse(JSON.stringify(this.getCurrentViewRecords()));\n    const getData = this.getDataModule().getData({}, this.getDataModule().generateQuery().requiresCount());\n    getData.then(e => {\n      this.bulkRefresh(e.result, oldValues, e.count);\n    });\n  }\n\n  deleteRowElement(row$$1) {\n    const tr = this.getRowElementByUID(row$$1.uid);\n    const index = parseInt(tr.getAttribute(ariaRowIndex), 10);\n    remove(tr);\n\n    if (this.getFrozenColumns()) {\n      const mtr = this.getMovableRows()[index];\n      remove(mtr);\n    }\n  }\n\n  bulkRefresh(result, oldValues, count) {\n    const rowObj = this.getRowsObject();\n    const keyField = this.getPrimaryKeyFieldNames()[0];\n\n    for (let i = 0; i < rowObj.length; i++) {\n      if (!result.filter(e => {\n        return e[keyField] === rowObj[i].data[keyField];\n      }).length) {\n        this.deleteRowElement(rowObj[i]);\n        rowObj.splice(i, 1);\n        i--;\n      }\n    }\n\n    for (let i = 0; i < result.length; i++) {\n      let isRowExist;\n      oldValues.filter(e => {\n        if (e[keyField] === result[i][keyField]) {\n          if (e !== result[i]) {\n            this.setRowData(result[i][keyField], result[i]);\n          }\n\n          isRowExist = true;\n        }\n      });\n\n      if (!isRowExist) {\n        this.renderRowElement(result[i], i);\n      }\n    }\n\n    this.currentViewData = result;\n    const rows = [].slice.call(this.getContentTable().getElementsByClassName(row));\n    resetRowIndex(this, this.getRowsObject(), rows);\n    setRowElements(this);\n\n    if (this.allowPaging) {\n      this.notify(inBoundModelChanged, {\n        module: 'pager',\n        properties: {\n          totalRecordsCount: count\n        }\n      });\n    }\n  }\n\n  renderRowElement(data, index) {\n    const row$$1 = new RowRenderer(this.serviceLocator, null, this);\n    const model = new RowModelGenerator(this);\n    const modelData = model.generateRows([data]);\n    const tr = row$$1.render(modelData[0], this.getColumns());\n    let mTr;\n    let mTbody;\n    this.addRowObject(modelData[0], index);\n    let tbody$$1 = this.getContentTable().querySelector(tbody);\n\n    if (tbody$$1.querySelector('.e-emptyrow')) {\n      const emptyRow = tbody$$1.querySelector('.e-emptyrow');\n      emptyRow.parentNode.removeChild(emptyRow);\n\n      if (this.getFrozenColumns()) {\n        const moveTbody = this.getContent().querySelector('.' + movableContent).querySelector(tbody);\n        moveTbody.firstElementChild.parentNode.removeChild(moveTbody.firstElementChild);\n      }\n    }\n\n    if (this.getFrozenColumns()) {\n      mTr = renderMovable(tr, this.getFrozenColumns(), this);\n\n      if (this.frozenRows && index < this.frozenRows) {\n        mTbody = this.getHeaderContent().querySelector('.' + movableHeader).querySelector(tbody);\n      } else {\n        mTbody = this.getContent().querySelector('.' + movableContent).querySelector(tbody);\n      }\n\n      mTbody.appendChild(mTr);\n\n      if (this.height === 'auto') {\n        this.notify(frozenHeight, {});\n      }\n    }\n\n    if (this.frozenRows && index < this.frozenRows) {\n      tbody$$1 = this.getHeaderContent().querySelector(tbody);\n    } else {\n      tbody$$1 = this.getContent().querySelector(tbody);\n    }\n\n    tbody$$1 = this.getContent().querySelector(tbody);\n    tbody$$1.appendChild(tr);\n  }\n\n  addRowObject(row$$1, index) {\n    const frzCols = this.getFrozenColumns();\n\n    if (frzCols) {\n      const mRows = this.getMovableRowsObject();\n      const mRow = row$$1.clone();\n      mRow.cells = mRow.cells.slice(frzCols);\n      row$$1.cells = row$$1.cells.slice(0, frzCols);\n      mRows.splice(index, 1, mRow);\n    }\n\n    this.getRowsObject().splice(index, 1, row$$1);\n  }\n  /**\n   * @hidden\n   * @returns {void}\n   */\n\n\n  updateVisibleExpandCollapseRows() {\n    const rows = this.getRowsObject();\n\n    for (let i = 0, len = rows.length; i < len; i++) {\n      if (rows[i].isDataRow && this.getRowElementByUID(rows[i].uid).style.display === 'none') {\n        rows[i].visible = false;\n      } else {\n        rows[i].visible = true;\n      }\n    }\n  }\n  /**\n   * @param {string | number} height - specifies the height\n   * @returns {number | string} - specifies the height number\n   * @hidden\n   */\n\n\n  getHeight(height) {\n    if (!Number.isInteger(height) && height.indexOf('%') !== -1) {\n      height = parseInt(height, 10) / 100 * this.element.clientHeight;\n    } else if (!Number.isInteger(height) && this.height !== 'auto') {\n      height = parseInt(height, 10);\n    } else {\n      height = this.height;\n    }\n\n    return height;\n  }\n  /**\n   * @hidden\n   * @returns {Element} - returns frozen right content\n   */\n\n\n  getFrozenRightContent() {\n    return this.getContent().querySelector('.e-frozen-right-content');\n  }\n  /**\n   * @hidden\n   * @returns {Element} - returns frozen right header\n   */\n\n\n  getFrozenRightHeader() {\n    return this.getHeaderContent().querySelector('.e-frozen-right-header');\n  }\n  /**\n   * @hidden\n   * @returns {Element} - returns movable header tbody\n   */\n\n\n  getMovableHeaderTbody() {\n    return this.getMovableVirtualHeader().querySelector(tbody);\n  }\n  /**\n   * @hidden\n   * @returns {Element} - returns movable content tbody\n   */\n\n\n  getMovableContentTbody() {\n    return this.getMovableVirtualContent().querySelector(tbody);\n  }\n  /**\n   * @hidden\n   * @returns {Element} - returns frozen header tbody\n   */\n\n\n  getFrozenHeaderTbody() {\n    return this.getFrozenVirtualHeader().querySelector(tbody);\n  }\n  /**\n   * @hidden\n   * @returns {Element} - returns frozen left content tbody\n   */\n\n\n  getFrozenLeftContentTbody() {\n    return this.getFrozenVirtualContent().querySelector(tbody);\n  }\n  /**\n   * @hidden\n   * @returns {Element} - returns frozen right header tbody\n   */\n\n\n  getFrozenRightHeaderTbody() {\n    return this.getFrozenRightHeader().querySelector(tbody);\n  }\n  /**\n   * @returns {Element} returns frozen right content tbody\n   * @hidden\n   */\n\n\n  getFrozenRightContentTbody() {\n    const cnt = this.getFrozenRightContent();\n    let tbody$$1;\n\n    if (cnt) {\n      tbody$$1 = this.getFrozenRightContent().querySelector(tbody);\n    }\n\n    return tbody$$1;\n  }\n  /**\n   * @param {boolean} isCustom - Defines custom filter dialog open\n   * @returns {void}\n   * @hidden\n   */\n\n\n  showResponsiveCustomFilter(isCustom) {\n    if (this.filterModule) {\n      this.filterModule.showCustomFilter(isCustom || this.rowRenderingMode === 'Vertical');\n    }\n  }\n  /**\n   * @param {boolean} isCustom - Defines custom sort dialog open\n   * @returns {void}\n   * @hidden\n   */\n\n\n  showResponsiveCustomSort(isCustom) {\n    if (this.sortModule) {\n      this.sortModule.showCustomSort(isCustom || this.rowRenderingMode === 'Vertical');\n    }\n  }\n  /**\n   * To manually show the vertical row mode filter dialog\n   *\n   * @returns {void}\n   */\n\n\n  showAdaptiveFilterDialog() {\n    if (this.enableAdaptiveUI) {\n      this.showResponsiveCustomFilter(true);\n    }\n  }\n  /**\n   * To manually show the vertical row sort filter dialog\n   *\n   * @returns {void}\n   */\n\n\n  showAdaptiveSortDialog() {\n    if (this.enableAdaptiveUI) {\n      this.showResponsiveCustomSort(true);\n    }\n  }\n  /**\n   * @param {boolean} isColVirtualization - Defines column virtualization\n   * @returns {Column[]} returns array of column models\n   * @hidden\n   */\n\n\n  getCurrentVisibleColumns(isColVirtualization) {\n    const cols = [];\n    const gridCols = isColVirtualization ? this.getColumns() : this.columnModel;\n\n    for (const col of gridCols) {\n      if (col.visible) {\n        cols.push(col);\n      }\n    }\n\n    return cols;\n  }\n\n  enableInfiniteAggrgate() {\n    if (this.enableInfiniteScrolling && this.groupSettings.columns.length && !this.groupSettings.disablePageWiseAggregates) {\n      this.setProperties({\n        groupSettings: {\n          disablePageWiseAggregates: true\n        }\n      }, true);\n    }\n  }\n\n};\n\n__decorate$1([Property()], Grid.prototype, \"parentDetails\", void 0);\n\n__decorate$1([Property([])], Grid.prototype, \"columns\", void 0);\n\n__decorate$1([Property(true)], Grid.prototype, \"enableAltRow\", void 0);\n\n__decorate$1([Property(true)], Grid.prototype, \"enableHover\", void 0);\n\n__decorate$1([Property(false)], Grid.prototype, \"enableAutoFill\", void 0);\n\n__decorate$1([Property(true)], Grid.prototype, \"allowKeyboard\", void 0);\n\n__decorate$1([Property(false)], Grid.prototype, \"enableStickyHeader\", void 0);\n\n__decorate$1([Property(false)], Grid.prototype, \"allowTextWrap\", void 0);\n\n__decorate$1([Complex({}, TextWrapSettings)], Grid.prototype, \"textWrapSettings\", void 0);\n\n__decorate$1([Complex({}, ResizeSettings)], Grid.prototype, \"resizeSettings\", void 0);\n\n__decorate$1([Property(false)], Grid.prototype, \"allowPaging\", void 0);\n\n__decorate$1([Complex({}, PageSettings)], Grid.prototype, \"pageSettings\", void 0);\n\n__decorate$1([Property(false)], Grid.prototype, \"enableVirtualization\", void 0);\n\n__decorate$1([Property(false)], Grid.prototype, \"enableColumnVirtualization\", void 0);\n\n__decorate$1([Property(false)], Grid.prototype, \"enableInfiniteScrolling\", void 0);\n\n__decorate$1([Complex({}, SearchSettings)], Grid.prototype, \"searchSettings\", void 0);\n\n__decorate$1([Property(false)], Grid.prototype, \"allowSorting\", void 0);\n\n__decorate$1([Property('Ellipsis')], Grid.prototype, \"clipMode\", void 0);\n\n__decorate$1([Property(true)], Grid.prototype, \"allowMultiSorting\", void 0);\n\n__decorate$1([Property(false)], Grid.prototype, \"allowExcelExport\", void 0);\n\n__decorate$1([Property(false)], Grid.prototype, \"allowPdfExport\", void 0);\n\n__decorate$1([Complex({}, SortSettings)], Grid.prototype, \"sortSettings\", void 0);\n\n__decorate$1([Complex({}, InfiniteScrollSettings)], Grid.prototype, \"infiniteScrollSettings\", void 0);\n\n__decorate$1([Property(true)], Grid.prototype, \"allowSelection\", void 0);\n\n__decorate$1([Property(-1)], Grid.prototype, \"selectedRowIndex\", void 0);\n\n__decorate$1([Complex({}, SelectionSettings)], Grid.prototype, \"selectionSettings\", void 0);\n\n__decorate$1([Property(false)], Grid.prototype, \"allowFiltering\", void 0);\n\n__decorate$1([Property('Horizontal')], Grid.prototype, \"rowRenderingMode\", void 0);\n\n__decorate$1([Property(false)], Grid.prototype, \"enableAdaptiveUI\", void 0);\n\n__decorate$1([Property(false)], Grid.prototype, \"allowReordering\", void 0);\n\n__decorate$1([Property(false)], Grid.prototype, \"allowResizing\", void 0);\n\n__decorate$1([Property(false)], Grid.prototype, \"allowRowDragAndDrop\", void 0);\n\n__decorate$1([Complex({}, RowDropSettings)], Grid.prototype, \"rowDropSettings\", void 0);\n\n__decorate$1([Complex({}, FilterSettings)], Grid.prototype, \"filterSettings\", void 0);\n\n__decorate$1([Property(false)], Grid.prototype, \"allowGrouping\", void 0);\n\n__decorate$1([Property(false)], Grid.prototype, \"enableImmutableMode\", void 0);\n\n__decorate$1([Property(false)], Grid.prototype, \"showColumnMenu\", void 0);\n\n__decorate$1([Complex({}, GroupSettings)], Grid.prototype, \"groupSettings\", void 0);\n\n__decorate$1([Complex({}, EditSettings)], Grid.prototype, \"editSettings\", void 0);\n\n__decorate$1([Collection([], AggregateRow)], Grid.prototype, \"aggregates\", void 0);\n\n__decorate$1([Property(false)], Grid.prototype, \"showColumnChooser\", void 0);\n\n__decorate$1([Complex({}, ColumnChooserSettings)], Grid.prototype, \"columnChooserSettings\", void 0);\n\n__decorate$1([Property(false)], Grid.prototype, \"enableHeaderFocus\", void 0);\n\n__decorate$1([Property('auto')], Grid.prototype, \"height\", void 0);\n\n__decorate$1([Property('auto')], Grid.prototype, \"width\", void 0);\n\n__decorate$1([Property('Default')], Grid.prototype, \"gridLines\", void 0);\n\n__decorate$1([Property()], Grid.prototype, \"rowTemplate\", void 0);\n\n__decorate$1([Property()], Grid.prototype, \"detailTemplate\", void 0);\n\n__decorate$1([Property()], Grid.prototype, \"childGrid\", void 0);\n\n__decorate$1([Property()], Grid.prototype, \"queryString\", void 0);\n\n__decorate$1([Property('AllPages')], Grid.prototype, \"printMode\", void 0);\n\n__decorate$1([Property('Expanded')], Grid.prototype, \"hierarchyPrintMode\", void 0);\n\n__decorate$1([Property([])], Grid.prototype, \"dataSource\", void 0);\n\n__decorate$1([Property(null)], Grid.prototype, \"rowHeight\", void 0);\n\n__decorate$1([Property()], Grid.prototype, \"query\", void 0);\n\n__decorate$1([Property('USD')], Grid.prototype, \"currencyCode\", void 0);\n\n__decorate$1([Property()], Grid.prototype, \"toolbar\", void 0);\n\n__decorate$1([Property()], Grid.prototype, \"contextMenuItems\", void 0);\n\n__decorate$1([Property()], Grid.prototype, \"columnMenuItems\", void 0);\n\n__decorate$1([Property()], Grid.prototype, \"toolbarTemplate\", void 0);\n\n__decorate$1([Property()], Grid.prototype, \"pagerTemplate\", void 0);\n\n__decorate$1([Property(0)], Grid.prototype, \"frozenRows\", void 0);\n\n__decorate$1([Property(0)], Grid.prototype, \"frozenColumns\", void 0);\n\n__decorate$1([Property('All')], Grid.prototype, \"columnQueryMode\", void 0);\n\n__decorate$1([Property({})], Grid.prototype, \"currentAction\", void 0);\n\n__decorate$1([Property('19.4.38')], Grid.prototype, \"ej2StatePersistenceVersion\", void 0);\n\n__decorate$1([Event()], Grid.prototype, \"created\", void 0);\n\n__decorate$1([Event()], Grid.prototype, \"destroyed\", void 0);\n\n__decorate$1([Event()], Grid.prototype, \"load\", void 0);\n\n__decorate$1([Event()], Grid.prototype, \"rowDataBound\", void 0);\n\n__decorate$1([Event()], Grid.prototype, \"queryCellInfo\", void 0);\n\n__decorate$1([Event()], Grid.prototype, \"headerCellInfo\", void 0);\n\n__decorate$1([Event()], Grid.prototype, \"actionBegin\", void 0);\n\n__decorate$1([Event()], Grid.prototype, \"actionComplete\", void 0);\n\n__decorate$1([Event()], Grid.prototype, \"actionFailure\", void 0);\n\n__decorate$1([Event()], Grid.prototype, \"dataBound\", void 0);\n\n__decorate$1([Event()], Grid.prototype, \"recordDoubleClick\", void 0);\n\n__decorate$1([Event()], Grid.prototype, \"recordClick\", void 0);\n\n__decorate$1([Event()], Grid.prototype, \"rowSelecting\", void 0);\n\n__decorate$1([Event()], Grid.prototype, \"rowSelected\", void 0);\n\n__decorate$1([Event()], Grid.prototype, \"rowDeselecting\", void 0);\n\n__decorate$1([Event()], Grid.prototype, \"rowDeselected\", void 0);\n\n__decorate$1([Event()], Grid.prototype, \"cellSelecting\", void 0);\n\n__decorate$1([Event()], Grid.prototype, \"cellSelected\", void 0);\n\n__decorate$1([Event()], Grid.prototype, \"cellDeselecting\", void 0);\n\n__decorate$1([Event()], Grid.prototype, \"cellDeselected\", void 0);\n\n__decorate$1([Event()], Grid.prototype, \"columnSelecting\", void 0);\n\n__decorate$1([Event()], Grid.prototype, \"columnSelected\", void 0);\n\n__decorate$1([Event()], Grid.prototype, \"columnDeselecting\", void 0);\n\n__decorate$1([Event()], Grid.prototype, \"columnDeselected\", void 0);\n\n__decorate$1([Event()], Grid.prototype, \"columnDragStart\", void 0);\n\n__decorate$1([Event()], Grid.prototype, \"columnDrag\", void 0);\n\n__decorate$1([Event()], Grid.prototype, \"columnDrop\", void 0);\n\n__decorate$1([Event()], Grid.prototype, \"printComplete\", void 0);\n\n__decorate$1([Event()], Grid.prototype, \"beforePrint\", void 0);\n\n__decorate$1([Event()], Grid.prototype, \"pdfQueryCellInfo\", void 0);\n\n__decorate$1([Event()], Grid.prototype, \"pdfHeaderQueryCellInfo\", void 0);\n\n__decorate$1([Event()], Grid.prototype, \"pdfAggregateQueryCellInfo\", void 0);\n\n__decorate$1([Event()], Grid.prototype, \"excelAggregateQueryCellInfo\", void 0);\n\n__decorate$1([Event()], Grid.prototype, \"exportDetailDataBound\", void 0);\n\n__decorate$1([Event()], Grid.prototype, \"excelQueryCellInfo\", void 0);\n\n__decorate$1([Event()], Grid.prototype, \"excelHeaderQueryCellInfo\", void 0);\n\n__decorate$1([Event()], Grid.prototype, \"beforeExcelExport\", void 0);\n\n__decorate$1([Event()], Grid.prototype, \"excelExportComplete\", void 0);\n\n__decorate$1([Event()], Grid.prototype, \"beforePdfExport\", void 0);\n\n__decorate$1([Event()], Grid.prototype, \"pdfExportComplete\", void 0);\n\n__decorate$1([Event()], Grid.prototype, \"rowDragStartHelper\", void 0);\n\n__decorate$1([Event()], Grid.prototype, \"detailDataBound\", void 0);\n\n__decorate$1([Event()], Grid.prototype, \"rowDragStart\", void 0);\n\n__decorate$1([Event()], Grid.prototype, \"rowDrag\", void 0);\n\n__decorate$1([Event()], Grid.prototype, \"rowDrop\", void 0);\n\n__decorate$1([Event()], Grid.prototype, \"toolbarClick\", void 0);\n\n__decorate$1([Event()], Grid.prototype, \"beforeOpenColumnChooser\", void 0);\n\n__decorate$1([Event()], Grid.prototype, \"beforeOpenAdaptiveDialog\", void 0);\n\n__decorate$1([Event()], Grid.prototype, \"batchAdd\", void 0);\n\n__decorate$1([Event()], Grid.prototype, \"batchDelete\", void 0);\n\n__decorate$1([Event()], Grid.prototype, \"batchCancel\", void 0);\n\n__decorate$1([Event()], Grid.prototype, \"beforeBatchAdd\", void 0);\n\n__decorate$1([Event()], Grid.prototype, \"beforeBatchDelete\", void 0);\n\n__decorate$1([Event()], Grid.prototype, \"beforeBatchSave\", void 0);\n\n__decorate$1([Event()], Grid.prototype, \"beginEdit\", void 0);\n\n__decorate$1([Event()], Grid.prototype, \"commandClick\", void 0);\n\n__decorate$1([Event()], Grid.prototype, \"cellEdit\", void 0);\n\n__decorate$1([Event()], Grid.prototype, \"cellSave\", void 0);\n\n__decorate$1([Event()], Grid.prototype, \"cellSaved\", void 0);\n\n__decorate$1([Event()], Grid.prototype, \"resizeStart\", void 0);\n\n__decorate$1([Event()], Grid.prototype, \"resizing\", void 0);\n\n__decorate$1([Event()], Grid.prototype, \"resizeStop\", void 0);\n\n__decorate$1([Event()], Grid.prototype, \"keyPressed\", void 0);\n\n__decorate$1([Event()], Grid.prototype, \"beforeDataBound\", void 0);\n\n__decorate$1([Event()], Grid.prototype, \"contextMenuOpen\", void 0);\n\n__decorate$1([Event()], Grid.prototype, \"contextMenuClick\", void 0);\n\n__decorate$1([Event()], Grid.prototype, \"columnMenuOpen\", void 0);\n\n__decorate$1([Event()], Grid.prototype, \"columnMenuClick\", void 0);\n\n__decorate$1([Event()], Grid.prototype, \"checkBoxChange\", void 0);\n\n__decorate$1([Event()], Grid.prototype, \"beforeCopy\", void 0);\n\n__decorate$1([Event()], Grid.prototype, \"beforePaste\", void 0);\n\n__decorate$1([Event()], Grid.prototype, \"beforeAutoFill\", void 0);\n\n__decorate$1([Event()], Grid.prototype, \"columnDataStateChange\", void 0);\n\n__decorate$1([Event()], Grid.prototype, \"dataStateChange\", void 0);\n\n__decorate$1([Event()], Grid.prototype, \"dataSourceChanged\", void 0);\n\n__decorate$1([Event()], Grid.prototype, \"exportGroupCaption\", void 0);\n\n__decorate$1([Event()], Grid.prototype, \"lazyLoadGroupExpand\", void 0);\n\n__decorate$1([Event()], Grid.prototype, \"lazyLoadGroupCollapse\", void 0);\n\nGrid = Grid_1 = __decorate$1([NotifyPropertyChanges], Grid);\n/**\n * @returns {string[]} returns the cloned property\n * @hidden\n */\n\nfunction getCloneProperties() {\n  return ['aggregates', 'allowGrouping', 'allowFiltering', 'allowMultiSorting', 'allowReordering', 'allowSorting', 'allowTextWrap', 'childGrid', 'columns', 'currentViewData', 'dataSource', 'detailTemplate', 'enableAltRow', 'enableColumnVirtualization', 'filterSettings', 'gridLines', 'groupSettings', 'height', 'locale', 'pageSettings', 'printMode', 'query', 'queryString', 'enableRtl', 'rowHeight', 'rowTemplate', 'sortSettings', 'textWrapSettings', 'allowPaging', 'hierarchyPrintMode', 'searchSettings', 'queryCellInfo', 'beforeDataBound'];\n}\n/**\n *\n * The `Print` module is used to handle print action.\n */\n\n\nclass Print {\n  /**\n   * Constructor for the Grid print module\n   *\n   * @param {IGrid} parent - specifies the IGrid\n   * @param {Scroll} scrollModule - specifies the scroll module\n   * @hidden\n   */\n  constructor(parent, scrollModule) {\n    this.isAsyncPrint = false;\n    this.defered = new Deferred();\n    this.parent = parent;\n\n    if (this.parent.isDestroyed) {\n      return;\n    }\n\n    this.parent.on(contentReady, this.isContentReady(), this);\n    this.actionBeginFunction = this.actionBegin.bind(this);\n    this.parent.addEventListener(actionBegin, this.actionBeginFunction);\n    this.parent.on(onEmpty, this.onEmpty.bind(this));\n    this.parent.on(hierarchyPrint, this.hierarchyPrint, this);\n    this.scrollModule = scrollModule;\n  }\n\n  isContentReady() {\n    if (this.isPrintGrid() && (this.parent.hierarchyPrintMode === 'None' || !this.parent.childGrid)) {\n      return this.contentReady;\n    }\n\n    return () => {\n      this.defered.promise.then(() => {\n        this.contentReady();\n      });\n\n      if (this.isPrintGrid()) {\n        this.hierarchyPrint();\n      }\n    };\n  }\n\n  hierarchyPrint() {\n    this.removeColGroup(this.parent);\n    const printGridObj = window.printGridObj;\n\n    if (printGridObj && !printGridObj.element.querySelector('[aria-busy=true')) {\n      printGridObj.printModule.defered.resolve();\n    }\n  }\n  /**\n   * By default, prints all the Grid pages and hides the pager.\n   * > You can customize print options using the\n   * [`printMode`](grid/#printmode-string/).\n   *\n   * @returns {void}\n   */\n\n\n  print() {\n    this.renderPrintGrid();\n  }\n\n  onEmpty() {\n    if (this.isPrintGrid()) {\n      this.contentReady();\n    }\n  }\n\n  actionBegin() {\n    if (this.isPrintGrid()) {\n      this.isAsyncPrint = true;\n    }\n  }\n\n  renderPrintGrid() {\n    const gObj = this.parent;\n    const element = createElement('div', {\n      id: this.parent.element.id + '_print',\n      className: gObj.element.className + ' e-print-grid'\n    });\n    element.classList.remove('e-gridhover');\n    document.body.appendChild(element);\n    const printGrid = new Grid(getPrintGridModel(gObj, gObj.hierarchyPrintMode));\n\n    for (let i = 0; i < printGrid.columns.length; i++) {\n      printGrid.columns[i] = extend({}, printGrid.columns[i]);\n\n      if (gObj.isFrozenGrid() && !gObj.getFrozenColumns()) {\n        printGrid.columns[i].freeze = undefined;\n      }\n    } // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n\n    if (this.parent.isAngular) {\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      printGrid.viewContainerRef = this.parent.viewContainerRef;\n    } // eslint-disable-next-line @typescript-eslint/no-empty-function\n\n\n    printGrid.load = () => {};\n\n    printGrid.query = gObj.getQuery().clone();\n    window.printGridObj = printGrid;\n    printGrid.isPrinting = true;\n    const modules = printGrid.getInjectedModules();\n    const injectedModues = gObj.getInjectedModules();\n\n    if (!modules || modules.length !== injectedModues.length) {\n      printGrid.setInjectedModules(injectedModues);\n    }\n\n    gObj.notify(printGridInit, {\n      element: element,\n      printgrid: printGrid\n    });\n    this.parent.log('exporting_begin', this.getModuleName());\n    printGrid.registeredTemplate = this.parent.registeredTemplate;\n    printGrid.isVue = this.parent.isVue;\n    printGrid.appendTo(element);\n    printGrid.trigger = gObj.trigger;\n  }\n\n  contentReady() {\n    if (this.isPrintGrid()) {\n      const gObj = this.parent;\n\n      if (this.isAsyncPrint) {\n        this.printGrid();\n        return;\n      }\n\n      const args = {\n        requestType: 'print',\n        element: gObj.element,\n        selectedRows: gObj.getContentTable().querySelectorAll('tr[aria-selected=\"true\"]'),\n        cancel: false,\n        hierarchyPrintMode: gObj.hierarchyPrintMode\n      };\n\n      if (!this.isAsyncPrint) {\n        gObj.trigger(beforePrint, args);\n      }\n\n      if (args.cancel) {\n        detach(gObj.element);\n        return;\n      }\n\n      if (!this.isAsyncPrint) {\n        this.printGrid();\n      }\n    }\n  }\n\n  printGrid() {\n    const gObj = this.parent; // Height adjustment on print grid\n\n    if (gObj.height !== 'auto') {\n      // if scroller enabled\n      const cssProps = this.scrollModule.getCssProperties();\n      const contentDiv = gObj.element.querySelector('.' + content);\n      const headerDiv = gObj.element.querySelector('.' + gridHeader);\n      contentDiv.style.height = 'auto';\n      contentDiv.style.overflowY = 'auto';\n      headerDiv.style[cssProps.padding] = '';\n      headerDiv.firstElementChild.style[cssProps.border] = '';\n    } // Grid alignment adjustment on grouping\n\n\n    if (gObj.allowGrouping) {\n      if (!gObj.groupSettings.columns.length) {\n        gObj.element.querySelector('.e-groupdroparea').style.display = 'none';\n      } else {\n        this.removeColGroup(gObj);\n      }\n    } // hide horizontal scroll\n\n\n    for (const element of [].slice.call(gObj.element.getElementsByClassName(content))) {\n      element.style.overflowX = 'hidden';\n    } // Hide the waiting popup\n\n\n    const waitingPop = [].slice.call(gObj.element.getElementsByClassName('e-spin-show'));\n\n    for (const element of [].slice.call(waitingPop)) {\n      classList(element, ['e-spin-hide'], ['e-spin-show']);\n    }\n\n    this.printGridElement(gObj);\n    gObj.isPrinting = false;\n    delete window.printGridObj;\n    const args = {\n      element: gObj.element\n    };\n    gObj.trigger(printComplete, args);\n    gObj.destroy();\n    this.parent.log('exporting_complete', this.getModuleName());\n  }\n\n  printGridElement(gObj) {\n    classList(gObj.element, ['e-print-grid-layout'], ['e-print-grid']);\n\n    if (gObj.isPrinting) {\n      detach(gObj.element);\n    }\n\n    this.printWind = window.open('', 'print', 'height=' + window.outerHeight + ',width=' + window.outerWidth + ',tabbar=no');\n    this.printWind.moveTo(0, 0);\n    this.printWind.resizeTo(screen.availWidth, screen.availHeight);\n    this.printWind = print(gObj.element, this.printWind);\n  }\n\n  removeColGroup(gObj) {\n    const depth = gObj.groupSettings.columns.length;\n    const element = gObj.element;\n    const id = '#' + gObj.element.id;\n\n    if (!depth) {\n      return;\n    }\n\n    const groupCaption = selectAll(`${id}captioncell.e-groupcaption`, element);\n    const colSpan = groupCaption[depth - 1].getAttribute('colspan');\n\n    for (let i = 0; i < groupCaption.length; i++) {\n      groupCaption[i].setAttribute('colspan', colSpan);\n    }\n\n    const colGroups = selectAll(`colgroup${id}colgroup`, element);\n    const contentColGroups = selectAll('.e-content colgroup', element);\n    this.hideColGroup(colGroups, depth);\n    this.hideColGroup(contentColGroups, depth);\n  }\n\n  hideColGroup(colGroups, depth) {\n    for (let i = 0; i < colGroups.length; i++) {\n      for (let j = 0; j < depth; j++) {\n        colGroups[i].children[j].style.display = 'none';\n      }\n    }\n  }\n  /**\n   * To destroy the print\n   *\n   * @returns {boolean} returns the isPrintGrid or not\n   * @hidden\n   */\n\n\n  isPrintGrid() {\n    return this.parent.element.id.indexOf('_print') > 0 && this.parent.isPrinting;\n  }\n  /**\n   * To destroy the print\n   *\n   * @returns {void}\n   * @hidden\n   */\n\n\n  destroy() {\n    if (this.parent.isDestroyed) {\n      return;\n    }\n\n    this.parent.off(contentReady, this.contentReady.bind(this));\n    this.parent.removeEventListener(actionBegin, this.actionBeginFunction);\n    this.parent.off(onEmpty, this.onEmpty.bind(this));\n    this.parent.off(hierarchyPrint, this.hierarchyPrint);\n  }\n  /**\n   * For internal use only - Get the module name.\n   *\n   * @returns {string} returns the module name\n   * @private\n   */\n\n\n  getModuleName() {\n    return 'print';\n  }\n\n}\n\nPrint.printGridProp = [...getCloneProperties(), beforePrint, printComplete, load]; //https://typescript.codeplex.com/discussions/401501\n\n/**\n * Function to check whether target object implement specific interface\n *\n * @param  {Object} target - specifies the target\n * @param  {string} checkFor - specifies the checkfors\n * @returns {boolean} returns the boolean\n * @hidden\n */\n\nfunction doesImplementInterface(target, checkFor) {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  return target.prototype && checkFor in target.prototype;\n}\n/**\n * Function to get value from provided data\n *\n * @param  {string} field - specifies the field\n * @param  {Object} data - specifies the data\n * @param  {ColumnModel} column - specifies the column\n * @returns {Object} returns the object\n * @hidden\n */\n// eslint-disable-next-line\n\n\nfunction valueAccessor(field, data, column) {\n  return isNullOrUndefined(field) || field === '' ? '' : DataUtil.getObject(field, data);\n}\n/**\n * Defines the method used to apply custom header cell values from external function and display this on each header cell rendered.\n *\n * @param  {string} field - specifies the field\n * @param  {ColumnModel} column - specifies the column\n * @returns {object} headerValueAccessor\n * @hidden\n */\n\n\nfunction headerValueAccessor(field, column) {\n  return isNullOrUndefined(field) || field === '' ? '' : DataUtil.getObject(field, column);\n}\n/**\n * The function used to update Dom using requestAnimationFrame.\n *\n * @param {Function} updateFunction - Function that contains the actual action\n * @param {object} callBack - defines the callback\n * @returns {void}\n * @hidden\n */\n// eslint-disable-next-line\n\n\nfunction getUpdateUsingRaf(updateFunction, callBack) {\n  requestAnimationFrame(() => {\n    try {\n      callBack(null, updateFunction());\n    } catch (e) {\n      callBack(e);\n    }\n  });\n}\n/**\n * @hidden\n * @param {PdfExportProperties | ExcelExportProperties} exportProperties - Defines the export properties\n * @returns {boolean} Returns isExportColumns\n */\n\n\nfunction isExportColumns(exportProperties) {\n  return !isNullOrUndefined(exportProperties) && !isNullOrUndefined(exportProperties.columns) && exportProperties.columns.length > 0;\n}\n/**\n * @param {PdfExportProperties | ExcelExportProperties} exportProperties - Defines the export properties\n * @param {IGrid} gObj - Defines the grid object\n * @returns {void}\n * @hidden\n */\n\n\nfunction updateColumnTypeForExportColumns(exportProperties, gObj) {\n  const exportColumns = exportProperties.columns;\n  const gridColumns = gObj.columns;\n\n  for (let i = 0; i < exportColumns.length; i++) {\n    if (gridColumns.length - 1 >= i) {\n      if (gridColumns[i].columns) {\n        for (let j = 0; j < gridColumns[i].columns.length; j++) {\n          exportColumns[i].columns[j].type = gridColumns[i].columns[j].type;\n        }\n      } else {\n        exportColumns[i].type = gridColumns[i].type;\n      }\n    }\n  }\n}\n/**\n * @hidden\n * @param {IGrid} grid - Defines the grid\n * @returns {void}\n */\n\n\nfunction updatecloneRow(grid) {\n  const nRows = [];\n  const actualRows = grid.vRows;\n\n  for (let i = 0; i < actualRows.length; i++) {\n    if (actualRows[i].isDataRow) {\n      nRows.push(actualRows[i]);\n    } else if (!actualRows[i].isDataRow) {\n      nRows.push(actualRows[i]);\n\n      if (!actualRows[i].isExpand && actualRows[i].isCaptionRow) {\n        i += getCollapsedRowsCount(actualRows[i], grid);\n      }\n    }\n  }\n\n  grid.vcRows = nRows;\n}\n\nlet count = 0;\n/**\n * @hidden\n * @param {Row<Column>} val - Defines the value\n * @param {IGrid} grid - Defines the grid\n * @returns {number} Returns the collapsed row count\n */\n\nfunction getCollapsedRowsCount(val, grid) {\n  count = 0;\n  const gSummary = 'gSummary';\n  const total = 'count';\n  const gLen = grid.groupSettings.columns.length;\n  const records = 'records';\n  const items = 'items';\n  const value = val[gSummary];\n  let dataRowCnt = 0;\n  const agrCnt = 'aggregatesCount';\n\n  if (value === val.data[total]) {\n    if (grid.groupSettings.columns.length && !isNullOrUndefined(val[agrCnt]) && val[agrCnt]) {\n      if (grid.groupSettings.columns.length !== 1) {\n        count += val.indent !== 0 && value < 2 ? val[gSummary] * (gLen - val.indent + (gLen - val.indent) * val[agrCnt]) : val[gSummary] * (gLen - val.indent + (gLen - val.indent - 1) * val[agrCnt]) + val[agrCnt];\n      } else if (grid.groupSettings.columns.length === 1) {\n        count += val[gSummary] * (gLen - val.indent) + val[agrCnt];\n      }\n    } else if (grid.groupSettings.columns.length) {\n      if (grid.groupSettings.columns.length !== 1) {\n        count += val[gSummary] * (grid.groupSettings.columns.length - val.indent);\n      } else {\n        count += val[gSummary];\n      }\n    }\n\n    return count;\n  } else {\n    for (let i = 0, len = val.data[items].length; i < len; i++) {\n      const gLevel = val.data[items][i];\n      count += gLevel[items].length + (gLen !== grid.columns.length && !isNullOrUndefined(gLevel[items][records]) ? gLevel[items][records].length : 0);\n      dataRowCnt += !isNullOrUndefined(gLevel[items][records]) && !isNullOrUndefined(val[agrCnt]) ? gLevel[items][records].length : gLevel[items].length;\n\n      if (gLevel[items].GroupGuid && gLevel[items].childLevels !== 0) {\n        recursive(gLevel);\n      }\n    }\n\n    count += val.data[items].length;\n\n    if (!isNullOrUndefined(val[agrCnt])) {\n      if (val[agrCnt] && count && dataRowCnt !== 0) {\n        count += (count - dataRowCnt) * val[agrCnt] + val[agrCnt];\n      }\n    }\n  }\n\n  return count;\n}\n/**\n * @param {Object[]} row - Defines the row\n * @returns {void}\n * @hidden\n */\n\n\nfunction recursive(row$$1) {\n  const items = 'items';\n  const rCount = 'count';\n\n  for (let j = 0, length = row$$1[items].length; j < length; j++) {\n    const nLevel = row$$1[items][j];\n    count += nLevel[rCount];\n\n    if (nLevel[items].childLevels !== 0) {\n      recursive(nLevel);\n    }\n  }\n}\n/**\n * @param {Object[]} collection - Defines the array\n * @param {Object} predicate - Defines the predicate\n * @returns {Object} Returns the object\n * @hidden\n */\n\n\nfunction iterateArrayOrObject(collection, predicate) {\n  const result = [];\n\n  for (let i = 0, len = collection.length; i < len; i++) {\n    const pred = predicate(collection[i], i);\n\n    if (!isNullOrUndefined(pred)) {\n      result.push(pred);\n    }\n  }\n\n  return result;\n}\n/**\n * @param {Object[]} array - Defines the array\n * @returns {Object} Returns the object\n * @hidden\n */\n\n\nfunction iterateExtend(array) {\n  const obj = [];\n\n  for (let i = 0; i < array.length; i++) {\n    obj.push(extend({}, getActualProperties(array[i]), {}, true));\n  }\n\n  return obj;\n}\n/**\n * @param {string} template - Defines the template\n * @returns {Function} Returns the function\n * @hidden\n */\n\n\nfunction templateCompiler(template) {\n  if (template) {\n    try {\n      if (document.querySelectorAll(template).length) {\n        return compile(document.querySelector(template).innerHTML.trim());\n      }\n    } catch (e) {\n      return compile(template);\n    }\n  }\n\n  return undefined;\n}\n/**\n * @param {Element} node - Defines the column\n * @param {Object} customAttributes - Defines the index\n * @returns {void}\n * @hidden\n */\n\n\nfunction setStyleAndAttributes(node, customAttributes) {\n  const copyAttr = {};\n  const literals = ['style', 'class']; //Dont touch the original object - make a copy\n\n  extend(copyAttr, customAttributes, {});\n\n  if ('style' in copyAttr) {\n    setStyleAttribute(node, copyAttr[literals[0]]);\n    delete copyAttr[literals[0]];\n  }\n\n  if ('class' in copyAttr) {\n    addClass([node], copyAttr[literals[1]]);\n    delete copyAttr[literals[1]];\n  }\n\n  attributes(node, copyAttr);\n}\n/**\n * @param {Object} copied - Defines the column\n * @param {Object} first - Defines the inndex\n * @param {Object} second - Defines the second object\n * @param {string[]} exclude - Defines the exclude\n * @returns {Object} Returns the object\n * @hidden\n */\n\n\nfunction extend$1(copied, first, second, exclude) {\n  const moved = extend(copied, first, second);\n  const values = Object.keys(moved);\n\n  for (let i = 0; i < values.length; i++) {\n    if (exclude && exclude.indexOf(values[i]) !== -1) {\n      delete moved[values[i]];\n    }\n  }\n\n  return moved;\n}\n/**\n * @param {Column[]} columnModel - Defines the column\n * @param {number} ind - Defines the inndex\n * @returns {number} - Returns the columnindex\n * @hidden\n */\n\n\nfunction setColumnIndex(columnModel, ind = 0) {\n  for (let i = 0, len = columnModel.length; i < len; i++) {\n    if (columnModel[i].columns) {\n      columnModel[i].index = isNullOrUndefined(columnModel[i].index) ? ind : columnModel[i].index;\n      ind++;\n      ind = setColumnIndex(columnModel[i].columns, ind);\n    } else {\n      columnModel[i].index = isNullOrUndefined(columnModel[i].index) ? ind : columnModel[i].index;\n      ind++;\n    }\n  }\n\n  return ind;\n}\n/**\n * @param {Column[] | string[] | ColumnModel[]} columns - Defines the column\n * @param {boolean} autoWidth - Defines the autowidth\n * @param {IGrid} gObj - Defines the class name\n * @returns {Column} - Returns the columns\n * @hidden\n */\n\n\nfunction prepareColumns(columns, autoWidth, gObj) {\n  for (let c = 0, len = columns.length; c < len; c++) {\n    let column;\n\n    if (typeof columns[c] === 'string') {\n      column = new Column({\n        field: columns[c]\n      }, gObj);\n    } else if (!(columns[c] instanceof Column) || columns[c].columns) {\n      if (!columns[c].columns) {\n        column = new Column(columns[c], gObj);\n      } else {\n        columns[c].columns = prepareColumns(columns[c].columns, null, gObj);\n        column = new Column(columns[c], gObj);\n      }\n    } else {\n      column = columns[c];\n    }\n\n    if (column.type && column.type.toLowerCase() === 'checkbox') {\n      column.allowReordering = false;\n    }\n\n    column.headerText = isNullOrUndefined(column.headerText) ? column.foreignKeyValue || column.field || '' : column.headerText;\n    column.foreignKeyField = column.foreignKeyField || column.field;\n    column.valueAccessor = (typeof column.valueAccessor === 'string' ? getValue(column.valueAccessor, window) : column.valueAccessor) || valueAccessor;\n    column.width = autoWidth && isNullOrUndefined(column.width) ? 200 : column.width;\n\n    if (isNullOrUndefined(column.visible)) {\n      column.visible = true;\n    }\n\n    columns[c] = column;\n  }\n\n  return columns;\n}\n/**\n * @param {HTMLElement} popUp - Defines the popup element\n * @param {MouseEvent | TouchEvent} e - Defines the moouse event\n * @param {string} className - Defines the class name\n * @returns {void}\n * @hidden\n */\n\n\nfunction setCssInGridPopUp(popUp, e, className) {\n  const popUpSpan = popUp.querySelector('span');\n  const position = popUp.parentElement.getBoundingClientRect();\n  const targetPosition = e.target.getBoundingClientRect();\n  popUpSpan.className = className;\n  popUp.style.display = '';\n  const isBottomTail = (isNullOrUndefined(e.clientY) ? e.changedTouches[0].clientY : e.clientY) > popUp.offsetHeight + 10;\n  popUp.style.top = targetPosition.top - position.top + (isBottomTail ? -(popUp.offsetHeight + 10) : popUp.offsetHeight + 10) + 'px'; //10px for tail element\n\n  popUp.style.left = getPopupLeftPosition(popUp, e, targetPosition, position.left) + 'px';\n\n  if (isBottomTail) {\n    popUp.querySelector('.e-downtail').style.display = '';\n    popUp.querySelector('.e-uptail').style.display = 'none';\n  } else {\n    popUp.querySelector('.e-downtail').style.display = 'none';\n    popUp.querySelector('.e-uptail').style.display = '';\n  }\n}\n/**\n * @param {HTMLElement} popup - Defines the popup element\n * @param {MouseEvent | TouchEvent} e  - Defines the mouse event\n * @param {Object} targetPosition - Defines the target position\n * @param {number} targetPosition.top - Defines the top position\n * @param {number} targetPosition.left  - Defines the left position\n * @param {number} targetPosition.right  - Defines the right position\n * @param {number} left - Defines the left position\n * @returns {number} Returns the popup left position\n * @hidden\n */\n\n\nfunction getPopupLeftPosition(popup, e, targetPosition, left) {\n  const width = popup.offsetWidth / 2;\n  const x = getPosition(e).x;\n\n  if (x - targetPosition.left < width) {\n    return targetPosition.left - left;\n  } else if (targetPosition.right - x < width) {\n    return targetPosition.right - left - width * 2;\n  } else {\n    return x - left - width;\n  }\n}\n/**\n * @param {Object} obj - Defines the object\n * @returns {Object} Returns the Properties\n * @hidden\n */\n\n\nfunction getActualProperties(obj) {\n  if (obj instanceof ChildProperty) {\n    return getValue('properties', obj);\n  } else {\n    return obj;\n  }\n}\n/**\n * @param {Element} elem - Defines the element\n * @param {string} selector - Defines the string selector\n * @param {boolean} isID - Defines the isID\n * @returns {Element} Returns the element\n * @hidden\n */\n\n\nfunction parentsUntil(elem, selector, isID) {\n  let parent = elem;\n\n  while (parent) {\n    if (isID ? parent.id === selector : parent.classList.contains(selector)) {\n      break;\n    }\n\n    parent = parent.parentElement;\n  }\n\n  return parent;\n}\n/**\n * @param {Element} element - Defines the element\n * @param {Element} elements - Defines the element\n * @returns {number} Returns the element index\n * @hidden\n */\n\n\nfunction getElementIndex(element, elements) {\n  let index = -1;\n\n  for (let i = 0, len = elements.length; i < len; i++) {\n    if (elements[i].isEqualNode(element)) {\n      index = i;\n      break;\n    }\n  }\n\n  return index;\n}\n/**\n * @param {Object} value - Defines the value\n * @param {Object} collection - defines the collection\n * @returns {number} Returns the array\n * @hidden\n */\n\n\nfunction inArray(value, collection) {\n  for (let i = 0, len = collection.length; i < len; i++) {\n    if (collection[i] === value) {\n      return i;\n    }\n  }\n\n  return -1;\n}\n/**\n * @param {Object} collection - Defines the collection\n * @returns {Object} Returns the object\n * @hidden\n */\n\n\nfunction getActualPropFromColl(collection) {\n  const coll = [];\n\n  for (let i = 0, len = collection.length; i < len; i++) {\n    // eslint-disable-next-line no-prototype-builtins\n    if (collection[i].hasOwnProperty('properties')) {\n      coll.push(collection[i].properties);\n    } else {\n      coll.push(collection[i]);\n    }\n  }\n\n  return coll;\n}\n/**\n * @param {Element} target - Defines the target element\n * @param {string} selector - Defines the selector\n * @returns {void}\n * @hidden\n */\n\n\nfunction removeElement(target, selector) {\n  const elements = [].slice.call(target.querySelectorAll(selector));\n\n  for (let i = 0; i < elements.length; i++) {\n    remove(elements[i]);\n  }\n}\n/**\n * @param {MouseEvent | TouchEvent} e Defines the mouse event\n * @returns {IPosition} Returns the position\n * @hidden\n */\n\n\nfunction getPosition(e) {\n  const position = {};\n  position.x = isNullOrUndefined(e.clientX) ? e.changedTouches[0].clientX : e.clientX;\n  position.y = isNullOrUndefined(e.clientY) ? e.changedTouches[0].clientY : e.clientY;\n  return position;\n}\n\nlet uid = 0;\n/**\n * @param {string} prefix - Defines the prefix string\n * @returns {string} Returns the uid\n * @hidden\n */\n\nfunction getUid(prefix) {\n  return prefix + uid++;\n}\n/**\n * @param {Element | DocumentFragment} elem - Defines the element\n * @param {Element[] | NodeList} children - Defines the Element\n * @returns {Element} Returns the element\n * @hidden\n */\n\n\nfunction appendChildren(elem, children) {\n  for (let i = 0, len = children.length; i < len; i++) {\n    if (len === children.length) {\n      elem.appendChild(children[i]);\n    } else {\n      elem.appendChild(children[0]);\n    }\n  }\n\n  return elem;\n}\n/**\n * @param {Element} elem - Defines the element\n * @param {string} selector - Defines the selector\n * @param {boolean} isID - Defines isID\n * @returns {Element} Return the element\n * @hidden\n */\n\n\nfunction parents(elem, selector, isID) {\n  let parent = elem;\n  const parents = [];\n\n  while (parent) {\n    if (isID ? parent.id === selector : parent.classList.contains(selector)) {\n      parents.push(parent);\n    }\n\n    parent = parent.parentElement;\n  }\n\n  return parents;\n}\n/**\n * @param {AggregateType | string} type - Defines the type\n * @param {Object} data - Defines the data\n * @param {AggregateColumnModel} column - Defines the column\n * @param {Object} context - Defines the context\n * @returns {Object} Returns the calculated aggragate\n * @hidden\n */\n\n\nfunction calculateAggregate(type, data, column, context) {\n  if (type === 'Custom') {\n    let temp = column.customAggregate;\n\n    if (typeof temp === 'string') {\n      temp = getValue(temp, window);\n    }\n\n    return temp ? temp.call(context, data, column) : '';\n  }\n\n  return column.field in data || data instanceof Array ? DataUtil.aggregates[type.toLowerCase()](data, column.field) : null;\n}\n/** @hidden */\n\n\nlet scrollWidth = null;\n/** @hidden\n * @returns {number} - Returns the scrollbarwidth\n */\n\nfunction getScrollBarWidth() {\n  if (scrollWidth !== null) {\n    return scrollWidth;\n  }\n\n  const divNode = document.createElement('div');\n  let value = 0;\n  divNode.style.cssText = 'width:100px;height: 100px;overflow: scroll;position: absolute;top: -9999px;';\n  document.body.appendChild(divNode);\n  value = divNode.offsetWidth - divNode.clientWidth | 0;\n  document.body.removeChild(divNode);\n  return scrollWidth = value;\n}\n/** @hidden */\n\n\nlet rowHeight;\n/**\n * @param {HTMLElement} element - Defines the element\n * @returns {number} Returns the roww height\n * @hidden\n */\n\nfunction getRowHeight(element) {\n  if (rowHeight !== undefined) {\n    return rowHeight;\n  }\n\n  const table$$1 = createElement('table', {\n    className: table,\n    styles: 'visibility: hidden'\n  });\n  table$$1.innerHTML = '<tr><td class=\"e-rowcell\">A<td></tr>';\n  element.appendChild(table$$1);\n  const rect = table$$1.querySelector('td').getBoundingClientRect();\n  element.removeChild(table$$1);\n  rowHeight = Math.ceil(rect.height);\n  return rowHeight;\n}\n/** @hidden */\n\n\nlet actualRowHeight;\n/**\n * @param {HTMLElement} element - Defines the HTMl element\n * @returns {number} Returns the row height\n * @hidden\n */\n\nfunction getActualRowHeight(element) {\n  if (actualRowHeight !== undefined) {\n    return rowHeight;\n  }\n\n  const table$$1 = createElement('table', {\n    className: table,\n    styles: 'visibility: hidden'\n  });\n  table$$1.innerHTML = '<tr><td class=\"e-rowcell\">A<td></tr>';\n  element.appendChild(table$$1);\n  const rect = table$$1.querySelector('tr').getBoundingClientRect();\n  element.removeChild(table$$1);\n  return rect.height;\n}\n/**\n * @param {string} field - Defines the field\n * @returns {boolean} - Returns is complex field\n * @hidden\n */\n\n\nfunction isComplexField(field) {\n  return field.split('.').length > 1;\n}\n/**\n * @param {string} field - Defines the field\n * @returns {string} - Returns the get complex field ID\n * @hidden\n */\n\n\nfunction getComplexFieldID(field = '') {\n  return field.replace(/\\./g, '___');\n}\n/**\n * @param {string} field - Defines the field\n * @returns {string} - Returns the set complex field ID\n * @hidden\n */\n\n\nfunction setComplexFieldID(field = '') {\n  return field.replace(/___/g, '.');\n}\n/**\n * @param {Column} col - Defines the column\n * @param {string} type - Defines the type\n * @param {Element} elem - Defines th element\n * @returns {boolean} Returns is Editable\n * @hidden\n */\n\n\nfunction isEditable(col, type, elem) {\n  const row$$1 = parentsUntil(elem, row);\n  const isOldRow = !row$$1 ? true : row$$1 && !row$$1.classList.contains('e-insertedrow');\n\n  if (type === 'beginEdit' && isOldRow) {\n    if (col.isIdentity || col.isPrimaryKey || !col.allowEditing) {\n      return false;\n    }\n\n    return true;\n  } else if (type === 'add' && col.isIdentity) {\n    return false;\n  } else {\n    if (isOldRow && !col.allowEditing && !col.isIdentity && !col.isPrimaryKey) {\n      return false;\n    }\n\n    return true;\n  }\n}\n/**\n * @param {IGrid} inst - Defines the IGrid\n * @returns {boolean} Returns is action prevent in boolean\n * @hidden\n */\n\n\nfunction isActionPrevent(inst) {\n  const dlg = select('#' + inst.element.id + 'EditConfirm', inst.element);\n  return inst.editSettings.mode === 'Batch' && selectAll('.e-updatedtd', inst.element).length && inst.editSettings.showConfirmDialog && (dlg ? dlg.classList.contains('e-popup-close') : true);\n}\n/**\n * @param {any} elem - Defines the element\n * @param {boolean} action - Defines the boolean for action\n * @returns {void}\n * @hidden\n */\n// eslint-disable-next-line\n\n\nfunction wrap(elem, action) {\n  const clName = 'e-wrap';\n  elem = elem instanceof Array ? elem : [elem];\n\n  for (let i = 0; i < elem.length; i++) {\n    if (action) {\n      elem[i].classList.add(clName);\n    } else {\n      elem[i].classList.remove(clName);\n    }\n  }\n}\n/**\n * @param {ServiceLocator} serviceLocator - Defines the service locator\n * @param {Column} column  - Defines the column\n * @returns {void}\n * @hidden\n */\n\n\nfunction setFormatter(serviceLocator, column) {\n  const fmtr = serviceLocator.getService('valueFormatter');\n  const format = 'format';\n  let args;\n\n  if (column.type === 'date' || column.type === 'datetime') {\n    args = {\n      type: column.type,\n      skeleton: column.format\n    };\n\n    if (typeof column.format === 'string' && column.format !== 'yMd') {\n      args[format] = column.format;\n    }\n  }\n\n  switch (column.type) {\n    case 'date':\n      column.setFormatter(fmtr.getFormatFunction(args));\n      column.setParser(fmtr.getParserFunction(args));\n      break;\n\n    case 'datetime':\n      column.setFormatter(fmtr.getFormatFunction(args));\n      column.setParser(fmtr.getParserFunction(args));\n      break;\n\n    case 'number':\n      column.setFormatter(fmtr.getFormatFunction({\n        format: column.format\n      }));\n      column.setParser(fmtr.getParserFunction({\n        format: column.format\n      }));\n      break;\n  }\n}\n/**\n * @param {Element} cells - Defines the cell element\n * @param {boolean} add - Defines the add\n * @param {string} args - Defines the args\n * @returns {void}\n * @hidden\n */\n\n\nfunction addRemoveActiveClasses(cells, add, ...args) {\n  for (let i = 0, len = cells.length; i < len; i++) {\n    if (add) {\n      classList(cells[i], [...args], []);\n      cells[i].setAttribute('aria-selected', 'true');\n    } else {\n      classList(cells[i], [], [...args]);\n      cells[i].removeAttribute('aria-selected');\n    }\n  }\n}\n/**\n * @param {string} result - Defines th string\n * @returns {string} Returns the distinct staing values\n * @hidden\n */\n\n\nfunction distinctStringValues(result) {\n  const temp = {};\n  const res = [];\n\n  for (let i = 0; i < result.length; i++) {\n    if (!(result[i] in temp)) {\n      res.push(result[i].toString());\n      temp[result[i]] = 1;\n    }\n  }\n\n  return res;\n}\n/**\n * @param {Element} target - Defines the target\n * @param {Dialog} dialogObj - Defines the dialog\n * @returns {void}\n * @hidden\n */\n\n\nfunction getFilterMenuPostion(target, dialogObj) {\n  const elementVisible = dialogObj.element.style.display;\n  dialogObj.element.style.display = 'block';\n  const dlgWidth = dialogObj.width;\n  const newpos = calculateRelativeBasedPosition(target, dialogObj.element);\n  dialogObj.element.style.display = elementVisible;\n  dialogObj.element.style.top = newpos.top + target.getBoundingClientRect().height - 5 + 'px';\n  const leftPos = newpos.left - dlgWidth + target.clientWidth;\n\n  if (leftPos < 1) {\n    dialogObj.element.style.left = dlgWidth + leftPos - 16 + 'px'; // right calculation\n  } else {\n    dialogObj.element.style.left = leftPos + -4 + 'px';\n  }\n}\n/**\n * @param {Object} args - Defines the args\n * @param {Popup} args.popup - Defines the args for popup\n * @param {Dialog} dialogObj - Defines the dialog obj\n * @returns {void}\n * @hidden\n */\n\n\nfunction getZIndexCalcualtion(args, dialogObj) {\n  args.popup.element.style.zIndex = (dialogObj.zIndex + 1).toString();\n}\n/**\n * @param {Element} elem - Defines the element\n * @returns {void}\n * @hidden\n */\n\n\nfunction toogleCheckbox(elem) {\n  const span = elem.querySelector('.e-frame');\n  const input = span.previousSibling;\n\n  if (span.classList.contains('e-check')) {\n    input.checked = false;\n    classList(span, ['e-uncheck'], ['e-check']);\n  } else {\n    input.checked = true;\n    classList(span, ['e-check'], ['e-uncheck']);\n  }\n}\n/**\n * @param {HTMLInputElement} elem - Defines the element\n * @param {boolean} checked - Defines is checked\n * @returns {void}\n * @hidden\n */\n\n\nfunction setChecked(elem, checked) {\n  elem.checked = checked;\n}\n/**\n * @param {string} uid - Defines the string\n * @param {Element} elem - Defines the Element\n * @param {string} className - Defines the classname\n * @returns {Element} Returns the box wrap\n * @hidden\n */\n\n\nfunction createCboxWithWrap(uid, elem, className) {\n  const div = createElement('div', {\n    className: className\n  });\n  div.appendChild(elem);\n  div.setAttribute('uid', uid);\n  return div;\n}\n/**\n * @param {Element} elem - Defines the element\n * @param {boolean} checked - Defines is checked\n * @returns {void}\n * @hidden\n */\n\n\nfunction removeAddCboxClasses(elem, checked) {\n  removeClass([elem], ['e-check', 'e-stop', 'e-uncheck']);\n\n  if (checked) {\n    elem.classList.add('e-check');\n  } else {\n    elem.classList.add('e-uncheck');\n  }\n}\n/**\n * Refresh the Row model's foreign data.\n *\n * @param {IRow<Column>} row - Grid Row model object.\n * @param {Column[]} columns - Foreign columns array.\n * @param {Object} data - Updated Row data.\n * @returns {void}\n * @hidden\n */\n\n\nfunction refreshForeignData(row$$1, columns, data) {\n  for (let i = 0; i < columns.length; i++) {\n    setValue(columns[i].field, getForeignData(columns[i], data), row$$1.foreignKeyData);\n  }\n\n  const cells = row$$1.cells;\n\n  for (let i = 0; i < cells.length; i++) {\n    if (cells[i].isForeignKey) {\n      setValue('foreignKeyData', getValue(cells[i].column.field, row$$1.foreignKeyData), cells[i]);\n    }\n  }\n}\n/**\n * Get the foreign data for the corresponding cell value.\n *\n * @param {Column} column - Foreign Key column\n * @param {Object} data - Row data.\n * @param {string | number} lValue - cell value.\n * @param {Object} foreignKeyData - foreign data source.\n * @returns {Object} Returns the object\n * @hidden\n */\n\n\nfunction getForeignData(column, data, lValue, foreignKeyData) {\n  const fField = column.foreignKeyField;\n  let key = !isNullOrUndefined(lValue) ? lValue : valueAccessor(column.field, data, column);\n  key = isNullOrUndefined(key) ? '' : key;\n  const query = new Query();\n  const fdata = foreignKeyData || (column.dataSource instanceof DataManager && column.dataSource.dataSource.json.length ? column.dataSource.dataSource.json : column.columnData);\n\n  if (key.getDay) {\n    query.where(getDatePredicate({\n      field: fField,\n      operator: 'equal',\n      value: key,\n      matchCase: false\n    }));\n  } else {\n    query.where(fField, '==', key, false);\n  }\n\n  return new DataManager(fdata).executeLocal(query);\n}\n/**\n * To use to get the column's object by the foreign key value.\n *\n * @param {string} foreignKeyValue - Defines ForeignKeyValue.\n * @param {Column[]} columns - Array of column object.\n * @returns {Column} Returns the element\n * @hidden\n */\n\n\nfunction getColumnByForeignKeyValue(foreignKeyValue, columns) {\n  let column;\n  return columns.some(col => {\n    column = col;\n    return col.foreignKeyValue === foreignKeyValue;\n  }) && column;\n}\n/**\n * @param {PredicateModel} filterObject - Defines the filterObject\n * @param {string} type - Defines the type\n * @returns {Predicate} Returns the Predicate\n * @hidden\n */\n\n\nfunction getDatePredicate(filterObject, type) {\n  let datePredicate;\n  let prevDate;\n  let nextDate;\n  const prevObj = extend({}, getActualProperties(filterObject));\n  const nextObj = extend({}, getActualProperties(filterObject));\n\n  if (isNullOrUndefined(filterObject.value)) {\n    datePredicate = new Predicate(prevObj.field, prevObj.operator, prevObj.value, false);\n    return datePredicate;\n  }\n\n  const value = new Date(filterObject.value);\n\n  if (filterObject.operator === 'equal' || filterObject.operator === 'notequal') {\n    if (type === 'datetime') {\n      prevDate = new Date(value.setSeconds(value.getSeconds() - 1));\n      nextDate = new Date(value.setSeconds(value.getSeconds() + 2));\n      filterObject.value = new Date(value.setSeconds(nextDate.getSeconds() - 1));\n    } else {\n      prevDate = new Date(value.setHours(0) - 1);\n      nextDate = new Date(value.setHours(24));\n    }\n\n    prevObj.value = prevDate;\n    nextObj.value = nextDate;\n\n    if (filterObject.operator === 'equal') {\n      prevObj.operator = 'greaterthan';\n      nextObj.operator = 'lessthan';\n    } else if (filterObject.operator === 'notequal') {\n      prevObj.operator = 'lessthanorequal';\n      nextObj.operator = 'greaterthanorequal';\n    }\n\n    const predicateSt = new Predicate(prevObj.field, prevObj.operator, prevObj.value, false);\n    const predicateEnd = new Predicate(nextObj.field, nextObj.operator, nextObj.value, false);\n    datePredicate = filterObject.operator === 'equal' ? predicateSt.and(predicateEnd) : predicateSt.or(predicateEnd);\n  } else {\n    if (type === 'date' && (filterObject.operator === 'lessthanorequal' || filterObject.operator === 'greaterthan')) {\n      prevObj.value = new Date(value.setHours(24) - 1);\n    }\n\n    if (typeof prevObj.value === 'string') {\n      prevObj.value = new Date(prevObj.value);\n    }\n\n    const predicates = new Predicate(prevObj.field, prevObj.operator, prevObj.value, false);\n    datePredicate = predicates;\n  }\n\n  if (filterObject.setProperties) {\n    filterObject.setProperties({\n      ejpredicate: datePredicate\n    }, true);\n  } else {\n    filterObject.ejpredicate = datePredicate;\n  }\n\n  return datePredicate;\n}\n/**\n * @param {Element} ele - Defines the element\n * @param {number} frzCols - Defines the frozen columns\n * @param {IGrid} gObj - Defines the IGrid\n * @returns {Element} Returns the element\n * @hidden\n */\n\n\nfunction renderMovable(ele, frzCols, gObj) {\n  frzCols = frzCols && gObj && gObj.isRowDragable() ? frzCols + 1 : frzCols;\n  const mEle = ele.cloneNode(true);\n\n  for (let i = 0; i < frzCols; i++) {\n    mEle.removeChild(mEle.children[0]);\n  }\n\n  for (let i = frzCols, len = ele.childElementCount; i < len; i++) {\n    ele.removeChild(ele.children[ele.childElementCount - 1]);\n  }\n\n  return mEle;\n}\n/**\n * @param {IGrid} grid - Defines the IGrid\n * @returns {boolean} Returns true if group adaptive is true\n * @hidden\n */\n\n\nfunction isGroupAdaptive(grid) {\n  return grid.enableVirtualization && grid.groupSettings.columns.length > 0 && grid.isVirtualAdaptive;\n}\n/**\n * @param {string} field - Defines the Field\n * @param {Object} object - Defines the objec\n * @returns {any} Returns the object\n * @hidden\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n\nfunction getObject(field = '', object) {\n  if (field) {\n    let value = object;\n    const splits = field.split('.');\n\n    for (let i = 0; i < splits.length && !isNullOrUndefined(value); i++) {\n      value = value[splits[i]];\n    }\n\n    return value;\n  }\n}\n/**\n * @param {string | Object} format - defines the format\n * @param {string} colType - Defines the coltype\n * @returns {string} Returns the custom Data format\n * @hidden\n */\n\n\nfunction getCustomDateFormat(format, colType) {\n  const intl = new Internationalization();\n  let formatvalue;\n  const formatter = 'format';\n  const type = 'type';\n\n  if (colType === 'date') {\n    formatvalue = typeof format === 'object' ? intl.getDatePattern({\n      type: format[type] ? format[type] : 'date',\n      format: format[formatter]\n    }, false) : intl.getDatePattern({\n      type: 'dateTime',\n      skeleton: format\n    }, false);\n  } else {\n    formatvalue = typeof format === 'object' ? intl.getDatePattern({\n      type: format[type] ? format[type] : 'dateTime',\n      format: format[formatter]\n    }, false) : intl.getDatePattern({\n      type: 'dateTime',\n      skeleton: format\n    }, false);\n  }\n\n  return formatvalue;\n}\n/**\n * @param {IGrid} gObj - Defines the IGrid\n * @param {HierarchyGridPrintMode} hierarchyPrintMode - Defines the hierarchyPrintMode\n * @returns {Object} Returns the object\n * @hidden\n */\n\n\nfunction getExpandedState(gObj, hierarchyPrintMode) {\n  const rows = gObj.getRowsObject();\n  const obj = {};\n\n  for (const row$$1 of rows) {\n    if (row$$1.isExpand && !row$$1.isDetailRow) {\n      const index = gObj.allowPaging && gObj.printMode === 'AllPages' ? row$$1.index + gObj.pageSettings.currentPage * gObj.pageSettings.pageSize - gObj.pageSettings.pageSize : row$$1.index;\n      obj[index] = {};\n      obj[index].isExpand = true;\n      obj[index].gridModel = getPrintGridModel(row$$1.childGrid, hierarchyPrintMode);\n      obj[index].gridModel.query = gObj.childGrid.query;\n    }\n  }\n\n  return obj;\n}\n/**\n * @param {IGrid} gObj - Defines the grid objct\n * @param {HierarchyGridPrintMode} hierarchyPrintMode - Defines the hierarchyPrintMode\n * @returns {IGrid} Returns the IGrid\n * @hidden\n */\n\n\nfunction getPrintGridModel(gObj, hierarchyPrintMode = 'Expanded') {\n  const printGridModel = {};\n\n  if (!gObj) {\n    return printGridModel;\n  }\n\n  const isFrozen = gObj.isFrozenGrid() && !gObj.getFrozenColumns();\n\n  for (const key of Print.printGridProp) {\n    if (key === 'columns') {\n      printGridModel[key] = getActualPropFromColl(isFrozen ? gObj.getColumns() : gObj[key]);\n    } else if (key === 'allowPaging') {\n      printGridModel[key] = gObj.printMode === 'CurrentPage';\n    } else {\n      printGridModel[key] = getActualProperties(gObj[key]);\n    }\n  }\n\n  printGridModel['enableHover'] = false;\n\n  if (gObj.childGrid && hierarchyPrintMode !== 'None') {\n    printGridModel.expandedRows = getExpandedState(gObj, hierarchyPrintMode);\n  }\n\n  return printGridModel;\n}\n/**\n * @param {Object} copied - Defines the copied object\n * @param {Object} first - Defines the first object\n * @param {Object} second - Defines the second object\n * @param {boolean} deep - Defines the deep\n * @returns {Object} Returns the extended object\n * @hidden\n */\n\n\nfunction extendObjWithFn(copied, first, second, deep) {\n  const res = copied || {};\n  let len = arguments.length;\n\n  if (deep) {\n    len = len - 1;\n  }\n\n  for (let i = 1; i < len; i++) {\n    // eslint-disable-next-line prefer-rest-params\n    if (!arguments[i]) {\n      continue;\n    } // eslint-disable-next-line prefer-rest-params\n\n\n    const obj1 = arguments[i];\n    const keys = Object.keys(Object.getPrototypeOf(obj1)).length ? Object.keys(obj1).concat(getPrototypesOfObj(obj1)) : Object.keys(obj1);\n\n    for (let i = 0; i < keys.length; i++) {\n      const source = res[keys[i]];\n      const cpy = obj1[keys[i]];\n      let cln;\n\n      if (deep && (isObject(cpy) || Array.isArray(cpy))) {\n        if (isObject(cpy)) {\n          cln = source ? source : {};\n          res[keys[i]] = extend({}, cln, cpy, deep);\n        } else {\n          cln = source ? source : [];\n          res[keys[i]] = extend([], cln, cpy, deep);\n        }\n      } else {\n        res[keys[i]] = cpy;\n      }\n    }\n  }\n\n  return res;\n}\n/**\n * @param {Object} obj - Defines the obj\n * @returns {string[]} Returns the string\n * @hidden\n */\n\n\nfunction getPrototypesOfObj(obj) {\n  let keys = [];\n\n  while (Object.getPrototypeOf(obj) && Object.keys(Object.getPrototypeOf(obj)).length) {\n    keys = keys.concat(Object.keys(Object.getPrototypeOf(obj)));\n    obj = Object.getPrototypeOf(obj);\n  }\n\n  return keys;\n}\n/**\n * @param {Column[]} column - Defines the Column\n * @returns {number} Returns the column Depth\n * @hidden\n */\n\n\nfunction measureColumnDepth(column) {\n  let max = 0;\n\n  for (let i = 0; i < column.length; i++) {\n    const depth = checkDepth(column[i], 0);\n\n    if (max < depth) {\n      max = depth;\n    }\n  }\n\n  return max + 1;\n}\n/**\n * @param {Column} col - Defines the Column\n * @param {number} index - Defines the index\n * @returns {number} Returns the depth\n * @hidden\n */\n\n\nfunction checkDepth(col, index) {\n  let max = index;\n  const indices = [];\n\n  if (col.columns) {\n    index++;\n\n    for (let i = 0; i < col.columns.length; i++) {\n      indices[i] = checkDepth(col.columns[i], index);\n    }\n\n    for (let j = 0; j < indices.length; j++) {\n      if (max < indices[j]) {\n        max = indices[j];\n      }\n    }\n\n    index = max;\n  }\n\n  return index;\n}\n/**\n * @param {IGrid} gObj - Defines the IGrid\n * @param {PredicateModel[]} filteredCols - Defines the PredicateModel\n * @returns {void}\n * @hidden\n */\n\n\nfunction refreshFilteredColsUid(gObj, filteredCols) {\n  for (let i = 0; i < filteredCols.length; i++) {\n    filteredCols[i].uid = filteredCols[i].isForeignKey ? getColumnByForeignKeyValue(filteredCols[i].field, gObj.getForeignKeyColumns()).uid : gObj.enableColumnVirtualization ? getColumnModelByFieldName(gObj, filteredCols[i].field).uid : gObj.getColumnByField(filteredCols[i].field).uid;\n  }\n}\n/** @hidden */\n// eslint-disable-next-line @typescript-eslint/no-namespace\n\n\nvar Global = /*#__PURE__*/(() => {\n  (function (Global) {\n    // eslint-disable-next-line prefer-const\n    Global.timer = null;\n  })(Global || (Global = {}));\n\n  return Global;\n})();\n\n/**\n * @param {Element} element - Defines the element\n * @returns {Object} Returns the transform values\n * @hidden\n */\nfunction getTransformValues(element) {\n  const style = document.defaultView.getComputedStyle(element, null);\n  const transformV = style.getPropertyValue('transform');\n  const replacedTv = transformV.replace(/,/g, '');\n  const translateX = parseFloat(replacedTv.split(' ')[4]);\n  const translateY = parseFloat(replacedTv.split(' ')[5]);\n  return {\n    width: translateX,\n    height: translateY\n  };\n}\n/**\n * @param {Element} rootElement - Defines the root Element\n * @param {Element} element - Defines the element\n * @returns {void}\n * @hidden\n */\n\n\nfunction applyBiggerTheme(rootElement, element) {\n  if (rootElement.classList.contains('e-bigger')) {\n    element.classList.add('e-bigger');\n  }\n}\n/**\n * @param {HTMLElement} mTD - Defines the movable TD\n * @param {HTMLElement} fTD  - Defines the Frozen TD\n * @returns {void}\n * @hidden\n */\n\n\nfunction alignFrozenEditForm(mTD, fTD) {\n  if (mTD && fTD) {\n    const mHeight = closest(mTD, '.' + row).getBoundingClientRect().height;\n    const fHeight = closest(fTD, '.' + row).getBoundingClientRect().height;\n\n    if (mHeight > fHeight) {\n      fTD.style.height = mHeight + 'px';\n    } else {\n      mTD.style.height = fHeight + 'px';\n    }\n  }\n}\n/**\n * @param {Element} row - Defines row element\n * @param {IGrid} gridObj - Defines grid object\n * @returns {boolean} Returns isRowEnteredInGrid\n * @hidden\n */\n\n\nfunction ensureLastRow(row$$1, gridObj) {\n  const cntOffset = gridObj.getContent().firstElementChild.offsetHeight;\n  return row$$1 && row$$1.getBoundingClientRect().top > cntOffset;\n}\n/**\n * @param {Element} row - Defines row element\n * @param {number} rowTop - Defines row top number\n * @returns {boolean} Returns first row is true\n * @hidden\n */\n\n\nfunction ensureFirstRow(row$$1, rowTop) {\n  return row$$1 && row$$1.getBoundingClientRect().top < rowTop;\n}\n/**\n * @param {number} index - Defines index\n * @param {IGrid} gObj - Defines grid object\n * @returns {boolean} Returns isRowEnteredInGrid\n * @hidden\n */\n\n\nfunction isRowEnteredInGrid(index, gObj) {\n  const rowHeight = gObj.getRowHeight();\n  const startIndex = gObj.getContent().firstElementChild.scrollTop / rowHeight;\n  const endIndex = startIndex + gObj.getContent().firstElementChild.offsetHeight / rowHeight;\n  return index < endIndex && index > startIndex;\n}\n/**\n * @param {IGrid} gObj - Defines the grid object\n * @param {Object} data - Defines the query\n * @returns {number} Returns the edited data index\n * @hidden\n */\n\n\nfunction getEditedDataIndex(gObj, data) {\n  const keyField = gObj.getPrimaryKeyFieldNames()[0];\n  let dataIndex;\n  gObj.getCurrentViewRecords().filter((e, index) => {\n    if (e[keyField] === data[keyField]) {\n      dataIndex = index;\n    }\n  });\n  return dataIndex;\n}\n/**\n * @param {Object} args - Defines the argument\n * @param {Query} query - Defines the query\n * @returns {FilterStateObj} Returns the filter state object\n * @hidden\n */\n\n\nfunction eventPromise(args, query) {\n  const state = getStateEventArgument(query);\n  const def = new Deferred();\n  state.dataSource = def.resolve;\n  state.action = args;\n  return {\n    state: state,\n    deffered: def\n  };\n}\n/**\n * @param {Query} query - Defines the query\n * @returns {Object} Returns the state event argument\n * @hidden\n */\n\n\nfunction getStateEventArgument(query) {\n  const adaptr = new UrlAdaptor();\n  const dm = new DataManager({\n    url: '',\n    adaptor: new UrlAdaptor()\n  });\n  const state = adaptr.processQuery(dm, query);\n  const data = JSON.parse(state.data);\n  return data;\n}\n/**\n * @param {IGrid} gObj - Defines the Igrid\n * @returns {boolean} Returns the ispercentageWidth\n * @hidden\n */\n\n\nfunction ispercentageWidth(gObj) {\n  const columns = gObj.getVisibleColumns();\n  let percentageCol = 0;\n  let undefinedWidthCol = 0;\n\n  for (let i = 0; i < columns.length; i++) {\n    if (isUndefined(columns[i].width)) {\n      undefinedWidthCol++;\n    } else if (columns[i].width.toString().indexOf('%') !== -1) {\n      percentageCol++;\n    }\n  }\n\n  return (gObj.width === 'auto' || typeof gObj.width === 'string' && gObj.width.indexOf('%') !== -1) && !gObj.groupSettings.showGroupedColumn && gObj.groupSettings.columns.length && percentageCol && !undefinedWidthCol;\n}\n/**\n * @param {IGrid} gObj - Defines the IGrid\n * @param {Row<Column>[]} rows - Defines the row\n * @param {HTMLTableRowElement[]} rowElms - Row elements\n * @param {number} index - Row index\n * @returns {void}\n * @hidden\n */\n\n\nfunction resetRowIndex(gObj, rows, rowElms, index) {\n  let startIndex = index ? index : 0;\n\n  for (let i = 0; i < rows.length; i++) {\n    if (rows[i].isDataRow) {\n      rows[i].index = startIndex;\n      rows[i].isAltRow = gObj.enableAltRow ? startIndex % 2 !== 0 : false;\n      rowElms[i].setAttribute(ariaRowIndex, startIndex.toString());\n\n      if (rows[i].isAltRow) {\n        rowElms[i].classList.add('e-altrow');\n      } else {\n        rowElms[i].classList.remove('e-altrow');\n      }\n\n      for (let j = 0; j < rowElms[i].cells.length; j++) {\n        rowElms[i].cells[j].setAttribute('index', startIndex.toString());\n      }\n\n      startIndex++;\n    }\n  }\n\n  if (!rows.length) {\n    gObj.renderModule.emptyRow(true);\n  }\n}\n/**\n * @param {IGrid} gObj - Defines the grid object\n * @param {Object} changes - Defines the changes\n * @param {string} type - Defines the type\n * @param {string} keyField - Defines the keyfield\n * @returns {void}\n * @hidden\n */\n\n\nfunction compareChanges(gObj, changes, type, keyField) {\n  const newArray = gObj.dataToBeUpdated[type].concat(changes[type]).reduce((r, o) => {\n    r[o[keyField]] = r[o[keyField]] === undefined ? o : Object.assign(r[o[keyField]], o);\n    return r;\n  }, {});\n  gObj.dataToBeUpdated[type] = Object.keys(newArray).map(k => newArray[k]);\n}\n/**\n * @param {IGrid} gObj - Defines the grid object\n * @returns {void}\n * @hidden\n */\n\n\nfunction setRowElements(gObj) {\n  if (gObj.isFrozenGrid()) {\n    gObj.contentModule.rowElements = [].slice.call(gObj.element.querySelectorAll('.e-movableheader .e-row, .e-movablecontent .e-row'));\n    const cls = gObj.getFrozenMode() === leftRight ? '.e-frozen-left-header .e-row, .e-frozen-left-content .e-row' : '.e-frozenheader .e-row, .e-frozencontent .e-row';\n    gObj.contentModule.freezeRowElements = [].slice.call(gObj.element.querySelectorAll(cls));\n\n    if (gObj.getFrozenMode() === leftRight) {\n      gObj.contentModule.frozenRightRowElements = [].slice.call(gObj.element.querySelectorAll('.e-frozen-right-header .e-row, .e-frozen-right-content .e-row'));\n    }\n  } else {\n    gObj.contentModule.rowElements = [].slice.call(gObj.element.querySelectorAll('.e-row:not(.e-addedrow)'));\n  }\n}\n/**\n * @param {IGrid} gObj - Defines the grid object\n * @param {Cell<Column>} cells - Defines the callback function\n * @param {freezeTable} tableName - Defines the row\n * @returns {Cell<Column>[]} Returns the cell\n * @hidden\n */\n\n\nfunction splitFrozenRowObjectCells(gObj, cells, tableName) {\n  const left = gObj.getFrozenLeftCount();\n  const movable = gObj.getMovableColumnsCount();\n  const right = gObj.getFrozenRightColumnsCount();\n  const frozenMode = gObj.getFrozenMode();\n  const drag = gObj.isRowDragable() ? 1 : 0;\n  const rightIndex = frozenMode === 'Right' ? left + movable : left + movable + drag;\n  const mvblIndex = frozenMode === 'Right' ? left : left + drag;\n  const mvblEndIdx = frozenMode === 'Right' ? cells.length - right - drag : right ? cells.length - right : cells.length;\n\n  if (tableName === frozenLeft) {\n    cells = cells.slice(0, left ? left + drag : cells.length);\n  } else if (tableName === frozenRight) {\n    cells = cells.slice(rightIndex, cells.length);\n  } else if (tableName === 'movable') {\n    cells = cells.slice(mvblIndex, mvblEndIdx);\n  }\n\n  return cells;\n} // eslint-disable-next-line\n\n/** @hidden */\n\n\nfunction gridActionHandler(gObj, callBack, rows, force, rowObj) {\n  if (rows[0].length || force) {\n    if (rowObj) {\n      callBack(frozenLeft, rows[0], rowObj[0]);\n    } else {\n      callBack(frozenLeft, rows[0]);\n    }\n  }\n\n  if (gObj.isFrozenGrid() && (rows[1].length || force)) {\n    if (rowObj) {\n      callBack('movable', rows[1], rowObj[1]);\n    } else {\n      callBack('movable', rows[1]);\n    }\n  }\n\n  if ((gObj.getFrozenMode() === leftRight || gObj.getFrozenMode() === 'Right') && (rows[2].length || force)) {\n    if (rowObj) {\n      callBack(frozenRight, rows[2], rowObj[2]);\n    } else {\n      callBack(frozenRight, rows[2]);\n    }\n  }\n}\n/**\n * @param {IGrid} gObj - Defines the grid\n * @returns {Row<Column>} Returns the row\n * @hidden\n */\n\n\nfunction getGridRowObjects(gObj) {\n  return [gObj.getFrozenMode() !== 'Right' ? gObj.getRowsObject() : [], gObj.getMovableRowsObject(), gObj.getFrozenRightRowsObject()];\n}\n/**\n * @param {IGrid} gObj - Defines the grid\n * @returns {Element} Returns the element\n * @hidden\n */\n\n\nfunction getGridRowElements(gObj) {\n  return [gObj.getFrozenMode() !== 'Right' ? gObj.getAllDataRows(true) : [], gObj.getAllMovableDataRows(true), gObj.getAllFrozenRightDataRows(true)];\n}\n/**\n * @param {Element} row - Defines the row\n * @param {number} start - Defines the start index\n * @param {number} end - Defines the end index\n * @returns {void}\n * @hidden\n */\n\n\nfunction sliceElements(row$$1, start, end) {\n  const cells = row$$1.children;\n  const len = cells.length;\n  let k = 0;\n\n  for (let i = 0; i < len; i++, k++) {\n    if (i >= start && i < end) {\n      continue;\n    }\n\n    row$$1.removeChild(row$$1.children[k]);\n    k--;\n  }\n}\n/**\n * @param {IGrid} gObj - Defines the grid Object\n * @param {Column} col - Defines the column\n * @param {number} rowIndex - Defines the rowindex\n * @returns {Element} Returns the element\n * @hidden\n */\n\n\nfunction getCellsByTableName(gObj, col, rowIndex) {\n  if (col.getFreezeTableName() === 'movable') {\n    return [].slice.call(gObj.getMovableDataRows()[rowIndex].getElementsByClassName(rowCell));\n  } else if (col.getFreezeTableName() === frozenRight) {\n    return [].slice.call(gObj.getFrozenRightDataRows()[rowIndex].getElementsByClassName(rowCell));\n  } else {\n    return [].slice.call(gObj.getDataRows()[rowIndex].getElementsByClassName(rowCell));\n  }\n}\n/**\n * @param {IGrid} gObj - Defines the column\n * @param {Column} col - Defines the index\n * @param {number} rowIndex - Defines the rules\n * @param {number} index - Defines the movable column rules\n * @returns {Element} Returns the Element\n * @hidden\n */\n\n\nfunction getCellByColAndRowIndex(gObj, col, rowIndex, index) {\n  const left = gObj.getFrozenLeftCount();\n  const movable = gObj.getMovableColumnsCount();\n  index = col.getFreezeTableName() === 'movable' ? index - left : col.getFreezeTableName() === frozenRight ? index - (left + movable) : index;\n  return getCellsByTableName(gObj, col, rowIndex)[index];\n}\n/**\n * @param {Column} col - Defines the column\n * @param {number} index - Defines the index\n * @param {Object} rules - Defines the rules\n * @param {Object} mRules - Defines the movable column rules\n * @param {Object} frRules - Defines the Frozen rules\n * @param {number} len - Defines the length\n * @param {boolean} isCustom - Defines custom form validation\n * @returns {void}\n * @hidden\n */\n\n\nfunction setValidationRuels(col, index, rules, mRules, frRules, len, isCustom) {\n  if (isCustom) {\n    rules[getComplexFieldID(col.field)] = col.validationRules;\n  } else {\n    if (col.getFreezeTableName() === frozenLeft || !index && col.getFreezeTableName() === frozenRight || len === 1) {\n      rules[getComplexFieldID(col.field)] = col.validationRules;\n    } else if (col.getFreezeTableName() === 'movable' || !col.getFreezeTableName()) {\n      mRules[getComplexFieldID(col.field)] = col.validationRules;\n    } else if (col.getFreezeTableName() === frozenRight) {\n      frRules[getComplexFieldID(col.field)] = col.validationRules;\n    }\n  }\n}\n/**\n * @param {IGrid} gObj - Defines the grid object\n * @returns {Element} Returns the Element\n * @hidden\n */\n\n\nfunction getMovableTbody(gObj) {\n  let tbody$$1;\n\n  if (gObj.isFrozenGrid()) {\n    tbody$$1 = gObj.frozenRows && gObj.editSettings.newRowPosition === 'Top' ? gObj.getMovableHeaderTbody() : gObj.getMovableContentTbody();\n  }\n\n  return tbody$$1;\n}\n/**\n * @param {IGrid} gObj - Defines the grid object\n * @returns {Element} Returns the Element\n * @hidden\n */\n\n\nfunction getFrozenRightTbody(gObj) {\n  let tbody$$1;\n\n  if (gObj.getFrozenMode() === leftRight) {\n    tbody$$1 = gObj.frozenRows && gObj.editSettings.newRowPosition === 'Top' ? gObj.getFrozenRightHeaderTbody() : gObj.getFrozenRightContentTbody();\n  }\n\n  return tbody$$1;\n}\n/**\n * @param {Element} tbody - Table body\n * @param {Element} mTbody - Movanle table body\n * @param {Element} frTbody - Frozen right table body\n * @param {Element[]} tr - Table rows\n * @param {Element[]} mTr - Movable table rows\n * @param {Element[]} frTr - Frozen right table rows\n * @param {Function} callBack - Callback function\n * @returns {void}\n * @hidden\n */\n\n\nfunction setRowsInTbody(tbody$$1, mTbody, frTbody, tr, mTr, frTr, callBack) {\n  if (tbody$$1 && tr) {\n    callBack(tbody$$1, tr);\n  }\n\n  if (mTbody && mTr) {\n    callBack(mTbody, mTr);\n  }\n\n  if (frTbody && frTr) {\n    callBack(frTbody, frTr);\n  }\n}\n/**\n * @param {string} numberFormat - Format\n * @param {string} type - Value type\n * @param {boolean} isExcel - Boolean property\n * @returns {string} returns formated value\n * @hidden\n */\n\n\nfunction getNumberFormat(numberFormat, type, isExcel) {\n  let format;\n  const intl = new Internationalization();\n\n  if (type === 'number') {\n    try {\n      format = intl.getNumberPattern({\n        format: numberFormat,\n        currency: this.currency,\n        useGrouping: true\n      }, true);\n    } catch (error) {\n      format = numberFormat;\n    }\n  } else if (type === 'date' || type === 'time' || type === 'datetime') {\n    try {\n      format = intl.getDatePattern({\n        skeleton: numberFormat,\n        type: type\n      }, isExcel);\n\n      if (isNullOrUndefined(format)) {\n        // eslint-disable-next-line\n        throw 'error';\n      }\n    } catch (error) {\n      try {\n        format = intl.getDatePattern({\n          format: numberFormat,\n          type: type\n        }, isExcel);\n      } catch (error) {\n        format = numberFormat;\n      }\n    }\n  } else {\n    format = numberFormat;\n  }\n\n  if (type !== 'number') {\n    const patternRegex = /G|H|c|'| a|yy|y|EEEE|E/g;\n    const mtch = {\n      'G': '',\n      'H': 'h',\n      'c': 'd',\n      '\\'': '\"',\n      ' a': ' AM/PM',\n      'yy': 'yy',\n      'y': 'yyyy',\n      'EEEE': 'dddd',\n      'E': 'ddd'\n    };\n    format = format.replace(patternRegex, pattern => {\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      return mtch[pattern];\n    });\n  }\n\n  return format;\n}\n/**\n * @param {IGrid} gObj - Grid instance\n * @returns {void}\n * @hidden\n */\n\n\nfunction addBiggerDialog(gObj) {\n  if (gObj.enableAdaptiveUI) {\n    const dialogs = document.getElementsByClassName('e-responsive-dialog');\n\n    for (let i = 0; i < dialogs.length; i++) {\n      dialogs[i].classList.add('e-bigger');\n    }\n  }\n}\n/**\n * @param {string} value - specifies the trr\n * @param {Object} mapObject - specifies the idx\n * @returns {Object | string} returns object or string\n * @hidden\n */\n\n\nfunction performComplexDataOperation(value, mapObject) {\n  let returnObj;\n  const length = value.split('.').length;\n  const splits = value.split('.');\n  let duplicateMap = mapObject;\n\n  for (let i = 0; i < length; i++) {\n    returnObj = duplicateMap[splits[i]];\n    duplicateMap = returnObj;\n  }\n\n  return returnObj;\n}\n/**\n * @param {Object} tr - specifies the trr\n * @param {number} idx - specifies the idx\n * @param {string} displayVal - specifies the displayval\n * @param {Row<Column>} rows - specifies the rows\n * @param {IGrid} parent - Grid instance\n * @param {boolean} isContent - check for content renderer\n * @returns {void}\n * @hidden\n */\n\n\nfunction setDisplayValue(tr, idx, displayVal, rows, parent, isContent) {\n  const trs = Object.keys(tr);\n\n  for (let i = 0; i < trs.length; i++) {\n    const td = tr[trs[i]].querySelectorAll('td.e-rowcell')[idx];\n\n    if (tr[trs[i]].querySelectorAll('td.e-rowcell').length && td) {\n      setStyleAttribute(tr[trs[i]].querySelectorAll('td.e-rowcell')[idx], {\n        'display': displayVal\n      });\n\n      if (tr[trs[i]].querySelectorAll('td.e-rowcell')[idx].classList.contains('e-hide')) {\n        removeClass([tr[trs[i]].querySelectorAll('td.e-rowcell')[idx]], ['e-hide']);\n      }\n\n      if (isContent && parent.isRowDragable()) {\n        const index = parent.getFrozenColumns() ? idx : idx + 1;\n        rows[trs[i]].cells[index].visible = displayVal === '' ? true : false;\n      } else {\n        rows[trs[i]].cells[idx].visible = displayVal === '' ? true : false;\n      }\n    }\n  }\n} // eslint-disable-next-line\n\n/** @hidden */\n\n\nfunction addRemoveEventListener(parent, evt, isOn, module) {\n  for (const inst of evt) {\n    if (isOn) {\n      parent.on(inst.event, inst.handler, module);\n    } else {\n      parent.off(inst.event, inst.handler);\n    }\n  }\n} // eslint-disable-next-line\n\n/** @hidden */\n\n\nfunction createEditElement(parent, column, classNames, attr) {\n  const complexFieldName = getComplexFieldID(column.field);\n  attr = Object.assign(attr, {\n    id: parent.element.id + complexFieldName,\n    name: complexFieldName,\n    'e-mappinguid': column.uid\n  });\n  return parent.createElement('input', {\n    className: classNames,\n    attrs: attr\n  });\n}\n/**\n * @param {IGrid} gObj - Grid instance\n * @param {string} uid - Defines column's uid\n * @returns {Column} returns column model\n * @hidden\n */\n\n\nfunction getColumnModelByUid(gObj, uid) {\n  let column;\n\n  for (const col of gObj.columnModel) {\n    if (col.uid === uid) {\n      column = col;\n      break;\n    }\n  }\n\n  return column;\n}\n/**\n * @param {IGrid} gObj - Grid instance\n * @param {string} field - Defines column's uid\n * @returns {Column} returns column model\n * @hidden\n */\n\n\nfunction getColumnModelByFieldName(gObj, field) {\n  let column;\n\n  if (!gObj.columnModel) {\n    gObj.getColumns();\n  }\n\n  for (const col of gObj.columnModel) {\n    if (col.field === field) {\n      column = col;\n      break;\n    }\n  }\n\n  return column;\n}\n/**\n * @param {string} id - Defines component id\n * @param {string[]} evts - Defines events\n * @param {object} handlers - Defines event handlers\n * @param {any} instance - Defines class instance\n * @returns {void}\n * @hidden\n */\n// eslint-disable-next-line\n\n\nfunction registerEventHandlers(id, evts, handlers, instance) {\n  instance.eventHandlers[id] = {};\n\n  for (let i = 0; i < evts.length; i++) {\n    instance.eventHandlers[id][evts[i]] = handlers[evts[i]];\n  }\n}\n/**\n * @param {any} component - Defines component instance\n * @param {string[]} evts - Defines events\n * @param {any} instance - Defines class instance\n * @returns {void}\n * @hidden\n */\n// eslint-disable-next-line\n\n\nfunction removeEventHandlers(component, evts, instance) {\n  for (let i = 0; i < evts.length; i++) {\n    if (component.isDestroyed) {\n      break;\n    }\n\n    component.removeEventListener(evts[i], instance.eventHandlers[component.element.id][evts[i]]);\n  }\n}\n/**\n * @param {IGrid | IXLFilter} parent - Defines parent instance\n * @param {string[]} templates - Defines the templates name which are needs to clear\n * @returns {void}\n * @hidden\n */\n\n\nfunction clearReactVueTemplates(parent, templates) {\n  parent.destroyTemplate(templates);\n\n  if (parent.isReact) {\n    parent.renderTemplates();\n  }\n}\n/**\n *\n * @param { Element } row - Defines row element\n * @returns { number } row index\n */\n\n\nfunction getRowIndexFromElement(row$$1) {\n  return parseInt(row$$1.getAttribute(ariaRowIndex), 10);\n}\n/**\n *\n * @param { string[] } fields - Defines grouped fields\n * @param { values } values - Defines caption keys\n * @param { any } instance - Defines dynamic class instance\n * @returns { Predicate } returns filter predicate\n */\n// eslint-disable-next-line\n\n\nfunction generateExpandPredicates(fields, values, instance) {\n  let filterCols = [];\n\n  for (let i = 0; i < fields.length; i++) {\n    const column = instance.parent.getColumnByField(fields[i]);\n    const value = values[i] === 'null' ? null : values[i];\n    const pred = {\n      field: fields[i],\n      predicate: 'or',\n      uid: column.uid,\n      operator: 'equal',\n      type: column.type,\n      matchCase: instance.allowCaseSensitive,\n      ignoreAccent: instance.parent.filterSettings.ignoreAccent\n    };\n\n    if (value === '' || isNullOrUndefined(value)) {\n      filterCols = filterCols.concat(CheckBoxFilterBase.generateNullValuePredicates(pred));\n    } else {\n      filterCols.push(extend$1({}, {\n        value: value\n      }, pred));\n    }\n  }\n\n  return CheckBoxFilterBase.getPredicate(filterCols);\n}\n/**\n *\n * @param { Predicate } pred - Defines filter predicate\n * @returns { Predicate[] } Returns formed predicate\n */\n\n\nfunction getPredicates(pred) {\n  const predicateList = [];\n\n  for (const prop of Object.keys(pred)) {\n    predicateList.push(pred[prop]);\n  }\n\n  return predicateList;\n}\n/**\n *\n * @param { number } index - Defines group caption indent\n * @param { Row<Column>[] } rowsObject - Defines rows object\n * @returns { { fields: string[], keys: string[] } } Returns grouped keys and values\n */\n\n\nfunction getGroupKeysAndFields(index, rowsObject) {\n  const fields = [];\n  const keys = [];\n\n  for (let i = index; i >= 0; i--) {\n    if (rowsObject[i].isCaptionRow && fields.indexOf(rowsObject[i].data.field) === -1 && (rowsObject[i].indent < rowsObject[index].indent || i === index)) {\n      fields.push(rowsObject[i].data.field);\n      keys.push(rowsObject[i].data.key);\n\n      if (rowsObject[i].indent === 0) {\n        break;\n      }\n    }\n  }\n\n  return {\n    fields: fields,\n    keys: keys\n  };\n}\n/* tslint:disable-next-line:max-line-length */\n\n/**\n * @hidden\n * `CheckBoxFilterBase` module is used to handle filtering action.\n */\n\n\nclass CheckBoxFilterBase {\n  /**\n   * Constructor for checkbox filtering module\n   *\n   * @param {IXLFilter} parent - specifies the IXLFilter\n   * @hidden\n   */\n  constructor(parent) {\n    this.existingPredicate = {};\n    this.foreignKeyQuery = new Query();\n    /** @hidden */\n\n    this.filterState = true;\n    this.values = {};\n    this.renderEmpty = false;\n    this.parent = parent;\n    this.id = this.parent.element.id;\n    this.valueFormatter = new ValueFormatter(this.parent.locale);\n    this.cBoxTrue = createCheckBox(this.parent.createElement, false, {\n      checked: true,\n      label: ' '\n    });\n    this.cBoxFalse = createCheckBox(this.parent.createElement, false, {\n      checked: false,\n      label: ' '\n    });\n    this.cBoxTrue.insertBefore(this.parent.createElement('input', {\n      className: 'e-chk-hidden',\n      attrs: {\n        type: 'checkbox'\n      }\n    }), this.cBoxTrue.firstChild);\n    this.cBoxFalse.insertBefore(this.parent.createElement('input', {\n      className: 'e-chk-hidden',\n      attrs: {\n        'type': 'checkbox'\n      }\n    }), this.cBoxFalse.firstChild);\n    this.cBoxFalse.querySelector('.e-frame').classList.add('e-uncheck');\n\n    if (this.parent.enableRtl) {\n      addClass([this.cBoxTrue, this.cBoxFalse], ['e-rtl']);\n    }\n  }\n  /**\n   * @returns {void}\n   * @hidden\n   */\n\n\n  destroy() {\n    this.closeDialog();\n  }\n\n  wireEvents() {\n    EventHandler.add(this.dlg, 'click', this.clickHandler, this);\n    EventHandler.add(this.dlg, 'keyup', this.keyupHandler, this);\n    this.searchHandler = debounce(this.searchBoxKeyUp, 200);\n    const elem = this.dialogObj.element.querySelector('.e-searchinput');\n\n    if (elem) {\n      EventHandler.add(elem, 'keyup', this.searchHandler, this);\n    }\n  }\n\n  unWireEvents() {\n    EventHandler.remove(this.dlg, 'click', this.clickHandler);\n    EventHandler.remove(this.dlg, 'keyup', this.keyupHandler);\n    const elem = this.dialogObj.element.querySelector('.e-searchinput');\n\n    if (elem) {\n      EventHandler.remove(elem, 'keyup', this.searchHandler);\n    }\n  }\n\n  foreignKeyFilter(args, fColl, mPredicate) {\n    const fPredicate = {};\n    const filterCollection = [];\n    const query = this.foreignKeyQuery.clone();\n    this.options.column.dataSource.executeQuery(query.where(mPredicate)).then(e => {\n      this.options.column.columnData = e.result;\n      this.parent.notify(generateQuery, {\n        predicate: fPredicate,\n        column: this.options.column\n      });\n      args.ejpredicate = fPredicate.predicate.predicates;\n      const fpred = fPredicate.predicate.predicates;\n\n      for (let i = 0; i < fpred.length; i++) {\n        filterCollection.push({\n          field: fpred[i].field,\n          predicate: 'or',\n          matchCase: fpred[i].ignoreCase,\n          ignoreAccent: fpred[i].ignoreAccent,\n          operator: fpred[i].operator,\n          value: fpred[i].value,\n          type: this.options.type\n        });\n      }\n\n      args.filterCollection = filterCollection.length ? filterCollection : fColl.filter(col => col.field = this.options.field);\n      this.options.handler(args);\n    });\n  }\n\n  foreignFilter(args, value) {\n    const operator = this.options.isRemote ? this.options.column.type === 'string' ? 'contains' : 'equal' : this.options.column.type ? 'contains' : 'equal';\n    const initalPredicate = new Predicate(this.options.column.foreignKeyValue, operator, value, true, this.options.ignoreAccent);\n    this.foreignKeyFilter(args, [args.filterCollection], initalPredicate);\n  }\n\n  searchBoxClick(e) {\n    const target = e.target;\n\n    if (target.classList.contains('e-searchclear')) {\n      this.sInput.value = '';\n      this.refreshCheckboxes();\n      this.updateSearchIcon();\n      this.sInput.focus();\n    }\n  } // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  searchBoxKeyUp(e) {\n    this.refreshCheckboxes();\n    this.updateSearchIcon();\n  }\n\n  updateSearchIcon() {\n    if (this.sInput.value.length) {\n      classList(this.sIcon, ['e-chkcancel-icon'], ['e-search-icon']);\n    } else {\n      classList(this.sIcon, ['e-search-icon'], ['e-chkcancel-icon']);\n    }\n  }\n  /**\n   * Gets the localized label by locale keyword.\n   *\n   * @param {string} key - Defines localization key\n   * @returns {string} - returns localization label\n   */\n\n\n  getLocalizedLabel(key) {\n    return this.localeObj.getConstant(key);\n  }\n\n  updateDataSource() {\n    const dataSource = this.options.dataSource;\n    const str = 'object';\n\n    if (!(dataSource instanceof DataManager)) {\n      for (let i = 0; i < dataSource.length; i++) {\n        // eslint-disable-next-line valid-typeof\n        if (typeof dataSource !== str) {\n          const obj = {};\n          obj[this.options.field] = dataSource[i];\n          dataSource[i] = obj;\n        }\n      }\n    }\n  }\n\n  updateModel(options) {\n    this.options = options;\n    this.existingPredicate = options.actualPredicate || {};\n    this.options.dataSource = options.dataSource;\n    this.options.dataManager = options.dataManager ? options.dataManager : options.dataSource;\n    this.updateDataSource();\n    this.options.type = options.type;\n    this.options.format = options.format || '';\n    this.options.ignoreAccent = options.ignoreAccent || false;\n    this.options.filteredColumns = options.filteredColumns || this.parent.filterSettings.columns;\n    this.options.query = options.query || new Query();\n    this.options.allowCaseSensitive = options.allowCaseSensitive || false;\n    this.options.uid = options.column.uid;\n    this.values = {};\n    this.localeObj = options.localeObj;\n    this.isFiltered = options.filteredColumns.length;\n  }\n\n  getAndSetChkElem(options) {\n    this.dlg = this.parent.createElement('div', {\n      id: this.id + this.options.type + '_excelDlg',\n      attrs: {\n        uid: this.options.column.uid\n      },\n      className: 'e-checkboxfilter e-filter-popup'\n    });\n    this.sBox = this.parent.createElement('div', {\n      className: 'e-searchcontainer'\n    });\n\n    if (!options.hideSearchbox) {\n      this.sInput = this.parent.createElement('input', {\n        id: this.id + '_SearchBox',\n        className: 'e-searchinput'\n      });\n      this.sIcon = this.parent.createElement('span', {\n        className: 'e-searchclear e-search-icon e-icons e-input-group-icon',\n        attrs: {\n          type: 'text',\n          title: this.getLocalizedLabel('Search')\n        }\n      });\n      this.searchBox = this.parent.createElement('span', {\n        className: 'e-searchbox e-fields'\n      });\n      this.searchBox.appendChild(this.sInput);\n      this.sBox.appendChild(this.searchBox);\n      const inputargs = {\n        element: this.sInput,\n        floatLabelType: 'Never',\n        properties: {\n          placeholder: this.getLocalizedLabel('Search')\n        }\n      };\n      Input.createInput(inputargs, this.parent.createElement);\n      this.searchBox.querySelector('.e-input-group').appendChild(this.sIcon);\n    }\n\n    this.spinner = this.parent.createElement('div', {\n      className: 'e-spinner'\n    }); //for spinner\n\n    this.cBox = this.parent.createElement('div', {\n      id: this.id + this.options.type + '_CheckBoxList',\n      className: 'e-checkboxlist e-fields'\n    });\n    this.spinner.appendChild(this.cBox);\n    this.sBox.appendChild(this.spinner);\n    return this.sBox;\n  }\n\n  showDialog(options) {\n    const args = {\n      requestType: filterBeforeOpen,\n      columnName: this.options.field,\n      columnType: this.options.type,\n      cancel: false\n    };\n    const filterModel = 'filterModel';\n    args[filterModel] = this;\n    this.parent.notify(cBoxFltrBegin, args);\n\n    if (args.cancel) {\n      options.cancel = args.cancel;\n      return;\n    }\n\n    this.dialogObj = new Dialog({\n      visible: false,\n      content: this.sBox,\n      close: this.closeDialog.bind(this),\n      enableRtl: this.parent.enableRtl,\n      width: !isNullOrUndefined(parentsUntil(options.target, 'e-bigger')) || this.parent.element.classList.contains('e-device') ? 260 : 255,\n      target: this.parent.element,\n      animationSettings: {\n        effect: 'None'\n      },\n      buttons: [{\n        click: this.btnClick.bind(this),\n        buttonModel: {\n          content: this.getLocalizedLabel(this.isExcel ? 'OKButton' : 'FilterButton'),\n          cssClass: 'e-primary',\n          isPrimary: true\n        }\n      }, {\n        click: this.btnClick.bind(this),\n        buttonModel: {\n          cssClass: 'e-flat',\n          content: this.getLocalizedLabel(this.isExcel ? 'CancelButton' : 'ClearButton')\n        }\n      }],\n      created: this.dialogCreated.bind(this),\n      open: this.dialogOpen.bind(this)\n    });\n    const isStringTemplate = 'isStringTemplate';\n    this.dialogObj[isStringTemplate] = true;\n    this.renderResponsiveFilter(options);\n    this.dlg.setAttribute('aria-label', this.getLocalizedLabel('ExcelFilterDialogARIA'));\n\n    if (options.isResponsiveFilter) {\n      const responsiveCnt = document.querySelector('.e-responsive-dialog > .e-dlg-content > .e-mainfilterdiv');\n      responsiveCnt.appendChild(this.dlg);\n    } else {\n      this.parent.element.appendChild(this.dlg);\n    }\n\n    this.dialogObj.appendTo(this.dlg);\n    this.dialogObj.element.style.maxHeight = options.isResponsiveFilter ? 'none' : this.options.height + 'px';\n    this.dialogObj.show();\n    const content = this.dialogObj.element.querySelector('.e-dlg-content');\n    content.appendChild(this.sBox);\n    this.wireEvents();\n    createSpinner({\n      target: this.spinner\n    }, this.parent.createElement);\n    showSpinner(this.spinner);\n    this.getAllData();\n  }\n\n  renderResponsiveFilter(options) {\n    if (options.isResponsiveFilter) {\n      this.dialogObj.buttons = [{}];\n      this.dialogObj.position = {\n        X: '',\n        Y: ''\n      };\n      this.dialogObj.target = document.querySelector('.e-resfilter > .e-dlg-content > .e-mainfilterdiv');\n      this.dialogObj.width = '100%';\n    }\n  }\n\n  dialogCreated(e) {\n    if (this.options.isResponsiveFilter) {\n      this.dialogObj.element.style.left = '0px';\n    } else {\n      if (!Browser.isDevice) {\n        getFilterMenuPostion(this.options.target, this.dialogObj);\n      } else {\n        this.dialogObj.position = {\n          X: 'center',\n          Y: 'center'\n        };\n      }\n    }\n\n    this.parent.notify(filterDialogCreated, e);\n  }\n\n  openDialog(options) {\n    this.updateModel(options);\n    this.getAndSetChkElem(options);\n    this.showDialog(options);\n  }\n\n  closeDialog() {\n    if (this.dialogObj && !this.dialogObj.isDestroyed) {\n      this.isBlanks = false;\n      const filterTemplateCol = this.options.columns.filter(col => col.getFilterItemTemplate()); // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n      const registeredTemplate = this.parent.registeredTemplate;\n\n      if (filterTemplateCol.length && !isNullOrUndefined(registeredTemplate) && registeredTemplate.filterItemTemplate) {\n        this.parent.destroyTemplate(['filterItemTemplate']);\n      }\n\n      if ((this.parent.isReact || this.parent.isVue) && this.parent.destroyTemplate !== undefined) {\n        clearReactVueTemplates(this.parent, ['filterItemTemplate']);\n      }\n\n      this.parent.notify(filterMenuClose, {\n        field: this.options.field\n      });\n      this.dialogObj.destroy();\n      this.unWireEvents();\n      remove(this.dlg);\n      this.dlg = null;\n      this.parent.notify(filterDialogClose, {});\n    }\n  }\n  /**\n   * @param {Column} col - Defines column details\n   * @returns {void}\n   * @hidden\n   */\n\n\n  clearFilter(col) {\n    // eslint-disable-next-line max-len\n    const args = {\n      instance: this,\n      handler: this.clearFilter,\n      cancel: false\n    };\n    this.parent.notify(fltrPrevent, args);\n\n    if (args.cancel) {\n      return;\n    }\n\n    this.options.handler({\n      action: 'clear-filter',\n      field: col ? col.field : this.options.field\n    });\n  }\n\n  btnClick(e) {\n    if (this.filterState) {\n      if (e.target.tagName.toLowerCase() === 'input' && e.target.classList.contains('e-searchinput')) {\n        let value = e.target.value;\n\n        if (this.options.column.type === 'boolean') {\n          if (value !== '' && this.getLocalizedLabel('FilterTrue').toLowerCase().indexOf(value.toLowerCase()) !== -1) {\n            value = true;\n          } else if (value !== '' && this.getLocalizedLabel('FilterFalse').toLowerCase().indexOf(value.toLowerCase()) !== -1) {\n            value = false;\n          }\n        }\n\n        if (this.options.type === 'date' || this.options.type === 'datetime') {\n          value = this.valueFormatter.fromView(value, this.options.parserFn, this.options.type);\n        }\n\n        const args = {\n          action: 'filtering',\n          filterCollection: {\n            field: this.options.field,\n            operator: this.options.isRemote ? this.options.column.type === 'string' ? 'contains' : 'equal' : this.options.column.type === 'date' || this.options.column.type === 'datetime' || this.options.column.type === 'boolean' ? 'equal' : 'contains',\n            value: value,\n            matchCase: false,\n            type: this.options.column.type,\n            ignoreAccent: this.options.ignoreAccent\n          },\n          field: this.options.field\n        };\n\n        if (value !== undefined && value !== null && value !== '') {\n          if (this.isBlanks && value && typeof value === 'string' && this.getLocalizedLabel('Blanks').toLowerCase().indexOf(value.toLowerCase()) >= 0) {\n            this.fltrBtnHandler();\n          } else {\n            if (this.isForeignColumn(this.options.column)) {\n              this.foreignFilter(args, value);\n            } else {\n              this.options.handler(args);\n            }\n          }\n        } else {\n          this.closeDialog();\n        }\n      } else {\n        if (e.keyCode === 13) {\n          this.fltrBtnHandler();\n        } else {\n          const text = e.target.firstChild.textContent.toLowerCase();\n\n          if (this.getLocalizedLabel(this.isExcel ? 'OKButton' : 'FilterButton').toLowerCase() === text) {\n            this.fltrBtnHandler();\n          } else if (this.getLocalizedLabel('ClearButton').toLowerCase() === text) {\n            this.clearFilter();\n          }\n        }\n      }\n\n      this.closeDialog();\n    } else if (!(e.target.tagName.toLowerCase() === 'input')) {\n      this.clearFilter();\n      this.closeDialog();\n    }\n  }\n  /**\n   * @returns {void}\n   * @hidden\n   */\n\n\n  fltrBtnHandler() {\n    let checked = [].slice.call(this.cBox.querySelectorAll('.e-check:not(.e-selectall)'));\n    const check = checked;\n    let optr = 'equal';\n    const ddlValue = this.dialogObj.element.querySelector('.e-dropdownlist');\n\n    if (ddlValue) {\n      this.options.operator = optr = ddlValue.ej2_instances[0].value;\n    }\n\n    this.isMenuNotEqual = this.options.operator === 'notequal';\n    let searchInput;\n\n    if (!this.options.hideSearchbox) {\n      searchInput = this.searchBox.querySelector('.e-searchinput');\n    }\n\n    const caseSen = this.options.allowCaseSensitive;\n    const defaults = {\n      field: this.options.field,\n      predicate: this.isMenuNotEqual ? 'and' : 'or',\n      uid: this.options.uid,\n      operator: optr,\n      type: this.options.type,\n      matchCase: caseSen,\n      ignoreAccent: this.options.ignoreAccent\n    };\n    const isNotEqual = this.itemsCnt !== checked.length && this.itemsCnt - checked.length < checked.length;\n\n    if (isNotEqual && searchInput && searchInput.value === '') {\n      optr = this.isMenuNotEqual ? 'equal' : 'notequal';\n      checked = [].slice.call(this.cBox.querySelectorAll('.e-uncheck:not(.e-selectall)'));\n      defaults.predicate = this.isMenuNotEqual ? 'or' : 'and';\n      defaults.operator = optr;\n    }\n\n    let value;\n    let val;\n    let length;\n    let fObj;\n    let coll = [];\n\n    if (checked.length !== this.itemsCnt || searchInput && searchInput.value && searchInput.value !== '') {\n      for (let i = 0; i < checked.length; i++) {\n        value = this.values[parentsUntil(checked[i], 'e-ftrchk').getAttribute('uid')];\n        fObj = extend({}, {\n          value: value\n        }, defaults);\n\n        if (value && !value.toString().length) {\n          fObj.operator = isNotEqual ? 'notequal' : 'equal';\n        }\n\n        if (value === '' || isNullOrUndefined(value)) {\n          coll = coll.concat(CheckBoxFilterBase.generateNullValuePredicates(defaults));\n        } else {\n          coll.push(fObj);\n        }\n\n        const args = {\n          instance: this,\n          handler: this.fltrBtnHandler,\n          arg1: fObj.field,\n          arg2: fObj.predicate,\n          arg3: fObj.operator,\n          arg4: fObj.matchCase,\n          arg5: fObj.ignoreAccent,\n          arg6: fObj.value,\n          cancel: false\n        };\n        this.parent.notify(fltrPrevent, args);\n\n        if (args.cancel) {\n          return;\n        }\n      }\n\n      if (this.options.type === 'date' || this.options.type === 'datetime') {\n        length = check.length - 1;\n        val = this.values[parentsUntil(check[length], 'e-ftrchk').getAttribute('uid')];\n\n        if (isNullOrUndefined(val) && isNotEqual) {\n          coll.push({\n            field: defaults.field,\n            matchCase: defaults.matchCase,\n            operator: 'equal',\n            predicate: 'and',\n            value: null\n          });\n        }\n      }\n\n      this.initiateFilter(coll);\n    } else {\n      const isClearFilter = this.parent.filterSettings.columns.some(value => {\n        return this.options.field === value.field;\n      });\n\n      if (isClearFilter) {\n        this.clearFilter();\n      }\n    }\n  } // eslint-disable-next-line\n\n  /** @hidden */\n\n\n  static generateNullValuePredicates(defaults) {\n    const coll = [];\n\n    if (defaults.type === 'string') {\n      coll.push({\n        field: defaults.field,\n        ignoreAccent: defaults.ignoreAccent,\n        matchCase: defaults.matchCase,\n        operator: defaults.operator,\n        predicate: defaults.predicate,\n        value: ''\n      });\n    }\n\n    coll.push({\n      field: defaults.field,\n      matchCase: defaults.matchCase,\n      operator: defaults.operator,\n      predicate: defaults.predicate,\n      value: null\n    });\n    coll.push({\n      field: defaults.field,\n      matchCase: defaults.matchCase,\n      operator: defaults.operator,\n      predicate: defaults.predicate,\n      value: undefined\n    });\n    return coll;\n  }\n\n  initiateFilter(fColl) {\n    const firstVal = fColl[0];\n    let predicate;\n\n    if (!isNullOrUndefined(firstVal)) {\n      predicate = firstVal.ejpredicate ? firstVal.ejpredicate : new Predicate(firstVal.field, firstVal.operator, firstVal.value, !firstVal.matchCase, firstVal.ignoreAccent);\n\n      for (let j = 1; j < fColl.length; j++) {\n        predicate = fColl[j].ejpredicate !== undefined ? predicate[fColl[j].predicate](fColl[j].ejpredicate) : predicate[fColl[j].predicate](fColl[j].field, fColl[j].operator, fColl[j].value, !fColl[j].matchCase, fColl[j].ignoreAccent);\n      }\n\n      const args = {\n        action: 'filtering',\n        filterCollection: fColl,\n        field: this.options.field,\n        ejpredicate: Predicate.or(predicate)\n      };\n      this.options.handler(args);\n    }\n  }\n\n  isForeignColumn(col) {\n    return col.isForeignColumn ? col.isForeignColumn() : false;\n  }\n\n  refreshCheckboxes() {\n    const val = this.sInput.value;\n    const column = this.options.column;\n    const query = this.isForeignColumn(column) ? this.foreignKeyQuery.clone() : this.options.query.clone();\n    const foreignQuery = this.options.query.clone();\n    const pred = query.queries.filter(e => {\n      return e && e.fn === 'onWhere';\n    })[0];\n    query.queries = [];\n    foreignQuery.queries = [];\n    let parsed = this.options.type !== 'string' && parseFloat(val) ? parseFloat(val) : val;\n    let operator = this.options.isRemote ? this.options.type === 'string' ? 'contains' : 'equal' : this.options.type ? 'contains' : 'equal';\n    const matchCase = true;\n    const ignoreAccent = this.options.ignoreAccent;\n    const field = this.isForeignColumn(column) ? column.foreignKeyValue : column.field;\n    parsed = parsed === '' || parsed === undefined ? undefined : parsed;\n    let coll = [];\n    const defaults = {\n      field: field,\n      predicate: 'or',\n      uid: this.options.uid,\n      operator: 'equal',\n      type: this.options.type,\n      matchCase: matchCase,\n      ignoreAccent: ignoreAccent\n    };\n    let predicte;\n    const moduleName = this.options.dataManager.adaptor.getModuleName;\n\n    if (this.options.type === 'boolean') {\n      if (parsed !== undefined && this.getLocalizedLabel('FilterTrue').toLowerCase().indexOf(parsed.toLowerCase()) !== -1) {\n        parsed = 'true';\n      } else if (parsed !== undefined && this.getLocalizedLabel('FilterFalse').toLowerCase().indexOf(parsed.toLowerCase()) !== -1) {\n        parsed = 'false';\n      }\n\n      if (parsed !== undefined && this.getLocalizedLabel('FilterTrue').toLowerCase().indexOf(parsed.toLowerCase()) !== -1 && moduleName) {\n        // eslint-disable-next-line no-constant-condition\n        parsed = moduleName() === 'ODataAdaptor' || 'ODataV4Adaptor' ? true : 'true';\n      } else if (parsed !== undefined && this.getLocalizedLabel('FilterFalse').toLowerCase().indexOf(parsed.toLowerCase()) !== -1 && moduleName) {\n        // eslint-disable-next-line no-constant-condition\n        parsed = moduleName() === 'ODataAdaptor' || 'ODataV4Adaptor' ? false : 'false';\n      }\n\n      operator = 'equal';\n    }\n\n    if ((this.options.type === 'date' || this.options.type === 'datetime') && this.options.format) {\n      const intl = new Internationalization();\n      const format = typeof this.options.format === 'string' ? this.options.format : this.options.format.format;\n\n      if (format) {\n        parsed = intl.parseDate(val, {\n          format: format\n        }) || new Date(val);\n      } else {\n        parsed = new Date(val);\n      }\n    }\n\n    this.addDistinct(query);\n    const args = {\n      requestType: filterSearchBegin,\n      filterModel: this,\n      columnName: field,\n      column: column,\n      operator: operator,\n      matchCase: matchCase,\n      ignoreAccent: ignoreAccent,\n      filterChoiceCount: null,\n      query: query,\n      value: parsed\n    };\n    this.parent.trigger(actionBegin, args, filterargs => {\n      // eslint-disable-next-line no-self-assign\n      filterargs.operator = filterargs.operator;\n      predicte = new Predicate(field, filterargs.operator, parsed, filterargs.matchCase, filterargs.ignoreAccent);\n\n      if (this.options.type === 'date' || this.options.type === 'datetime') {\n        operator = 'equal';\n        const filterObj = {\n          field: field,\n          operator: operator,\n          value: parsed,\n          matchCase: matchCase,\n          ignoreAccent: ignoreAccent\n        };\n\n        if (!isNullOrUndefined(parsed)) {\n          predicte = getDatePredicate(filterObj, this.options.type);\n        }\n      }\n\n      if (val && typeof val === 'string' && this.isBlanks && this.getLocalizedLabel('Blanks').toLowerCase().indexOf(val.toLowerCase()) >= 0) {\n        coll = coll.concat(CheckBoxFilterBase.generateNullValuePredicates(defaults));\n        const emptyValPredicte = CheckBoxFilterBase.generatePredicate(coll);\n        emptyValPredicte.predicates.push(predicte);\n        query.where(emptyValPredicte);\n      } else if (val.length) {\n        predicte = !isNullOrUndefined(pred) ? predicte.and(pred.e) : predicte;\n        query.where(predicte);\n      } else if (!isNullOrUndefined(pred)) {\n        query.where(pred.e);\n      }\n\n      filterargs.filterChoiceCount = !isNullOrUndefined(filterargs.filterChoiceCount) ? filterargs.filterChoiceCount : 1000;\n      const fPredicate = {};\n      showSpinner(this.spinner);\n      this.renderEmpty = false;\n\n      if (this.isForeignColumn(column) && val.length) {\n        const colData = 'result' in column.dataSource ? new DataManager(column.dataSource.result) : column.dataSource; // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n        colData.executeQuery(query).then(e => {\n          const columnData = this.options.column.columnData;\n          this.options.column.columnData = e.result;\n          this.parent.notify(generateQuery, {\n            predicate: fPredicate,\n            column: column\n          });\n\n          if (fPredicate.predicate.predicates.length) {\n            foreignQuery.where(fPredicate.predicate);\n          } else {\n            this.renderEmpty = true;\n          }\n\n          this.options.column.columnData = columnData;\n          foreignQuery.take(filterargs.filterChoiceCount);\n          this.search(filterargs, foreignQuery);\n        });\n      } else {\n        query.take(filterargs.filterChoiceCount);\n        this.search(filterargs, query);\n      }\n    });\n  }\n\n  search(args, query) {\n    if (this.parent.dataSource && 'result' in this.parent.dataSource) {\n      this.filterEvent(args, query);\n    } else {\n      this.processSearch(query);\n    }\n  }\n\n  getPredicateFromCols(columns) {\n    const predicates = CheckBoxFilterBase.getPredicate(columns);\n    const predicateList = [];\n    const fPredicate = {};\n    const isGrid = this.parent.getForeignKeyColumns !== undefined;\n    const foreignColumn = isGrid ? this.parent.getForeignKeyColumns() : [];\n\n    for (const prop of Object.keys(predicates)) {\n      let col;\n\n      if (isGrid && this.parent.getColumnByField(prop).isForeignColumn()) {\n        col = getColumnByForeignKeyValue(prop, foreignColumn);\n      }\n\n      if (col) {\n        this.parent.notify(generateQuery, {\n          predicate: fPredicate,\n          column: col\n        });\n\n        if (fPredicate.predicate.predicates.length) {\n          predicateList.push(Predicate.or(fPredicate.predicate.predicates));\n        }\n      } else {\n        predicateList.push(predicates[prop]);\n      }\n    }\n\n    return predicateList.length && Predicate.and(predicateList);\n  }\n\n  getQuery() {\n    return this.parent.getQuery ? this.parent.getQuery().clone() : new Query();\n  }\n\n  getAllData() {\n    const query = this.getQuery();\n    query.requiresCount(); //consider take query\n\n    this.addDistinct(query);\n    const args = {\n      requestType: filterChoiceRequest,\n      query: query,\n      filterChoiceCount: null\n    };\n    const filterModel = 'filterModel';\n    args[filterModel] = this;\n    this.parent.trigger(actionBegin, args, args => {\n      args.filterChoiceCount = !isNullOrUndefined(args.filterChoiceCount) ? args.filterChoiceCount : 1000;\n      query.take(args.filterChoiceCount);\n\n      if (this.parent.dataSource && 'result' in this.parent.dataSource) {\n        this.filterEvent(args, query);\n      } else {\n        this.processDataOperation(query, true);\n      }\n    });\n  }\n\n  addDistinct(query) {\n    let filteredColumn = DataUtil.distinct(this.options.filteredColumns, 'field');\n\n    if (filteredColumn.indexOf(this.options.column.field) <= -1) {\n      filteredColumn = filteredColumn.concat(this.options.column.field);\n    }\n\n    query.distinct(filteredColumn);\n    return query;\n  }\n\n  filterEvent(args, query) {\n    const defObj = eventPromise(args, query);\n    this.parent.trigger(dataStateChange, defObj.state);\n    const def = defObj.deffered;\n    def.promise.then(e => {\n      this.dataSuccess(e);\n    });\n  }\n\n  processDataOperation(query, isInitial) {\n    this.options.dataSource = this.options.dataSource instanceof DataManager ? this.options.dataSource : new DataManager(this.options.dataSource);\n    const allPromise = [];\n    const runArray = [];\n\n    if (this.isForeignColumn(this.options.column) && isInitial) {\n      const colData = 'result' in this.options.column.dataSource ? new DataManager(this.options.column.dataSource.result) : this.options.column.dataSource;\n      this.foreignKeyQuery.params = query.params;\n      allPromise.push(colData.executeQuery(this.foreignKeyQuery));\n      runArray.push(data => this.foreignKeyData = data);\n    }\n\n    allPromise.push(this.options.dataSource.executeQuery(query));\n    runArray.push(this.dataSuccess.bind(this));\n    let i = 0;\n    Promise.all(allPromise).then(e => {\n      for (let j = 0; j < e.length; j++) {\n        runArray[i++](e[j].result);\n      }\n    });\n  }\n\n  dataSuccess(e) {\n    this.fullData = e;\n    const args1 = {\n      dataSource: this.fullData,\n      executeQuery: true,\n      field: this.options.field\n    };\n    this.parent.notify(beforeCheckboxRenderer, args1);\n\n    if (args1.executeQuery) {\n      const query = new Query();\n\n      if (this.parent.searchSettings && this.parent.searchSettings.key.length) {\n        const sSettings = this.parent.searchSettings;\n        const fields = sSettings.fields.length ? sSettings.fields : this.options.columns.map(f => f.field);\n        query.search(sSettings.key, fields, sSettings.operator, sSettings.ignoreCase, sSettings.ignoreAccent);\n      }\n\n      if (this.options.filteredColumns.length) {\n        const cols = [];\n\n        for (let i = 0; i < this.options.filteredColumns.length; i++) {\n          const filterColumn = this.options.filteredColumns[i];\n\n          if (this.options.uid) {\n            filterColumn.uid = filterColumn.uid || this.parent.getColumnByField(filterColumn.field).uid;\n\n            if (filterColumn.uid !== this.options.uid) {\n              cols.push(this.options.filteredColumns[i]);\n            }\n          } else {\n            if (filterColumn.field !== this.options.field) {\n              cols.push(this.options.filteredColumns[i]);\n            }\n          }\n        }\n\n        const predicate = this.getPredicateFromCols(cols);\n\n        if (predicate) {\n          query.where(predicate);\n        }\n      } // query.select(this.options.field);\n\n\n      const result = new DataManager(args1.dataSource).executeLocal(query);\n      const col = this.options.column;\n      this.filteredData = CheckBoxFilterBase.getDistinct(result, this.options.field, col, this.foreignKeyData).records || [];\n    }\n\n    const data = args1.executeQuery ? this.filteredData : args1.dataSource;\n    this.processDataSource(null, true, data, args1);\n\n    if (this.sInput) {\n      this.sInput.focus();\n    }\n\n    const args = {\n      requestType: filterAfterOpen,\n      columnName: this.options.field,\n      columnType: this.options.type\n    };\n    const filterModel = 'filterModel';\n    args[filterModel] = this;\n    this.parent.notify(cBoxFltrComplete, args);\n  }\n\n  processDataSource(query, isInitial, dataSource, args) {\n    showSpinner(this.spinner); // query = query ? query : this.options.query.clone();\n    // query.requiresCount();\n    // let result: Object = new DataManager(dataSource as JSON[]).executeLocal(query);\n    // let res: { result: Object[] } = result as { result: Object[] };\n\n    this.updateResult();\n    this.createFilterItems(dataSource, isInitial, args);\n  }\n\n  processSearch(query) {\n    this.processDataOperation(query);\n  }\n\n  updateResult() {\n    this.result = {};\n    const predicate = this.getPredicateFromCols(this.options.filteredColumns);\n    const query = new Query();\n\n    if (predicate) {\n      query.where(predicate);\n    }\n\n    this.parent.notify(beforeCheckboxRendererQuery, {\n      query: query\n    });\n    const result = new DataManager(this.fullData).executeLocal(query);\n\n    for (const res of result) {\n      this.result[getObject(this.options.field, res)] = true;\n    }\n  }\n\n  clickHandler(e) {\n    const target = e.target;\n    const elem = parentsUntil(target, 'e-checkbox-wrapper');\n\n    if (parentsUntil(target, 'e-searchbox')) {\n      this.searchBoxClick(e);\n    }\n\n    if (elem) {\n      const selectAll$$1 = elem.querySelector('.e-selectall');\n\n      if (selectAll$$1) {\n        this.updateAllCBoxes(!selectAll$$1.classList.contains('e-check'));\n      } else {\n        toogleCheckbox(elem.parentElement);\n      }\n\n      this.updateIndeterminatenBtn();\n      elem.querySelector('.e-chk-hidden').focus();\n    }\n\n    this.setFocus(parentsUntil(elem, 'e-ftrchk'));\n  }\n\n  keyupHandler(e) {\n    this.setFocus(parentsUntil(e.target, 'e-ftrchk'));\n  }\n\n  setFocus(elem) {\n    const prevElem = this.dlg.querySelector('.e-chkfocus');\n\n    if (prevElem) {\n      prevElem.classList.remove('e-chkfocus');\n    }\n\n    if (elem) {\n      elem.classList.add('e-chkfocus');\n    }\n  }\n\n  updateAllCBoxes(checked) {\n    const cBoxes = [].slice.call(this.cBox.getElementsByClassName('e-frame'));\n\n    for (const cBox of cBoxes) {\n      removeAddCboxClasses(cBox, checked);\n      setChecked(cBox.previousSibling, checked);\n    }\n  }\n\n  dialogOpen() {\n    if (this.parent.element.classList.contains('e-device')) {\n      this.dialogObj.element.querySelector('.e-input-group').classList.remove('e-input-focus');\n\n      if (!this.options.isResponsiveFilter) {\n        this.dialogObj.element.querySelector('.e-btn').focus();\n      }\n    }\n  }\n\n  createCheckbox(value, checked, data) {\n    const elem = checked ? this.cBoxTrue.cloneNode(true) : this.cBoxFalse.cloneNode(true);\n    setChecked(elem.querySelector('input'), checked);\n    const label = elem.querySelector('.e-label');\n    const dummyData = extendObjWithFn({}, data, {\n      column: this.options.column,\n      parent: this.parent\n    });\n    label.innerHTML = !isNullOrUndefined(value) && value.toString().length ? value : this.getLocalizedLabel('Blanks');\n\n    if (label.innerHTML === this.getLocalizedLabel('Blanks')) {\n      this.isBlanks = true;\n    }\n\n    if (typeof value === 'boolean') {\n      label.innerHTML = value === true ? this.getLocalizedLabel('FilterTrue') : this.getLocalizedLabel('FilterFalse');\n    }\n\n    addClass([label], ['e-checkboxfiltertext']);\n\n    if (this.options.template && data[this.options.column.field] !== this.getLocalizedLabel('SelectAll')) {\n      label.innerHTML = '';\n      const isReactCompiler = this.parent.isReact && this.options.column.filter && typeof this.options.column.filter.itemTemplate !== 'string';\n\n      if (isReactCompiler) {\n        this.options.template(dummyData, this.parent, 'filterItemTemplate', null, null, null, label);\n        this.parent.renderTemplates();\n      } else {\n        appendChildren(label, this.options.template(dummyData, this.parent, 'filterItemTemplate'));\n      }\n    }\n\n    return elem;\n  }\n\n  updateIndeterminatenBtn() {\n    const cnt = this.cBox.children.length - 1;\n    let className = [];\n    let disabled = false;\n    const elem = this.cBox.querySelector('.e-selectall');\n    const selected = this.cBox.querySelectorAll('.e-check:not(.e-selectall)').length;\n    let btn;\n\n    if (!this.options.isResponsiveFilter) {\n      btn = this.dialogObj.btnObj[0];\n      btn.disabled = false;\n    }\n\n    const input = elem.previousSibling;\n    setChecked(input, false);\n    input.indeterminate = false;\n\n    if (cnt === selected) {\n      className = ['e-check'];\n      setChecked(input, true);\n    } else if (selected) {\n      className = ['e-stop'];\n      input.indeterminate = true;\n    } else {\n      className = ['e-uncheck'];\n      disabled = true;\n\n      if (btn) {\n        btn.disabled = true;\n      }\n    }\n\n    if (btn) {\n      this.filterState = !btn.disabled;\n      btn.dataBind();\n    }\n\n    removeClass([elem], ['e-check', 'e-stop', 'e-uncheck']);\n    addClass([elem], className);\n    this.parent.notify(refreshCustomFilterOkBtn, {\n      disabled: disabled\n    });\n  }\n\n  createFilterItems(data, isInitial, args1) {\n    const cBoxes = this.parent.createElement('div');\n    let btn;\n    let disabled = false;\n\n    if (!this.options.isResponsiveFilter) {\n      btn = this.dialogObj.btnObj[0];\n    }\n\n    let nullCounter = -1;\n    let key = 'ejValue';\n\n    if (!args1.executeQuery) {\n      key = args1.field;\n    }\n\n    for (let i = 0; i < data.length; i++) {\n      const val = getValue(key, data[i]);\n\n      if (val === '' || isNullOrUndefined(val)) {\n        nullCounter = nullCounter + 1;\n      }\n    }\n\n    this.itemsCnt = nullCounter !== -1 ? data.length - nullCounter : data.length;\n\n    if (data.length && !this.renderEmpty) {\n      const selectAllValue = this.getLocalizedLabel('SelectAll');\n      const innerDiv = this.cBox.querySelector('.e-checkfltrnmdiv');\n\n      if (innerDiv) {\n        innerDiv.classList.remove('e-checkfltrnmdiv');\n      }\n\n      const checkBox = this.createCheckbox(selectAllValue, false, {\n        [this.options.field]: selectAllValue\n      });\n      const selectAll$$1 = createCboxWithWrap(getUid('cbox'), checkBox, 'e-ftrchk');\n      selectAll$$1.querySelector('.e-frame').classList.add('e-selectall');\n      cBoxes.appendChild(selectAll$$1);\n      let predicate = new Predicate('field', 'equal', this.options.field);\n\n      if (this.options.foreignKeyValue) {\n        predicate = predicate.or('field', 'equal', this.options.foreignKeyValue);\n      }\n\n      const isColFiltered = new DataManager(this.options.filteredColumns).executeLocal(new Query().where(predicate)).length;\n      let isRndere;\n\n      for (let i = 0; i < data.length; i++) {\n        const uid = getUid('cbox');\n        this.values[uid] = getValue(key, data[i]);\n        let value = getValue(this.options.field, data[i]);\n\n        if (this.options.formatFn) {\n          value = this.valueFormatter.toView(value, this.options.formatFn);\n        }\n\n        const args = {\n          value: value,\n          column: this.options.column,\n          data: data[i]\n        };\n        this.parent.notify(filterCboxValue, args);\n        value = args.value;\n\n        if (value === '' || isNullOrUndefined(value)) {\n          if (isRndere) {\n            continue;\n          }\n\n          isRndere = true;\n        }\n\n        const checkbox = this.createCheckbox(value, this.getCheckedState(isColFiltered, this.values[uid]), getValue('dataObj', data[i]));\n        cBoxes.appendChild(createCboxWithWrap(uid, checkbox, 'e-ftrchk'));\n      }\n\n      this.cBox.innerHTML = '';\n      appendChildren(this.cBox, [].slice.call(cBoxes.children));\n      this.updateIndeterminatenBtn();\n\n      if (btn) {\n        btn.disabled = false;\n      }\n\n      disabled = false;\n    } else {\n      cBoxes.appendChild(this.parent.createElement('span', {\n        innerHTML: this.getLocalizedLabel('NoResult')\n      }));\n      this.cBox.innerHTML = '';\n      this.cBox.appendChild(this.parent.createElement('div', {\n        className: 'e-checkfltrnmdiv'\n      }));\n      appendChildren(this.cBox.children[0], [].slice.call(cBoxes.children));\n\n      if (btn) {\n        btn.disabled = true;\n      }\n\n      disabled = true;\n    }\n\n    if (btn) {\n      this.filterState = !btn.disabled;\n      btn.dataBind();\n    }\n\n    const args = {\n      requestType: filterChoiceRequest,\n      dataSource: this.renderEmpty ? [] : data\n    };\n    const filterModel = 'filterModel';\n    args[filterModel] = this;\n    this.parent.notify(cBoxFltrComplete, args);\n    this.parent.notify(refreshCustomFilterOkBtn, {\n      disabled: disabled\n    });\n    hideSpinner(this.spinner);\n  }\n\n  getCheckedState(isColFiltered, value) {\n    if (!this.isFiltered || !isColFiltered) {\n      return true;\n    } else {\n      const checkState = this.result[value];\n      return this.options.operator === 'notequal' ? !checkState : checkState;\n    }\n  }\n\n  static getDistinct(json, field, column, foreignKeyData$$1) {\n    let len = json.length;\n    const result = [];\n    let value;\n    const ejValue = 'ejValue';\n    const lookup = {};\n    const isForeignKey = column && column.isForeignColumn ? column.isForeignColumn() : false;\n\n    while (len--) {\n      value = json[len];\n      value = getObject(field, value); //local remote diff, check with mdu\n\n      if (!(value in lookup)) {\n        const obj = {};\n        obj[ejValue] = value;\n        lookup[value] = true;\n\n        if (isForeignKey) {\n          const foreignDataObj = getForeignData(column, {}, value, foreignKeyData$$1)[0];\n          setValue(foreignKeyData, foreignDataObj, json[len]);\n          value = getValue(column.foreignKeyValue, foreignDataObj);\n        }\n\n        setValue(field, isNullOrUndefined(value) ? null : value, obj);\n        setValue('dataObj', json[len], obj);\n        result.push(obj);\n      }\n    }\n\n    return DataUtil.group(DataUtil.sort(result, field, DataUtil.fnAscending), 'ejValue');\n  }\n\n  static getPredicate(columns) {\n    const cols = DataUtil.distinct(columns, 'field', true) || [];\n    let collection = [];\n    const pred = {};\n\n    for (let i = 0; i < cols.length; i++) {\n      collection = new DataManager(columns).executeLocal(new Query().where('field', 'equal', cols[i].field));\n\n      if (collection.length !== 0) {\n        pred[cols[i].field] = CheckBoxFilterBase.generatePredicate(collection);\n      }\n    }\n\n    return pred;\n  }\n\n  static generatePredicate(cols) {\n    const len = cols ? cols.length : 0;\n    let predicate;\n    const operate = 'or';\n    const first = CheckBoxFilterBase.updateDateFilter(cols[0]);\n    first.ignoreAccent = !isNullOrUndefined(first.ignoreAccent) ? first.ignoreAccent : false;\n\n    if (first.type === 'date' || first.type === 'datetime') {\n      predicate = getDatePredicate(first, first.type);\n    } else {\n      predicate = first.ejpredicate ? first.ejpredicate : new Predicate(first.field, first.operator, first.value, !CheckBoxFilterBase.getCaseValue(first), first.ignoreAccent);\n    }\n\n    for (let p = 1; p < len; p++) {\n      cols[p] = CheckBoxFilterBase.updateDateFilter(cols[p]);\n\n      if (len > 2 && p > 1 && cols[p].predicate === 'or') {\n        if (cols[p].type === 'date' || cols[p].type === 'datetime') {\n          predicate.predicates.push(getDatePredicate(cols[p], cols[p].type));\n        } else {\n          predicate.predicates.push(new Predicate(cols[p].field, cols[p].operator, cols[p].value, !CheckBoxFilterBase.getCaseValue(cols[p]), cols[p].ignoreAccent));\n        }\n      } else {\n        if (cols[p].type === 'date' || cols[p].type === 'datetime') {\n          if (cols[p].predicate === 'and' && cols[p].operator === 'equal') {\n            predicate = predicate[operate](getDatePredicate(cols[p], cols[p].type), cols[p].type, cols[p].ignoreAccent);\n          } else {\n            predicate = predicate[cols[p].predicate](getDatePredicate(cols[p], cols[p].type), cols[p].type, cols[p].ignoreAccent);\n          }\n        } else {\n          predicate = cols[p].ejpredicate ? predicate[cols[p].predicate](cols[p].ejpredicate) : predicate[cols[p].predicate](cols[p].field, cols[p].operator, cols[p].value, !CheckBoxFilterBase.getCaseValue(cols[p]), cols[p].ignoreAccent);\n        }\n      }\n    }\n\n    return predicate || null;\n  }\n\n  static getCaseValue(filter) {\n    if (isNullOrUndefined(filter.matchCase)) {\n      if (filter.type === 'string' || isNullOrUndefined(filter.type) && typeof filter.value === 'string') {\n        return false;\n      } else {\n        return true;\n      }\n    } else {\n      return filter.matchCase;\n    }\n  }\n\n  static updateDateFilter(filter) {\n    if (filter.type === 'date' || filter.type === 'datetime' || filter.value instanceof Date) {\n      filter.type = filter.type || 'date';\n    }\n\n    return filter;\n  }\n\n}\n/**\n * @hidden\n * `ExcelFilter` module is used to handle filtering action.\n */\n\n\nclass ExcelFilterBase extends CheckBoxFilterBase {\n  /**\n   * Constructor for excel filtering module\n   *\n   * @param {IXLFilter} parent - parent details\n   * @param {Object} customFltrOperators - operator details\n   * @hidden\n   */\n  constructor(parent, customFltrOperators) {\n    super(parent);\n    this.childRefs = [];\n    this.eventHandlers = {};\n    this.isDevice = false;\n    this.customFilterOperators = customFltrOperators;\n    this.isExcel = true;\n  }\n\n  getCMenuDS(type, operator) {\n    const options = {\n      number: ['Equal', 'NotEqual', '', 'LessThan', 'LessThanOrEqual', 'GreaterThan', 'GreaterThanOrEqual', 'Between', '', 'CustomFilter'],\n      string: ['Equal', 'NotEqual', '', 'StartsWith', 'EndsWith', '', 'Contains', '', 'CustomFilter']\n    };\n    options.date = options.number;\n    options.datetime = options.number;\n    const model = [];\n\n    for (let i = 0; i < options[type].length; i++) {\n      if (options[type][i].length) {\n        if (operator) {\n          model.push({\n            text: this.getLocalizedLabel(options[type][i]) + '...',\n            iconCss: 'e-icons e-icon-check ' + (operator === options[type][i].toLowerCase() ? '' : 'e-emptyicon')\n          });\n        } else {\n          model.push({\n            text: this.getLocalizedLabel(options[type][i]) + '...'\n          });\n        }\n      } else {\n        model.push({\n          separator: true\n        });\n      }\n    }\n\n    return model;\n  }\n  /**\n   * To destroy the filter bar.\n   *\n   * @returns {void}\n   * @hidden\n   */\n\n\n  destroy() {\n    if (this.dlg) {\n      this.unwireExEvents();\n      super.closeDialog();\n    }\n\n    if (!this.isDevice && this.menuObj) {\n      const li = this.menuObj.element.querySelector('li.e-focused');\n\n      if (!(li && parentsUntil(li, 'e-excel-menu'))) {\n        this.destroyCMenu();\n      }\n    }\n\n    if (this.dlgObj && !this.dlgObj.isDestroyed) {\n      this.removeDialog();\n    }\n  }\n\n  createMenu(type, isFiltered, isCheckIcon, eleOptions) {\n    const options = {\n      string: 'TextFilter',\n      date: 'DateFilter',\n      datetime: 'DateTimeFilter',\n      number: 'NumberFilter'\n    };\n    this.menu = this.parent.createElement('div', {\n      className: 'e-contextmenu-wrapper'\n    });\n\n    if (this.parent.enableRtl) {\n      this.menu.classList.add('e-rtl');\n    } else {\n      this.menu.classList.remove('e-rtl');\n    }\n\n    const ul = this.parent.createElement('ul');\n    const icon = isFiltered ? 'e-excl-filter-icon e-filtered' : 'e-excl-filter-icon'; // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n    if (this.parent.allowSorting && this.parent.getModuleName() === 'grid' && !this.options.isResponsiveFilter) {\n      const hdrele = this.parent.getColumnHeaderByUid(eleOptions.uid).getAttribute('aria-sort');\n      const colIsSort = this.parent.getColumnByField(eleOptions.field).allowSorting;\n      const isAsc = !colIsSort || hdrele === 'ascending' ? 'e-disabled e-excel-ascending' : 'e-excel-ascending';\n      const isDesc = !colIsSort || hdrele === 'descending' ? 'e-disabled e-excel-descending' : 'e-excel-descending';\n      const ascName = type === 'string' ? this.getLocalizedLabel('SortAtoZ') : type === 'datetime' || type === 'date' ? this.getLocalizedLabel('SortByOldest') : this.getLocalizedLabel('SortSmallestToLargest');\n      const descName = type === 'string' ? this.getLocalizedLabel('SortZtoA') : type === 'datetime' || type === 'date' ? this.getLocalizedLabel('SortByNewest') : this.getLocalizedLabel('SortLargestToSmallest');\n      ul.appendChild(this.createMenuElem(ascName, isAsc, 'e-sortascending'));\n      ul.appendChild(this.createMenuElem(descName, isDesc, 'e-sortdescending'));\n      const separator = this.parent.createElement('li', {\n        className: 'e-separator e-menu-item e-excel-separator'\n      });\n      ul.appendChild(separator);\n    }\n\n    if (!this.options.isResponsiveFilter) {\n      ul.appendChild(this.createMenuElem(this.getLocalizedLabel('ClearFilter'), isFiltered ? '' : 'e-disabled', icon));\n    }\n\n    if (type !== 'boolean') {\n      ul.appendChild(this.createMenuElem(this.getLocalizedLabel(options[type]), 'e-submenu', isCheckIcon && this.ensureTextFilter() ? 'e-icon-check' : icon + ' e-emptyicon', true));\n    }\n\n    this.menu.appendChild(ul);\n    this.parent.notify(beforeFltrcMenuOpen, {\n      element: this.menu\n    });\n    this.parent.notify(refreshCustomFilterClearBtn, {\n      isFiltered: isFiltered\n    });\n  }\n\n  createMenuElem(val, className, iconName, isSubMenu) {\n    const li = this.parent.createElement('li', {\n      className: className + ' e-menu-item'\n    });\n    li.innerHTML = val;\n    li.insertBefore(this.parent.createElement('span', {\n      className: 'e-menu-icon e-icons ' + iconName\n    }), li.firstChild);\n\n    if (isSubMenu) {\n      li.appendChild(this.parent.createElement('span', {\n        className: 'e-icons e-caret'\n      }));\n    }\n\n    return li;\n  }\n\n  wireExEvents() {\n    EventHandler.add(this.dlg, 'mouseover', this.hoverHandler, this);\n    EventHandler.add(this.dlg, 'click', this.clickExHandler, this);\n  }\n\n  unwireExEvents() {\n    EventHandler.remove(this.dlg, 'mouseover', this.hoverHandler);\n    EventHandler.remove(this.dlg, 'click', this.clickExHandler);\n  }\n\n  clickExHandler(e) {\n    const options = {\n      string: 'TextFilter',\n      date: 'DateFilter',\n      datetime: 'DateTimeFilter',\n      number: 'NumberFilter'\n    };\n    const menuItem = parentsUntil(e.target, 'e-menu-item');\n\n    if (menuItem) {\n      if (this.getLocalizedLabel('ClearFilter') === menuItem.innerText.trim()) {\n        this.clearFilter();\n        this.closeDialog();\n      } else if (this.options.isResponsiveFilter && this.getLocalizedLabel(options[this.options.type]) === menuItem.innerText.trim()) {\n        this.hoverHandler(e);\n      }\n    }\n  }\n\n  destroyCMenu() {\n    this.isCMenuOpen = false;\n\n    if (this.menuObj && !this.menuObj.isDestroyed) {\n      this.menuObj.destroy();\n      remove(this.cmenu);\n      this.parent.notify(renderResponsiveCmenu, {\n        target: null,\n        header: '',\n        isOpen: false,\n        col: this.options.column\n      });\n    }\n  }\n\n  hoverHandler(e) {\n    if (this.options.isResponsiveFilter && e.type === 'mouseover') {\n      return;\n    }\n\n    const target = e.target.querySelector('.e-contextmenu');\n    const li = parentsUntil(e.target, 'e-menu-item');\n    const focused = this.menu.querySelector('.e-focused');\n    let isSubMenu;\n\n    if (focused) {\n      focused.classList.remove('e-focused');\n    }\n\n    if (li) {\n      li.classList.add('e-focused');\n      isSubMenu = li.classList.contains('e-submenu');\n    }\n\n    if (target) {\n      return;\n    }\n\n    if (!isSubMenu) {\n      const submenu = this.menu.querySelector('.e-submenu');\n\n      if (!isNullOrUndefined(submenu)) {\n        submenu.classList.remove('e-selected');\n      }\n\n      this.destroyCMenu();\n    }\n\n    const selectedMenu = this.ensureTextFilter();\n\n    if (!this.isCMenuOpen && isSubMenu) {\n      li.classList.add('e-selected');\n      this.isCMenuOpen = true;\n      const menuOptions = {\n        items: this.getCMenuDS(this.options.type, selectedMenu ? selectedMenu.replace(/\\s/g, '') : undefined),\n        select: this.selectHandler.bind(this),\n        onClose: this.destroyCMenu.bind(this),\n        enableRtl: this.parent.enableRtl,\n        beforeClose: this.preventClose.bind(this),\n        cssClass: this.options.isResponsiveFilter ? 'e-res-contextmenu-wrapper' : ''\n      };\n      this.parent.element.appendChild(this.cmenu);\n      this.menuObj = new ContextMenu(menuOptions, this.cmenu);\n      const client = this.menu.querySelector('.e-submenu').getBoundingClientRect();\n      const pos = {\n        top: 0,\n        left: 0\n      };\n\n      if (this.options.isResponsiveFilter) {\n        const options = {\n          string: 'TextFilter',\n          date: 'DateFilter',\n          datetime: 'DateTimeFilter',\n          number: 'NumberFilter'\n        };\n        const content$$1 = document.querySelector('.e-responsive-dialog > .e-dlg-header-content');\n        const height = content$$1.offsetHeight + 4;\n        this.menuObj.element.style.height = 'calc(100% - ' + height + 'px)';\n        this.menuObj.open(height, 0, document.body);\n        const header = this.getLocalizedLabel(options[this.options.type]);\n        this.parent.notify(renderResponsiveCmenu, {\n          target: this.menuObj.element.parentElement,\n          header: header,\n          isOpen: true\n        });\n      } else {\n        if (Browser.isDevice) {\n          this.isDevice = true;\n          const contextRect = this.getContextBounds();\n          pos.top = (window.innerHeight - contextRect.height) / 2;\n          pos.left = (window.innerWidth - contextRect.width) / 2;\n          this.closeDialog();\n          this.isDevice = false;\n        } else {\n          pos.top = Browser.isIE ? window.pageYOffset + client.top : window.scrollY + client.top;\n          pos.left = this.getCMenuYPosition(this.dlg);\n        }\n\n        this.menuObj.open(pos.top, pos.left, e.target);\n      }\n\n      applyBiggerTheme(this.parent.element, this.menuObj.element.parentElement);\n    }\n  }\n\n  ensureTextFilter() {\n    let selectedMenu;\n    const predicates = this.existingPredicate[this.options.field];\n\n    if (predicates && predicates.length === 2) {\n      if (predicates[0].operator === 'greaterthanorequal' && predicates[1].operator === 'lessthanorequal') {\n        selectedMenu = 'between';\n      } else {\n        selectedMenu = 'customfilter';\n      }\n    } else {\n      if (predicates && predicates.length === 1) {\n        this.optrData = this.customFilterOperators[this.options.type + 'Operator'];\n        selectedMenu = predicates[0].operator;\n      }\n    }\n\n    return selectedMenu;\n  }\n\n  preventClose(args) {\n    if (this.options && this.options.isResponsiveFilter && args.event) {\n      const target = args.event.target;\n      const isFilterBack = target.classList.contains('e-resfilterback') || target.classList.contains('e-res-back-btn') || target.classList.contains('e-menu-item');\n      args.cancel = !isFilterBack;\n    } else {\n      if (args.event instanceof MouseEvent && args.event.target.classList.contains('e-submenu')) {\n        args.cancel = true;\n      }\n    }\n  }\n\n  getContextBounds() {\n    this.menuObj.element.style.display = 'block';\n    return this.menuObj.element.getBoundingClientRect();\n  }\n\n  getCMenuYPosition(target) {\n    const contextWidth = this.getContextBounds().width;\n    const targetPosition = target.getBoundingClientRect();\n    const leftPos = targetPosition.right + contextWidth - this.parent.element.clientWidth;\n    let targetBorder = target.offsetWidth - target.clientWidth;\n    targetBorder = targetBorder ? targetBorder + 1 : 0;\n    return leftPos < 1 ? targetPosition.right + 1 - targetBorder : targetPosition.left - contextWidth - 1 + targetBorder;\n  }\n\n  openDialog(options) {\n    this.updateModel(options);\n    this.getAndSetChkElem(options);\n    this.showDialog(options);\n\n    if (options.cancel) {\n      return;\n    }\n\n    this.dialogObj.dataBind();\n    const filterLength = this.existingPredicate[options.field] && this.existingPredicate[options.field].length || this.options.filteredColumns.filter(col => {\n      return this.options.field === col.field;\n    }).length;\n    this.createMenu(options.type, filterLength > 0, filterLength === 1 || filterLength === 2, options);\n    this.dlg.insertBefore(this.menu, this.dlg.firstChild);\n    this.dlg.classList.add('e-excelfilter');\n\n    if (this.parent.enableRtl) {\n      this.dlg.classList.add('e-rtl');\n    }\n\n    this.dlg.classList.remove('e-checkboxfilter');\n    this.cmenu = this.parent.createElement('ul', {\n      className: 'e-excel-menu'\n    });\n    this.parent.notify(filterDialogCreated, {});\n    this.wireExEvents();\n  }\n\n  closeDialog() {\n    this.destroy();\n  }\n\n  selectHandler(e) {\n    if (e.item) {\n      this.parent.notify(filterCmenuSelect, {});\n      this.menuItem = e.item;\n      this.renderDialogue(e);\n    }\n  }\n  /**\n   * @hidden\n   * @param {MenuEventArgs} e - event args\n   * @returns {void}\n   */\n\n\n  renderDialogue(e) {\n    const target = e ? e.element : undefined;\n    const column = this.options.field;\n    const isComplex = !isNullOrUndefined(column) && isComplexField(column);\n    const complexFieldName = !isNullOrUndefined(column) && getComplexFieldID(column);\n    const mainDiv = this.parent.createElement('div', {\n      className: 'e-xlfl-maindiv',\n      id: isComplex ? complexFieldName + '-xlflmenu' : column + '-xlflmenu'\n    });\n    this.dlgDiv = this.parent.createElement('div', {\n      className: 'e-xlflmenu',\n      id: isComplex ? complexFieldName + '-xlfldlg' : column + '-xlfldlg'\n    });\n\n    if (this.options.isResponsiveFilter) {\n      const responsiveCnt = document.querySelector('.e-resfilter > .e-dlg-content > .e-xl-customfilterdiv');\n      responsiveCnt.appendChild(this.dlgDiv);\n    } else {\n      this.parent.element.appendChild(this.dlgDiv);\n    }\n\n    this.dlgObj = new Dialog({\n      header: this.getLocalizedLabel('CustomFilter'),\n      isModal: true,\n      overlayClick: this.removeDialog.bind(this),\n      showCloseIcon: true,\n      closeOnEscape: false,\n      target: document.body,\n      // target: this.parent.element,\n      visible: false,\n      enableRtl: this.parent.enableRtl,\n      open: () => {\n        const row$$1 = this.dlgObj.element.querySelector('table.e-xlfl-table>tr');\n\n        if (this.options.column.filterTemplate) {\n          row$$1.querySelector('#' + this.options.column.field + '-xlfl-frstvalue').focus();\n        } else {//(row.cells[1].querySelector('input:not([type=hidden])') as HTMLElement).focus();\n        }\n      },\n      close: this.removeDialog.bind(this),\n      created: this.createdDialog.bind(this, target, column),\n      buttons: [{\n        click: this.filterBtnClick.bind(this, column),\n        buttonModel: {\n          content: this.getLocalizedLabel('OKButton'),\n          isPrimary: true,\n          cssClass: 'e-xlfl-okbtn'\n        }\n      }, {\n        click: this.removeDialog.bind(this),\n        buttonModel: {\n          content: this.getLocalizedLabel('CancelButton'),\n          cssClass: 'e-xlfl-cancelbtn'\n        }\n      }],\n      content: mainDiv,\n      width: 430,\n      animationSettings: {\n        effect: 'None'\n      }\n    });\n    const isStringTemplate = 'isStringTemplate';\n    this.dlgObj[isStringTemplate] = true;\n    this.renderResponsiveDialog();\n    this.dlgDiv.setAttribute('aria-label', this.getLocalizedLabel('CustomFilterDialogARIA'));\n    this.childRefs.push(this.dlgObj);\n    this.dlgObj.appendTo(this.dlgDiv);\n  }\n\n  renderResponsiveDialog() {\n    if (this.options.isResponsiveFilter) {\n      const rowResponsiveDlg = document.querySelector('.e-row-responsive-filter');\n\n      if (rowResponsiveDlg) {\n        rowResponsiveDlg.classList.remove('e-row-responsive-filter');\n      }\n\n      this.dlgObj.buttons = [{}];\n      this.dlgObj.header = undefined;\n      this.dlgObj.position = {\n        X: '',\n        Y: ''\n      };\n      this.dlgObj.target = document.querySelector('.e-resfilter > .e-dlg-content > .e-xl-customfilterdiv');\n      this.dlgObj.width = '100%';\n      this.dlgObj.isModal = false;\n      this.dlgObj.showCloseIcon = false;\n    }\n  }\n  /**\n   * @hidden\n   * @returns {void}\n   */\n\n\n  removeDialog() {\n    this.parent.notify(customFilterClose, {});\n\n    if ((this.parent.isReact || this.parent.isVue) && this.parent.destroyTemplate !== undefined) {\n      clearReactVueTemplates(this.parent, ['filterTemplate']);\n    }\n\n    this.removeObjects(this.childRefs);\n    remove(this.dlgDiv);\n    this.parent.notify(filterDialogClose, {});\n  }\n\n  createdDialog(target, column) {\n    this.renderCustomFilter(target, column);\n    this.dlgObj.element.style.left = '0px';\n\n    if (!this.options.isResponsiveFilter) {\n      this.dlgObj.element.style.top = '0px';\n    } else {\n      const content$$1 = document.querySelector('.e-responsive-dialog > .e-dlg-header-content');\n      const height = content$$1.offsetHeight + 4;\n      this.dlgObj.element.style.top = height + 'px';\n    }\n\n    if (!this.options.isResponsiveFilter && Browser.isDevice && window.innerWidth < 440) {\n      this.dlgObj.element.style.width = '90%';\n    }\n\n    this.parent.notify(beforeCustomFilterOpen, {\n      column: column,\n      dialog: this.dialogObj\n    });\n    this.dlgObj.show();\n    applyBiggerTheme(this.parent.element, this.dlgObj.element.parentElement);\n  }\n\n  renderCustomFilter(target, column) {\n    const dlgConetntEle = this.dlgObj.element.querySelector('.e-xlfl-maindiv');\n    const dlgFields = this.parent.createElement('div', {\n      innerHTML: this.getLocalizedLabel('ShowRowsWhere'),\n      className: 'e-xlfl-dlgfields'\n    });\n    dlgConetntEle.appendChild(dlgFields); //column name\n\n    const fieldSet = this.parent.createElement('div', {\n      innerHTML: this.options.displayName,\n      className: 'e-xlfl-fieldset'\n    });\n    dlgConetntEle.appendChild(fieldSet);\n    this.renderFilterUI(column, dlgConetntEle);\n  }\n  /**\n   * @hidden\n   * @param {string} col - Defines column details\n   * @returns {void}\n   */\n\n\n  filterBtnClick(col) {\n    const isComplex = !isNullOrUndefined(col) && isComplexField(col);\n    const complexFieldName = !isNullOrUndefined(col) && getComplexFieldID(col);\n    const colValue = isComplex ? complexFieldName : col;\n    const fValue = this.dlgDiv.querySelector('#' + colValue + '-xlfl-frstvalue').ej2_instances[0];\n    const fOperator = this.dlgDiv.querySelector('#' + colValue + '-xlfl-frstoptr').ej2_instances[0];\n    const sValue = this.dlgDiv.querySelector('#' + colValue + '-xlfl-secndvalue').ej2_instances[0];\n    const sOperator = this.dlgDiv.querySelector('#' + colValue + '-xlfl-secndoptr').ej2_instances[0];\n    let checkBoxValue;\n\n    if (this.options.type === 'string') {\n      const checkBox = this.dlgDiv.querySelector('#' + colValue + '-xlflmtcase').ej2_instances[0];\n      checkBoxValue = checkBox.checked;\n    }\n\n    const andRadio = this.dlgDiv.querySelector('#' + colValue + 'e-xlfl-frstpredicate').ej2_instances[0];\n    let predicate = andRadio.checked ? 'and' : 'or';\n\n    if (sValue.value === null) {\n      predicate = 'or';\n    }\n\n    this.filterByColumn(this.options.field, fOperator.value, fValue.value, predicate, checkBoxValue, this.options.ignoreAccent, sOperator.value, sValue.value);\n    this.removeDialog();\n  }\n  /**\n   * @hidden\n   * Filters grid row by column name with given options.\n   *\n   * @param {string} fieldName - Defines the field name of the filter column.\n   * @param {string} firstOperator - Defines the first operator by how to filter records.\n   * @param {string | number | Date | boolean} firstValue - Defines the first value which is used to filter records.\n   * @param  {string} predicate - Defines the relationship between one filter query with another by using AND or OR predicate.\n   * @param {boolean} matchCase - If ignore case set to true, then filter records with exact match or else\n   * filter records with case insensitive(uppercase and lowercase letters treated as same).\n   * @param {boolean} ignoreAccent - If ignoreAccent set to true, then ignores the diacritic characters or accents when filtering.\n   * @param {string} secondOperator - Defines the second operator by how to filter records.\n   * @param {string | number | Date | boolean} secondValue - Defines the first value which is used to filter records.\n   * @returns {void}\n   */\n\n\n  filterByColumn(fieldName, firstOperator, firstValue, predicate, matchCase, ignoreAccent, secondOperator, secondValue) {\n    const col = this.parent.getColumnByField ? this.parent.getColumnByField(fieldName) : this.options.column;\n    const field = this.isForeignColumn(col) ? col.foreignKeyValue : fieldName;\n    const fColl = [];\n    let mPredicate;\n    fColl.push({\n      field: field,\n      predicate: predicate,\n      matchCase: matchCase,\n      ignoreAccent: ignoreAccent,\n      operator: firstOperator,\n      value: firstValue,\n      type: this.options.type\n    });\n    const arg = {\n      instance: this,\n      handler: this.filterByColumn,\n      arg1: fieldName,\n      arg2: firstOperator,\n      arg3: firstValue,\n      arg4: predicate,\n      arg5: matchCase,\n      arg6: ignoreAccent,\n      arg7: secondOperator,\n      arg8: secondValue,\n      cancel: false\n    };\n    this.parent.notify(fltrPrevent, arg);\n\n    if (arg.cancel) {\n      return;\n    }\n\n    mPredicate = new Predicate(field, firstOperator.toLowerCase(), firstValue, !matchCase, ignoreAccent);\n\n    if (!isNullOrUndefined(secondValue) && !isNullOrUndefined(secondOperator)) {\n      fColl.push({\n        field: field,\n        predicate: predicate,\n        matchCase: matchCase,\n        ignoreAccent: ignoreAccent,\n        operator: secondOperator,\n        value: secondValue,\n        type: this.options.type\n      }); // eslint-disable-next-line max-len\n\n      mPredicate = mPredicate[predicate](field, secondOperator.toLowerCase(), secondValue, !matchCase, ignoreAccent);\n    }\n\n    const args = {\n      action: 'filtering',\n      filterCollection: fColl,\n      field: this.options.field,\n      ejpredicate: mPredicate,\n      actualPredicate: fColl\n    };\n\n    if (this.isForeignColumn(col)) {\n      this.foreignKeyFilter(args, fColl, mPredicate);\n    } else {\n      this.options.handler(args);\n    }\n  } // eslint-disable-next-line max-len\n\n\n  renderOperatorUI(column, table$$1, elementID, predicates, isFirst) {\n    const fieldElement = this.parent.createElement('tr', {\n      className: 'e-xlfl-fields'\n    });\n    table$$1.appendChild(fieldElement);\n    const xlfloptr = this.parent.createElement('td', {\n      className: 'e-xlfl-optr'\n    });\n    fieldElement.appendChild(xlfloptr);\n    const optrDiv = this.parent.createElement('div', {\n      className: 'e-xlfl-optrdiv'\n    });\n    const isComplex = !isNullOrUndefined(column) && isComplexField(column);\n    const complexFieldName = !isNullOrUndefined(column) && getComplexFieldID(column);\n    const optrInput = this.parent.createElement('input', {\n      id: isComplex ? complexFieldName + elementID : column + elementID\n    });\n    optrDiv.appendChild(optrInput);\n    xlfloptr.appendChild(optrDiv);\n    const optr = this.options.type + 'Operator';\n    const dropDatasource = this.customFilterOperators[optr];\n    this.optrData = dropDatasource;\n    let selectedValue = this.dropSelectedVal(this.options.column, predicates, isFirst); //Trailing three dots are sliced.\n\n    let menuText = '';\n\n    if (this.menuItem) {\n      menuText = this.menuItem.text.slice(0, -3);\n\n      if (menuText !== this.getLocalizedLabel('CustomFilter')) {\n        selectedValue = isFirst ? menuText : undefined;\n      }\n\n      if (menuText === this.getLocalizedLabel('Between')) {\n        selectedValue = this.getLocalizedLabel(isFirst ? 'GreaterThanOrEqual' : 'LessThanOrEqual');\n      }\n    }\n\n    const col = this.options.column;\n    const dropOptr = new DropDownList(extend$1({\n      dataSource: dropDatasource,\n      fields: {\n        text: 'text',\n        value: 'value'\n      },\n      text: selectedValue,\n      enableRtl: this.parent.enableRtl\n    }, col.filter.params));\n    this.childRefs.push(dropOptr);\n    const evt = {\n      'open': this.dropDownOpen.bind(this),\n      'change': this.dropDownValueChange.bind(this)\n    };\n    registerEventHandlers(optrInput.id, [open, change], evt, this);\n    dropOptr.addEventListener(open, this.eventHandlers[optrInput.id][open]);\n    dropOptr.addEventListener(change, this.eventHandlers[optrInput.id][change]);\n    dropOptr.appendTo(optrInput);\n    const operator = this.getSelectedValue(selectedValue);\n    return {\n      fieldElement,\n      operator\n    };\n  }\n\n  removeHandlersFromComponent(component) {\n    if (component.element.classList.contains('e-dropdownlist')) {\n      removeEventHandlers(component, [open, change], this);\n    } else if (component.element.classList.contains('e-autocomplete')) {\n      removeEventHandlers(component, [actionComplete, focus], this);\n    }\n  }\n\n  dropDownOpen(args) {\n    args.popup.element.style.zIndex = (this.dialogObj.zIndex + 1).toString();\n  }\n\n  dropDownValueChange(args) {\n    if (args.element.id.includes('-xlfl-frstoptr')) {\n      this.firstOperator = args.value.toString();\n    } else {\n      this.secondOperator = args.value.toString();\n    }\n  }\n  /**\n   * @hidden\n   * @returns {FilterUI} returns filter UI\n   */\n\n\n  getFilterUIInfo() {\n    return {\n      firstOperator: this.firstOperator,\n      secondOperator: this.secondOperator,\n      field: this.options.field\n    };\n  }\n\n  getSelectedValue(text) {\n    const selectedField = new DataManager(this.optrData).executeLocal(new Query().where('text', 'equal', text));\n    return !isNullOrUndefined(selectedField[0]) ? selectedField[0].value : '';\n  }\n\n  dropSelectedVal(col, predicates, isFirst) {\n    let operator;\n\n    if (predicates && predicates.length > 0) {\n      operator = predicates.length === 2 ? isFirst ? predicates[0].operator : predicates[1].operator : isFirst ? predicates[0].operator : undefined;\n    } else if (isFirst && col.type === 'string' && !col.filter.operator) {\n      operator = 'startswith';\n    } else {\n      operator = isFirst ? col.filter.operator || 'equal' : undefined;\n    }\n\n    return this.getSelectedText(operator);\n  }\n\n  getSelectedText(operator) {\n    const selectedField = new DataManager(this.optrData).executeLocal(new Query().where('value', 'equal', operator));\n    return !isNullOrUndefined(selectedField[0]) ? selectedField[0].text : '';\n  }\n\n  renderFilterUI(column, dlgConetntEle) {\n    const predicates = this.existingPredicate[column];\n    const table$$1 = this.parent.createElement('table', {\n      className: 'e-xlfl-table'\n    });\n    dlgConetntEle.appendChild(table$$1);\n    const colGroup$$1 = this.parent.createElement(colGroup);\n    colGroup$$1.innerHTML = '<col style=\"width: 50%\"></col><col style=\"width: 50%\"></col>';\n    table$$1.appendChild(colGroup$$1); //Renders first dropdown\n\n    let optr = this.renderOperatorUI(column, table$$1, '-xlfl-frstoptr', predicates, true);\n    this.firstOperator = optr.operator; //Renders first value\n\n    this.renderFlValueUI(column, optr, '-xlfl-frstvalue', predicates, true);\n    const predicate = this.parent.createElement('tr', {\n      className: 'e-xlfl-predicate'\n    });\n    table$$1.appendChild(predicate); //Renders first radion button\n\n    this.renderRadioButton(column, predicate, predicates); //Renders second dropdown\n\n    optr = this.renderOperatorUI(column, table$$1, '-xlfl-secndoptr', predicates, false);\n    this.secondOperator = optr.operator; //Renders second text box\n\n    this.renderFlValueUI(column, optr, '-xlfl-secndvalue', predicates, false);\n  }\n\n  renderRadioButton(column, tr, predicates) {\n    const td = this.parent.createElement('td', {\n      className: 'e-xlfl-radio',\n      attrs: {\n        'colSpan': '2'\n      }\n    });\n    tr.appendChild(td);\n    const radioDiv = this.parent.createElement('div', {\n      className: 'e-xlfl-radiodiv',\n      attrs: {\n        'style': 'display: inline-block'\n      }\n    });\n    const isComplex = !isNullOrUndefined(column) && isComplexField(column);\n    const complexFieldName = !isNullOrUndefined(column) && getComplexFieldID(column);\n    const frstpredicate = this.parent.createElement('input', {\n      id: isComplex ? complexFieldName + 'e-xlfl-frstpredicate' : column + 'e-xlfl-frstpredicate',\n      attrs: {\n        'type': 'radio'\n      }\n    });\n    const secndpredicate = this.parent.createElement('input', {\n      id: isComplex ? complexFieldName + 'e-xlfl-secndpredicate' : column + 'e-xlfl-secndpredicate',\n      attrs: {\n        'type': 'radio'\n      }\n    }); //appends into div\n\n    radioDiv.appendChild(frstpredicate);\n    radioDiv.appendChild(secndpredicate);\n    td.appendChild(radioDiv);\n\n    if (this.options.type === 'string') {\n      this.renderMatchCase(column, tr, td, '-xlflmtcase', predicates);\n    } // Initialize AND RadioButton component.\n\n\n    const andRadio = new RadioButton({\n      label: this.getLocalizedLabel('AND'),\n      name: 'default',\n      checked: true,\n      enableRtl: this.parent.enableRtl\n    });\n    this.childRefs.push(andRadio); // Initialize OR RadioButton component.\n\n    const orRadio = new RadioButton({\n      label: this.getLocalizedLabel('OR'),\n      name: 'default',\n      enableRtl: this.parent.enableRtl\n    });\n    this.childRefs.push(orRadio);\n    const flValue = predicates && predicates.length === 2 ? predicates[1].predicate : 'and';\n\n    if (flValue === 'and') {\n      andRadio.checked = true;\n      orRadio.checked = false;\n    } else {\n      orRadio.checked = true;\n      andRadio.checked = false;\n    } // Render initialized RadioButton.\n\n\n    andRadio.appendTo(frstpredicate);\n    orRadio.appendTo(secndpredicate);\n    andRadio.element.nextElementSibling.classList.add('e-xlfl-radio-and');\n    orRadio.element.nextElementSibling.classList.add('e-xlfl-radio-or');\n  } // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n\n  removeObjects(elements) {\n    for (const obj of elements) {\n      if (obj && !obj.isDestroyed) {\n        this.removeHandlersFromComponent(obj);\n        obj.destroy();\n      }\n    }\n  } // eslint-disable-next-line max-len\n\n\n  renderFlValueUI(column, optr, elementId, predicates, isFirst) {\n    const value = this.parent.createElement('td', {\n      className: 'e-xlfl-value'\n    });\n    optr.fieldElement.appendChild(value);\n    const isComplex = !isNullOrUndefined(column) && isComplexField(column);\n    const complexFieldName = !isNullOrUndefined(column) && getComplexFieldID(column);\n    const valueDiv = this.parent.createElement('div', {\n      className: 'e-xlfl-valuediv'\n    });\n    const isFilteredCol = this.options.filteredColumns.some(col => {\n      return column === col.field;\n    });\n    const fltrPredicates = this.options.filteredColumns.filter(col => col.field === column);\n\n    if (this.options.column.filterTemplate) {\n      let data = {};\n      const columnObj = this.options.column;\n\n      if (isFilteredCol && elementId) {\n        data = this.getExcelFilterData(elementId, data, columnObj, predicates, fltrPredicates);\n      }\n\n      const isReactCompiler = this.parent.isReact && typeof this.options.column.filterTemplate !== 'string';\n      const tempID = this.parent.element.id + columnObj.uid + 'filterTemplate';\n\n      if (isReactCompiler) {\n        this.options.column.getFilterTemplate()(data, this.parent, 'filterTemplate', tempID, null, null, valueDiv);\n        this.parent.renderTemplates();\n      } else {\n        const element = this.options.column.getFilterTemplate()(data, this.parent, 'filterTemplate', tempID);\n        appendChildren(valueDiv, element);\n      } // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n\n      (this.parent.isAngular ? valueDiv.children[0] : valueDiv.querySelector('input')).id = isComplex ? complexFieldName + elementId : column + elementId;\n      value.appendChild(valueDiv);\n    } else {\n      const valueInput = this.parent.createElement('input', {\n        id: isComplex ? complexFieldName + elementId : column + elementId\n      });\n      valueDiv.appendChild(valueInput);\n      value.appendChild(valueDiv);\n      let flValue;\n      let predicate;\n\n      if (predicates && predicates.length > 0) {\n        predicate = predicates.length === 2 ? isFirst ? predicates[0] : predicates[1] : isFirst ? predicates[0] : undefined;\n        flValue = predicate && predicate.operator === optr.operator ? predicate.value : undefined;\n\n        if (isNullOrUndefined(flValue)) {\n          flValue = undefined;\n        }\n      }\n\n      const types = {\n        'string': this.renderAutoComplete.bind(this),\n        'number': this.renderNumericTextBox.bind(this),\n        'date': this.renderDate.bind(this),\n        'datetime': this.renderDateTime.bind(this)\n      };\n      types[this.options.type](this.options, column, valueInput, flValue, this.parent.enableRtl);\n    }\n  }\n\n  getExcelFilterData(elementId, data, columnObj, predicates, fltrPredicates) {\n    const predIndex = elementId === '-xlfl-frstvalue' ? 0 : 1;\n\n    if (elementId === '-xlfl-frstvalue' || fltrPredicates.length > 1) {\n      data = {\n        column: predicates instanceof Array ? predicates[predIndex] : predicates\n      };\n      const indx = this.options.column.columnData && fltrPredicates.length > 1 ? this.options.column.columnData.length === 1 ? 0 : 1 : predIndex;\n      data[this.options.field] = columnObj.foreignKeyValue ? this.options.column.columnData[indx][columnObj.foreignKeyValue] : fltrPredicates[indx].value;\n\n      if (this.options.foreignKeyValue) {\n        data[this.options.foreignKeyValue] = this.options.column.columnData[indx][columnObj.foreignKeyValue];\n      }\n    }\n\n    return data;\n  } // eslint-disable-next-line max-len\n\n\n  renderMatchCase(column, tr, matchCase, elementId, predicates) {\n    const matchCaseDiv = this.parent.createElement('div', {\n      className: 'e-xlfl-matchcasediv',\n      attrs: {\n        'style': 'display: inline-block'\n      }\n    });\n    const isComplex = !isNullOrUndefined(column) && isComplexField(column);\n    const complexFieldName = !isNullOrUndefined(column) && getComplexFieldID(column);\n    const matchCaseInput = this.parent.createElement('input', {\n      id: isComplex ? complexFieldName + elementId : column + elementId,\n      attrs: {\n        'type': 'checkbox'\n      }\n    });\n    matchCaseDiv.appendChild(matchCaseInput);\n    matchCase.appendChild(matchCaseDiv);\n    const flValue = predicates && predicates.length > 0 ? predicates && predicates.length === 2 ? predicates[1].matchCase : predicates[0].matchCase : false; // Initialize Match Case check box.\n\n    const checkbox = new CheckBox({\n      label: this.getLocalizedLabel('MatchCase'),\n      enableRtl: this.parent.enableRtl,\n      checked: flValue\n    });\n    this.childRefs.push(checkbox); // Render initialized CheckBox.\n\n    checkbox.appendTo(matchCaseInput);\n  } // eslint-disable-next-line max-len\n\n\n  renderDate(options, column, inputValue, fValue, isRtl) {\n    const format = getCustomDateFormat(options.format, options.type) || options.format;\n    const datePicker = new DatePicker(extend$1({\n      format: format,\n      cssClass: 'e-popup-flmenu',\n      placeholder: this.getLocalizedLabel('CustomFilterDatePlaceHolder'),\n      width: '100%',\n      enableRtl: isRtl,\n      value: new Date(fValue),\n      locale: this.parent.locale\n    }, options.column.filter.params));\n    this.childRefs.push(datePicker);\n    datePicker.appendTo(inputValue);\n  } // eslint-disable-next-line max-len\n\n\n  renderDateTime(options, column, inputValue, fValue, isRtl) {\n    const format = getCustomDateFormat(options.format, options.type);\n    const dateTimePicker = new DateTimePicker(extend$1({\n      format: format,\n      cssClass: 'e-popup-flmenu',\n      placeholder: this.getLocalizedLabel('CustomFilterDatePlaceHolder'),\n      width: '100%',\n      enableRtl: isRtl,\n      value: new Date(fValue),\n      locale: this.parent.locale\n    }, options.column.filter.params));\n    this.childRefs.push(dateTimePicker);\n    dateTimePicker.appendTo(inputValue);\n  }\n\n  completeAction(e) {\n    e.result = distinctStringValues(e.result);\n  } // eslint-disable-next-line max-len\n\n\n  renderNumericTextBox(options, column, inputValue, fValue, isRtl) {\n    const numericTextBox = new NumericTextBox(extend$1({\n      format: options.format,\n      placeholder: this.getLocalizedLabel('CustomFilterPlaceHolder'),\n      enableRtl: isRtl,\n      value: fValue,\n      locale: this.parent.locale\n    }, options.column.filter.params));\n    this.childRefs.push(numericTextBox);\n    numericTextBox.appendTo(inputValue);\n  } // eslint-disable-next-line max-len\n\n\n  renderAutoComplete(options, column, inputValue, fValue, isRtl) {\n    const colObj = this.options.column;\n    const isForeignColumn = this.isForeignColumn(colObj);\n    const dataSource = isForeignColumn ? colObj.dataSource : options.dataSource;\n    const fields = {\n      value: isForeignColumn ? colObj.foreignKeyValue : column\n    };\n    const actObj = new AutoComplete(extend$1({\n      dataSource: dataSource instanceof DataManager ? dataSource : new DataManager(dataSource),\n      fields: fields,\n      query: this.getQuery(),\n      sortOrder: 'Ascending',\n      locale: this.parent.locale,\n      cssClass: 'e-popup-flmenu',\n      autofill: true,\n      placeholder: this.getLocalizedLabel('CustomFilterPlaceHolder'),\n      enableRtl: isRtl,\n      text: fValue\n    }, colObj.filter.params));\n\n    if (dataSource && 'result' in dataSource) {\n      const defObj = eventPromise({\n        requestType: 'stringfilterrequest'\n      }, this.getQuery());\n      this.parent.trigger(dataStateChange, defObj.state);\n      const def = defObj.deffered;\n      def.promise.then(e => {\n        actObj.dataSource = new DataManager(e);\n      });\n    }\n\n    this.childRefs.push(actObj);\n    const evt = {\n      'actionComplete': this.acActionComplete(actObj, column),\n      'focus': this.acFocus(actObj, column, options, inputValue)\n    };\n    registerEventHandlers(inputValue.id, [actionComplete, focus], evt, this);\n    actObj.addEventListener(focus, this.eventHandlers[inputValue.id][focus]);\n    actObj.addEventListener(actionComplete, this.eventHandlers[inputValue.id][actionComplete]);\n    actObj.appendTo(inputValue);\n  }\n\n  acActionComplete(actObj, column) {\n    return e => {\n      const isComplex = !isNullOrUndefined(column) && isComplexField(column);\n      e.result = e.result.filter((obj, index, arr) => {\n        return arr.map(mapObject => {\n          return isComplex ? performComplexDataOperation(actObj.fields.value, mapObject) : mapObject[actObj.fields.value];\n        }).indexOf(isComplex ? performComplexDataOperation(actObj.fields.value, obj) : obj[actObj.fields.value]) === index;\n      });\n    };\n  }\n\n  acFocus(actObj, column, options, inputValue) {\n    return () => {\n      const isComplex = !isNullOrUndefined(column) && isComplexField(column);\n      const complexFieldName = !isNullOrUndefined(column) && getComplexFieldID(column);\n      const columnvalue = isComplex ? complexFieldName : column;\n      actObj.filterType = this.dlgDiv.querySelector('#' + columnvalue + (inputValue.id === columnvalue + '-xlfl-frstvalue' ? '-xlfl-frstoptr' : '-xlfl-secndoptr')).ej2_instances[0].value;\n      actObj.ignoreCase = options.type === 'string' ? !this.dlgDiv.querySelector('#' + columnvalue + '-xlflmtcase').ej2_instances[0].checked : true;\n      actObj.filterType = !isNullOrUndefined(actObj.filterType) ? actObj.filterType : 'equal';\n    };\n  }\n\n}\n/**\n * Common export\n */\n\n/**\n * Base export\n */\n\n/**\n *\n * The `Sort` module is used to handle sorting action.\n */\n\n\nclass Sort {\n  /**\n   * Constructor for Grid sorting module\n   *\n   * @param {IGrid} parent - specifies the IGrid\n   * @param {SortSettings} sortSettings - specifies the SortSettings\n   * @param {string[]} sortedColumns - specifies the string\n   * @param {ServiceLocator} locator - specifies the ServiceLocator\n   * @hidden\n   */\n  constructor(parent, sortSettings, sortedColumns, locator) {\n    this.contentRefresh = true;\n    this.isModelChanged = true;\n    this.aria = new AriaService();\n    this.currentTarget = null;\n    this.parent = parent;\n    this.sortSettings = sortSettings;\n    this.sortedColumns = sortedColumns;\n    this.serviceLocator = locator;\n    this.focus = locator.getService('focus');\n    this.addEventListener();\n    this.setFullScreenDialog();\n  }\n  /**\n   * The function used to update sortSettings\n   *\n   * @returns {void}\n   * @hidden\n   */\n\n\n  updateModel() {\n    const sortedColumn = {\n      field: this.columnName,\n      direction: this.direction\n    };\n    let index;\n    const gCols = this.parent.groupSettings.columns;\n    let flag = false;\n\n    if (!this.isMultiSort) {\n      if (!gCols.length) {\n        this.sortSettings.columns = [sortedColumn];\n      } else {\n        const sortedCols = [];\n\n        for (let i = 0, len = gCols.length; i < len; i++) {\n          index = this.getSortedColsIndexByField(gCols[i], sortedCols);\n\n          if (this.columnName === gCols[i]) {\n            flag = true;\n            sortedCols.push(sortedColumn);\n          } else {\n            const sCol = this.getSortColumnFromField(gCols[i]);\n            sortedCols.push({\n              field: sCol.field,\n              direction: sCol.direction,\n              isFromGroup: sCol.isFromGroup\n            });\n          }\n        }\n\n        if (!flag) {\n          sortedCols.push(sortedColumn);\n        }\n\n        this.sortSettings.columns = sortedCols;\n      }\n    } else {\n      index = this.getSortedColsIndexByField(this.columnName);\n\n      if (index > -1) {\n        this.sortSettings.columns.splice(index, 1);\n      }\n\n      this.sortSettings.columns.push(sortedColumn); // eslint-disable-next-line no-self-assign\n\n      this.sortSettings.columns = this.sortSettings.columns;\n    }\n\n    this.parent.dataBind();\n    this.lastSortedCol = this.columnName;\n  }\n  /**\n   * The function used to trigger onActionComplete\n   *\n   * @param {NotifyArgs} e - specifies the NotifyArgs\n   * @returns {void}\n   * @hidden\n   */\n\n\n  onActionComplete(e) {\n    const args = !this.isRemove ? {\n      columnName: this.columnName,\n      direction: this.direction,\n      requestType: 'sorting',\n      type: actionComplete\n    } : {\n      requestType: 'sorting',\n      type: actionComplete\n    };\n    this.isRemove = false;\n    this.parent.trigger(actionComplete, extend(e, args));\n  }\n  /**\n   * Sorts a column with the given options.\n   *\n   * @param {string} columnName - Defines the column name to sort.\n   * @param {SortDirection} direction - Defines the direction of sorting field.\n   * @param {boolean} isMultiSort - Specifies whether the previously sorted columns are to be maintained.\n   * @returns {void}\n   */\n\n\n  sortColumn(columnName, direction, isMultiSort) {\n    const gObj = this.parent;\n\n    if (this.parent.getColumnByField(columnName).allowSorting === false || this.parent.isContextMenuOpen()) {\n      this.parent.log('action_disabled_column', {\n        moduleName: this.getModuleName(),\n        columnName: columnName\n      });\n      return;\n    }\n\n    if (!gObj.allowMultiSorting) {\n      isMultiSort = gObj.allowMultiSorting;\n    }\n\n    if (this.isActionPrevent()) {\n      gObj.notify(preventBatch, {\n        instance: this,\n        handler: this.sortColumn,\n        arg1: columnName,\n        arg2: direction,\n        arg3: isMultiSort\n      });\n      return;\n    }\n\n    this.backupSettings();\n    this.columnName = columnName;\n    this.direction = direction;\n    this.isMultiSort = isMultiSort;\n    this.removeSortIcons();\n    this.updateSortedCols(columnName, isMultiSort);\n    this.updateModel();\n  }\n\n  setFullScreenDialog() {\n    if (this.serviceLocator) {\n      this.serviceLocator.registerAdaptiveService(this, this.parent.enableAdaptiveUI, ResponsiveDialogAction.isSort);\n    }\n  }\n\n  backupSettings() {\n    this.lastSortedCols = iterateExtend(this.sortSettings.columns);\n    this.lastCols = this.sortedColumns;\n  }\n\n  restoreSettings() {\n    this.isModelChanged = false;\n    this.isMultiSort = true;\n    this.parent.setProperties({\n      sortSettings: {\n        columns: this.lastSortedCols\n      }\n    }, true); //this.parent.sortSettings.columns =  this.lastSortedCols;\n\n    this.sortedColumns = this.lastCols;\n    this.isModelChanged = true;\n  }\n\n  updateSortedCols(columnName, isMultiSort) {\n    if (!isMultiSort) {\n      if (this.parent.allowGrouping) {\n        for (let i = 0, len = this.sortedColumns.length; i < len; i++) {\n          if (this.parent.groupSettings.columns.indexOf(this.sortedColumns[i]) < 0) {\n            this.sortedColumns.splice(i, 1);\n            len--;\n            i--;\n          }\n        }\n      } else {\n        this.sortedColumns.splice(0, this.sortedColumns.length);\n      }\n    }\n\n    if (this.sortedColumns.indexOf(columnName) < 0) {\n      this.sortedColumns.push(columnName);\n    }\n  }\n  /**\n   * @param {NotifyArgs} e - specifies the NotifyArgs\n   * @returns {void}\n   * @hidden\n   */\n\n\n  onPropertyChanged(e) {\n    if (e.module !== this.getModuleName()) {\n      return;\n    }\n\n    if (this.contentRefresh) {\n      const args = this.sortSettings.columns.length ? {\n        columnName: this.columnName,\n        direction: this.direction,\n        requestType: 'sorting',\n        type: actionBegin,\n        target: this.currentTarget,\n        cancel: false\n      } : {\n        requestType: 'sorting',\n        type: actionBegin,\n        cancel: false,\n        target: this.currentTarget\n      };\n      this.parent.notify(modelChanged, args);\n    }\n\n    this.refreshSortSettings();\n    this.removeSortIcons();\n    this.addSortIcons();\n  }\n\n  refreshSortSettings() {\n    this.sortedColumns.length = 0;\n    const sortColumns = this.sortSettings.columns;\n\n    for (let i = 0; i < sortColumns.length; i++) {\n      if (!sortColumns[i].isFromGroup) {\n        this.sortedColumns.push(sortColumns[i].field);\n      }\n    }\n  }\n  /**\n   * Clears all the sorted columns of the Grid.\n   *\n   * @returns {void}\n   */\n\n\n  clearSorting() {\n    const cols = getActualPropFromColl(this.sortSettings.columns);\n\n    if (this.isActionPrevent()) {\n      this.parent.notify(preventBatch, {\n        instance: this,\n        handler: this.clearSorting\n      });\n      return;\n    }\n\n    for (let i = 0, len = cols.length; i < len; i++) {\n      this.removeSortColumn(cols[i].field);\n    }\n  }\n\n  isActionPrevent() {\n    return isActionPrevent(this.parent);\n  }\n  /**\n   * Remove sorted column by field name.\n   *\n   * @param {string} field - Defines the column field name to remove sort.\n   * @returns {void}\n   * @hidden\n   */\n\n\n  removeSortColumn(field) {\n    const gObj = this.parent;\n    const cols = this.sortSettings.columns;\n\n    if (cols.length === 0 && this.sortedColumns.indexOf(field) < 0) {\n      return;\n    }\n\n    if (this.isActionPrevent()) {\n      this.parent.notify(preventBatch, {\n        instance: this,\n        handler: this.removeSortColumn,\n        arg1: field\n      });\n      return;\n    }\n\n    this.backupSettings();\n    this.removeSortIcons();\n    const args = {\n      requestType: 'sorting',\n      type: actionBegin,\n      target: this.currentTarget\n    };\n\n    for (let i = 0, len = cols.length; i < len; i++) {\n      if (cols[i].field === field) {\n        if (gObj.allowGrouping && gObj.groupSettings.columns.indexOf(cols[i].field) > -1) {\n          continue;\n        }\n\n        this.sortedColumns.splice(this.sortedColumns.indexOf(cols[i].field), 1);\n        cols.splice(i, 1);\n        this.isRemove = true;\n\n        if (this.isModelChanged) {\n          this.parent.notify(modelChanged, args);\n        }\n\n        break;\n      }\n    }\n\n    if (!args.cancel) {\n      this.addSortIcons();\n    }\n  }\n\n  getSortedColsIndexByField(field, sortedColumns) {\n    const cols = sortedColumns ? sortedColumns : this.sortSettings.columns;\n\n    for (let i = 0, len = cols.length; i < len; i++) {\n      if (cols[i].field === field) {\n        return i;\n      }\n    }\n\n    return -1;\n  }\n  /**\n   * For internal use only - Get the module name.\n   *\n   * @returns {string} returns the module name\n   * @private\n   */\n\n\n  getModuleName() {\n    return 'sort';\n  }\n\n  initialEnd() {\n    this.parent.off(contentReady, this.initialEnd);\n\n    if (this.parent.getColumns().length && this.sortSettings.columns.length) {\n      const gObj = this.parent;\n      this.contentRefresh = false;\n      this.isMultiSort = this.sortSettings.columns.length > 1;\n\n      for (const col of gObj.sortSettings.columns.slice()) {\n        if (this.sortedColumns.indexOf(col.field) > -1) {\n          this.sortColumn(col.field, col.direction, true);\n        }\n      }\n\n      this.isMultiSort = false;\n      this.contentRefresh = true;\n    }\n  }\n  /**\n   * @returns {void}\n   * @hidden\n   */\n\n\n  addEventListener() {\n    if (this.parent.isDestroyed) {\n      return;\n    }\n\n    this.evtHandlers = [{\n      event: setFullScreenDialog,\n      handler: this.setFullScreenDialog\n    }, {\n      event: contentReady,\n      handler: this.initialEnd\n    }, {\n      event: sortComplete,\n      handler: this.onActionComplete\n    }, {\n      event: inBoundModelChanged,\n      handler: this.onPropertyChanged\n    }, {\n      event: click,\n      handler: this.clickHandler\n    }, {\n      event: headerRefreshed,\n      handler: this.refreshSortIcons\n    }, {\n      event: keyPressed,\n      handler: this.keyPressed\n    }, {\n      event: cancelBegin,\n      handler: this.cancelBeginEvent\n    }, {\n      event: destroy,\n      handler: this.destroy\n    }];\n    addRemoveEventListener(this.parent, this.evtHandlers, true, this);\n  }\n  /**\n   * @returns {void}\n   * @hidden\n   */\n\n\n  removeEventListener() {\n    if (this.parent.isDestroyed) {\n      return;\n    }\n\n    addRemoveEventListener(this.parent, this.evtHandlers, false);\n  }\n  /**\n   * To destroy the sorting\n   *\n   * @returns {void}\n   * @hidden\n   */\n\n\n  destroy() {\n    this.isModelChanged = false;\n    const gridElement = this.parent.element;\n\n    if (!gridElement || !gridElement.querySelector('.' + gridHeader) && !gridElement.querySelector('.' + gridContent)) {\n      return;\n    }\n\n    if (this.parent.element.querySelector('.e-gridpopup').getElementsByClassName('e-sortdirect').length) {\n      this.parent.element.querySelector('.e-gridpopup').style.display = 'none';\n    } // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n\n    if (!this.parent.refreshing && (this.parent.isDestroyed || !this.parent.allowSorting)) {\n      this.clearSorting();\n    }\n\n    this.isModelChanged = true;\n    this.removeEventListener();\n  }\n\n  cancelBeginEvent(e) {\n    if (e.requestType === 'sorting') {\n      this.restoreSettings();\n      this.refreshSortIcons();\n      this.isMultiSort = true;\n    }\n  }\n\n  clickHandler(e) {\n    const gObj = this.parent;\n    this.currentTarget = null;\n    this.popUpClickHandler(e);\n    const target = closest(e.target, '.e-headercell');\n\n    if (target && !e.target.classList.contains('e-grptogglebtn') && !target.classList.contains('e-resized') && !e.target.classList.contains('e-rhandler') && !e.target.classList.contains('e-columnmenu') && !e.target.classList.contains('e-filtermenudiv') && !parentsUntil(e.target, 'e-stackedheadercell') && !(gObj.allowSelection && gObj.selectionSettings.allowColumnSelection && e.target.classList.contains('e-headercell'))) {\n      const gObj = this.parent;\n      const colObj = gObj.getColumnByUid(target.querySelector('.e-headercelldiv').getAttribute('e-mappinguid'));\n\n      if (colObj.type !== 'checkbox') {\n        this.initiateSort(target, e, colObj);\n\n        if (Browser.isDevice) {\n          this.showPopUp(e);\n        }\n      }\n    }\n\n    if (target) {\n      target.classList.remove('e-resized');\n    }\n\n    if (parentsUntil(e.target, 'e-excel-ascending') || parentsUntil(e.target, 'e-excel-descending')) {\n      const colUid = closest(e.target, '.e-filter-popup').getAttribute('uid');\n      const direction = isNullOrUndefined(parentsUntil(e.target, 'e-excel-descending')) ? 'Ascending' : 'Descending';\n      this.sortColumn(gObj.getColumnByUid(colUid).field, direction, false);\n    }\n  }\n\n  keyPressed(e) {\n    const ele = e.target;\n\n    if (!this.parent.isEdit && (e.action === 'enter' || e.action === 'ctrlEnter' || e.action === 'shiftEnter') && closest(ele, '.e-headercell')) {\n      const target = this.focus.getFocusedElement();\n\n      if (isNullOrUndefined(target) || !target.classList.contains('e-headercell') || !target.querySelector('.e-headercelldiv')) {\n        return;\n      }\n\n      const col = this.parent.getColumnByUid(target.querySelector('.e-headercelldiv').getAttribute('e-mappinguid'));\n      this.initiateSort(target, e, col);\n    }\n  }\n\n  initiateSort(target, e, column) {\n    const gObj = this.parent;\n    const field = column.field;\n    this.currentTarget = e.target;\n    const direction = !target.getElementsByClassName('e-ascending').length ? 'Ascending' : 'Descending';\n    this.isMultiSort = e.ctrlKey || this.enableSortMultiTouch || navigator.userAgent.indexOf('Mac OS') !== -1 && e.metaKey;\n\n    if (e.shiftKey || this.sortSettings.allowUnsort && target.getElementsByClassName('e-descending').length && !(gObj.groupSettings.columns.indexOf(field) > -1)) {\n      this.removeSortColumn(field);\n    } else {\n      this.sortColumn(field, direction, this.isMultiSort);\n    }\n  }\n\n  showPopUp(e) {\n    const target = closest(e.target, '.e-headercell');\n\n    if (this.parent.allowMultiSorting && (!isNullOrUndefined(target) || this.parent.isContextMenuOpen())) {\n      setCssInGridPopUp(this.parent.element.querySelector('.e-gridpopup'), e, 'e-sortdirect e-icons e-icon-sortdirect' + (this.sortedColumns.length > 1 ? ' e-spanclicked' : ''));\n    }\n  }\n\n  popUpClickHandler(e) {\n    const target = e.target;\n\n    if (closest(target, '.e-headercell') || e.target.classList.contains(rowCell) || closest(target, '.e-gridpopup')) {\n      if (target.classList.contains('e-sortdirect')) {\n        if (!target.classList.contains('e-spanclicked')) {\n          target.classList.add('e-spanclicked');\n          this.enableSortMultiTouch = true;\n        } else {\n          target.classList.remove('e-spanclicked');\n          this.enableSortMultiTouch = false;\n          this.parent.element.querySelector('.e-gridpopup').style.display = 'none';\n        }\n      }\n    } else {\n      this.parent.element.querySelector('.e-gridpopup').style.display = 'none';\n    }\n  }\n\n  addSortIcons() {\n    const gObj = this.parent;\n    let header;\n    let filterElement;\n    const cols = this.sortSettings.columns;\n    const fieldNames = this.parent.getColumns().map(c => c.field);\n\n    for (let i = 0, len = cols.length; i < len; i++) {\n      header = gObj.getColumnHeaderByField(cols[i].field);\n\n      if (fieldNames.indexOf(cols[i].field) === -1 || isNullOrUndefined(header)) {\n        continue;\n      }\n\n      this.aria.setSort(header, cols[i].direction.toLowerCase());\n\n      if (this.isMultiSort && cols.length > 1) {\n        header.querySelector('.e-headercelldiv').insertBefore(this.parent.createElement('span', {\n          className: 'e-sortnumber',\n          innerHTML: (i + 1).toString()\n        }), header.querySelector('.e-headertext'));\n      }\n\n      filterElement = header.querySelector('.e-sortfilterdiv');\n\n      if (cols[i].direction === 'Ascending') {\n        classList(filterElement, ['e-ascending', 'e-icon-ascending'], []);\n      } else {\n        classList(filterElement, ['e-descending', 'e-icon-descending'], []);\n      }\n    }\n  }\n\n  removeSortIcons(position) {\n    const gObj = this.parent;\n    let header;\n    const cols = this.sortSettings.columns;\n    const fieldNames = this.parent.getColumns().map(c => c.field);\n\n    for (let i = position ? position : 0, len = !isNullOrUndefined(position) ? position + 1 : cols.length; i < len; i++) {\n      header = gObj.getColumnHeaderByField(cols[i].field);\n\n      if (isNullOrUndefined(header) || gObj.allowGrouping && gObj.groupSettings.columns.indexOf(cols[i].field) > -1 && !header.querySelector('.e-sortfilterdiv')) {\n        continue;\n      }\n\n      if (fieldNames.indexOf(cols[i].field) === -1) {\n        continue;\n      }\n\n      this.aria.setSort(header, 'none');\n      classList(header.querySelector('.e-sortfilterdiv'), [], ['e-descending', 'e-icon-descending', 'e-ascending', 'e-icon-ascending']);\n\n      if (header.querySelector('.e-sortnumber')) {\n        header.querySelector('.e-headercelldiv').removeChild(header.querySelector('.e-sortnumber'));\n      }\n    }\n  }\n\n  getSortColumnFromField(field) {\n    for (let i = 0, len = this.sortSettings.columns.length; i < len; i++) {\n      if (this.sortSettings.columns[i].field === field) {\n        return this.sortSettings.columns[i];\n      }\n    }\n\n    return false;\n  }\n\n  updateAriaAttr() {\n    const fieldNames = this.parent.getColumns().map(c => c.field);\n\n    for (const col of this.sortedColumns) {\n      if (fieldNames.indexOf(col) === -1) {\n        continue;\n      }\n\n      const header = this.parent.getColumnHeaderByField(col);\n      this.aria.setSort(header, this.getSortColumnFromField(col).direction);\n    }\n  }\n\n  refreshSortIcons(params = {\n    args: {\n      isFrozen: false\n    }\n  }) {\n    if (!params.args.isFrozen) {\n      this.removeSortIcons();\n      this.isMultiSort = true;\n      this.removeSortIcons();\n      this.addSortIcons();\n      this.isMultiSort = false;\n      this.updateAriaAttr();\n    }\n  }\n  /**\n   * To show the responsive custom sort dialog\n   *\n   * @param {boolean} enable - specifes dialog open\n   * @returns {void}\n   * @hidden\n   */\n\n\n  showCustomSort(enable) {\n    this.responsiveDialogRenderer.isCustomDialog = enable;\n    this.responsiveDialogRenderer.showResponsiveDialog();\n  }\n\n}\n/**\n * `NumericContainer` module handles rendering and refreshing numeric container.\n */\n\n\nclass NumericContainer {\n  /**\n   * Constructor for numericContainer module\n   *\n   * @param {Pager} pagerModule - specifies the pagerModule\n   * @hidden\n   */\n  constructor(pagerModule) {\n    this.pagerModule = pagerModule;\n  }\n  /**\n   * The function is used to render numericContainer\n   *\n   * @returns {void}\n   * @hidden\n   */\n\n\n  render() {\n    this.pagerElement = this.pagerModule.element;\n    this.renderNumericContainer();\n    this.refreshNumericLinks();\n    this.wireEvents();\n  }\n  /**\n   * Refreshes the numeric container of Pager.\n   *\n   * @returns {void}\n   */\n\n\n  refresh() {\n    this.pagerModule.updateTotalPages();\n\n    if (this.links.length) {\n      this.updateLinksHtml();\n    }\n\n    this.updateStyles();\n  }\n  /**\n   * The function is used to refresh refreshNumericLinks\n   *\n   * @returns {void}\n   * @hidden\n   */\n\n\n  refreshNumericLinks() {\n    let link;\n    const pagerObj = this.pagerModule;\n    const div = pagerObj.element.querySelector('.e-numericcontainer');\n    const frag = document.createDocumentFragment();\n    div.innerHTML = '';\n\n    for (let i = 1; i <= pagerObj.pageCount; i++) {\n      link = createElement('a', {\n        className: 'e-link e-numericitem e-spacing e-pager-default',\n        attrs: {\n          role: 'link',\n          tabindex: '-1',\n          'aria-label': 'Goto Page ' + i,\n          href: 'javascript:void(0);',\n          name: 'Goto page' + i\n        }\n      });\n\n      if (pagerObj.currentPage === i) {\n        classList(link, ['e-currentitem', 'e-active'], ['e-pager-default']);\n      }\n\n      frag.appendChild(link);\n    }\n\n    div.appendChild(frag);\n    this.links = [].slice.call(div.childNodes);\n  }\n  /**\n   * Binding events to the element while component creation\n   *\n   * @returns {void}\n   * @hidden\n   */\n\n\n  wireEvents() {\n    EventHandler.add(this.pagerElement, 'click', this.clickHandler, this);\n  }\n  /**\n   * Unbinding events from the element while component destroy\n   *\n   * @returns {void}\n   * @hidden\n   */\n\n\n  unwireEvents() {\n    EventHandler.remove(this.pagerModule.element, 'click', this.clickHandler);\n  }\n  /**\n   * To destroy the PagerMessage\n   *\n   * @function destroy\n   * @returns {void}\n   * @hidden\n   */\n\n\n  destroy() {\n    this.unwireEvents();\n  }\n\n  renderNumericContainer() {\n    this.element = createElement('div', {\n      className: 'e-pagercontainer',\n      attrs: {\n        'role': 'navigation'\n      }\n    });\n    this.renderFirstNPrev(this.element);\n    this.renderPrevPagerSet(this.element);\n    this.element.appendChild(createElement('div', {\n      className: 'e-numericcontainer'\n    }));\n    this.renderNextPagerSet(this.element);\n    this.renderNextNLast(this.element);\n    this.pagerModule.element.appendChild(this.element);\n  }\n\n  renderFirstNPrev(pagerContainer) {\n    this.first = createElement('div', {\n      className: 'e-first e-icons e-icon-first',\n      attrs: {\n        title: this.pagerModule.getLocalizedLabel('firstPageTooltip'),\n        'aria-label': this.pagerModule.getLocalizedLabel('firstPageTooltip'),\n        tabindex: '-1'\n      }\n    });\n    this.prev = createElement('div', {\n      className: 'e-prev e-icons e-icon-prev',\n      attrs: {\n        title: this.pagerModule.getLocalizedLabel('previousPageTooltip'),\n        'aria-label': this.pagerModule.getLocalizedLabel('previousPageTooltip'),\n        tabindex: '-1'\n      }\n    });\n    append([this.first, this.prev], pagerContainer);\n  }\n\n  renderPrevPagerSet(pagerContainer) {\n    const prevPager = createElement('div');\n    this.PP = createElement('a', {\n      className: 'e-link e-pp e-spacing',\n      innerHTML: '...',\n      attrs: {\n        title: this.pagerModule.getLocalizedLabel('previousPagerTooltip'),\n        role: 'link',\n        'aria-label': this.pagerModule.getLocalizedLabel('previousPagerTooltip'),\n        tabindex: '-1',\n        name: this.pagerModule.getLocalizedLabel('previousPagerTooltip'),\n        href: 'javascript:void(0);'\n      }\n    });\n    prevPager.appendChild(this.PP);\n    pagerContainer.appendChild(prevPager);\n  }\n\n  renderNextPagerSet(pagerContainer) {\n    const nextPager = createElement('div');\n    this.NP = createElement('a', {\n      className: 'e-link e-np e-spacing',\n      innerHTML: '...',\n      attrs: {\n        title: this.pagerModule.getLocalizedLabel('nextPagerTooltip'),\n        role: 'link',\n        'aria-label': this.pagerModule.getLocalizedLabel('nextPagerTooltip'),\n        tabindex: '-1',\n        name: this.pagerModule.getLocalizedLabel('nextPagerTooltip'),\n        href: 'javascript:void(0);'\n      }\n    });\n    nextPager.appendChild(this.NP);\n    pagerContainer.appendChild(nextPager);\n  }\n\n  renderNextNLast(pagerContainer) {\n    this.next = createElement('div', {\n      className: 'e-next e-icons e-icon-next',\n      attrs: {\n        title: this.pagerModule.getLocalizedLabel('nextPageTooltip'),\n        'aria-label': this.pagerModule.getLocalizedLabel('nextPageTooltip'),\n        tabindex: '-1'\n      }\n    });\n    this.last = createElement('div', {\n      className: 'e-last e-icons e-icon-last',\n      attrs: {\n        title: this.pagerModule.getLocalizedLabel('lastPageTooltip'),\n        'aria-label': this.pagerModule.getLocalizedLabel('lastPageTooltip'),\n        tabindex: '-1'\n      }\n    });\n    append([this.next, this.last], pagerContainer);\n  }\n\n  clickHandler(e) {\n    const pagerObj = this.pagerModule;\n    const target = e.target;\n    pagerObj.previousPageNo = pagerObj.currentPage;\n\n    if (!target.classList.contains('e-disable') && !isNullOrUndefined(target.getAttribute('index'))) {\n      pagerObj.currentPage = parseInt(target.getAttribute('index'), 10);\n      pagerObj.dataBind();\n    }\n\n    return false;\n  }\n\n  updateLinksHtml() {\n    const pagerObj = this.pagerModule;\n    let currentPageSet;\n    let pageNo;\n    pagerObj.currentPage = pagerObj.totalPages === 1 ? 1 : pagerObj.currentPage;\n\n    if (pagerObj.currentPage > pagerObj.totalPages && pagerObj.totalPages) {\n      pagerObj.currentPage = pagerObj.totalPages;\n    }\n\n    currentPageSet = parseInt((pagerObj.currentPage / pagerObj.pageCount).toString(), 10);\n\n    if (pagerObj.currentPage % pagerObj.pageCount === 0 && currentPageSet > 0) {\n      currentPageSet = currentPageSet - 1;\n    }\n\n    for (let i = 0; i < pagerObj.pageCount; i++) {\n      pageNo = currentPageSet * pagerObj.pageCount + 1 + i;\n\n      if (pageNo <= pagerObj.totalPages) {\n        this.links[i].style.display = '';\n        this.links[i].setAttribute('index', pageNo.toString());\n        this.links[i].innerHTML = !pagerObj.customText ? pageNo.toString() : pagerObj.customText + pageNo;\n\n        if (pagerObj.currentPage !== pageNo) {\n          this.links[i].classList.add('e-pager-default');\n        } else {\n          this.links[i].classList.remove('e-pager-default');\n        }\n      } else {\n        this.links[i].innerHTML = !pagerObj.customText ? pageNo.toString() : pagerObj.customText + pageNo;\n        this.links[i].style.display = 'none';\n      }\n\n      classList(this.links[i], [], ['e-currentitem', 'e-active']);\n    }\n\n    this.first.setAttribute('index', '1');\n    this.last.setAttribute('index', pagerObj.totalPages.toString());\n    this.prev.setAttribute('index', (pagerObj.currentPage - 1).toString());\n    this.next.setAttribute('index', (pagerObj.currentPage + 1).toString());\n    this.pagerElement.querySelector('.e-mfirst').setAttribute('index', '1');\n    this.pagerElement.querySelector('.e-mlast').setAttribute('index', pagerObj.totalPages.toString());\n    this.pagerElement.querySelector('.e-mprev').setAttribute('index', (pagerObj.currentPage - 1).toString());\n    this.pagerElement.querySelector('.e-mnext').setAttribute('index', (pagerObj.currentPage + 1).toString());\n    this.PP.setAttribute('index', (parseInt(this.links[0].getAttribute('index'), 10) - pagerObj.pageCount).toString());\n    this.NP.setAttribute('index', (parseInt(this.links[this.links.length - 1].getAttribute('index'), 10) + 1).toString());\n  }\n\n  updateStyles() {\n    this.updateFirstNPrevStyles();\n    this.updatePrevPagerSetStyles();\n    this.updateNextPagerSetStyles();\n    this.updateNextNLastStyles();\n\n    if (this.links.length) {\n      classList(this.links[(this.pagerModule.currentPage - 1) % this.pagerModule.pageCount], ['e-currentitem', 'e-active'], []);\n    }\n  }\n\n  updateFirstNPrevStyles() {\n    const firstPage = ['e-firstpage', 'e-pager-default'];\n    const firstPageDisabled = ['e-firstpagedisabled', 'e-disable'];\n    const prevPage = ['e-prevpage', 'e-pager-default'];\n    const prevPageDisabled = ['e-prevpagedisabled', 'e-disable'];\n\n    if (this.pagerModule.totalPages > 0 && this.pagerModule.currentPage > 1) {\n      classList(this.prev, prevPage, prevPageDisabled);\n      classList(this.first, firstPage, firstPageDisabled);\n      classList(this.pagerElement.querySelector('.e-mfirst'), firstPage, firstPageDisabled);\n      classList(this.pagerElement.querySelector('.e-mprev'), prevPage, prevPageDisabled);\n    } else {\n      classList(this.prev, prevPageDisabled, prevPage);\n      classList(this.first, firstPageDisabled, firstPage);\n      classList(this.pagerElement.querySelector('.e-mprev'), prevPageDisabled, prevPage);\n      classList(this.pagerElement.querySelector('.e-mfirst'), firstPageDisabled, firstPage);\n    }\n  }\n\n  updatePrevPagerSetStyles() {\n    if (this.pagerModule.currentPage > this.pagerModule.pageCount) {\n      classList(this.PP, ['e-numericitem', 'e-pager-default'], ['e-nextprevitemdisabled', 'e-disable']);\n    } else {\n      classList(this.PP, ['e-nextprevitemdisabled', 'e-disable'], ['e-numericitem', 'e-pager-default']);\n    }\n  }\n\n  updateNextPagerSetStyles() {\n    const pagerObj = this.pagerModule;\n    const firstPage = this.links[0].innerHTML.replace(pagerObj.customText, '');\n\n    if (!firstPage.length || !this.links.length || parseInt(firstPage, 10) + pagerObj.pageCount > pagerObj.totalPages) {\n      classList(this.NP, ['e-nextprevitemdisabled', 'e-disable'], ['e-numericitem', 'e-pager-default']);\n    } else {\n      classList(this.NP, ['e-numericitem', 'e-pager-default'], ['e-nextprevitemdisabled', 'e-disable']);\n    }\n  }\n\n  updateNextNLastStyles() {\n    const lastPage = ['e-lastpage', 'e-pager-default'];\n    const lastPageDisabled = ['e-lastpagedisabled', 'e-disable'];\n    const nextPage = ['e-nextpage', 'e-pager-default'];\n    const nextPageDisabled = ['e-nextpagedisabled', 'e-disable'];\n    const pagerObj = this.pagerModule;\n\n    if (pagerObj.currentPage === pagerObj.totalPages || pagerObj.totalRecordsCount === 0) {\n      classList(this.last, lastPageDisabled, lastPage);\n      classList(this.next, nextPageDisabled, nextPage);\n      classList(this.pagerElement.querySelector('.e-mlast'), lastPageDisabled, lastPage);\n      classList(this.pagerElement.querySelector('.e-mnext'), nextPageDisabled, nextPage);\n    } else {\n      classList(this.last, lastPage, lastPageDisabled);\n      classList(this.next, nextPage, nextPageDisabled);\n      classList(this.pagerElement.querySelector('.e-mlast'), lastPage, lastPageDisabled);\n      classList(this.pagerElement.querySelector('.e-mnext'), nextPage, nextPageDisabled);\n    }\n  }\n\n}\n/**\n * `PagerMessage` module is used to display pager information.\n */\n\n\nclass PagerMessage {\n  /**\n   * Constructor for externalMessage module\n   *\n   * @param {Pager} pagerModule - specifies the pager Module\n   * @hidden\n   */\n  constructor(pagerModule) {\n    this.pagerModule = pagerModule;\n  }\n  /**\n   * The function is used to render pager message\n   *\n   * @returns {void}\n   * @hidden\n   */\n\n\n  render() {\n    const div = createElement('div', {\n      className: 'e-parentmsgbar',\n      attrs: {\n        'aria-label': 'Pager Information'\n      }\n    });\n    this.pageNoMsgElem = createElement('span', {\n      className: 'e-pagenomsg',\n      styles: 'textalign:right'\n    });\n    this.pageCountMsgElem = createElement('span', {\n      className: 'e-pagecountmsg',\n      styles: 'textalign:right'\n    });\n    append([this.pageNoMsgElem, this.pageCountMsgElem], div);\n    this.pagerModule.element.appendChild(div);\n    this.refresh();\n  }\n  /**\n   * Refreshes the pager information.\n   *\n   * @returns {void}\n   */\n\n\n  refresh() {\n    const pagerObj = this.pagerModule;\n    this.pageNoMsgElem.textContent = this.format(pagerObj.getLocalizedLabel('currentPageInfo'), [pagerObj.totalRecordsCount === 0 ? 0 : pagerObj.currentPage, pagerObj.totalPages || 0, pagerObj.totalRecordsCount || 0]) + ' ';\n    this.pageCountMsgElem.textContent = this.format(pagerObj.getLocalizedLabel(pagerObj.totalRecordsCount <= 1 ? 'totalItemInfo' : 'totalItemsInfo'), [pagerObj.totalRecordsCount || 0, pagerObj.totalRecordsCount ? pagerObj.pageSize * (pagerObj.currentPage - 1) + 1 : 0, pagerObj.pageSize * pagerObj.currentPage > pagerObj.totalRecordsCount ? pagerObj.totalRecordsCount : pagerObj.pageSize * pagerObj.currentPage]);\n    this.pageNoMsgElem.parentElement.setAttribute('aria-label', this.pageNoMsgElem.textContent + this.pageCountMsgElem.textContent);\n  }\n  /**\n   * Hides the Pager information.\n   *\n   * @returns {void}\n   */\n\n\n  hideMessage() {\n    if (this.pageNoMsgElem) {\n      this.pageNoMsgElem.style.display = 'none';\n    }\n\n    if (this.pageCountMsgElem) {\n      this.pageCountMsgElem.style.display = 'none';\n    }\n  }\n  /**\n   * Shows the Pager information.\n   *\n   * @returns {void}\n   */\n\n\n  showMessage() {\n    if (!this.pageNoMsgElem) {\n      this.render();\n    }\n\n    this.pageNoMsgElem.style.display = '';\n    this.pageCountMsgElem.style.display = '';\n  }\n  /**\n   * To destroy the PagerMessage\n   *\n   * @function destroy\n   * @returns {void}\n   * @hidden\n   */\n\n\n  destroy() {//destroy\n  }\n\n  format(str, args) {\n    let regx;\n\n    for (let i = 0; i < args.length; i++) {\n      regx = new RegExp('\\\\{' + i + '\\\\}', 'gm');\n      str = str.replace(regx, args[i].toString());\n    }\n\n    return str;\n  }\n\n}\n\nvar __decorate$5 = undefined && undefined.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n/**\n * Represents the `Pager` component.\n * ```html\n * <div id=\"pager\"/>\n * ```\n * ```typescript\n * <script>\n *   var pagerObj = new Pager({ totalRecordsCount: 50, pageSize:10 });\n *   pagerObj.appendTo(\"#pager\");\n * </script>\n * ```\n */\n\n\nlet Pager = class Pager extends Component {\n  /**\n   * Constructor for creating the component.\n   *\n   * @param {PagerModel} options - specifies the options\n   * @param {string} element - specifies the element\n   * @hidden\n   */\n  constructor(options, element) {\n    super(options, element);\n    /** @hidden */\n\n    this.hasParent = false;\n    this.pageRefresh = 'pager-refresh';\n  }\n  /**\n   * To provide the array of modules needed for component rendering\n   *\n   * @returns {ModuleDeclaration[]} returns the modules declaration\n   * @hidden\n   */\n\n\n  requiredModules() {\n    const modules = [];\n\n    if (this.enableExternalMessage) {\n      modules.push({\n        member: 'externalMessage',\n        args: [this]\n      });\n    }\n\n    if (this.checkpagesizes()) {\n      modules.push({\n        member: 'pagerdropdown',\n        args: [this]\n      });\n    }\n\n    return modules;\n  }\n  /**\n   * Initialize the event handler\n   *\n   * @returns {void}\n   * @hidden\n   */\n\n\n  preRender() {\n    //preRender\n    this.defaultConstants = {\n      currentPageInfo: '{0} of {1} pages',\n      totalItemsInfo: '({0} items)',\n      totalItemInfo: '({0} item)',\n      firstPageTooltip: 'Go to first page',\n      lastPageTooltip: 'Go to last page',\n      nextPageTooltip: 'Go to next page',\n      previousPageTooltip: 'Go to previous page',\n      nextPagerTooltip: 'Go to next pager',\n      previousPagerTooltip: 'Go to previous pager',\n      pagerDropDown: 'Items per page',\n      pagerAllDropDown: 'Items',\n      CurrentPageInfo: '{0} of {1} pages',\n      TotalItemsInfo: '({0} items)',\n      FirstPageTooltip: 'Go to first page',\n      LastPageTooltip: 'Go to last page',\n      NextPageTooltip: 'Go to next page',\n      PreviousPageTooltip: 'Go to previous page',\n      NextPagerTooltip: 'Go to next pager',\n      PreviousPagerTooltip: 'Go to previous pager',\n      PagerDropDown: 'Items per page',\n      PagerAllDropDown: 'Items',\n      All: 'All'\n    };\n    this.containerModule = new NumericContainer(this);\n    this.pagerMessageModule = new PagerMessage(this);\n  }\n  /**\n   * To Initialize the component rendering\n   *\n   * @returns {void}\n   */\n\n\n  render() {\n    if (this.template) {\n      if (this.isReactTemplate()) {\n        this.on(this.pageRefresh, this.pagerTemplate, this);\n        this.notify(this.pageRefresh, {});\n      } else {\n        this.pagerTemplate();\n      }\n    } else {\n      this.initLocalization();\n      this.updateRTL();\n      this.totalRecordsCount = this.totalRecordsCount || 0;\n      this.renderFirstPrevDivForDevice();\n      this.containerModule.render();\n\n      if (this.enablePagerMessage) {\n        this.pagerMessageModule.render();\n      }\n\n      this.renderNextLastDivForDevice();\n\n      if (this.checkpagesizes() && this.pagerdropdownModule) {\n        this.pagerdropdownModule.render();\n      }\n\n      this.addAriaLabel();\n\n      if (this.enableExternalMessage && this.externalMessageModule) {\n        this.externalMessageModule.render();\n      }\n\n      this.refresh();\n      this.trigger('created', {\n        'currentPage': this.currentPage,\n        'totalRecordsCount': this.totalRecordsCount\n      });\n    }\n  }\n  /**\n   * Get the properties to be maintained in the persisted state.\n   *\n   * @returns {string} returns the persist data\n   * @hidden\n   */\n\n\n  getPersistData() {\n    const keyEntity = ['currentPage', 'pageSize'];\n    return this.addOnPersist(keyEntity);\n  }\n  /**\n   * To destroy the Pager component.\n   *\n   * @method destroy\n   * @returns {void}\n   */\n\n\n  destroy() {\n    if (this.isReactTemplate()) {\n      this.off(this.pageRefresh, this.pagerTemplate);\n\n      if (!this.hasParent) {\n        this.destroyTemplate(['template']);\n      }\n    }\n\n    super.destroy();\n    this.containerModule.destroy();\n    this.pagerMessageModule.destroy();\n\n    if (!this.isReactTemplate()) {\n      this.element.innerHTML = '';\n    }\n  }\n  /**\n   * Destroys the given template reference.\n   *\n   * @param {string[]} propertyNames - Defines the collection of template name.\n   * @param {any} index - Defines the index\n   */\n  // eslint-disable-next-line\n\n\n  destroyTemplate(propertyNames, index) {\n    this.clearTemplate(propertyNames, index);\n  }\n  /**\n   * For internal use only - Get the module name.\n   *\n   * @returns {string} returns the module name\n   * @private\n   */\n\n\n  getModuleName() {\n    return 'pager';\n  }\n  /**\n   * Called internally if any of the property value changed.\n   *\n   * @param {PagerModel} newProp - specifies the new property\n   * @param {PagerModel} oldProp - specifies the old propety\n   * @returns {void}\n   * @hidden\n   */\n\n\n  onPropertyChanged(newProp, oldProp) {\n    if (this.isDestroyed) {\n      return;\n    }\n\n    if (newProp.pageCount !== oldProp.pageCount) {\n      this.containerModule.refreshNumericLinks();\n      this.containerModule.refresh();\n    }\n\n    for (const prop of Object.keys(newProp)) {\n      switch (prop) {\n        case 'currentPage':\n          if (this.checkGoToPage(newProp.currentPage, oldProp.currentPage)) {\n            this.currentPageChanged(newProp, oldProp);\n          }\n\n          break;\n\n        case 'pageSize':\n        case 'totalRecordsCount':\n        case 'customText':\n          if (this.checkpagesizes() && this.pagerdropdownModule) {\n            if (oldProp.pageSize !== newProp.pageSize) {\n              this.currentPage = 1;\n            }\n\n            this.pagerdropdownModule.setDropDownValue('value', this.pageSize);\n          }\n\n          if (newProp.pageSize !== oldProp.pageSize) {\n            this.pageSize = newProp.pageSize;\n            this.currentPageChanged(newProp, oldProp);\n          } else {\n            this.refresh();\n          }\n\n          break;\n\n        case 'pageSizes':\n          if (this.checkpagesizes() && this.pagerdropdownModule) {\n            this.pagerdropdownModule.destroy();\n            this.pagerdropdownModule.render();\n          }\n\n          this.refresh();\n          break;\n\n        case 'template':\n          this.templateFn = this.compile(this.template);\n          this.refresh();\n          break;\n\n        case 'locale':\n          this.initLocalization();\n          this.refresh();\n          break;\n\n        case 'enableExternalMessage':\n          if (this.enableExternalMessage && this.externalMessageModule) {\n            this.externalMessageModule.render();\n          }\n\n          break;\n\n        case 'externalMessage':\n          if (this.externalMessageModule) {\n            this.externalMessageModule.refresh();\n          }\n\n          break;\n\n        case 'enableRtl':\n          this.updateRTL();\n          break;\n\n        case 'enablePagerMessage':\n          if (this.enablePagerMessage) {\n            this.pagerMessageModule.showMessage();\n          } else {\n            this.pagerMessageModule.hideMessage();\n          }\n\n          break;\n      }\n    }\n  }\n  /**\n   * Gets the localized label by locale keyword.\n   *\n   * @param  {string} key - specifies the key\n   * @returns {string} returns the localized label\n   */\n\n\n  getLocalizedLabel(key) {\n    return this.localeObj.getConstant(key);\n  }\n  /**\n   * Navigate to target page by given number.\n   *\n   * @param  {number} pageNo - Defines page number.\n   * @returns {void}\n   */\n\n\n  goToPage(pageNo) {\n    if (this.checkGoToPage(pageNo)) {\n      this.currentPage = pageNo;\n      this.dataBind();\n    }\n  }\n  /**\n   * @param {number} pageSize - specifies the pagesize\n   * @returns {void}\n   * @hidden\n   */\n\n\n  setPageSize(pageSize) {\n    this.pageSize = pageSize;\n    this.dataBind();\n  }\n\n  checkpagesizes() {\n    if (this.pageSizes === true || this.pageSizes.length) {\n      return true;\n    }\n\n    return false;\n  }\n\n  checkGoToPage(newPageNo, oldPageNo) {\n    if (newPageNo !== this.currentPage) {\n      this.previousPageNo = this.currentPage;\n    }\n\n    if (!isNullOrUndefined(oldPageNo)) {\n      this.previousPageNo = oldPageNo;\n    }\n\n    if (this.previousPageNo !== newPageNo && newPageNo >= 1 && newPageNo <= this.totalPages) {\n      return true;\n    }\n\n    return false;\n  }\n\n  currentPageChanged(newProp, oldProp) {\n    if (this.enableQueryString) {\n      this.updateQueryString(this.currentPage);\n    }\n\n    if (newProp.currentPage !== oldProp.currentPage || newProp.pageSize !== oldProp.pageSize) {\n      const args = {\n        currentPage: this.currentPage,\n        newProp: newProp,\n        oldProp: oldProp,\n        cancel: false\n      };\n      this.trigger('click', args);\n\n      if (!args.cancel) {\n        this.refresh();\n      }\n    }\n  }\n\n  pagerTemplate() {\n    if (this.isReactTemplate() && this.hasParent) {\n      return;\n    }\n\n    let result;\n    this.element.classList.add('e-pagertemplate');\n    this.compile(this.template);\n    const data = {\n      currentPage: this.currentPage,\n      pageSize: this.pageSize,\n      pageCount: this.pageCount,\n      totalRecordsCount: this.totalRecordsCount,\n      totalPages: this.totalPages\n    };\n    const tempId = this.element.parentElement.id + '_template';\n\n    if (this.isReactTemplate() && !this.isVue) {\n      this.getPagerTemplate()(data, this, 'template', tempId, null, null, this.element);\n      this.renderReactTemplates();\n    } else {\n      result = this.isVue ? this.getPagerTemplate()(data, this, 'template') : this.getPagerTemplate()(data);\n      appendChildren(this.element, result);\n    }\n  }\n  /**\n   * @returns {void}\n   * @hidden\n   */\n\n\n  updateTotalPages() {\n    this.totalPages = this.totalRecordsCount % this.pageSize === 0 ? this.totalRecordsCount / this.pageSize : parseInt((this.totalRecordsCount / this.pageSize).toString(), 10) + 1;\n  }\n  /**\n   * @returns {Function} returns the function\n   * @hidden\n   */\n\n\n  getPagerTemplate() {\n    return this.templateFn;\n  }\n  /**\n   * @param {string} template - specifies the template\n   * @returns {Function} returns the function\n   * @hidden\n   */\n\n\n  compile(template) {\n    if (template) {\n      try {\n        if (document.querySelectorAll(template).length) {\n          this.templateFn = compile(document.querySelector(template).innerHTML.trim());\n        }\n      } catch (e) {\n        this.templateFn = compile(template);\n      }\n    }\n\n    return undefined;\n  }\n  /**\n   * Refreshes page count, pager information and external message.\n   *\n   * @returns {void}\n   */\n\n\n  refresh() {\n    if (this.template) {\n      if (this.isReactTemplate()) {\n        this.updateTotalPages();\n        this.notify(this.pageRefresh, {});\n      } else {\n        this.element.innerHTML = '';\n        this.updateTotalPages();\n        this.pagerTemplate();\n      }\n    } else {\n      this.updateRTL();\n      this.containerModule.refresh();\n\n      if (this.enablePagerMessage) {\n        this.pagerMessageModule.refresh();\n      }\n\n      if (this.pagerdropdownModule) {\n        this.pagerdropdownModule.refresh();\n      }\n\n      if (this.enableExternalMessage && this.externalMessageModule) {\n        this.externalMessageModule.refresh();\n      }\n    }\n  }\n\n  updateRTL() {\n    if (this.enableRtl) {\n      this.element.classList.add('e-rtl');\n    } else {\n      this.element.classList.remove('e-rtl');\n    }\n  }\n\n  initLocalization() {\n    this.localeObj = new L10n(this.getModuleName(), this.defaultConstants, this.locale);\n  }\n\n  updateQueryString(value) {\n    const updatedUrl = this.getUpdatedURL(window.location.href, 'page', value.toString());\n    window.history.pushState({\n      path: updatedUrl\n    }, '', updatedUrl);\n  }\n\n  getUpdatedURL(uri, key, value) {\n    const regx = new RegExp('([?|&])' + key + '=.*?(&|#|$)', 'i');\n\n    if (uri.match(regx)) {\n      return uri.replace(regx, '$1' + key + '=' + value + '$2');\n    } else {\n      let hash = '';\n\n      if (uri.indexOf('#') !== -1) {\n        hash = uri.replace(/.*#/, '#');\n        uri = uri.replace(/#.*/, '');\n      }\n\n      return uri + (uri.indexOf('?') !== -1 ? '&' : '?') + key + '=' + value + hash;\n    }\n  }\n\n  renderFirstPrevDivForDevice() {\n    this.element.appendChild(createElement('div', {\n      className: 'e-mfirst e-icons e-icon-first',\n      attrs: {\n        title: this.getLocalizedLabel('firstPageTooltip'),\n        tabindex: '-1'\n      }\n    }));\n    this.element.appendChild(createElement('div', {\n      className: 'e-mprev e-icons e-icon-prev',\n      attrs: {\n        title: this.getLocalizedLabel('previousPageTooltip'),\n        tabindex: '-1'\n      }\n    }));\n  }\n\n  renderNextLastDivForDevice() {\n    this.element.appendChild(createElement('div', {\n      className: 'e-mnext e-icons e-icon-next',\n      attrs: {\n        title: this.getLocalizedLabel('nextPageTooltip'),\n        tabindex: '-1'\n      }\n    }));\n    this.element.appendChild(createElement('div', {\n      className: 'e-mlast e-icons e-icon-last',\n      attrs: {\n        title: this.getLocalizedLabel('lastPageTooltip'),\n        tabindex: '-1'\n      }\n    }));\n  }\n\n  addAriaLabel() {\n    const classList$$1 = ['.e-mfirst', '.e-mprev', '.e-mnext', '.e-mlast'];\n\n    if (!Browser.isDevice) {\n      for (let i = 0; i < classList$$1.length; i++) {\n        const element = this.element.querySelector(classList$$1[i]);\n        element.setAttribute('aria-label', element.getAttribute('title'));\n      }\n    }\n  }\n\n  isReactTemplate() {\n    return (this.isReact || this.isVue) && this.template && typeof this.template !== 'string';\n  }\n\n};\n\n__decorate$5([Property(false)], Pager.prototype, \"enableQueryString\", void 0);\n\n__decorate$5([Property(false)], Pager.prototype, \"enableExternalMessage\", void 0);\n\n__decorate$5([Property(true)], Pager.prototype, \"enablePagerMessage\", void 0);\n\n__decorate$5([Property(12)], Pager.prototype, \"pageSize\", void 0);\n\n__decorate$5([Property(10)], Pager.prototype, \"pageCount\", void 0);\n\n__decorate$5([Property(1)], Pager.prototype, \"currentPage\", void 0);\n\n__decorate$5([Property()], Pager.prototype, \"totalRecordsCount\", void 0);\n\n__decorate$5([Property()], Pager.prototype, \"externalMessage\", void 0);\n\n__decorate$5([Property(false)], Pager.prototype, \"pageSizes\", void 0);\n\n__decorate$5([Property()], Pager.prototype, \"template\", void 0);\n\n__decorate$5([Property('')], Pager.prototype, \"customText\", void 0);\n\n__decorate$5([Event()], Pager.prototype, \"click\", void 0);\n\n__decorate$5([Event()], Pager.prototype, \"dropDownChanged\", void 0);\n\n__decorate$5([Event()], Pager.prototype, \"created\", void 0);\n\nPager = __decorate$5([NotifyPropertyChanges], Pager);\n/**\n * `PagerDropDown` module handles selected pageSize from DropDownList.\n */\n\nclass PagerDropDown {\n  /**\n   * Constructor for pager module\n   *\n   * @param {Pager} pagerModule - specifies the pagermodule\n   * @hidden\n   */\n  constructor(pagerModule) {\n    this.pagerModule = pagerModule;\n  }\n  /**\n   * For internal use only - Get the module name.\n   *\n   * @returns {string} returns the module name\n   * @private\n   * @hidden\n   */\n\n\n  getModuleName() {\n    return 'pagerdropdown';\n  }\n  /**\n   * The function is used to render pager dropdown\n   *\n   * @returns {void}\n   * @hidden\n   */\n\n\n  render() {\n    const pagerObj = this.pagerModule;\n    this.pagerDropDownDiv = createElement('div', {\n      className: 'e-pagesizes'\n    });\n    const dropDownDiv = createElement('div', {\n      className: 'e-pagerdropdown'\n    });\n    const defaultTextDiv = createElement('div', {\n      className: 'e-pagerconstant'\n    });\n    const input = createElement('input', {\n      attrs: {\n        type: 'text',\n        tabindex: '1'\n      }\n    });\n    this.pagerCons = createElement('span', {\n      className: 'e-constant',\n      innerHTML: this.pagerModule.getLocalizedLabel('pagerDropDown')\n    });\n    dropDownDiv.appendChild(input);\n    defaultTextDiv.appendChild(this.pagerCons);\n    this.pagerDropDownDiv.appendChild(dropDownDiv);\n    this.pagerDropDownDiv.appendChild(defaultTextDiv);\n    this.pagerModule.element.appendChild(this.pagerDropDownDiv);\n    const pageSizesModule = this.pagerModule.pageSizes;\n    const pageSizesArray = pageSizesModule.length ? this.convertValue(pageSizesModule) : [this.pagerModule.getLocalizedLabel('All'), '5', '10', '12', '20'];\n    const defaultValue = this.pagerModule.pageSize;\n    this.dropDownListObject = new DropDownList({\n      dataSource: pageSizesArray,\n      value: defaultValue.toString(),\n      change: this.onChange.bind(this),\n      cssClass: 'e-alldrop'\n    });\n    this.dropDownListObject.appendTo(input);\n\n    if (pageSizesModule.length) {\n      this.dropDownListObject.element.value = this.pagerModule.pageSize.toString();\n    }\n\n    pagerObj.pageSize = defaultValue;\n    pagerObj.dataBind();\n    pagerObj.trigger('dropDownChanged', {\n      pageSize: defaultValue\n    });\n    this.addEventListener();\n  }\n  /**\n   * For internal use only - Get the pagesize.\n   *\n   * @param {ChangeEventArgs} e - specifies the changeeventargs\n   * @returns {void}\n   * @private\n   * @hidden\n   */\n\n\n  onChange(e) {\n    if (this.dropDownListObject.value === this.pagerModule.getLocalizedLabel('All')) {\n      this.pagerModule.pageSize = this.pagerModule.totalRecordsCount;\n      this.refresh();\n      e.value = this.pagerModule.pageSize;\n\n      if (document.getElementsByClassName('e-popup-open e-alldrop').length) {\n        document.getElementsByClassName('e-popup-open e-alldrop')[0].style.display = 'none';\n      }\n    } else {\n      this.pagerModule.pageSize = parseInt(this.dropDownListObject.value, 10);\n\n      if (this.pagerCons.innerHTML !== this.pagerModule.getLocalizedLabel('pagerDropDown')) {\n        this.refresh();\n      }\n    }\n\n    this.pagerModule.dataBind();\n    this.pagerModule.trigger('dropDownChanged', {\n      pageSize: parseInt(this.dropDownListObject.value, 10)\n    });\n  }\n\n  refresh() {\n    if (this.pagerCons) {\n      if (this.pagerModule.pageSize === this.pagerModule.totalRecordsCount) {\n        this.pagerCons.innerHTML = this.pagerModule.getLocalizedLabel('pagerAllDropDown');\n      } else {\n        this.pagerCons.innerHTML = this.pagerModule.getLocalizedLabel('pagerDropDown');\n      }\n    }\n  }\n\n  beforeValueChange(prop) {\n    if (typeof prop.newProp.value === 'number') {\n      const val = prop.newProp.value.toString();\n      prop.newProp.value = val;\n    }\n  }\n\n  convertValue(pageSizeValue) {\n    const item = pageSizeValue;\n\n    for (let i = 0; i < item.length; i++) {\n      item[i] = parseInt(item[i], 10) ? item[i].toString() : this.pagerModule.getLocalizedLabel(item[i]) !== '' ? this.pagerModule.getLocalizedLabel(item[i]) : item[i];\n    }\n\n    return item;\n  }\n\n  setDropDownValue(prop, value) {\n    if (this.dropDownListObject) {\n      this.dropDownListObject[prop] = value;\n    }\n  }\n\n  addEventListener() {\n    this.dropDownListObject.on('beforeValueChange', this.beforeValueChange, this);\n  }\n\n  removeEventListener() {\n    this.dropDownListObject.off('beforeValueChange', this.beforeValueChange);\n  }\n  /**\n   * To destroy the Pagerdropdown\n   *\n   * @param {string} args - specifies the arguments\n   * @param {string} args.requestType - specfies the request type\n   * @returns {void}\n   * @hidden\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  destroy(args) {\n    if (this.dropDownListObject && !this.dropDownListObject.isDestroyed) {\n      this.removeEventListener();\n      this.dropDownListObject.destroy();\n      remove(this.pagerDropDownDiv);\n    }\n  }\n\n}\n/**\n * `ExternalMessage` module is used to display user provided message.\n */\n\n\nclass ExternalMessage {\n  /**\n   * Constructor for externalMessage module\n   *\n   * @param {Pager} pagerModule - specifies the pagermodule\n   * @hidden\n   */\n  constructor(pagerModule) {\n    this.pagerModule = pagerModule;\n  }\n  /**\n   * For internal use only - Get the module name.\n   *\n   * @returns {string} returns the module name\n   * @private\n   */\n\n\n  getModuleName() {\n    return 'externalMessage';\n  }\n  /**\n   * The function is used to render pager externalMessage\n   *\n   * @returns {void}\n   * @hidden\n   */\n\n\n  render() {\n    this.element = createElement('div', {\n      className: 'e-pagerexternalmsg',\n      attrs: {\n        'aria-label': 'Pager external message'\n      }\n    });\n    this.pagerModule.element.appendChild(this.element);\n    this.refresh();\n  }\n  /**\n   * Refreshes the external message of Pager.\n   *\n   * @returns {void}\n   */\n\n\n  refresh() {\n    if (this.pagerModule.externalMessage && this.pagerModule.externalMessage.toString().length) {\n      this.showMessage();\n      this.element.innerHTML = this.pagerModule.externalMessage;\n    } else {\n      this.hideMessage();\n    }\n  }\n  /**\n   * Hides the external message of Pager.\n   *\n   * @returns {void}\n   */\n\n\n  hideMessage() {\n    if (!isNullOrUndefined(this.element)) {\n      this.element.style.display = 'none';\n    }\n  }\n  /**\n   * Shows the external message of the Pager.\n   *\n   * @returns {void}s\n   */\n\n\n  showMessage() {\n    this.element.style.display = '';\n  }\n  /**\n   * To destroy the PagerMessage\n   *\n   * @function destroy\n   * @returns {void}\n   * @hidden\n   */\n\n\n  destroy() {\n    remove(this.element);\n  }\n\n}\n/**\n * The `Page` module is used to render pager and handle paging action.\n */\n\n\nclass Page {\n  /**\n   * Constructor for the Grid paging module\n   *\n   * @param {IGrid} parent - specifies the IGrid\n   * @param {PageSettingsModel} pageSettings - specifies the PageSettingsModel\n   * @hidden\n   */\n  constructor(parent, pageSettings) {\n    this.isInitialRender = true;\n    Pager.Inject(ExternalMessage, PagerDropDown);\n    this.parent = parent;\n    this.pageSettings = pageSettings;\n    this.addEventListener();\n  }\n  /**\n   * For internal use only - Get the module name.\n   *\n   * @returns {string} returns the module name\n   * @private\n   */\n\n\n  getModuleName() {\n    return 'pager';\n  }\n  /**\n   * The function used to render pager from grid pageSettings\n   *\n   * @returns {void}\n   * @hidden\n   */\n\n\n  render() {\n    const gObj = this.parent;\n    this.pagerDestroy();\n\n    if (!isNullOrUndefined(this.parent.pagerTemplate)) {\n      this.pageSettings.template = this.parent.pagerTemplate;\n      this.parent.pageTemplateChange = true;\n    }\n\n    this.element = this.parent.createElement('div', {\n      className: 'e-gridpager'\n    });\n    const pagerObj = extend$1({}, extend({}, getActualProperties(this.pageSettings)), {\n      click: this.clickHandler.bind(this),\n      dropDownChanged: this.onSelect.bind(this),\n      enableRtl: gObj.enableRtl,\n      locale: gObj.locale,\n      created: this.addAriaAttr.bind(this)\n    }, ['parentObj', 'propName']);\n    this.pagerObj = new Pager(pagerObj);\n    this.pagerObj.hasParent = true;\n    this.pagerObj.on(pagerRefresh, this.renderReactPagerTemplate, this);\n    this.pagerObj.allowServerDataBinding = false;\n  }\n\n  onSelect(e) {\n    this.pageSettings.pageSize = e.pageSize;\n\n    if (!this.isInitialLoad) {\n      this.pageSettings.currentPage = 1;\n    }\n  }\n\n  addAriaAttr() {\n    if (!this.pageSettings.template) {\n      const numericContainerNew = this.parent.createElement('div', {\n        className: 'e-numericcontainer'\n      });\n      const pagerContainer = this.element.querySelector('.e-pagercontainer');\n      const frag = document.createDocumentFragment();\n      const numericContainer = this.element.querySelector('.e-numericcontainer');\n      const links = numericContainer.querySelectorAll('a');\n\n      for (let i = 0; i < links.length; i++) {\n        if (this.parent.getContentTable()) {\n          links[i].setAttribute('aria-owns', this.parent.getContentTable().id);\n        } else {\n          links[i].setAttribute('aria-owns', this.parent.element.getAttribute('id') + '_content_table');\n        }\n\n        const numericContainerDiv = this.parent.createElement('div');\n        numericContainerDiv.appendChild(links[i]);\n        frag.appendChild(numericContainerDiv);\n      }\n\n      numericContainerNew.appendChild(frag);\n      pagerContainer.replaceChild(numericContainerNew, numericContainer);\n      const classList$$1 = ['.e-mfirst', '.e-mprev', '.e-first', '.e-prev', '.e-next', '.e-last', '.e-mnext', '.e-mlast'];\n\n      for (let j = 0; j < classList$$1.length; j++) {\n        const element = this.element.querySelector(classList$$1[j]);\n\n        if (this.parent.getContentTable()) {\n          element.setAttribute('aria-owns', this.parent.getContentTable().id);\n        }\n      }\n    }\n  }\n\n  dataReady(e) {\n    this.updateModel(e);\n  }\n  /**\n   * Refreshes the page count, pager information, and external message.\n   *\n   * @returns {void}\n   */\n\n\n  refresh() {\n    this.pagerObj.refresh();\n  }\n  /**\n   * Navigates to the target page according to the given number.\n   *\n   * @param  {number} pageNo - Defines the page number to navigate.\n   * @returns {void}\n   */\n\n\n  goToPage(pageNo) {\n    this.pagerObj.goToPage(pageNo);\n  }\n  /**\n   * @param {number} pageSize - specifies the page size\n   * @returns {void}\n   * @hidden\n   */\n\n\n  setPageSize(pageSize) {\n    this.pagerObj.setPageSize(pageSize);\n  }\n  /**\n   * The function used to update pageSettings model\n   *\n   * @param {NotifyArgs} e - specfies the NotifyArgs\n   * @returns {void}\n   * @hidden\n   */\n\n\n  updateModel(e) {\n    this.parent.pageSettings.totalRecordsCount = e.count;\n    this.parent.dataBind();\n  }\n  /**\n   * The function used to trigger onActionComplete\n   *\n   * @param {NotifyArgs} e - specifies the NotifyArgs\n   * @returns {void}\n   * @hidden\n   */\n\n\n  onActionComplete(e) {\n    this.parent.trigger(actionComplete, extend(e, {\n      currentPage: this.parent.pageSettings.currentPage,\n      requestType: 'paging',\n      type: actionComplete\n    }));\n  }\n  /**\n   * @param {NotifyArgs} e - specifies the NotifyArgs\n   * @returns {void}\n   * @hidden\n   */\n\n\n  onPropertyChanged(e) {\n    if (e.module !== this.getModuleName()) {\n      return;\n    }\n\n    const newProp = e.properties;\n\n    for (const prop of Object.keys(newProp)) {\n      this.pagerObj[prop] = newProp[prop];\n    }\n\n    this.pagerObj.dataBind();\n  }\n\n  clickHandler(e) {\n    const gObj = this.parent;\n\n    if (this.isForceCancel || isActionPrevent(gObj) && !gObj.prevPageMoving) {\n      if (!this.isForceCancel) {\n        if (!isNullOrUndefined(e.newProp) && !isNullOrUndefined(e.newProp.pageSize)) {\n          gObj.notify(preventBatch, {\n            instance: this,\n            handler: this.setPageSize,\n            arg1: e.newProp.pageSize\n          });\n          this.pagerObj.pageSize = e.oldProp.pageSize;\n          gObj.pageSettings.pageSize = e.newProp.pageSize;\n        } else if (e.currentPage) {\n          gObj.notify(preventBatch, {\n            instance: this,\n            handler: this.goToPage,\n            arg1: e.currentPage\n          });\n          this.pagerObj.currentPage = gObj.pageSettings.currentPage === this.pagerObj.currentPage ? this.pagerObj.previousPageNo : gObj.pageSettings.currentPage;\n        }\n\n        this.isForceCancel = true;\n        this.pagerObj.dataBind();\n      } else {\n        this.isForceCancel = false;\n      }\n\n      e.cancel = true;\n      return;\n    }\n\n    gObj.pageSettings.pageSize = this.pagerObj.pageSize;\n    gObj.prevPageMoving = false;\n    const prevPage = this.pageSettings.currentPage;\n    this.pageSettings.currentPage = e.currentPage;\n    const args = {\n      cancel: false,\n      requestType: 'paging',\n      previousPage: prevPage,\n      currentPage: e.currentPage,\n      type: actionBegin\n    };\n    this.parent.notify(modelChanged, args);\n\n    if (args.cancel) {\n      e.cancel = true;\n    }\n\n    this.parent.requestTypeAction = 'paging';\n  }\n\n  keyPressHandler(e) {\n    if (e.action in keyActions) {\n      e.preventDefault();\n      this.element.querySelector(keyActions[e.action]).click();\n    }\n  }\n  /**\n   * Defines the text of the external message.\n   *\n   * @param  {string} message - Defines the message to update.\n   * @returns {void}\n   */\n\n\n  updateExternalMessage(message) {\n    if (!this.pagerObj.enableExternalMessage) {\n      this.pagerObj.enableExternalMessage = true;\n      this.pagerObj.dataBind();\n    }\n\n    this.pagerObj.externalMessage = message;\n    this.pagerObj.dataBind();\n  }\n\n  appendToElement() {\n    this.isInitialLoad = true;\n    this.parent.element.appendChild(this.element);\n    this.parent.setGridPager(this.element);\n    this.pagerObj.isReact = this.parent.isReact;\n    this.pagerObj.isVue = this.parent.isVue;\n    this.pagerObj.appendTo(this.element);\n    this.isInitialLoad = false;\n  }\n\n  enableAfterRender(e) {\n    if (e.module === this.getModuleName() && e.enable) {\n      this.render();\n      this.appendToElement();\n\n      if (this.isReactTemplate()) {\n        this.pagerObj.updateTotalPages();\n        this.created();\n      }\n    }\n  }\n  /**\n   * @returns {void}\n   * @hidden\n   */\n\n\n  addEventListener() {\n    this.handlers = {\n      load: this.render,\n      end: this.appendToElement,\n      ready: this.dataReady,\n      complete: this.onActionComplete,\n      updateLayout: this.enableAfterRender,\n      inboundChange: this.onPropertyChanged,\n      keyPress: this.keyPressHandler,\n      created: this.created\n    };\n\n    if (this.parent.isDestroyed) {\n      return;\n    }\n\n    if (this.parent.isReact || this.parent.isVue) {\n      this.parent.addEventListener(create, this.handlers.created.bind(this));\n    }\n\n    this.evtHandlers = [{\n      event: initialLoad,\n      handler: this.handlers.load\n    }, {\n      event: initialEnd,\n      handler: this.handlers.end\n    }, {\n      event: dataReady,\n      handler: this.handlers.ready\n    }, {\n      event: pageComplete,\n      handler: this.handlers.complete\n    }, {\n      event: uiUpdate,\n      handler: this.handlers.updateLayout\n    }, {\n      event: inBoundModelChanged,\n      handler: this.handlers.inboundChange\n    }, {\n      event: keyPressed,\n      handler: this.handlers.keyPress\n    }, {\n      event: destroy,\n      handler: this.destroy\n    }];\n    addRemoveEventListener(this.parent, this.evtHandlers, true, this);\n  }\n\n  created() {\n    if (this.isInitialRender && this.isReactTemplate()) {\n      this.isInitialRender = false;\n      this.renderReactPagerTemplate();\n    }\n  }\n\n  isReactTemplate() {\n    return (this.parent.isReact || this.parent.isVue) && this.pagerObj.template && typeof this.pagerObj.template !== 'string';\n  }\n\n  renderReactPagerTemplate() {\n    if (!this.isInitialRender && this.isReactTemplate()) {\n      let result;\n      this.parent.destroyTemplate(['pagerTemplate']);\n      this.element.classList.add('e-pagertemplate');\n      this.pagerObj.compile(this.pagerObj.template);\n      const page = this.parent.pageSettings;\n      const data = {\n        currentPage: page.currentPage,\n        pageSize: page.pageSize,\n        pageCount: page.pageCount,\n        totalRecordsCount: page.totalRecordsCount,\n        totalPages: this.pagerObj.totalPages\n      };\n      const tempId = this.parent.id + '_pagertemplate';\n\n      if (this.parent.isReact) {\n        this.pagerObj.templateFn(data, this.parent, 'pagerTemplate', tempId, null, null, this.pagerObj.element);\n        this.parent.renderTemplates();\n      } else {\n        result = this.pagerObj.templateFn(data, this.parent, 'pagerTemplate');\n        appendChildren(this.pagerObj.element, result);\n      }\n    }\n  }\n  /**\n   * @returns {void}\n   * @hidden\n   */\n\n\n  removeEventListener() {\n    if (this.parent.isDestroyed) {\n      return;\n    }\n\n    if (this.parent.isReact || this.parent.isVue) {\n      this.parent.removeEventListener(create, this.handlers.created);\n    }\n\n    this.parent.off(pagerRefresh, this.renderReactPagerTemplate);\n    addRemoveEventListener(this.parent, this.evtHandlers, false);\n  }\n  /**\n   * To destroy the pager\n   *\n   * @returns {void}\n   * @hidden\n   */\n\n\n  destroy() {\n    this.removeEventListener();\n\n    if (this.isReactTemplate()) {\n      this.parent.destroyTemplate(['pagerTemplate']);\n    }\n\n    this.pagerObj.destroy();\n  }\n\n  pagerDestroy() {\n    if (this.pagerObj && !this.pagerObj.isDestroyed) {\n      this.pagerObj.destroy();\n      remove(this.element);\n    }\n  }\n\n}\n/**\n * @hidden\n */\n\n\nconst keyActions = {\n  pageUp: '.e-prev',\n  pageDown: '.e-next',\n  ctrlAltPageDown: '.e-last',\n  ctrlAltPageUp: '.e-first',\n  altPageUp: '.e-pp',\n  altPageDown: '.e-np'\n};\n/**\n * FilterCellRenderer class which responsible for building filter cell.\n *\n * @hidden\n */\n\nclass FilterCellRenderer extends CellRenderer {\n  constructor() {\n    super(...arguments);\n    this.element = this.parent.createElement('TH', {\n      className: 'e-filterbarcell'\n    });\n  }\n  /**\n   * Function to return the wrapper for the TH content.\n   *\n   * @returns {string} returns the gui\n   */\n\n\n  getGui() {\n    return this.parent.createElement('div');\n  }\n  /**\n   * Function to render the cell content based on Column object.\n   *\n   * @param  {Cell} cell\n   * @param  {Object} data\n   */\n\n  /* tslint:disable-next-line:max-func-body-length */\n\n\n  render(cell, data) {\n    const tr = this.parent.element.querySelector('.e-filterbar');\n    const node = this.element.cloneNode();\n    const innerDIV = this.getGui();\n    let input;\n    const column = cell.column;\n    tr.appendChild(node);\n    node.setAttribute('e-mappinguid', column.uid);\n\n    if (column.filterTemplate) {\n      const fltrData = {};\n\n      if (data) {\n        fltrData[column.field] = data[column.field];\n      }\n\n      const col = 'column';\n      fltrData[col] = column;\n\n      if (column.visible) {\n        const isReactCompiler = this.parent.isReact && typeof column.filterTemplate !== 'string';\n        const tempID = this.parent.element.id + column.uid + 'filterTemplate';\n\n        if (isReactCompiler) {\n          column.getFilterTemplate()(fltrData, this.parent, 'filterTemplate', tempID, null, null, node);\n          this.parent.renderTemplates();\n        } else {\n          const element = column.getFilterTemplate()(fltrData, this.parent, 'filterTemplate', tempID);\n          appendChildren(node, element);\n        }\n      } else {\n        node.classList.add('e-hide');\n      }\n    } else {\n      if (column.type !== 'checkbox') {\n        if ((isNullOrUndefined(column.allowFiltering) || column.allowFiltering) && !isNullOrUndefined(column.filterBarTemplate)) {\n          node.classList.add('e-fltrtemp');\n          attributes(innerDIV, {\n            'class': 'e-fltrtempdiv'\n          });\n\n          if (isNullOrUndefined(column.filterBarTemplate.create)) {\n            input = this.parent.createElement('input', {\n              id: column.field + '_filterBarcell',\n              className: 'e-filterUi_input e-filtertext e-fltrTemp',\n              attrs: {\n                type: 'search',\n                title: column.headerText\n              }\n            });\n            innerDIV.appendChild(input);\n          } else {\n            const args = {\n              column: column,\n              node: Element\n            };\n            let temp = column.filterBarTemplate.create;\n\n            if (typeof temp === 'string') {\n              temp = getValue(temp, window);\n            }\n\n            input = temp(args);\n\n            if (typeof input === 'string') {\n              const div = this.parent.createElement('div');\n              div.innerHTML = input;\n              input = div.firstChild;\n            }\n\n            attributes(innerDIV, {\n              class: 'e-filterUi_input e-filtertext e-fltrTemp',\n              title: column.headerText,\n              id: column.field + '_filterBarcell'\n            });\n            innerDIV.appendChild(input);\n          }\n        } else {\n          attributes(innerDIV, {\n            'class': 'e-filterdiv e-fltrinputdiv'\n          });\n          input = this.parent.createElement('input', {\n            id: column.field + '_filterBarcell',\n            className: 'e-filtertext',\n            attrs: {\n              type: 'search',\n              title: column.headerText + cell.attributes.title,\n              value: data[cell.column.field] ? data[cell.column.field] : '',\n              role: 'search'\n            }\n          });\n          innerDIV.appendChild(input);\n          const args = {\n            element: input,\n            floatLabelType: 'Never',\n            properties: {\n              enableRtl: this.parent.enableRtl,\n              showClearButton: true\n            }\n          };\n          Input.createInput(args, this.parent.createElement);\n        } //TODO: apply intial filtering\n\n\n        if (column.allowFiltering === false || column.field === '' || isNullOrUndefined(column.field)) {\n          input.setAttribute('disabled', 'true');\n          input.classList.add('e-disable');\n        }\n\n        if (!column.visible) {\n          node.classList.add('e-hide');\n        }\n\n        this.appendHtml(node, innerDIV); // render's the dropdownlist component if showFilterBarOperator sets to true\n\n        if (this.parent.filterSettings.showFilterBarOperator && this.parent.filterSettings.type === 'FilterBar' && !this.parent.isPrinting && isNullOrUndefined(column.filterTemplate) && isNullOrUndefined(column.filterBarTemplate)) {\n          this.operatorIconRender(innerDIV, column, cell);\n        }\n\n        if ((isNullOrUndefined(column.allowFiltering) || column.allowFiltering) && !isNullOrUndefined(column.filterBarTemplate)) {\n          let templateWrite = column.filterBarTemplate.write;\n          const args = {\n            element: input,\n            column: column\n          };\n\n          if (typeof templateWrite === 'string') {\n            templateWrite = getValue(templateWrite, window);\n          }\n\n          templateWrite.call(this, args);\n        }\n      }\n    }\n\n    return node;\n  }\n  /**\n   * Function to specifies how the result content to be placed in the cell.\n   *\n   * @param {Element} node - specifies the node\n   * @param {string|Element} innerHtml - specifies the innerHTML\n   * @returns {Element} retruns the element\n   */\n\n\n  appendHtml(node, innerHtml) {\n    node.appendChild(innerHtml);\n    return node;\n  }\n\n  operatorIconRender(innerDIV, column, cell) {\n    const gObj = this.parent;\n    const fbicon = this.parent.createElement('input', {\n      className: ' e-filterbaroperator e-icons e-icon-filter',\n      id: cell.column.uid\n    });\n    innerDIV.querySelector('span').appendChild(fbicon);\n    let operators = column.filter && column.filter.operator ? column.filter.operator : 'equal';\n\n    if (!isNullOrUndefined(gObj.filterModule.operators[column.field])) {\n      operators = gObj.filterModule.operators[column.field];\n    }\n\n    this.dropOptr = new DropDownList({\n      fields: {\n        text: 'text',\n        value: 'value'\n      },\n      popupHeight: 'auto',\n      value: operators,\n      width: '0px',\n      enabled: column.allowFiltering,\n      popupWidth: 'auto',\n      enableRtl: this.parent.enableRtl,\n      change: this.internalEvent.bind(this),\n      beforeOpen: function () {\n        const operator = gObj.filterModule.customOperators;\n        this.dataSource = operator[gObj.getColumnByUid(this.element.id).type + 'Operator'];\n\n        for (let i = 0; i < this.dataSource.length; i++) {\n          if (column.filter && column.filter.operator && isNullOrUndefined(gObj.filterModule.operators[column.field]) && this.dataSource[i].value === column.filter.operator) {\n            this.value = column.filter.operator;\n          }\n        }\n      }\n    });\n    this.dropOptr.appendTo(fbicon);\n    const spanElmt = closest(this.dropOptr.element, 'span');\n    spanElmt.classList.add('e-filterbardropdown');\n    spanElmt.removeAttribute('tabindex');\n  }\n\n  internalEvent(e) {\n    const gObj = this.parent;\n    const col = gObj.getColumnByUid(e.element.getAttribute('id'));\n    e.column = col;\n    gObj.filterModule.operators[col.field] = e.value;\n    gObj.notify(getFilterBarOperator, e);\n  }\n\n}\n/**\n * `filter operators` render boolean column.\n *\n * @hidden\n */\n\n\nclass FlMenuOptrUI {\n  constructor(parent, customFltrOperators, serviceLocator, filterSettings) {\n    this.ddOpen = this.dropDownOpen.bind(this);\n    this.parent = parent;\n    this.serviceLocator = serviceLocator;\n    this.filterSettings = filterSettings;\n    this.customFilterOperators = customFltrOperators;\n\n    if (this.parent) {\n      this.parent.on(filterMenuClose, this.destroyDropDownList, this);\n      this.parent.on(destroy, this.destroyDropDownList, this);\n    }\n  }\n  /**\n   * @param {Element} dlgConetntEle - specifies the content element\n   * @param {Element} target - specifies the target\n   * @param {Column} column - specifies the column\n   * @param {Dialog} dlgObj - specifies the dialog\n   * @param {Object[]} operator - specifies the operator list\n   * @returns {void}\n   * @hidden\n   */\n  // eslint-disable-next-line max-len\n\n\n  renderOperatorUI(dlgConetntEle, target, column, dlgObj, operator) {\n    this.dialogObj = dlgObj;\n    const optr = column.type + 'Operator';\n    this.optrData = this.customOptr = !isNullOrUndefined(operator) ? operator : !isNullOrUndefined(this.parent.filterSettings.operators) && !isNullOrUndefined(this.parent.filterSettings.operators[optr]) ? this.parent.filterSettings.operators[optr] : this.customFilterOperators[optr];\n    const dropDatasource = this.customOptr;\n    const selectedValue = this.dropSelectedVal(column, optr);\n    const optrDiv = this.parent.createElement('div', {\n      className: 'e-flm_optrdiv'\n    });\n    dlgConetntEle.appendChild(optrDiv);\n    const optrInput = this.parent.createElement('input', {\n      id: column.uid + '-floptr'\n    });\n    optrDiv.appendChild(optrInput);\n    this.dropOptr = new DropDownList({\n      dataSource: dropDatasource,\n      fields: {\n        text: 'text',\n        value: 'value'\n      },\n      cssClass: 'e-popup-flmenu',\n      enableRtl: this.parent.enableRtl,\n      text: selectedValue\n    });\n    this.dropOptr.addEventListener(open, this.ddOpen);\n    this.dropOptr.appendTo('#' + column.uid + '-floptr');\n  }\n\n  renderResponsiveDropDownList(args) {\n    args.popup.element.style.width = '100%';\n  }\n\n  dropDownOpen(args) {\n    args.popup.element.style.zIndex = (this.dialogObj.zIndex + 1).toString();\n\n    if (this.parent.enableAdaptiveUI) {\n      this.renderResponsiveDropDownList(args);\n    }\n  } // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  dropSelectedVal(col, optr) {\n    let selValue = '';\n    const columns = this.parent.filterSettings.columns;\n\n    for (const column of columns) {\n      if (col.field === column.field || col.isForeignColumn() && col.foreignKeyValue === column.field) {\n        const selectedField = new DataManager(this.optrData).executeLocal(new Query().where('value', 'equal', column.operator));\n        selValue = !isNullOrUndefined(selectedField[0]) ? selectedField[0].text : '';\n      }\n    }\n\n    if (selValue === '') {\n      // rewuired or not\n      if (col.filter.operator) {\n        const optrLen = Object.keys(this.optrData).length;\n\n        for (let i = 0; i < optrLen; i++) {\n          if (this.optrData[i].value === col.filter.operator) {\n            selValue = this.optrData[i].text;\n          }\n        }\n      } else {\n        selValue = this.optrData[0].text;\n      }\n    }\n\n    return selValue;\n  }\n  /**\n   * @returns {string} returns the operator\n   * @hidden\n   */\n\n\n  getFlOperator() {\n    return this.dropOptr.value;\n  }\n\n  destroyDropDownList() {\n    if (this.dropOptr.isDestroyed) {\n      return;\n    }\n\n    this.dropOptr.removeEventListener(open, this.ddOpen);\n    this.dropOptr.destroy();\n    this.parent.off(filterMenuClose, this.destroyDropDownList);\n    this.parent.off(destroy, this.destroyDropDownList);\n  }\n\n}\n/**\n * `string filterui` render string column.\n *\n * @hidden\n */\n\n\nclass StringFilterUI {\n  constructor(parent, serviceLocator, filterSettings) {\n    this.parent = parent;\n    this.serLocator = serviceLocator;\n    this.filterSettings = filterSettings;\n\n    if (this.parent) {\n      this.parent.on(filterMenuClose, this.destroy, this);\n      this.parent.on(destroy, this.destroy, this);\n    }\n  }\n\n  create(args) {\n    this.instance = this.parent.createElement('input', {\n      className: 'e-flmenu-input',\n      id: 'strui-' + args.column.uid\n    });\n    args.target.appendChild(this.instance);\n    this.dialogObj = args.dialogObj;\n    this.actObj = this.getAutoCompleteOptions(args);\n    this.actObj.appendTo(this.instance);\n  }\n\n  getAutoCompleteOptions(args) {\n    const isForeignColumn = args.column.isForeignColumn();\n    let foreignColumnQuery;\n\n    if (isForeignColumn) {\n      foreignColumnQuery = new Query();\n      foreignColumnQuery.params = this.parent.query.params;\n    }\n\n    const dataSource = isForeignColumn ? args.column.dataSource : this.parent.dataSource;\n    const fields = {\n      value: isForeignColumn ? args.column.foreignKeyValue : args.column.field\n    };\n    const autoComplete = new AutoComplete(extend({\n      dataSource: dataSource instanceof DataManager ? dataSource : new DataManager(dataSource),\n      fields: fields,\n      locale: this.parent.locale,\n      enableRtl: this.parent.enableRtl,\n      query: isForeignColumn ? foreignColumnQuery : this.parent.query.clone(),\n      sortOrder: 'Ascending',\n      cssClass: 'e-popup-flmenu',\n      autofill: true,\n      placeholder: args.localizeText.getConstant('EnterValue')\n    }, args.column.filter.params));\n    this.acFocus = this.focus(autoComplete, args);\n    this.acComplete = this.actionComplete(autoComplete);\n    this.acOpen = this.openPopup.bind(this);\n    autoComplete.addEventListener(focus, this.acFocus);\n    autoComplete.addEventListener(open, this.acOpen);\n    autoComplete.addEventListener(actionComplete, this.acComplete);\n\n    if (dataSource && 'result' in dataSource) {\n      const query = this.parent.getQuery ? this.parent.getQuery().clone() : new Query();\n      const defObj = eventPromise({\n        requestType: 'stringfilterrequest'\n      }, query);\n      this.parent.trigger(dataStateChange, defObj.state);\n      const def = defObj.deffered;\n      def.promise.then(e => {\n        autoComplete.dataSource = new DataManager(e);\n      });\n    }\n\n    return autoComplete;\n  }\n\n  write(args) {\n    if (args.filteredValue !== '' && !isNullOrUndefined(args.filteredValue)) {\n      const struiObj = document.querySelector('#strui-' + args.column.uid).ej2_instances[0];\n      struiObj.value = args.filteredValue;\n    }\n  }\n\n  read(element, column, filterOptr, filterObj) {\n    const actuiObj = document.querySelector('#strui-' + column.uid).ej2_instances[0];\n\n    if (Browser.isDevice) {\n      actuiObj.hidePopup();\n      actuiObj.focusOut();\n    }\n\n    let filterValue = actuiObj.value;\n\n    if (isNullOrUndefined(filterValue) || filterValue === '') {\n      filterValue = null;\n    }\n\n    filterObj.filterByColumn(column.field, filterOptr, filterValue, 'and', this.parent.filterSettings.enableCaseSensitivity);\n  }\n\n  openPopup(args) {\n    getZIndexCalcualtion(args, this.dialogObj);\n  }\n\n  focus(actObj, args) {\n    return () => {\n      actObj.filterType = args.getOptrInstance.getFlOperator();\n    };\n  }\n\n  actionComplete(actObj) {\n    return e => {\n      e.result = e.result.filter((obj, index, arr) => {\n        return arr.map(mapObj => {\n          return getValue(actObj.fields.value, mapObj);\n        }).indexOf(getValue(actObj.fields.value, obj)) === index;\n      });\n    };\n  }\n\n  destroy() {\n    if (!this.actObj || this.actObj.isDestroyed) {\n      return;\n    }\n\n    this.actObj.removeEventListener(focus, this.acFocus);\n    this.actObj.removeEventListener(open, this.acOpen);\n    this.actObj.removeEventListener(actionComplete, this.acComplete);\n    this.actObj.destroy();\n    this.parent.off(filterMenuClose, this.destroy);\n    this.parent.off(destroy, this.destroy);\n  }\n\n}\n/**\n * `numberfilterui` render number column.\n *\n * @hidden\n */\n\n\nclass NumberFilterUI {\n  constructor(parent, serviceLocator, filterSettings) {\n    this.filterSettings = filterSettings;\n    this.parent = parent;\n    this.serviceLocator = serviceLocator;\n\n    if (this.parent) {\n      this.parent.on(filterMenuClose, this.destroy, this);\n      this.parent.on(destroy, this.destroy, this);\n    }\n  }\n\n  keyEventHandler(args) {\n    if (args.keyCode === 13 || args.keyCode === 9) {\n      const evt = document.createEvent('HTMLEvents');\n      evt.initEvent('change', false, true); // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n      this.dispatchEvent(evt);\n    }\n  }\n\n  create(args) {\n    this.instance = this.parent.createElement('input', {\n      className: 'e-flmenu-input',\n      id: 'numberui-' + args.column.uid\n    });\n    args.target.appendChild(this.instance);\n    this.numericTxtObj = new NumericTextBox(extend({\n      format: typeof args.column.format === 'string' || isUndefined(args.column.format) ? args.column.format : args.column.format.format,\n      locale: this.parent.locale,\n      cssClass: 'e-popup-flmenu',\n      placeholder: args.localizeText.getConstant('EnterValue'),\n      enableRtl: this.parent.enableRtl\n    }, args.column.filter.params));\n    this.numericTxtObj.appendTo(this.instance);\n  }\n\n  write(args) {\n    const numberuiObj = document.querySelector('#numberui-' + args.column.uid).ej2_instances[0];\n    numberuiObj.element.addEventListener('keydown', this.keyEventHandler);\n    numberuiObj.value = args.filteredValue;\n  }\n\n  read(element, column, filterOptr, filterObj) {\n    const numberuiObj = document.querySelector('#numberui-' + column.uid).ej2_instances[0];\n    const filterValue = numberuiObj.value;\n    filterObj.filterByColumn(column.field, filterOptr, filterValue, 'and', true);\n  }\n\n  destroy() {\n    if (!this.numericTxtObj || this.numericTxtObj.isDestroyed) {\n      return;\n    }\n\n    this.numericTxtObj.destroy();\n    this.parent.off(filterMenuClose, this.destroy);\n    this.parent.off(destroy, this.destroy);\n  }\n\n}\n/**\n * `boolfilterui` render boolean column.\n *\n * @hidden\n */\n\n\nclass BooleanFilterUI {\n  constructor(parent, serviceLocator, filterSettings) {\n    this.parent = parent;\n    this.serviceLocator = serviceLocator;\n    this.filterSettings = filterSettings;\n\n    if (this.parent) {\n      this.parent.on(filterMenuClose, this.destroy, this);\n      this.parent.on(destroy, this.destroy, this);\n    }\n  }\n\n  create(args) {\n    const isForeignColumn = args.column.isForeignColumn();\n    const dataSource = isForeignColumn ? args.column.dataSource : this.parent.dataSource;\n    const fields = isForeignColumn ? args.column.foreignKeyValue : args.column.field;\n    this.elem = this.parent.createElement('input', {\n      className: 'e-flmenu-input',\n      id: 'bool-ui-' + args.column.uid\n    });\n    args.target.appendChild(this.elem);\n    this.dialogObj = args.dialogObj;\n    this.dropInstance = new DropDownList(extend({\n      dataSource: dataSource instanceof DataManager ? dataSource : new DataManager(dataSource),\n      query: new Query().select(fields),\n      fields: {\n        text: fields,\n        value: fields\n      },\n      placeholder: args.localizeText.getConstant('SelectValue'),\n      cssClass: 'e-popup-flmenu',\n      locale: this.parent.locale,\n      enableRtl: this.parent.enableRtl\n    }, args.column.filter.params));\n    this.ddOpen = this.openPopup.bind(this);\n    this.ddComplete = this.actionComplete(fields);\n    this.dropInstance.addEventListener(open, this.ddOpen);\n    this.dropInstance.addEventListener(actionComplete, this.ddComplete);\n    this.dropInstance.appendTo(this.elem);\n  }\n\n  write(args) {\n    const drpuiObj = document.querySelector('#bool-ui-' + args.column.uid).ej2_instances[0];\n\n    if (!isNullOrUndefined(args.filteredValue)) {\n      drpuiObj.text = args.filteredValue;\n    }\n  }\n\n  read(element, column, filterOptr, filterObj) {\n    const drpuiObj = document.querySelector('#bool-ui-' + column.uid).ej2_instances[0];\n    const filterValue = drpuiObj.value;\n    filterObj.filterByColumn(column.field, filterOptr, filterValue, 'and', false);\n  }\n\n  openPopup(args) {\n    getZIndexCalcualtion(args, this.dialogObj);\n  }\n\n  actionComplete(fields) {\n    return e => {\n      e.result = DataUtil.distinct(e.result, fields, true);\n    };\n  }\n\n  destroy() {\n    if (!this.dropInstance || this.dropInstance.isDestroyed) {\n      return;\n    }\n\n    this.dropInstance.removeEventListener(open, this.ddOpen);\n    this.dropInstance.removeEventListener(actionComplete, this.ddComplete);\n    this.dropInstance.destroy();\n    this.parent.off(filterMenuClose, this.destroy);\n    this.parent.off(destroy, this.destroy);\n  }\n\n}\n/**\n * `datefilterui` render date column.\n *\n * @hidden\n */\n\n\nclass DateFilterUI {\n  constructor(parent, serviceLocator, filterSettings) {\n    this.dpOpen = this.openPopup.bind(this);\n    this.parent = parent;\n    this.locator = serviceLocator;\n    this.fltrSettings = filterSettings;\n\n    if (this.parent) {\n      this.parent.on(filterMenuClose, this.destroy, this);\n      this.parent.on(destroy, this.destroy, this);\n    }\n  }\n\n  create(args) {\n    const format = getCustomDateFormat(args.column.format, args.column.type);\n    this.dialogObj = args.dialogObj;\n    this.inputElem = this.parent.createElement('input', {\n      className: 'e-flmenu-input',\n      id: 'dateui-' + args.column.uid\n    });\n    args.target.appendChild(this.inputElem);\n\n    if (args.column.type === 'date') {\n      this.datePickerObj = new DatePicker(extend({\n        format: format,\n        cssClass: 'e-popup-flmenu',\n        placeholder: args.localizeText.getConstant('ChooseDate'),\n        width: '100%',\n        locale: this.parent.locale,\n        enableRtl: this.parent.enableRtl\n      }, args.column.filter.params));\n    } else if (args.column.type === 'datetime') {\n      this.datePickerObj = new DateTimePicker(extend({\n        format: format,\n        cssClass: 'e-popup-flmenu',\n        placeholder: args.localizeText.getConstant('ChooseDate'),\n        width: '100%',\n        locale: this.parent.locale,\n        enableRtl: this.parent.enableRtl\n      }, args.column.filter.params));\n    }\n\n    this.datePickerObj.addEventListener(open, this.dpOpen);\n    this.datePickerObj.appendTo(this.inputElem);\n  }\n\n  write(args) {\n    const dateuiObj = document.querySelector('#dateui-' + args.column.uid).ej2_instances[0];\n    dateuiObj.value = !isNullOrUndefined(args.filteredValue) ? new Date(args.filteredValue) : null;\n  }\n\n  read(element, column, filterOptr, filterObj) {\n    const dateuiObj = document.querySelector('#dateui-' + column.uid).ej2_instances[0];\n    let filterValue = dateuiObj.value;\n    filterValue = isNullOrUndefined(filterValue) ? null : filterValue;\n    filterObj.filterByColumn(column.field, filterOptr, filterValue, 'and', true);\n  }\n\n  openPopup(args) {\n    args.popup.element.style.zIndex = (this.dialogObj.zIndex + 1).toString();\n  }\n\n  destroy() {\n    this.parent.off(filterMenuClose, this.destroy);\n    this.parent.off(destroy, this.destroy);\n\n    if (isNullOrUndefined(this.datePickerObj) || this.datePickerObj.isDestroyed) {\n      return;\n    }\n\n    this.datePickerObj.removeEventListener(open, this.dpOpen);\n    this.datePickerObj.destroy();\n  }\n\n}\n/**\n * `filter menu` render boolean column.\n *\n * @hidden\n */\n\n\nclass FilterMenuRenderer {\n  constructor(parent, filterSettings, serviceLocator, customFltrOperators, fltrObj) {\n    this.isDialogOpen = false;\n    this.maxHeight = '350px';\n    this.isMenuCheck = false;\n    this.colTypes = {\n      'string': StringFilterUI,\n      'number': NumberFilterUI,\n      'date': DateFilterUI,\n      'boolean': BooleanFilterUI,\n      'datetime': DateFilterUI\n    };\n    this.parent = parent;\n    this.filterSettings = filterSettings;\n    this.serviceLocator = serviceLocator;\n    this.customFilterOperators = customFltrOperators;\n    this.filterObj = fltrObj;\n    this.flMuiObj = new FlMenuOptrUI(this.parent, this.customFilterOperators, this.serviceLocator);\n    this.l10n = this.serviceLocator.getService('localization');\n    this.menuFilterBase = new CheckBoxFilterBase(parent);\n  }\n\n  clearCustomFilter(col) {\n    this.clearBtnClick(col);\n  }\n\n  applyCustomFilter(args) {\n    this.filterBtnClick(args.col);\n  }\n\n  openDialog(args) {\n    this.options = args;\n    this.col = this.parent.getColumnByField(args.field);\n\n    if (isNullOrUndefined(this.col.filter) || isNullOrUndefined(this.col.filter.type) || this.col.filter.type === 'Menu') {\n      ///\n      this.renderDlgContent(args.target, this.col);\n    }\n  }\n\n  closeDialog(target) {\n    if (!this.dlgObj) {\n      return;\n    }\n\n    if (this.parent.isReact || this.parent.isVue) {\n      clearReactVueTemplates(this.parent, ['filterTemplate']);\n    }\n\n    const elem = document.getElementById(this.dlgObj.element.id);\n\n    if (this.dlgObj && !this.dlgObj.isDestroyed && elem) {\n      const argument = {\n        cancel: false,\n        column: this.col,\n        target: target,\n        element: elem\n      };\n      this.parent.notify(filterMenuClose, argument);\n\n      if (argument.cancel) {\n        return;\n      }\n\n      this.isDialogOpen = false;\n\n      if (this.isMenuCheck) {\n        this.menuFilterBase.unWireEvents();\n        this.parent.off(cBoxFltrComplete, this.actionComplete);\n        this.isMenuCheck = false;\n      }\n\n      this.dlgObj.destroy();\n      remove(elem);\n    }\n\n    this.parent.notify(filterDialogClose, {});\n  }\n\n  renderDlgContent(target, column) {\n    const args = {\n      requestType: filterBeforeOpen,\n      columnName: column.field,\n      columnType: column.type\n    };\n    const filterModel = 'filterModel';\n    args[filterModel] = this;\n    this.parent.trigger(actionBegin, args);\n    const mainDiv = this.parent.createElement('div', {\n      className: 'e-flmenu-maindiv',\n      id: column.uid + '-flmenu'\n    });\n    this.dlgDiv = this.parent.createElement('div', {\n      className: 'e-flmenu',\n      id: column.uid + '-flmdlg'\n    });\n    this.dlgDiv.setAttribute('aria-label', this.l10n.getConstant('FilterMenuDialogARIA'));\n\n    if (this.parent.enableAdaptiveUI) {\n      const responsiveCnt = document.querySelector('.e-resfilter > .e-dlg-content > .e-mainfilterdiv');\n      responsiveCnt.appendChild(this.dlgDiv);\n    } else {\n      this.parent.element.appendChild(this.dlgDiv);\n    }\n\n    this.dlgObj = new Dialog({\n      showCloseIcon: false,\n      closeOnEscape: false,\n      locale: this.parent.locale,\n      visible: false,\n      enableRtl: this.parent.enableRtl,\n      created: this.dialogCreated.bind(this, target, column),\n      position: this.parent.element.classList.contains('e-device') ? {\n        X: 'center',\n        Y: 'center'\n      } : {\n        X: '',\n        Y: ''\n      },\n      target: this.parent.element.classList.contains('e-device') ? document.body : this.parent.element,\n      buttons: [{\n        click: this.filterBtnClick.bind(this, column),\n        buttonModel: {\n          content: this.l10n.getConstant('FilterButton'),\n          isPrimary: true,\n          cssClass: 'e-flmenu-okbtn'\n        }\n      }, {\n        click: this.clearBtnClick.bind(this, column),\n        buttonModel: {\n          content: this.l10n.getConstant('ClearButton'),\n          cssClass: 'e-flmenu-cancelbtn'\n        }\n      }],\n      content: mainDiv,\n      width: !isNullOrUndefined(parentsUntil(target, 'e-bigger')) || this.parent.element.classList.contains('e-device') ? 260 : 250,\n      animationSettings: {\n        effect: 'None'\n      },\n      cssClass: 'e-filter-popup'\n    });\n    const isStringTemplate = 'isStringTemplate';\n    this.dlgObj[isStringTemplate] = true;\n    this.renderResponsiveDialog();\n    this.dlgObj.appendTo(this.dlgDiv);\n  }\n\n  renderResponsiveDialog() {\n    const gObj = this.parent;\n\n    if (gObj.enableAdaptiveUI) {\n      this.dlgObj.position = {\n        X: '',\n        Y: ''\n      };\n      this.dlgObj.target = document.querySelector('.e-resfilter > .e-dlg-content > .e-mainfilterdiv');\n      this.dlgObj.width = '100%';\n      this.dlgObj.isModal = false;\n      this.dlgObj.buttons = [{}];\n    }\n  }\n\n  dialogCreated(target, column) {\n    if (!Browser.isDevice && target) {\n      getFilterMenuPostion(target, this.dlgObj);\n    }\n\n    this.renderFilterUI(target, column);\n    this.parent.notify(filterDialogCreated, {});\n\n    if (this.parent.enableAdaptiveUI) {\n      this.dlgObj.element.style.left = '0px';\n      this.dlgObj.element.style.maxHeight = 'none';\n    } else {\n      this.dlgObj.element.style.maxHeight = this.maxHeight;\n    }\n\n    this.dlgObj.show();\n\n    if (!column.filterTemplate) {\n      this.writeMethod(column, this.dlgObj.element.querySelector('#' + column.uid + '-flmenu'));\n    }\n\n    const args = {\n      requestType: filterAfterOpen,\n      columnName: column.field,\n      columnType: column.type\n    };\n    const filterModel = 'filterModel';\n    args[filterModel] = this;\n    this.isDialogOpen = true;\n\n    if (!this.isMenuCheck) {\n      this.parent.trigger(actionComplete, args);\n    }\n  }\n\n  renderFilterUI(target, col) {\n    const dlgConetntEle = this.dlgObj.element.querySelector('.e-flmenu-maindiv');\n    this.parent.log('column_type_missing', {\n      column: col\n    });\n    this.renderOperatorUI(dlgConetntEle, target, col);\n    this.renderFlValueUI(dlgConetntEle, target, col);\n  }\n\n  renderOperatorUI(dlgConetntEle, target, column) {\n    this.flMuiObj.renderOperatorUI(dlgConetntEle, target, column, this.dlgObj, this.filterObj.menuOperator);\n  }\n\n  renderFlValueUI(dlgConetntEle, target, column) {\n    const valueDiv = this.parent.createElement('div', {\n      className: 'e-flmenu-valuediv'\n    });\n    const fObj = this.filterObj;\n    dlgConetntEle.appendChild(valueDiv);\n    const instanceofFilterUI = new this.colTypes[column.type](this.parent, this.serviceLocator, this.parent.filterSettings);\n\n    if (column.filterTemplate) {\n      const fltrData = {};\n      const valueInString = 'value';\n      fltrData[column.field] = fltrData[valueInString] = fObj.values[column.field];\n\n      if (column.foreignKeyValue) {\n        fltrData[column.foreignKeyValue] = fObj.values[column.field];\n        fltrData[column.field] = undefined;\n      }\n\n      const col = 'column';\n      fltrData[col] = column;\n      const isReactCompiler = this.parent.isReact && typeof column.filterTemplate !== 'string';\n      const tempID = this.parent.element.id + column.uid + 'filterTemplate';\n\n      if (isReactCompiler) {\n        column.getFilterTemplate()(fltrData, this.parent, 'filterTemplate', tempID, null, null, valueDiv);\n        this.parent.renderTemplates();\n      } else {\n        const compElement = column.getFilterTemplate()(fltrData, this.parent, 'filterTemplate', tempID);\n        appendChildren(valueDiv, compElement);\n      }\n\n      if (this.isMenuCheck) {\n        this.menuFilterBase.cBox = this.dlgObj.element.querySelector('.e-checkboxlist.e-fields');\n        this.menuFilterBase.wireEvents();\n        this.parent.on(cBoxFltrComplete, this.actionComplete, this);\n        this.menuFilterBase.getAllData();\n      }\n    } else {\n      if (!isNullOrUndefined(column.filter) && !isNullOrUndefined(column.filter.ui) && !isNullOrUndefined(column.filter.ui.create)) {\n        let temp = column.filter.ui.create;\n\n        if (typeof temp === 'string') {\n          temp = getValue(temp, window);\n        }\n\n        temp({\n          column: column,\n          target: valueDiv,\n          getOptrInstance: this.flMuiObj,\n          dialogObj: this.dlgObj\n        });\n      } else {\n        instanceofFilterUI.create({\n          column: column,\n          target: valueDiv,\n          getOptrInstance: this.flMuiObj,\n          localizeText: this.l10n,\n          dialogObj: this.dlgObj\n        });\n      }\n    }\n  }\n\n  writeMethod(col, dlgContentEle) {\n    let flValue;\n    const target = dlgContentEle.querySelector('.e-flmenu-valinput');\n    const instanceofFilterUI = new this.colTypes[col.type](this.parent, this.serviceLocator, this.parent.filterSettings);\n    const columns = this.filterSettings.columns;\n\n    for (const column of columns) {\n      if (col.uid === column.uid) {\n        flValue = column.value;\n      }\n    }\n\n    if (!isNullOrUndefined(col.filter) && !isNullOrUndefined(col.filter.ui) && !isNullOrUndefined(col.filter.ui.write)) {\n      let temp = col.filter.ui.write;\n\n      if (typeof temp === 'string') {\n        temp = getValue(temp, window);\n      }\n\n      temp({\n        column: col,\n        target: target,\n        parent: this.parent,\n        filteredValue: flValue\n      });\n    } else {\n      instanceofFilterUI.write({\n        column: col,\n        target: target,\n        parent: this.parent,\n        filteredValue: flValue\n      });\n    }\n  }\n\n  filterBtnClick(col) {\n    let flValue;\n    const targ = this.dlgObj.element.querySelector('.e-flmenu-valuediv input');\n    const flOptrValue = this.flMuiObj.getFlOperator();\n    const instanceofFilterUI = new this.colTypes[col.type](this.parent, this.serviceLocator, this.parent.filterSettings);\n\n    if (col.filterTemplate) {\n      const element = this.dlgDiv.querySelector('.e-flmenu-valuediv');\n      let fltrValue;\n\n      if (element.children[0].value) {\n        fltrValue = element.children[0].value;\n      } else {\n        if (!isNullOrUndefined(element.children[0].ej2_instances)) {\n          // eslint-disable-next-line @typescript-eslint/no-explicit-any\n          fltrValue = (this.parent.isAngular ? element.children[0] : element.querySelector('input')).ej2_instances[0].value;\n        } else {\n          const eControl = element.querySelector('.e-control');\n          fltrValue = col.type === 'boolean' ? eControl.checked : !isNullOrUndefined(eControl.ej2_instances) ? eControl.ej2_instances[0].value : eControl.value;\n        }\n      }\n\n      this.filterObj.filterByColumn(col.field, flOptrValue, fltrValue);\n    } else {\n      if (!isNullOrUndefined(col.filter) && !isNullOrUndefined(col.filter.ui) && !isNullOrUndefined(col.filter.ui.read)) {\n        let temp = col.filter.ui.read;\n\n        if (typeof temp === 'string') {\n          temp = getValue(temp, window);\n        } // eslint-disable-next-line\n\n\n        flValue = temp({\n          element: targ,\n          column: col,\n          operator: flOptrValue,\n          fltrObj: this.filterObj\n        });\n      } else {\n        instanceofFilterUI.read(targ, col, flOptrValue, this.filterObj);\n      }\n    }\n\n    this.closeDialog();\n  }\n\n  closeResponsiveDialog() {\n    this.closeDialog();\n  }\n\n  clearBtnClick(column) {\n    this.filterObj.removeFilteredColsByField(column.field);\n    this.closeDialog();\n    const iconClass = this.parent.showColumnMenu ? '.e-columnmenu' : '.e-icon-filter';\n    const col = this.parent.element.querySelector('[e-mappinguid=\"' + column.uid + '\"]').parentElement;\n    const flIcon = col.querySelector(iconClass);\n\n    if (flIcon) {\n      flIcon.classList.remove('e-filtered');\n    }\n  }\n\n  destroy() {\n    this.closeDialog();\n  }\n  /**\n   * @returns {FilterUI} returns the filterUI\n   * @hidden\n   */\n\n\n  getFilterUIInfo() {\n    return {\n      field: this.col.field,\n      operator: this.flMuiObj.getFlOperator()\n    };\n  }\n\n  renderCheckBoxMenu() {\n    this.isMenuCheck = true;\n    this.menuFilterBase.updateModel(this.options);\n    this.menuFilterBase.getAndSetChkElem(this.options);\n    this.dlgObj.buttons = [{\n      click: this.menuFilterBase.btnClick.bind(this.menuFilterBase),\n      buttonModel: {\n        content: this.menuFilterBase.getLocalizedLabel('FilterButton'),\n        cssClass: 'e-primary',\n        isPrimary: true\n      }\n    }, {\n      click: this.menuFilterBase.btnClick.bind(this.menuFilterBase),\n      buttonModel: {\n        cssClass: 'e-flat',\n        content: this.menuFilterBase.getLocalizedLabel('ClearButton')\n      }\n    }];\n    this.menuFilterBase.dialogObj = this.dlgObj;\n    this.menuFilterBase.dlg = this.dlgObj.element;\n    this.menuFilterBase.dlg.classList.add('e-menucheckbox');\n    this.menuFilterBase.dlg.classList.remove('e-checkboxfilter');\n    this.maxHeight = '800px';\n    return this.menuFilterBase.sBox.innerHTML;\n  }\n\n  actionComplete(args) {\n    if (this.isMenuCheck) {\n      this.parent.trigger(actionComplete, args);\n    }\n  }\n\n}\n/**\n * @hidden\n * `CheckBoxFilter` module is used to handle filtering action.\n */\n\n\nclass CheckBoxFilter {\n  /**\n   * Constructor for checkbox filtering module\n   *\n   * @param {IGrid} parent - specifies the IGrid\n   * @param {FilterSettings} filterSettings - specifies the filtersettings\n   * @param {ServiceLocator} serviceLocator - specifies the ServiceLocator\n   * @hidden\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  constructor(parent, filterSettings, serviceLocator) {\n    this.parent = parent;\n    this.isresetFocus = true;\n    this.checkBoxBase = new CheckBoxFilterBase(parent);\n    this.addEventListener();\n  }\n  /**\n   * To destroy the check box filter.\n   *\n   * @returns {void}\n   * @hidden\n   */\n\n\n  destroy() {\n    this.removeEventListener();\n    this.checkBoxBase.closeDialog();\n  }\n\n  openDialog(options) {\n    this.checkBoxBase.openDialog(options);\n    this.parent.log('column_type_missing', {\n      column: options.column\n    });\n  }\n\n  closeDialog() {\n    this.destroy();\n\n    if (this.isresetFocus) {\n      this.parent.notify(restoreFocus, {});\n    }\n  }\n\n  closeResponsiveDialog() {\n    this.checkBoxBase.closeDialog();\n  }\n  /**\n   * For internal use only - Get the module name.\n   *\n   * @returns {string} - returns the module name\n   * @private\n   */\n\n\n  getModuleName() {\n    return 'checkboxFilter';\n  }\n\n  actionBegin(args) {\n    this.parent.trigger(actionBegin, args);\n  }\n\n  actionComplete(args) {\n    this.parent.trigger(actionComplete, args);\n  }\n\n  actionPrevent(args) {\n    if (isActionPrevent(this.parent)) {\n      this.parent.notify(preventBatch, args);\n      args.cancel = true;\n    }\n  }\n\n  clearCustomFilter(col) {\n    this.checkBoxBase.clearFilter(col);\n  }\n\n  applyCustomFilter() {\n    this.checkBoxBase.fltrBtnHandler();\n    this.checkBoxBase.closeDialog();\n  }\n\n  addEventListener() {\n    if (this.parent.isDestroyed) {\n      return;\n    }\n\n    this.parent.on(cBoxFltrBegin, this.actionBegin, this);\n    this.parent.on(cBoxFltrComplete, this.actionComplete, this);\n    this.parent.on(fltrPrevent, this.actionPrevent, this);\n  }\n\n  removeEventListener() {\n    if (this.parent.isDestroyed) {\n      return;\n    }\n\n    this.parent.off(cBoxFltrBegin, this.actionBegin);\n    this.parent.off(cBoxFltrComplete, this.actionComplete);\n    this.parent.off(fltrPrevent, this.actionPrevent);\n  }\n\n}\n/**\n * @hidden\n * `ExcelFilter` module is used to handle filtering action.\n */\n\n\nclass ExcelFilter extends CheckBoxFilter {\n  /**\n   * Constructor for excelbox filtering module\n   *\n   * @param {IGrid} parent - specifies the IGrid\n   * @param {FilterSettings} filterSettings - specifies the Filtersettings\n   * @param {ServiceLocator} serviceLocator - specifies the serviceLocator\n   * @param {object} customFltrOperators - specifies the customFltrOperators\n   * @hidden\n   */\n  constructor(parent, filterSettings, serviceLocator, customFltrOperators) {\n    super(parent, filterSettings, serviceLocator);\n    this.parent = parent;\n    this.isresetFocus = true;\n    this.excelFilterBase = new ExcelFilterBase(parent, customFltrOperators);\n  }\n  /**\n   * To destroy the excel filter.\n   *\n   * @returns {void}\n   * @hidden\n   */\n\n\n  destroy() {\n    this.excelFilterBase.closeDialog();\n  }\n\n  openDialog(options) {\n    this.excelFilterBase.openDialog(options);\n  }\n\n  closeDialog() {\n    this.excelFilterBase.closeDialog();\n\n    if (this.isresetFocus) {\n      this.parent.notify(restoreFocus, {});\n    }\n  }\n\n  clearCustomFilter(col) {\n    this.excelFilterBase.clearFilter(col);\n  }\n\n  closeResponsiveDialog(isCustomFilter) {\n    if (isCustomFilter) {\n      this.excelFilterBase.removeDialog();\n    } else {\n      this.closeDialog();\n    }\n  }\n\n  applyCustomFilter(args) {\n    if (!args.isCustomFilter) {\n      this.excelFilterBase.fltrBtnHandler();\n      this.excelFilterBase.closeDialog();\n    } else {\n      this.excelFilterBase.filterBtnClick(args.col.field);\n    }\n  }\n\n  filterByColumn(fieldName, firstOperator, firstValue, predicate, matchCase, ignoreAccent, secondOperator, secondValue) {\n    this.excelFilterBase.filterByColumn(fieldName, firstOperator, firstValue, predicate, matchCase, ignoreAccent, secondOperator, secondValue);\n  }\n  /**\n   * @returns {FilterUI} returns the filterUI\n   * @hidden\n   */\n\n\n  getFilterUIInfo() {\n    return this.excelFilterBase.getFilterUIInfo();\n  }\n  /**\n   * For internal use only - Get the module name.\n   *\n   * @returns {string} returns the module name\n   * @private\n   */\n\n\n  getModuleName() {\n    return 'excelFilter';\n  }\n\n}\n/**\n *\n * The `Filter` module is used to handle filtering action.\n */\n\n\nclass Filter {\n  /**\n   * Constructor for Grid filtering module\n   *\n   * @param {IGrid} parent - specifies the IGrid\n   * @param {FilterSettings} filterSettings - specifies the filterSettings\n   * @param {ServiceLocator} serviceLocator - specifes the serviceLocator\n   * @hidden\n   */\n  constructor(parent, filterSettings, serviceLocator) {\n    this.predicate = 'and';\n    this.contentRefresh = true;\n    this.filterByMethod = true;\n    this.refresh = true;\n    this.values = {};\n    this.operators = {};\n    this.cellText = {};\n    this.nextFlMenuOpen = '';\n    this.type = {\n      'Menu': FilterMenuRenderer,\n      'CheckBox': CheckBoxFilter,\n      'Excel': ExcelFilter\n    };\n    /** @hidden */\n\n    this.filterOperators = {\n      contains: 'contains',\n      endsWith: 'endswith',\n      equal: 'equal',\n      greaterThan: 'greaterthan',\n      greaterThanOrEqual: 'greaterthanorequal',\n      lessThan: 'lessthan',\n      lessThanOrEqual: 'lessthanorequal',\n      notEqual: 'notequal',\n      startsWith: 'startswith'\n    };\n    this.fltrDlgDetails = {\n      field: '',\n      isOpen: false\n    };\n    /** @hidden */\n\n    this.skipNumberInput = ['=', ' ', '!'];\n    this.skipStringInput = ['>', '<', '='];\n    this.actualPredicate = {};\n    this.parent = parent;\n    this.filterSettings = filterSettings;\n    this.serviceLocator = serviceLocator;\n    this.addEventListener();\n    this.setFullScreenDialog();\n  }\n  /**\n   * To render filter bar when filtering enabled.\n   *\n   * @param {NotifyArgs} e - specifies the NotifyArgs\n   * @returns {void}\n   * @hidden\n   */\n\n\n  render(e) {\n    if (DataUtil.getObject('args.isFrozen', e) || this.parent.getFrozenMode() === leftRight && DataUtil.getObject('args.renderFrozenRightContent', e)) {\n      return;\n    }\n\n    const gObj = this.parent;\n    this.l10n = this.serviceLocator.getService('localization');\n    this.getLocalizedCustomOperators();\n\n    if (this.parent.filterSettings.type === 'FilterBar') {\n      if (gObj.columns.length) {\n        const fltrElem = this.parent.element.querySelector('.e-filterbar');\n\n        if (fltrElem) {\n          remove(fltrElem);\n        }\n\n        const rowRenderer = new RowRenderer(this.serviceLocator, CellType.Filter, gObj);\n        const cellrender = this.serviceLocator.getService('cellRendererFactory');\n        cellrender.addCellRenderer(CellType.Filter, new FilterCellRenderer(this.parent, this.serviceLocator));\n        this.valueFormatter = this.serviceLocator.getService('valueFormatter');\n        rowRenderer.element = this.parent.createElement('tr', {\n          className: 'e-filterbar'\n        });\n        const row$$1 = this.generateRow();\n        row$$1.data = this.values;\n\n        if (gObj.getFrozenMode() === 'Right') {\n          const thead = gObj.getFrozenRightHeader().querySelector('thead');\n          thead.appendChild(rowRenderer.element);\n        } else {\n          this.parent.getHeaderContent().querySelector('thead').appendChild(rowRenderer.element);\n        }\n\n        const rowdrag = this.parent.element.querySelector('.e-rowdragheader');\n        this.element = rowRenderer.render(row$$1, gObj.getColumns(), null, null, rowRenderer.element);\n        const detail = this.element.querySelector('.e-detailheadercell');\n\n        if (detail) {\n          detail.className = 'e-filterbarcell e-mastercell';\n        }\n\n        if (rowdrag) {\n          rowdrag.className = 'e-dragheadercell e-mastercell';\n        }\n\n        const gCells = [].slice.call(this.element.getElementsByClassName('e-grouptopleftcell'));\n\n        if (gCells.length) {\n          gCells[gCells.length - 1].classList.add('e-lastgrouptopleftcell');\n        }\n\n        this.wireEvents();\n        this.parent.notify(freezeRender, {\n          case: 'filter'\n        });\n      }\n    }\n  }\n  /**\n   * To show the responsive custom filter dialog\n   *\n   * @param {boolean} enable - specifes dialog open\n   * @returns {void}\n   * @hidden\n   */\n\n\n  showCustomFilter(enable) {\n    this.responsiveDialogRenderer.isCustomDialog = enable;\n    this.responsiveDialogRenderer.showResponsiveDialog(this.column);\n  }\n  /**\n   * To create the filter module.\n   *\n   * @param {Column} col - specifies the filtering column name\n   * @returns {void}\n   * @hidden\n   */\n\n\n  setFilterModel(col) {\n    const type = col.filter.type || this.parent.filterSettings.type;\n    this.filterModule = new this.type[type](this.parent, this.parent.filterSettings, this.serviceLocator, this.customOperators, this);\n  }\n  /**\n   * To destroy the filter bar.\n   *\n   * @returns {void}\n   * @hidden\n   */\n\n\n  destroy() {\n    const gridElement = this.parent.element;\n\n    if (!gridElement || !gridElement.querySelector('.' + gridHeader) && !gridElement.querySelector('.' + gridContent)) {\n      return;\n    }\n\n    if (this.filterModule) {\n      this.filterModule.destroy();\n    } // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n\n    if (!this.parent.refreshing && (this.parent.isDestroyed || !this.parent.allowFiltering)) {\n      this.filterSettings.columns = [];\n    }\n\n    this.updateFilterMsg();\n    this.removeEventListener();\n    this.unWireEvents();\n\n    if (this.filterSettings.type === 'FilterBar' && this.filterSettings.showFilterBarOperator) {\n      const dropdownlist = [].slice.call(this.element.getElementsByClassName('e-filterbaroperator'));\n\n      for (let i = 0; i < dropdownlist.length; i++) {\n        if (dropdownlist[i].ej2_instances[0]) {\n          dropdownlist[i].ej2_instances[0].destroy();\n        }\n      }\n    }\n\n    if (this.element) {\n      if (this.element.parentElement) {\n        remove(this.element);\n      }\n\n      const filterBarElement = this.parent.getHeaderContent().querySelector('.e-filterbar');\n\n      if (this.parent.isFrozenGrid() && filterBarElement) {\n        remove(filterBarElement);\n      }\n    }\n  }\n\n  setFullScreenDialog() {\n    if (this.serviceLocator) {\n      this.serviceLocator.registerAdaptiveService(this, this.parent.enableAdaptiveUI, ResponsiveDialogAction.isFilter);\n    }\n  }\n\n  generateRow() {\n    const options = {};\n    const row$$1 = new Row(options);\n    row$$1.cells = this.generateCells();\n    return row$$1;\n  }\n\n  generateCells() {\n    //TODO: generate dummy column for group, detail, stacked row here for filtering;\n    const cells = [];\n\n    if (this.parent.allowGrouping) {\n      for (let c = 0, len = this.parent.groupSettings.columns.length; c < len; c++) {\n        cells.push(this.generateCell({}, CellType.HeaderIndent));\n      }\n    }\n\n    if (this.parent.detailTemplate || this.parent.childGrid) {\n      cells.push(this.generateCell({}, CellType.DetailHeader));\n    }\n\n    if (this.parent.isRowDragable() && this.parent.getFrozenMode() !== 'Right') {\n      cells.push(this.generateCell({}, CellType.RowDragHIcon));\n    }\n\n    for (const dummy of this.parent.getColumns()) {\n      cells.push(this.generateCell(dummy));\n    }\n\n    if (this.parent.getFrozenMode() === 'Right') {\n      cells.push(this.generateCell({}, CellType.RowDragHIcon));\n    }\n\n    return cells;\n  }\n\n  generateCell(column, cellType) {\n    const opt = {\n      'visible': column.visible,\n      'isDataCell': false,\n      'rowId': '',\n      'column': column,\n      'cellType': cellType ? cellType : CellType.Filter,\n      'attributes': {\n        title: this.l10n.getConstant('FilterbarTitle')\n      }\n    };\n    return new Cell(opt);\n  }\n  /**\n   * To update filterSettings when applying filter.\n   *\n   * @returns {void}\n   * @hidden\n   */\n\n\n  updateModel() {\n    const col = this.parent.getColumnByField(this.fieldName);\n    this.filterObjIndex = this.getFilteredColsIndexByField(col);\n    this.prevFilterObject = this.filterSettings.columns[this.filterObjIndex];\n    const arrayVal = Array.isArray(this.value) ? this.value : [this.value];\n\n    for (let i = 0, len = arrayVal.length; i < len; i++) {\n      const field = col.isForeignColumn() ? col.foreignKeyValue : this.fieldName;\n      const isMenuNotEqual = this.operator === 'notequal';\n      this.currentFilterObject = {\n        field: field,\n        uid: col.uid,\n        isForeignKey: col.isForeignColumn(),\n        operator: this.operator,\n        value: arrayVal[i],\n        predicate: this.predicate,\n        matchCase: this.matchCase,\n        ignoreAccent: this.ignoreAccent,\n        actualFilterValue: {},\n        actualOperator: {}\n      };\n      const index = this.getFilteredColsIndexByField(col);\n\n      if (index > -1 && !Array.isArray(this.value)) {\n        this.filterSettings.columns[index] = this.currentFilterObject;\n      } else {\n        this.filterSettings.columns.push(this.currentFilterObject);\n      }\n\n      if (isNullOrUndefined(this.value) && (this.operator === 'equal' || this.operator === 'notequal')) {\n        this.filterSettings.columns = [];\n\n        if (col.type === 'string') {\n          this.filterSettings.columns.push({\n            field: field,\n            ignoreAccent: this.ignoreAccent,\n            matchCase: this.matchCase,\n            operator: this.operator,\n            predicate: isMenuNotEqual ? 'and' : 'or',\n            value: ''\n          });\n        }\n\n        this.filterSettings.columns.push({\n          field: field,\n          ignoreAccent: this.ignoreAccent,\n          matchCase: this.matchCase,\n          operator: this.operator,\n          predicate: isMenuNotEqual ? 'and' : 'or',\n          value: undefined\n        });\n        this.filterSettings.columns.push({\n          field: field,\n          ignoreAccent: this.ignoreAccent,\n          matchCase: this.matchCase,\n          operator: this.operator,\n          predicate: isMenuNotEqual ? 'and' : 'or',\n          value: null\n        });\n      }\n    } // eslint-disable-next-line no-self-assign\n\n\n    this.filterSettings.columns = this.filterSettings.columns;\n    this.parent.dataBind();\n  }\n\n  getFilteredColsIndexByField(col) {\n    const cols = this.filterSettings.columns;\n\n    for (let i = 0, len = cols.length; i < len; i++) {\n      if (cols[i].uid === col.uid || col.isForeignColumn() && this.parent.getColumnByUid(col.uid).field === col.foreignKeyValue) {\n        return i;\n      }\n    }\n\n    return -1;\n  }\n  /**\n   * To trigger action complete event.\n   *\n   * @param {NotifyArgs} e - specifies the NotifyArgs\n   * @returns {void}\n   * @hidden\n   */\n\n\n  onActionComplete(e) {\n    const args = !this.isRemove ? {\n      currentFilterObject: this.currentFilterObject,\n\n      /* tslint:disable:no-string-literal */\n      currentFilteringColumn: !isNullOrUndefined(this.column) ? this.column.field : undefined,\n\n      /* tslint:enable:no-string-literal */\n      columns: this.filterSettings.columns,\n      requestType: 'filtering',\n      type: actionComplete\n    } : {\n      requestType: 'filtering',\n      type: actionComplete\n    };\n    this.parent.trigger(actionComplete, extend(e, args));\n    this.isRemove = false;\n  }\n\n  wireEvents() {\n    EventHandler.add(this.parent.getHeaderContent(), 'keyup', this.keyUpHandlerImmediate, this);\n  }\n\n  unWireEvents() {\n    EventHandler.remove(this.parent.getHeaderContent(), 'keyup', this.keyUpHandlerImmediate);\n  }\n\n  enableAfterRender(e) {\n    if (e.module === this.getModuleName() && e.enable) {\n      this.parent.getHeaderTable().classList.add('e-sortfilter');\n      this.render();\n    }\n  }\n\n  refreshFilterValue() {\n    if (this.filterSettings.type === 'FilterBar' && this.filterSettings.columns.length && !this.parent.getCurrentViewRecords().length && this.parent.enablePersistence) {\n      this.initialEnd();\n      this.parent.removeEventListener(beforeDataBound, this.refreshFilterValueFn);\n    }\n  }\n\n  initialEnd() {\n    this.parent.off(contentReady, this.initialEnd);\n\n    if (this.parent.getColumns().length && this.filterSettings.columns.length) {\n      const gObj = this.parent;\n      this.contentRefresh = false;\n      this.initialLoad = true;\n\n      for (const col of gObj.filterSettings.columns) {\n        this.filterByColumn(col.field, col.operator, col.value, col.predicate, col.matchCase, col.ignoreAccent, col.actualFilterValue, col.actualOperator);\n      }\n\n      this.initialLoad = false;\n      this.updateFilterMsg();\n      this.contentRefresh = true;\n    }\n  }\n  /**\n   * @returns {void}\n   * @hidden\n   */\n\n\n  addEventListener() {\n    if (this.parent.isDestroyed) {\n      return;\n    }\n\n    this.parent.on(setFullScreenDialog, this.setFullScreenDialog, this);\n    this.parent.on(uiUpdate, this.enableAfterRender, this);\n    this.parent.on(filterComplete, this.onActionComplete, this);\n    this.parent.on(inBoundModelChanged, this.onPropertyChanged, this);\n    this.parent.on(keyPressed, this.keyUpHandler, this);\n    this.parent.on(columnPositionChanged, this.columnPositionChanged, this);\n    this.parent.on(headerRefreshed, this.render, this);\n    this.parent.on(contentReady, this.initialEnd, this);\n    this.parent.on(filterMenuClose, this.filterMenuClose, this);\n    this.docClickHandler = this.clickHandler.bind(this);\n    EventHandler.add(document, 'click', this.docClickHandler, this);\n    EventHandler.add(this.parent.element, 'mousedown', this.refreshClearIcon, this);\n    this.parent.on(filterOpen, this.columnMenuFilter, this);\n    this.parent.on(click, this.filterIconClickHandler, this);\n    this.parent.on('persist-data-changed', this.initialEnd, this);\n    this.parent.on(closeFilterDialog, this.clickHandler, this);\n    this.parent.on(destroy, this.destroy, this);\n    this.refreshFilterValueFn = this.refreshFilterValue.bind(this);\n    this.parent.addEventListener(beforeDataBound, this.refreshFilterValueFn);\n  }\n  /**\n   * @returns {void}\n   * @hidden\n   */\n\n\n  removeEventListener() {\n    EventHandler.remove(document, 'click', this.docClickHandler);\n    EventHandler.remove(this.parent.element, 'mousedown', this.refreshClearIcon);\n\n    if (this.parent.isDestroyed) {\n      return;\n    }\n\n    this.parent.off(setFullScreenDialog, this.setFullScreenDialog);\n    this.parent.off(uiUpdate, this.enableAfterRender);\n    this.parent.off(filterComplete, this.onActionComplete);\n    this.parent.off(inBoundModelChanged, this.onPropertyChanged);\n    this.parent.off(keyPressed, this.keyUpHandler);\n    this.parent.off(columnPositionChanged, this.columnPositionChanged);\n    this.parent.off(headerRefreshed, this.render);\n    this.parent.off(filterOpen, this.columnMenuFilter);\n    this.parent.off(filterMenuClose, this.filterMenuClose);\n    this.parent.off(click, this.filterIconClickHandler);\n    this.parent.off(closeFilterDialog, this.clickHandler);\n    this.parent.off(destroy, this.destroy);\n  }\n\n  refreshClearIcon(e) {\n    if (this.parent.allowFiltering && this.parent.filterSettings.type === 'FilterBar' && e.target.classList.contains('e-clear-icon')) {\n      const targetText = e.target.previousElementSibling;\n      Input.setValue(null, targetText, 'Never', true);\n\n      if (this.filterSettings.mode === 'Immediate') {\n        this.removeFilteredColsByField(targetText.id.slice(0, -14)); //Length of _filterBarcell = 14\n      }\n    }\n  }\n\n  filterMenuClose() {\n    this.fltrDlgDetails.isOpen = false;\n  }\n  /**\n   * Filters the Grid row by fieldName, filterOperator, and filterValue.\n   *\n   * @param  {string} fieldName - Defines the field name of the filter column.\n   * @param  {string} filterOperator - Defines the operator to filter records.\n   * @param  {string | number | Date | boolean} filterValue - Defines the value which is used to filter records.\n   * @param  {string} predicate - Defines the relationship of one filter query with another by using AND or OR predicate.\n   * @param  {boolean} matchCase - If match case is set to true, then the filter records\n   * the exact match or <br> filters records that are case insensitive (uppercase and lowercase letters treated the same).\n   * @param {boolean} ignoreAccent - If ignoreAccent set to true, then filter ignores the diacritic characters or accents while filtering.\n   * @param  {string} actualFilterValue - Defines the actual filter value for the filter column.\n   * @param  {string} actualOperator - Defines the actual filter operator for the filter column.\n   * @returns {void}\n   */\n\n\n  filterByColumn(fieldName, filterOperator, filterValue, predicate, matchCase, ignoreAccent, actualFilterValue, actualOperator) {\n    const gObj = this.parent;\n    let filterCell;\n    this.column = gObj.grabColumnByFieldFromAllCols(fieldName);\n\n    if (this.filterSettings.type === 'FilterBar' && this.filterSettings.showFilterBarOperator && isNullOrUndefined(this.column.filterBarTemplate)) {\n      filterOperator = this.getOperatorName(fieldName);\n    }\n\n    if (!this.column) {\n      return;\n    }\n\n    if (this.filterSettings.type === 'FilterBar') {\n      filterCell = gObj.getHeaderContent().querySelector('[id=\\'' + this.column.field + '_filterBarcell\\']');\n    }\n\n    if (!isNullOrUndefined(this.column.allowFiltering) && !this.column.allowFiltering) {\n      this.parent.log('action_disabled_column', {\n        moduleName: this.getModuleName(),\n        columnName: this.column.headerText\n      });\n      return;\n    }\n\n    if (isActionPrevent(gObj)) {\n      gObj.notify(preventBatch, {\n        instance: this,\n        handler: this.filterByColumn,\n        arg1: fieldName,\n        arg2: filterOperator,\n        arg3: filterValue,\n        arg4: predicate,\n        arg5: matchCase,\n        arg6: ignoreAccent,\n        arg7: actualFilterValue,\n        arg8: actualOperator\n      });\n      return;\n    }\n\n    this.predicate = predicate ? predicate : Array.isArray(filterValue) ? 'or' : 'and';\n    this.value = filterValue;\n    this.matchCase = matchCase || false;\n    this.ignoreAccent = this.ignoreAccent = !isNullOrUndefined(ignoreAccent) ? ignoreAccent : this.parent.filterSettings.ignoreAccent;\n    this.fieldName = fieldName;\n    this.operator = filterOperator;\n    filterValue = !isNullOrUndefined(filterValue) ? filterValue.toString() : filterValue;\n\n    if (this.column.type === 'number' || this.column.type === 'date') {\n      this.matchCase = true;\n    }\n\n    gObj.getColumnHeaderByField(fieldName).setAttribute('aria-filtered', 'true');\n\n    if (filterCell && this.filterSettings.type === 'FilterBar') {\n      if (filterValue && filterValue.length < 1 || !this.filterByMethod && this.checkForSkipInput(this.column, filterValue)) {\n        this.filterStatusMsg = filterValue && filterValue.length < 1 ? '' : this.l10n.getConstant('InvalidFilterMessage');\n        this.updateFilterMsg();\n        return;\n      }\n\n      if (filterCell.value !== filterValue) {\n        filterCell.value = filterValue;\n      }\n    }\n\n    if (!isNullOrUndefined(this.column.format)) {\n      this.applyColumnFormat(filterValue);\n\n      if (this.initialLoad && this.filterSettings.type === 'FilterBar') {\n        filterCell.value = this.values[this.column.field];\n      }\n    } else {\n      this.values[this.column.field] = filterValue; //this line should be above updateModel\n    }\n\n    const predObj = {\n      field: this.fieldName,\n      predicate: predicate,\n      matchCase: matchCase,\n      ignoreAccent: ignoreAccent,\n      operator: this.operator,\n      value: this.value,\n      type: this.column.type\n    };\n    const filterColumn = this.parent.filterSettings.columns.filter(fColumn => {\n      return fColumn.field === this.fieldName;\n    });\n\n    if (filterColumn.length > 1 && !isNullOrUndefined(this.actualPredicate[this.fieldName])) {\n      this.actualPredicate[this.fieldName].push(predObj);\n    } else {\n      this.actualPredicate[this.fieldName] = [predObj];\n    }\n\n    if (this.checkAlreadyColFiltered(this.column.field)) {\n      return;\n    }\n\n    this.updateModel();\n  }\n\n  applyColumnFormat(filterValue) {\n    const getFlvalue = this.column.type === 'date' || this.column.type === 'datetime' ? new Date(filterValue) : parseFloat(filterValue);\n\n    if ((this.column.type === 'date' || this.column.type === 'datetime') && filterValue && filterValue.split(',').length > 1) {\n      this.values[this.column.field] = filterValue.split(',').map(val => {\n        return this.setFormatForFlColumn(new Date(val), this.column);\n      });\n    } else {\n      this.values[this.column.field] = this.setFormatForFlColumn(getFlvalue, this.column);\n    }\n  } // To skip the second time request to server while applying initial filtering - EJ2-44361\n\n\n  skipUid(col) {\n    let flag = true;\n    const colLen = Object.keys(col);\n\n    for (let i = 0; i < colLen.length; i++) {\n      const key = Object.keys(col[colLen[i]]);\n\n      if (key.length === 1 && key[0] === 'uid') {\n        flag = false;\n      }\n    }\n\n    return flag;\n  }\n\n  onPropertyChanged(e) {\n    if (e.module !== this.getModuleName()) {\n      return;\n    }\n\n    for (const prop of Object.keys(e.properties)) {\n      switch (prop) {\n        case 'columns':\n          // eslint-disable-next-line no-case-declarations\n          const col = 'columns'; // eslint-disable-next-line no-case-declarations\n\n          const args = {\n            currentFilterObject: this.currentFilterObject,\n            currentFilteringColumn: this.column ? this.column.field : undefined,\n            action: 'filter',\n            columns: this.filterSettings.columns,\n            requestType: 'filtering',\n            type: actionBegin,\n            cancel: false\n          };\n\n          if (this.contentRefresh && this.skipUid(e.properties[col])) {\n            this.parent.notify(modelChanged, args);\n\n            if (args.cancel) {\n              if (isNullOrUndefined(this.prevFilterObject)) {\n                this.filterSettings.columns.splice(this.filterSettings.columns.length - 1, 1);\n              } else {\n                this.filterSettings.columns[this.filterObjIndex] = this.prevFilterObject;\n              }\n\n              return;\n            }\n\n            this.updateFilterIcon();\n            this.refreshFilterSettings();\n            this.updateFilterMsg();\n            this.updateFilter();\n          }\n\n          break;\n\n        case 'showFilterBarStatus':\n          if (e.properties[prop]) {\n            this.updateFilterMsg();\n          } else if (this.parent.allowPaging) {\n            this.parent.updateExternalMessage('');\n          }\n\n          break;\n\n        case 'showFilterBarOperator':\n        case 'type':\n          this.parent.refreshHeader();\n          this.refreshFilterSettings();\n          break;\n      }\n    }\n  }\n\n  refreshFilterSettings() {\n    if (this.filterSettings.type === 'FilterBar') {\n      for (let i = 0; i < this.filterSettings.columns.length; i++) {\n        this.column = this.parent.grabColumnByUidFromAllCols(this.filterSettings.columns[i].uid);\n        let filterValue = this.filterSettings.columns[i].value;\n        filterValue = !isNullOrUndefined(filterValue) && filterValue.toString();\n\n        if (!isNullOrUndefined(this.column.format)) {\n          this.applyColumnFormat(filterValue);\n        } else {\n          const key = this.filterSettings.columns[i].field;\n          this.values[key] = this.filterSettings.columns[i].value;\n        }\n\n        const filterElement = this.getFilterBarElement(this.column.field);\n\n        if (filterElement) {\n          if (this.cellText[this.filterSettings.columns[i].field] !== '' && !isNullOrUndefined(this.cellText[this.filterSettings.columns[i].field])) {\n            filterElement.value = this.cellText[this.column.field];\n          } else {\n            filterElement.value = this.filterSettings.columns[i].value;\n          }\n        }\n      }\n\n      if (this.filterSettings.columns.length === 0) {\n        const col = this.parent.getColumns();\n\n        for (let i = 0; i < col.length; i++) {\n          const filterElement = this.getFilterBarElement(col[i].field);\n\n          if (filterElement && filterElement.value !== '') {\n            filterElement.value = '';\n            delete this.values[col[i].field];\n          }\n        }\n      }\n    }\n  }\n\n  updateFilterIcon() {\n    if (this.filterSettings.columns.length === 0 && this.parent.element.querySelector('.e-filtered')) {\n      const fltrIconElement = [].slice.call(this.parent.element.getElementsByClassName('e-filtered'));\n\n      for (let i = 0, len = fltrIconElement.length; i < len; i++) {\n        fltrIconElement[i].removeAttribute('aria-filtered');\n        fltrIconElement[i].classList.remove('e-filtered');\n      }\n    }\n  }\n\n  getFilterBarElement(col) {\n    const selector = '[id=\\'' + col + '_filterBarcell\\']';\n    let filterElement;\n\n    if (selector && !isNullOrUndefined(this.element)) {\n      filterElement = this.element.querySelector(selector);\n    }\n\n    return filterElement;\n  }\n  /**\n   * @private\n   * @returns {void}\n   */\n\n\n  refreshFilter() {\n    this.refreshFilterSettings();\n    this.updateFilterMsg();\n  }\n  /**\n   * Clears all the filtered rows of the Grid.\n   *\n   * @param {string[]} fields - returns the fields\n   * @returns {void}\n   */\n\n\n  clearFiltering(fields) {\n    const cols = getActualPropFromColl(this.filterSettings.columns);\n\n    if (!isNullOrUndefined(fields)) {\n      this.refresh = false;\n      fields.forEach(field => {\n        this.removeFilteredColsByField(field, false);\n      });\n      this.parent.setProperties({\n        filterSettings: {\n          columns: this.filterSettings.columns\n        }\n      }, true);\n      this.parent.renderModule.refresh();\n      this.refresh = true;\n      return;\n    }\n\n    if (isActionPrevent(this.parent)) {\n      this.parent.notify(preventBatch, {\n        instance: this,\n        handler: this.clearFiltering\n      });\n      return;\n    }\n\n    for (let i = 0; i < cols.length; i++) {\n      cols[i].uid = cols[i].uid || this.parent.getColumnByField(cols[i].field).uid;\n    }\n\n    const colUid = cols.map(f => f.uid);\n    const filteredcols = colUid.filter((item, pos) => colUid.indexOf(item) === pos);\n    this.refresh = false;\n\n    for (let i = 0, len = filteredcols.length; i < len; i++) {\n      this.removeFilteredColsByField(this.parent.getColumnByUid(filteredcols[i]).field, false);\n    }\n\n    this.refresh = true;\n\n    if (filteredcols.length) {\n      this.parent.renderModule.refresh();\n    }\n\n    if (this.parent.filterSettings.columns.length === 0 && this.parent.element.querySelector('.e-filtered')) {\n      const fltrElement = [].slice.call(this.parent.element.getElementsByClassName('e-filtered'));\n\n      for (let i = 0, len = fltrElement.length; i < len; i++) {\n        fltrElement[0].removeAttribute('aria-filtered');\n        fltrElement[0].classList.remove('e-filtered');\n      }\n    }\n\n    this.isRemove = true;\n    this.filterStatusMsg = '';\n    this.updateFilterMsg();\n  }\n\n  checkAlreadyColFiltered(field) {\n    const columns = this.filterSettings.columns;\n\n    for (const col of columns) {\n      if (col.field === field && col.value === this.value && col.operator === this.operator && col.predicate === this.predicate) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  columnMenuFilter(args) {\n    this.column = args.col;\n    const ele = closest(args.target, '#' + args.id);\n\n    if (args.isClose && !ele) {\n      this.filterModule.closeDialog();\n    } else if (ele) {\n      this.filterDialogOpen(this.column, args.target);\n    }\n  }\n\n  filterDialogOpen(col, target, left, top) {\n    if (this.filterModule) {\n      this.filterModule.closeDialog();\n    }\n\n    this.setFilterModel(col);\n    this.filterModule.openDialog(this.createOptions(col, target, left, top));\n  }\n  /**\n   * Create filter dialog options\n   *\n   * @param  {Column} col - Filtering column detail.\n   * @param  {Element} target -  Filter dialog target.\n   * @param  {number} left -  Filter dialog left position.\n   * @param  {number} top -  Filter dialog top position.\n   * @returns {Object} returns the created dialog options\n   * @hidden\n   */\n\n\n  createOptions(col, target, left, top) {\n    const gObj = this.parent;\n    const dataSource = col.filter.dataSource || gObj.dataSource && 'result' in gObj.dataSource ? gObj.dataSource : gObj.getDataModule().dataManager;\n    const type = col.filter.type || this.parent.filterSettings.type;\n    const options = {\n      type: col.type,\n      field: col.field,\n      displayName: col.headerText,\n      dataSource: dataSource,\n      format: col.format,\n      height: 800,\n      columns: gObj.getColumns(),\n      filteredColumns: gObj.filterSettings.columns,\n      target: target,\n      dataManager: gObj.getDataModule().dataManager,\n      formatFn: col.getFormatter(),\n      ignoreAccent: gObj.filterSettings.ignoreAccent,\n      parserFn: col.getParser(),\n      query: gObj.query,\n      template: col.getFilterItemTemplate(),\n      hideSearchbox: isNullOrUndefined(col.filter.hideSearchbox) ? false : col.filter.hideSearchbox,\n      handler: this.filterHandler.bind(this),\n      localizedStrings: gObj.getLocaleConstants(),\n      position: {\n        X: left,\n        Y: top\n      },\n      column: col,\n      foreignKeyValue: col.foreignKeyValue,\n      actualPredicate: this.actualPredicate,\n      localeObj: gObj.localeObj,\n      isRemote: gObj.getDataModule().isRemote(),\n      allowCaseSensitive: this.filterSettings.enableCaseSensitivity,\n      isResponsiveFilter: this.parent.enableAdaptiveUI,\n      operator: this.actualPredicate[col.field] && type === 'Menu' ? this.actualPredicate[col.field][0].operator : 'equal'\n    };\n    return options;\n  }\n  /**\n   * Removes filtered column by field name.\n   *\n   * @param  {string} field - Defines column field name to remove filter.\n   * @param  {boolean} isClearFilterBar - Specifies whether the filter bar value needs to be cleared.\n   * @returns {void}\n   * @hidden\n   */\n\n\n  removeFilteredColsByField(field, isClearFilterBar) {\n    let fCell;\n    const cols = this.filterSettings.columns;\n\n    if (isActionPrevent(this.parent)) {\n      const args = {\n        instance: this,\n        handler: this.removeFilteredColsByField,\n        arg1: field,\n        arg2: isClearFilterBar\n      };\n      this.parent.notify(preventBatch, args);\n      return;\n    }\n\n    const colUid = cols.map(f => f.uid);\n    const filteredColsUid = colUid.filter((item, pos) => colUid.indexOf(item) === pos);\n\n    for (let i = 0, len = filteredColsUid.length; i < len; i++) {\n      cols[i].uid = cols[i].uid || this.parent.getColumnByField(cols[i].field).uid;\n      let len = cols.length;\n      const column = this.parent.grabColumnByUidFromAllCols(filteredColsUid[i]);\n\n      if (column.field === field || column.field === column.foreignKeyValue && column.isForeignColumn()) {\n        const currentPred = this.filterSettings.columns.filter(e => {\n          return e.uid === column.uid;\n        })[0];\n\n        if (this.filterSettings.type === 'FilterBar' && !isClearFilterBar) {\n          const selector = '[id=\\'' + column.field + '_filterBarcell\\']';\n          fCell = this.parent.getHeaderContent().querySelector(selector);\n\n          if (fCell) {\n            fCell.value = '';\n            delete this.values[field];\n          }\n        }\n\n        while (len--) {\n          if (cols[len].uid === column.uid) {\n            cols.splice(len, 1);\n          }\n        }\n\n        const fltrElement = this.parent.getColumnHeaderByField(column.field);\n        fltrElement.removeAttribute('aria-filtered');\n\n        if (this.filterSettings.type !== 'FilterBar') {\n          const iconClass = this.parent.showColumnMenu ? '.e-columnmenu' : '.e-icon-filter';\n          fltrElement.querySelector(iconClass).classList.remove('e-filtered');\n        }\n\n        this.isRemove = true;\n\n        if (this.actualPredicate[field]) {\n          delete this.actualPredicate[field];\n        }\n\n        if (this.values[field]) {\n          delete this.values[field];\n        }\n\n        if (this.refresh) {\n          this.parent.notify(modelChanged, {\n            requestType: 'filtering',\n            type: actionBegin,\n            currentFilterObject: currentPred,\n            currentFilterColumn: column,\n            action: 'clearFilter'\n          });\n        }\n\n        break;\n      }\n    }\n\n    this.updateFilterMsg();\n  }\n  /**\n   * For internal use only - Get the module name.\n   *\n   * @returns {string} returns the module name\n   * @private\n   */\n\n\n  getModuleName() {\n    return 'filter';\n  }\n\n  keyUpHandlerImmediate(e) {\n    if (e.keyCode !== 13) {\n      this.keyUpHandler(e);\n    }\n  }\n\n  keyUpHandler(e) {\n    const gObj = this.parent;\n    const target = e.target;\n\n    if (target && matches(target, '.e-filterbar input')) {\n      const closeHeaderEle = closest(target, 'th.e-filterbarcell');\n      this.column = gObj.getColumnByUid(closeHeaderEle.getAttribute('e-mappinguid'));\n\n      if (!this.column) {\n        return;\n      }\n\n      if (e.action === 'altDownArrow' && this.parent.filterSettings.showFilterBarOperator) {\n        const dropDownListInput = closest(target, 'span').querySelector('.e-filterbaroperator');\n        dropDownListInput.ej2_instances[0].showPopup();\n        dropDownListInput.focus();\n      }\n\n      if ((this.filterSettings.mode === 'Immediate' || e.keyCode === 13 && !e.target.classList.contains('e-filterbaroperator')) && e.keyCode !== 9 && !this.column.filterTemplate) {\n        this.value = target.value.trim();\n        this.processFilter(e);\n      }\n    }\n\n    if (e.action === 'altDownArrow' && this.filterSettings.type !== 'FilterBar') {\n      const element = gObj.focusModule.currentInfo.element;\n\n      if (element && element.classList.contains('e-headercell')) {\n        const column = gObj.getColumnByUid(element.firstElementChild.getAttribute('e-mappinguid'));\n        this.openMenuByField(column.field);\n        this.parent.focusModule.clearIndicator();\n      }\n    }\n\n    if (e.action === 'escape' && this.filterSettings.type === 'Menu' && this.filterModule) {\n      this.filterModule.closeDialog();\n      gObj.notify(restoreFocus, {});\n    }\n  }\n\n  updateCrossIcon(element) {\n    if (element.value.length) {\n      element.nextElementSibling.classList.remove('e-hide');\n    }\n  }\n\n  updateFilterMsg() {\n    if (this.filterSettings.type === 'FilterBar') {\n      const gObj = this.parent;\n      let getFormatFlValue;\n      const columns = this.filterSettings.columns;\n      let column;\n\n      if (!this.filterSettings.showFilterBarStatus) {\n        return;\n      }\n\n      if (columns.length > 0 && this.filterStatusMsg !== this.l10n.getConstant('InvalidFilterMessage')) {\n        this.filterStatusMsg = '';\n\n        for (let index = 0; index < columns.length; index++) {\n          column = gObj.grabColumnByUidFromAllCols(columns[index].uid) || gObj.grabColumnByFieldFromAllCols(columns[index].field);\n\n          if (index) {\n            this.filterStatusMsg += ' && ';\n          }\n\n          if (!isNullOrUndefined(column.format)) {\n            const flValue = column.type === 'date' || column.type === 'datetime' ? this.valueFormatter.fromView(this.values[column.field], column.getParser(), column.type) : this.values[column.field];\n\n            if (!(column.type === 'date' || column.type === 'datetime')) {\n              const formater = this.serviceLocator.getService('valueFormatter');\n              getFormatFlValue = formater.toView(flValue, column.getParser()).toString();\n            } else {\n              getFormatFlValue = this.setFormatForFlColumn(flValue, column);\n            }\n\n            this.filterStatusMsg += column.headerText + ': ' + getFormatFlValue;\n          } else {\n            this.filterStatusMsg += column.headerText + ': ' + this.values[column.field];\n          }\n        }\n      }\n\n      if (gObj.allowPaging) {\n        gObj.updateExternalMessage(this.filterStatusMsg);\n      } //TODO: virtual paging\n\n\n      this.filterStatusMsg = '';\n    }\n  }\n\n  setFormatForFlColumn(value, column) {\n    const formater = this.serviceLocator.getService('valueFormatter');\n    return formater.toView(value, column.getFormatter()).toString();\n  }\n\n  checkForSkipInput(column, value) {\n    let isSkip;\n\n    if (column.type === 'number') {\n      if (DataUtil.operatorSymbols[value] || this.skipNumberInput.indexOf(value) > -1) {\n        isSkip = true;\n      }\n    } else if (column.type === 'string') {\n      for (const val of value) {\n        if (this.skipStringInput.indexOf(val) > -1) {\n          isSkip = true;\n        }\n      }\n    }\n\n    return isSkip;\n  }\n\n  processFilter(e) {\n    this.stopTimer();\n    this.startTimer(e);\n  }\n\n  startTimer(e) {\n    this.timer = window.setInterval(() => {\n      this.onTimerTick();\n    }, e.keyCode === 13 ? 0 : this.filterSettings.immediateModeDelay);\n  }\n\n  stopTimer() {\n    window.clearInterval(this.timer);\n  }\n\n  onTimerTick() {\n    const selector = '[id=\\'' + this.column.field + '_filterBarcell\\']';\n    let filterElement = this.element.querySelector(selector);\n\n    if (!filterElement && this.parent.isFrozenGrid()) {\n      filterElement = this.parent.getHeaderContent().querySelector(selector);\n    }\n\n    let filterValue;\n    this.cellText[this.column.field] = filterElement.value;\n    this.stopTimer();\n\n    if (!isNullOrUndefined(this.column.filterBarTemplate)) {\n      let templateRead = this.column.filterBarTemplate.read;\n\n      if (typeof templateRead === 'string') {\n        templateRead = getValue(templateRead, window);\n      }\n\n      if (!isNullOrUndefined(templateRead)) {\n        this.value = templateRead.call(this, filterElement);\n      }\n    } else {\n      filterValue = JSON.parse(JSON.stringify(filterElement.value));\n    }\n\n    if (isNullOrUndefined(this.value) || this.value === '') {\n      this.removeFilteredColsByField(this.column.field);\n      return;\n    }\n\n    this.validateFilterValue(this.value);\n    this.filterByMethod = false;\n    this.filterByColumn(this.column.field, this.operator, this.value, this.predicate, this.filterSettings.enableCaseSensitivity, this.ignoreAccent);\n    this.filterByMethod = true;\n    filterElement.value = filterValue;\n    this.updateFilterMsg();\n  }\n\n  validateFilterValue(value) {\n    let skipInput;\n    let index;\n    this.matchCase = this.filterSettings.enableCaseSensitivity;\n\n    switch (this.column.type) {\n      case 'number':\n        if (this.column.filter.operator) {\n          this.operator = this.column.filter.operator;\n        } else {\n          this.operator = this.filterOperators.equal;\n        }\n\n        skipInput = ['>', '<', '=', '!'];\n\n        for (let i = 0; i < value.length; i++) {\n          if (skipInput.indexOf(value[i]) > -1) {\n            index = i;\n            break;\n          }\n        }\n\n        this.getOperator(value.substring(index));\n\n        if (index !== 0) {\n          this.value = value.substring(0, index);\n        }\n\n        if (this.value !== '' && value.length >= 1) {\n          this.value = this.valueFormatter.fromView(this.value, this.column.getParser(), this.column.type);\n        }\n\n        if (isNaN(this.value)) {\n          this.filterStatusMsg = this.l10n.getConstant('InvalidFilterMessage');\n        }\n\n        break;\n\n      case 'date':\n      case 'datetime':\n        this.operator = this.filterOperators.equal;\n\n        if (this.value !== '' && !(this.value instanceof Date)) {\n          this.getOperator(value);\n          this.value = this.valueFormatter.fromView(this.value, this.column.getParser(), this.column.type);\n\n          if (isNullOrUndefined(this.value)) {\n            this.filterStatusMsg = this.l10n.getConstant('InvalidFilterMessage');\n          }\n        }\n\n        break;\n\n      case 'string':\n        this.matchCase = false;\n\n        if (value.charAt(0) === '*') {\n          this.value = this.value.slice(1);\n          this.operator = this.filterOperators.startsWith;\n        } else if (value.charAt(value.length - 1) === '%') {\n          this.value = this.value.slice(0, -1);\n          this.operator = this.filterOperators.startsWith;\n        } else if (value.charAt(0) === '%') {\n          this.value = this.value.slice(1);\n          this.operator = this.filterOperators.endsWith;\n        } else {\n          if (this.column.filter.operator) {\n            this.operator = this.column.filter.operator;\n          } else {\n            this.operator = this.filterOperators.startsWith;\n          }\n        }\n\n        break;\n\n      case 'boolean':\n        if (value.toLowerCase() === 'true' || value === '1') {\n          this.value = true;\n        } else if (value.toLowerCase() === 'false' || value === '0') {\n          this.value = false;\n        } else if (value.length) {\n          this.filterStatusMsg = this.l10n.getConstant('InvalidFilterMessage');\n        }\n\n        this.operator = this.filterOperators.equal;\n        break;\n\n      default:\n        if (this.column.filter.operator) {\n          this.operator = this.column.filter.operator;\n        } else {\n          this.operator = this.filterOperators.equal;\n        }\n\n    }\n  }\n\n  getOperator(value) {\n    const singleOp = value.charAt(0);\n    const multipleOp = value.slice(0, 2);\n    const operators = extend({\n      '=': this.filterOperators.equal,\n      '!': this.filterOperators.notEqual\n    }, DataUtil.operatorSymbols); // eslint-disable-next-line no-prototype-builtins\n\n    if (operators.hasOwnProperty(singleOp) || operators.hasOwnProperty(multipleOp)) {\n      this.operator = operators[singleOp];\n      this.value = value.substring(1);\n\n      if (!this.operator) {\n        this.operator = operators[multipleOp];\n        this.value = value.substring(2);\n      }\n    }\n\n    if (this.operator === this.filterOperators.lessThan || this.operator === this.filterOperators.greaterThan) {\n      if (this.value.charAt(0) === '=') {\n        this.operator = this.operator + 'orequal';\n        this.value = this.value.substring(1);\n      }\n    }\n  }\n\n  columnPositionChanged() {\n    if (this.parent.filterSettings.type !== 'FilterBar') {\n      return;\n    }\n  }\n\n  getLocalizedCustomOperators() {\n    const numOptr = [{\n      value: 'equal',\n      text: this.l10n.getConstant('Equal')\n    }, {\n      value: 'greaterthan',\n      text: this.l10n.getConstant('GreaterThan')\n    }, {\n      value: 'greaterthanorequal',\n      text: this.l10n.getConstant('GreaterThanOrEqual')\n    }, {\n      value: 'lessthan',\n      text: this.l10n.getConstant('LessThan')\n    }, {\n      value: 'lessthanorequal',\n      text: this.l10n.getConstant('LessThanOrEqual')\n    }, {\n      value: 'notequal',\n      text: this.l10n.getConstant('NotEqual')\n    }];\n    this.customOperators = {\n      stringOperator: [{\n        value: 'startswith',\n        text: this.l10n.getConstant('StartsWith')\n      }, {\n        value: 'endswith',\n        text: this.l10n.getConstant('EndsWith')\n      }, {\n        value: 'contains',\n        text: this.l10n.getConstant('Contains')\n      }, {\n        value: 'equal',\n        text: this.l10n.getConstant('Equal')\n      }, {\n        value: 'notequal',\n        text: this.l10n.getConstant('NotEqual')\n      }],\n      numberOperator: numOptr,\n      dateOperator: numOptr,\n      datetimeOperator: numOptr,\n      booleanOperator: [{\n        value: 'equal',\n        text: this.l10n.getConstant('Equal')\n      }, {\n        value: 'notequal',\n        text: this.l10n.getConstant('NotEqual')\n      }]\n    };\n  }\n  /**\n   * @param {string} field - specifies the field name\n   * @returns {void}\n   * @hidden\n   */\n\n\n  openMenuByField(field) {\n    const gObj = this.parent;\n\n    if (gObj.enableAdaptiveUI) {\n      this.showCustomFilter(false);\n      return;\n    }\n\n    const column = gObj.getColumnByField(field);\n    const header = gObj.getColumnHeaderByField(field);\n    const target = header.querySelector('.e-filtermenudiv');\n\n    if (!target) {\n      return;\n    }\n\n    const gClient = gObj.element.getBoundingClientRect();\n    const fClient = target.getBoundingClientRect();\n    this.filterDialogOpen(column, target, fClient.right - gClient.left, fClient.bottom - gClient.top);\n  }\n\n  filterIconClickHandler(e) {\n    const target = e.target;\n\n    if (target.classList.contains('e-filtermenudiv') && (this.parent.filterSettings.type === 'Menu' || this.parent.filterSettings.type === 'CheckBox' || this.parent.filterSettings.type === 'Excel')) {\n      const gObj = this.parent;\n      const col = gObj.getColumnByUid(parentsUntil(target, 'e-headercell').firstElementChild.getAttribute('e-mappinguid'));\n      this.column = col;\n\n      if (this.fltrDlgDetails.field === col.field && this.fltrDlgDetails.isOpen) {\n        return;\n      }\n\n      if (this.filterModule) {\n        this.filterModule.closeDialog();\n      }\n\n      this.fltrDlgDetails = {\n        field: col.field,\n        isOpen: true\n      };\n      this.openMenuByField(col.field);\n    }\n  }\n\n  clickHandler(e) {\n    if (this.filterSettings.type === 'FilterBar' && this.filterSettings.showFilterBarOperator) {\n      if (parentsUntil(e.target, 'e-filterbarcell') && e.target.classList.contains('e-input-group-icon')) {\n        closest(e.target, 'div').querySelector('.e-filterbaroperator').focus();\n      }\n\n      if (e.target.classList.contains('e-list-item')) {\n        const inputId = document.querySelector('.e-popup-open').getAttribute('id').replace('_popup', '');\n\n        if (inputId.indexOf('grid-column') !== -1) {\n          closest(document.getElementById(inputId), 'div').querySelector('.e-filtertext').focus();\n        }\n      }\n    }\n\n    if (this.filterSettings.mode === 'Immediate' || this.parent.filterSettings.type === 'Menu' || this.parent.filterSettings.type === 'CheckBox' || this.parent.filterSettings.type === 'Excel') {\n      const target = e.target;\n      const datepickerEle = target.classList.contains('e-day'); // due to datepicker popup cause\n\n      const dialog = parentsUntil(this.parent.element, 'e-dialog');\n      let hasDialog = false;\n      const popupEle = parentsUntil(target, 'e-popup');\n      const hasDialogClosed = this.parent.element.querySelector('.e-filter-popup');\n\n      if (dialog && popupEle) {\n        hasDialog = dialog.id === popupEle.id;\n      }\n\n      if (hasDialogClosed && (parentsUntil(target, 'e-excel-ascending') || parentsUntil(target, 'e-excel-descending'))) {\n        this.filterModule.closeDialog(target);\n      }\n\n      if (parentsUntil(target, 'e-filter-popup') || target.classList.contains('e-filtermenudiv')) {\n        return;\n      } else if (this.filterModule && !parentsUntil(target, 'e-popup-wrapper') && !closest(target, '.e-filter-item.e-menu-item') && !datepickerEle) {\n        if (hasDialog && !parentsUntil(target, 'e-filter-popup') && !parentsUntil(target, 'e-popup-flmenu') || !popupEle && hasDialogClosed) {\n          this.filterModule.isresetFocus = parentsUntil(target, 'e-grid') && parentsUntil(target, 'e-grid').id === this.parent.element.id;\n          this.filterModule.closeDialog(target);\n        }\n      }\n    }\n  }\n\n  filterHandler(args) {\n    this.actualPredicate[args.field] = args.actualPredicate;\n    const dataManager = new DataManager(this.filterSettings.columns);\n    const query = new Query().where('field', this.filterOperators.equal, args.field);\n    const result = dataManager.executeLocal(query);\n\n    for (let i = 0; i < result.length; i++) {\n      let index = -1;\n\n      for (let j = 0; j < this.filterSettings.columns.length; j++) {\n        if (result[i].field === this.filterSettings.columns[j].field) {\n          index = j;\n          break;\n        }\n      }\n\n      if (index !== -1) {\n        this.filterSettings.columns.splice(index, 1);\n      }\n    }\n\n    if (this.values[args.field]) {\n      delete this.values[args.field];\n    }\n\n    const iconClass = this.parent.showColumnMenu ? '.e-columnmenu' : '.e-icon-filter';\n    const filterIconElement = this.parent.getColumnHeaderByField(args.field).querySelector(iconClass);\n\n    if (args.action === 'filtering') {\n      this.filterSettings.columns = this.filterSettings.columns.concat(args.filterCollection);\n\n      if (this.filterSettings.columns.length && filterIconElement) {\n        filterIconElement.classList.add('e-filtered');\n      }\n    } else {\n      if (filterIconElement) {\n        filterIconElement.classList.remove('e-filtered');\n      }\n\n      args.requestType = 'filtering';\n      this.parent.renderModule.refresh(args); //hot-fix onpropertychanged not working for object { array }\n    }\n\n    this.parent.dataBind();\n  }\n\n  updateFilter() {\n    const cols = this.filterSettings.columns;\n    this.actualPredicate = {};\n\n    for (let i = 0; i < cols.length; i++) {\n      this.column = this.parent.getColumnByField(cols[i].field) || getColumnByForeignKeyValue(cols[i].field, this.parent.getForeignKeyColumns());\n      let fieldName = cols[i].field;\n\n      if (!this.parent.getColumnByField(cols[i].field)) {\n        fieldName = getColumnByForeignKeyValue(cols[i].field, this.parent.getForeignKeyColumns()).field;\n      }\n\n      this.refreshFilterIcon(fieldName, cols[i].operator, cols[i].value, cols[i].type, cols[i].predicate, cols[i].matchCase, cols[i].ignoreAccent, cols[i].uid);\n    }\n  }\n\n  refreshFilterIcon(fieldName, operator, value, type, predicate, matchCase, ignoreAccent, uid) {\n    const obj = {\n      field: fieldName,\n      predicate: predicate,\n      matchCase: matchCase,\n      ignoreAccent: ignoreAccent,\n      operator: operator,\n      value: value,\n      type: type\n    };\n\n    if (this.actualPredicate[fieldName]) {\n      this.actualPredicate[fieldName].push(obj);\n    } else {\n      this.actualPredicate[fieldName] = [obj];\n    }\n\n    const field = uid ? this.parent.grabColumnByUidFromAllCols(uid).field : fieldName;\n    this.addFilteredClass(field);\n  }\n\n  addFilteredClass(fieldName) {\n    let filterIconElement;\n\n    if (this.parent.showColumnMenu) {\n      filterIconElement = this.parent.getColumnHeaderByField(fieldName).querySelector('.e-columnmenu');\n    } else if (this.parent.getColumnByField(fieldName)) {\n      filterIconElement = this.parent.getColumnHeaderByField(fieldName).querySelector('.e-icon-filter');\n    }\n\n    if (filterIconElement) {\n      filterIconElement.classList.add('e-filtered');\n    }\n  }\n  /**\n   * @hidden\n   * @returns {FilterUI} returns the FilterUI\n   */\n\n\n  getFilterUIInfo() {\n    return this.filterModule ? this.filterModule.getFilterUIInfo() : {};\n  }\n  /**\n   * @param {string} field - specifies the field name\n   * @returns {string} returns the operator name\n   * @hidden\n   */\n\n\n  getOperatorName(field) {\n    return document.getElementById(this.parent.getColumnByField(field).uid).ej2_instances[0].value;\n  }\n  /**\n   * Renders checkbox items in Menu filter dialog.\n   *\n   * @returns {void}\n   */\n\n\n  renderCheckboxOnFilterMenu() {\n    return this.filterModule.renderCheckBoxMenu();\n  }\n\n}\n\nconst resizeClassList = {\n  root: 'e-rhandler',\n  suppress: 'e-rsuppress',\n  icon: 'e-ricon',\n  helper: 'e-rhelper',\n  header: 'th.e-headercell',\n  cursor: 'e-rcursor'\n};\n/**\n * `Resize` module is used to handle Resize to fit for columns.\n *\n * @hidden\n * @private\n */\n\nclass Resize {\n  /**\n   * Constructor for the Grid resize module\n   *\n   * @param {IGrid} parent - specifies the IGrid\n   * @hidden\n   */\n  constructor(parent) {\n    this.tapped = false;\n    this.isDblClk = true;\n    this.parent = parent;\n\n    if (this.parent.isDestroyed) {\n      return;\n    }\n\n    this.widthService = new ColumnWidthService(parent);\n    this.addEventListener();\n  }\n  /**\n   * Resize by field names.\n   *\n   * @param  {string|string[]} fName - Defines the field name.\n   * @returns {void}\n   */\n\n\n  autoFitColumns(fName) {\n    const columnName = fName === undefined || fName === null || fName.length <= 0 ? this.parent.getColumns().map(x => x.field) : typeof fName === 'string' ? [fName] : fName;\n    this.findColumn(columnName);\n  }\n\n  autoFit() {\n    const newarray = this.parent.getColumns().filter(c => c.autoFit === true).map(c => c.field || c.headerText);\n\n    if (newarray.length > 0) {\n      this.autoFitColumns(newarray);\n    }\n\n    if (this.parent.resizeSettings.mode === 'Auto') {\n      this.widthService.setWidthToTable();\n    }\n  }\n\n  resizeColumn(fName, index, id) {\n    const gObj = this.parent;\n    let tWidth = 0;\n    let headerTable;\n    let contentTable;\n    let footerTable;\n    const headerDivTag = 'e-gridheader';\n    const contentDivTag = gridContent;\n    const footerDivTag = gridFooter;\n    let indentWidth = 0;\n    const uid = id ? id : this.parent.getUidByColumnField(fName);\n    const columnIndex = this.parent.getNormalizedColumnIndex(uid);\n    let headerTextClone;\n    let contentTextClone;\n    let footerTextClone;\n    const columnIndexByField = this.parent.getColumnIndexByField(fName);\n    const left = gObj.getFrozenColumns() || gObj.getFrozenLeftColumnsCount();\n    const movable = gObj.getMovableColumnsCount();\n\n    if (!isNullOrUndefined(gObj.getFooterContent())) {\n      footerTable = gObj.getFooterContentTable();\n    }\n\n    if (gObj.isFrozenGrid()) {\n      const col = gObj.getColumnByField(fName);\n\n      if (col.getFreezeTableName() === frozenLeft) {\n        headerTable = gObj.getHeaderTable();\n        contentTable = gObj.getContentTable();\n        headerTextClone = headerTable.querySelector('[e-mappinguid=\"' + uid + '\"]').parentElement.cloneNode(true);\n        contentTextClone = contentTable.querySelectorAll(`td:nth-child(${columnIndex + 1})`);\n\n        if (footerTable) {\n          footerTextClone = footerTable.querySelectorAll(`td:nth-child(${columnIndex + 1})`);\n        }\n      } else if (col.getFreezeTableName() === 'movable') {\n        headerTable = gObj.getHeaderContent().querySelector('.' + movableHeader).children[0];\n        contentTable = gObj.getContent().querySelector('.' + movableContent).children[0];\n        headerTextClone = headerTable.querySelector('[e-mappinguid=\"' + uid + '\"]').parentElement.cloneNode(true);\n        contentTextClone = contentTable.querySelectorAll(`td:nth-child(${columnIndex - left + 1})`);\n\n        if (footerTable) {\n          footerTable = gObj.getFooterContent().querySelector('.e-movablefootercontent').children[0];\n          footerTextClone = footerTable.querySelectorAll(`td:nth-child(${columnIndex - left + 1})`);\n        }\n      } else if (col.getFreezeTableName() === frozenRight) {\n        headerTable = gObj.getHeaderContent().querySelector('.e-frozen-right-header').children[0];\n        contentTable = gObj.getContent().querySelector('.e-frozen-right-content').children[0];\n        headerTextClone = headerTable.querySelector('[e-mappinguid=\"' + uid + '\"]').parentElement.cloneNode(true);\n        contentTextClone = contentTable.querySelectorAll(`td:nth-child(${columnIndex - (left + movable) + 1})`);\n\n        if (footerTable) {\n          footerTable = gObj.getFooterContent().querySelector('.e-movablefootercontent').children[0];\n          footerTextClone = footerTable.querySelectorAll(`td:nth-child(${columnIndex - (left + movable) + 1})`);\n        }\n      }\n    } else {\n      headerTable = gObj.getHeaderTable();\n      contentTable = gObj.getContentTable();\n      headerTextClone = headerTable.querySelector('[e-mappinguid=\"' + uid + '\"]').parentElement.cloneNode(true);\n      contentTextClone = contentTable.querySelectorAll(`td:nth-child(${columnIndex + 1}):not(.e-groupcaption)`);\n\n      if (footerTable) {\n        footerTextClone = footerTable.querySelectorAll(`td:nth-child(${columnIndex + 1}):not(.e-groupcaption)`);\n      }\n    }\n\n    const indentWidthClone = [].slice.call(headerTable.querySelector('tr').getElementsByClassName('e-grouptopleftcell'));\n\n    if (indentWidthClone.length > 0) {\n      for (let i = 0; i < indentWidthClone.length; i++) {\n        indentWidth += indentWidthClone[i].offsetWidth;\n      }\n    }\n\n    const detailsElement = contentTable.querySelector('.e-detailrowcollapse') || contentTable.querySelector('.e-detailrowexpand');\n\n    if ((this.parent.detailTemplate || this.parent.childGrid) && detailsElement) {\n      indentWidth += detailsElement.offsetWidth;\n    }\n\n    const headerText = [headerTextClone];\n    const contentText = [];\n    const footerText = [];\n\n    if (footerTable) {\n      for (let i = 0; i < footerTextClone.length; i++) {\n        footerText[i] = footerTextClone[i].cloneNode(true);\n      }\n    }\n\n    for (let i = 0; i < contentTextClone.length; i++) {\n      contentText[i] = contentTextClone[i].cloneNode(true);\n    }\n\n    const wHeader = this.createTable(headerTable, headerText, headerDivTag);\n    let wFooter = null;\n    let wContent = null;\n\n    if (gObj.getCurrentViewRecords().length) {\n      wContent = this.createTable(contentTable, contentText, contentDivTag);\n    }\n\n    if (footerText.length) {\n      wFooter = this.createTable(footerTable, footerText, footerDivTag);\n    }\n\n    const columnbyindex = gObj.getColumns()[columnIndexByField];\n    const width = columnbyindex.width = formatUnit(Math.max(wHeader, wContent, wFooter));\n    const colMaxWidth = columnbyindex.maxWidth && parseFloat(columnbyindex.maxWidth.toString());\n\n    if (parseInt(width, 10) > colMaxWidth) {\n      columnbyindex.width = colMaxWidth;\n    }\n\n    this.widthService.setColumnWidth(gObj.getColumns()[columnIndexByField]);\n    const result = gObj.getColumns().some(x => x.width === null || x.width === undefined || x.width.length <= 0);\n\n    if (result === false) {\n      const element = gObj.getColumns();\n\n      for (let i = 0; i < element.length; i++) {\n        if (element[i].visible) {\n          tWidth = tWidth + parseFloat(element[i].width);\n        }\n      }\n    }\n\n    let calcTableWidth = tWidth + indentWidth;\n\n    if (tWidth > 0 && !gObj.isFrozenGrid()) {\n      if (this.parent.detailTemplate || this.parent.childGrid) {\n        this.widthService.setColumnWidth(new Column({\n          width: '30px'\n        }));\n      }\n\n      if (this.parent.resizeSettings.mode === 'Auto') {\n        calcTableWidth = '100%';\n      }\n\n      headerTable.style.width = formatUnit(calcTableWidth);\n      contentTable.style.width = formatUnit(calcTableWidth);\n\n      if (!isNullOrUndefined(footerTable)) {\n        footerTable.style.width = formatUnit(calcTableWidth);\n      }\n    }\n\n    if (gObj.isFrozenGrid()) {\n      this.widthService.refreshFrozenScrollbar();\n    }\n\n    const tableWidth = headerTable.offsetWidth;\n    const contentwidth = gObj.getContent().scrollWidth;\n\n    if (contentwidth > tableWidth) {\n      headerTable.classList.add('e-tableborder');\n      contentTable.classList.add('e-tableborder');\n    } else {\n      headerTable.classList.remove('e-tableborder');\n      contentTable.classList.remove('e-tableborder');\n    }\n\n    if (!isNullOrUndefined(footerTable)) {\n      footerTable.classList.add('e-tableborder');\n    }\n  }\n  /**\n   * To destroy the resize\n   *\n   * @returns {void}\n   * @hidden\n   */\n\n\n  destroy() {\n    const gridElement = this.parent.element;\n\n    if (!gridElement || !gridElement.querySelector('.' + gridHeader) && !gridElement.querySelector('.' + gridContent)) {\n      return;\n    }\n\n    this.widthService = null;\n    this.unwireEvents();\n    this.removeEventListener();\n  }\n  /**\n   * For internal use only - Get the module name.\n   *\n   * @returns {string} returns the module name\n   * @private\n   */\n\n\n  getModuleName() {\n    return 'resize';\n  }\n\n  findColumn(fName) {\n    for (let i = 0; i < fName.length; i++) {\n      const fieldName = fName[i];\n      const columnIndex = this.parent.getColumnIndexByField(fieldName);\n      const column = this.parent.getColumns()[columnIndex];\n\n      if (columnIndex > -1 && !isNullOrUndefined(column) && column.visible === true) {\n        this.resizeColumn(fieldName, columnIndex);\n      }\n    }\n  }\n  /**\n   * To create table for autofit\n   *\n   * @param {Element} table - specifies the table\n   * @param {Element[]} text - specifies the text\n   * @param {string} tag - specifies the tag name\n   * @returns {number} returns the number\n   * @hidden\n   */\n\n\n  createTable(table$$1, text, tag) {\n    const myTableDiv = this.parent.createElement('div');\n    myTableDiv.className = this.parent.element.className;\n    myTableDiv.style.cssText = 'display: inline-block;visibility:hidden;position:absolute';\n    const mySubDiv = this.parent.createElement('div');\n    mySubDiv.className = tag;\n    const myTable = this.parent.createElement('table');\n    myTable.className = table$$1.className;\n    myTable.classList.add('e-resizetable');\n    myTable.style.cssText = 'table-layout: auto;width: auto';\n    const myTr = this.parent.createElement('tr');\n\n    for (let i = 0; i < text.length; i++) {\n      const tr = myTr.cloneNode();\n      tr.className = table$$1.querySelector('tr').className;\n      tr.appendChild(text[i]);\n      myTable.appendChild(tr);\n    }\n\n    mySubDiv.appendChild(myTable);\n    myTableDiv.appendChild(mySubDiv);\n    document.body.appendChild(myTableDiv);\n    const offsetWidthValue = myTable.getBoundingClientRect().width;\n    document.body.removeChild(myTableDiv);\n    return Math.ceil(offsetWidthValue);\n  }\n  /**\n   * @returns {void}\n   * @hidden\n   */\n\n\n  addEventListener() {\n    if (this.parent.isDestroyed) {\n      return;\n    }\n\n    this.parent.on(headerRefreshed, this.refreshHeight, this);\n    this.parent.on(initialEnd, this.wireEvents, this);\n    this.parent.on(contentReady, this.autoFit, this);\n    this.parent.on(refreshHandlers, this.refreshHeight, this);\n    this.parent.on(destroy, this.destroy, this);\n  }\n  /**\n   * @returns {void}\n   * @hidden\n   */\n\n\n  removeEventListener() {\n    if (this.parent.isDestroyed) {\n      return;\n    }\n\n    this.parent.off(headerRefreshed, this.refreshHeight);\n    this.parent.off(initialEnd, this.wireEvents);\n    this.parent.off(refreshHandlers, this.refreshHeight);\n    this.parent.off(destroy, this.destroy);\n  }\n  /**\n   * @returns {void}\n   * @hidden\n   */\n\n\n  render() {\n    this.unwireEvents();\n    this.wireEvents();\n    this.setHandlerHeight();\n  }\n\n  refreshHeight() {\n    if (this.parent.getHeaderTable()) {\n      const element = this.getResizeHandlers();\n\n      for (let i = 0; i < element.length; i++) {\n        if (element[i].parentElement.offsetHeight > 0) {\n          element[i].style.height = element[i].parentElement.offsetHeight + 'px';\n        }\n      }\n\n      this.setHandlerHeight();\n    }\n  }\n\n  wireEvents() {\n    EventHandler.add(this.parent.getHeaderContent(), Browser.touchStartEvent, this.touchResizeStart, this);\n    EventHandler.add(this.parent.getHeaderContent(), dblclick, this.callAutoFit, this);\n  }\n\n  unwireEvents() {\n    EventHandler.remove(this.parent.getHeaderContent(), Browser.touchStartEvent, this.touchResizeStart);\n    EventHandler.remove(this.parent.getHeaderContent(), dblclick, this.callAutoFit);\n  }\n\n  getResizeHandlers() {\n    return this.parent.isFrozenGrid() ? [].slice.call(this.parent.getHeaderContent().getElementsByClassName(resizeClassList.root)) : [].slice.call(this.parent.getHeaderTable().getElementsByClassName(resizeClassList.root));\n  }\n\n  setHandlerHeight() {\n    const element = [].slice.call(this.parent.getHeaderTable().getElementsByClassName(resizeClassList.suppress));\n\n    for (let i = 0; i < element.length; i++) {\n      element[i].style.height = element[i].parentElement.offsetHeight + 'px';\n    }\n  }\n\n  callAutoFit(e) {\n    if (e.target.classList.contains('e-rhandler')) {\n      const col = this.getTargetColumn(e);\n\n      if (col.columns) {\n        return;\n      }\n\n      this.resizeColumn(col.field, this.parent.getNormalizedColumnIndex(col.uid), col.uid);\n      const header = closest(e.target, resizeClassList.header);\n      header.classList.add('e-resized');\n    }\n  }\n\n  touchResizeStart(e) {\n    if (!Global.timer) {\n      Global.timer = setTimeout(() => {\n        Global.timer = null;\n      }, 300);\n      return this.resizeStart(e);\n    } else {\n      clearTimeout(Global.timer);\n      Global.timer = null;\n      this.callAutoFit(e);\n    }\n  }\n\n  resizeStart(e) {\n    if (e.target.classList.contains('e-rhandler')) {\n      if (!this.helper) {\n        if (this.getScrollBarWidth() === 0) {\n          if (this.parent.allowGrouping) {\n            for (let i = 0; i < this.parent.groupSettings.columns.length; i++) {\n              this.widthService.setColumnWidth(new Column({\n                width: '30px'\n              }), i);\n            }\n          }\n\n          for (const col of this.refreshColumnWidth()) {\n            this.widthService.setColumnWidth(col);\n          }\n\n          this.widthService.setWidthToTable();\n        }\n\n        this.refreshStackedColumnWidth();\n        this.element = e.target;\n\n        if (this.parent.getVisibleFrozenColumns()) {\n          const mtbody = this.parent.getMovableContentTbody();\n          const ftbody = this.parent.getFrozenLeftContentTbody();\n          const frtbody = this.parent.getFrozenRightContentTbody();\n          const mtr = [].slice.call(mtbody.querySelectorAll('tr'));\n          const ftr = [].slice.call(ftbody.querySelectorAll('tr'));\n          let frTr = [];\n\n          if (this.parent.getFrozenMode() === leftRight && frtbody) {\n            frTr = [].slice.call(frtbody.querySelectorAll('tr'));\n          }\n\n          for (let i = 0; i < mtr.length; i++) {\n            gridActionHandler(this.parent, (tableName, row$$1) => {\n              if (this.parent.rowHeight) {\n                row$$1[i].style.height = this.parent.rowHeight + 'px';\n              } else {\n                row$$1[i].style.removeProperty('height');\n              }\n            }, [ftr, mtr, frTr]);\n          }\n        }\n\n        this.parentElementWidth = this.parent.element.getBoundingClientRect().width;\n        this.appendHelper();\n        this.column = this.getTargetColumn(e);\n        this.pageX = this.getPointX(e);\n\n        if (this.column.getFreezeTableName() === frozenRight) {\n          if (this.parent.enableRtl) {\n            this.minMove = (this.column.minWidth ? parseFloat(this.column.minWidth.toString()) : 0) - parseFloat(isNullOrUndefined(this.column.width) ? '' : this.column.width.toString());\n          } else {\n            this.minMove = parseFloat(isNullOrUndefined(this.column.width) ? '' : this.column.width.toString()) - (this.column.minWidth ? parseFloat(this.column.minWidth.toString()) : 0);\n          }\n        } else if (this.parent.enableRtl) {\n          this.minMove = parseFloat(this.column.width.toString()) - (this.column.minWidth ? parseFloat(this.column.minWidth.toString()) : 0);\n        } else {\n          this.minMove = (this.column.minWidth ? parseFloat(this.column.minWidth.toString()) : 0) - parseFloat(isNullOrUndefined(this.column.width) ? '' : this.column.width.toString());\n        }\n\n        this.minMove += this.pageX;\n      }\n\n      if (Browser.isDevice && !this.helper.classList.contains(resizeClassList.icon)) {\n        this.helper.classList.add(resizeClassList.icon);\n        EventHandler.add(document, Browser.touchStartEvent, this.removeHelper, this);\n        EventHandler.add(this.helper, Browser.touchStartEvent, this.resizeStart, this);\n      } else {\n        const args = {\n          e: e,\n          column: this.column\n        };\n        this.parent.trigger(resizeStart, args, args => {\n          if (args.cancel || this.parent.isEdit) {\n            this.cancelResizeAction();\n            return;\n          }\n\n          EventHandler.add(document, Browser.touchEndEvent, this.resizeEnd, this);\n          EventHandler.add(this.parent.element, Browser.touchMoveEvent, this.resizing, this);\n          this.updateCursor('add');\n        });\n      }\n    }\n  }\n\n  cancelResizeAction(removeEvents) {\n    if (removeEvents) {\n      EventHandler.remove(this.parent.element, Browser.touchMoveEvent, this.resizing);\n      EventHandler.remove(document, Browser.touchEndEvent, this.resizeEnd);\n      this.updateCursor('remove');\n    }\n\n    if (Browser.isDevice) {\n      EventHandler.remove(document, Browser.touchStartEvent, this.removeHelper);\n      EventHandler.remove(this.helper, Browser.touchStartEvent, this.resizeStart);\n    }\n\n    detach(this.helper);\n    this.refresh();\n  }\n\n  getWidth(width, minWidth, maxWidth) {\n    if (minWidth && width < minWidth) {\n      return minWidth;\n    } else if (maxWidth && width > maxWidth) {\n      return maxWidth;\n    } else {\n      return width;\n    }\n  }\n\n  updateResizeEleHeight() {\n    const elements = [].slice.call(this.parent.getHeaderContent().getElementsByClassName('e-rhandler'));\n\n    for (let i = 0; i < elements.length; i++) {\n      elements[i].style.height = this.element.parentElement.offsetHeight + 'px';\n    }\n  }\n\n  getColData(column, mousemove) {\n    return {\n      width: parseFloat(isNullOrUndefined(this.widthService.getWidth(column)) || this.widthService.getWidth(column) === 'auto' ? '0' : this.widthService.getWidth(column).toString()) + mousemove,\n      minWidth: column.minWidth ? parseFloat(column.minWidth.toString()) : null,\n      maxWidth: column.maxWidth ? parseFloat(column.maxWidth.toString()) : null\n    };\n  }\n\n  resizing(e) {\n    if (isNullOrUndefined(this.column)) {\n      return;\n    }\n\n    let offsetWidth = 0;\n\n    if (isNullOrUndefined(this.column)) {\n      offsetWidth = parentsUntil(this.element, 'th').offsetWidth;\n    }\n\n    if (this.parent.allowTextWrap) {\n      this.updateResizeEleHeight();\n      this.setHelperHeight();\n    }\n\n    let pageX = this.getPointX(e);\n    let mousemove = this.parent.enableRtl ? -(pageX - this.pageX) : pageX - this.pageX;\n\n    if (this.column.getFreezeTableName() === frozenRight) {\n      mousemove = this.parent.enableRtl ? pageX - this.pageX : this.pageX - pageX;\n    }\n\n    const colData = this.getColData(this.column, mousemove);\n\n    if (!colData.width) {\n      colData.width = closest(this.element, 'th').offsetWidth;\n    }\n\n    let width = this.getWidth(colData.width, colData.minWidth, colData.maxWidth);\n    this.parent.log('resize_min_max', {\n      column: this.column,\n      width\n    });\n\n    if (this.column.getFreezeTableName() === frozenRight) {\n      if (this.parent.enableRtl && this.minMove >= pageX || !this.parent.enableRtl && this.minMove <= pageX) {\n        width = this.column.minWidth ? parseFloat(this.column.minWidth.toString()) : 10;\n        this.pageX = pageX = this.minMove;\n      }\n    }\n\n    if (this.column.getFreezeTableName() !== frozenRight && (!this.parent.enableRtl && this.minMove >= pageX || this.parent.enableRtl && this.minMove <= pageX) || this.column.getFreezeTableName() === frozenRight && (this.parent.enableRtl && this.minMove >= pageX || !this.parent.enableRtl && this.minMove <= pageX)) {\n      width = this.column.minWidth ? parseFloat(this.column.minWidth.toString()) : 10;\n      this.pageX = pageX = this.minMove;\n    }\n\n    if (width !== parseFloat(isNullOrUndefined(this.column.width) || this.column.width === 'auto' ? offsetWidth.toString() : this.column.width.toString())) {\n      this.pageX = pageX;\n      this.column.width = formatUnit(width);\n      const args = {\n        e: e,\n        column: this.column\n      };\n      this.parent.trigger(onResize, args);\n\n      if (args.cancel) {\n        this.cancelResizeAction(true);\n        return;\n      }\n\n      let columns = [this.column];\n      let finalColumns = [this.column];\n\n      if (this.column.columns) {\n        columns = this.getSubColumns(this.column, []);\n        columns = this.calulateColumnsWidth(columns, false, mousemove);\n        finalColumns = this.calulateColumnsWidth(columns, true, mousemove);\n      }\n\n      for (const col of finalColumns) {\n        this.widthService.setColumnWidth(col, null, 'resize');\n      }\n\n      this.updateHelper();\n    }\n\n    this.isDblClk = false;\n  }\n\n  calulateColumnsWidth(columns, isUpdate, mousemove) {\n    const finalColumns = [];\n\n    for (const col of columns) {\n      let totalWidth = 0;\n\n      for (let i = 0; i < columns.length; i++) {\n        totalWidth += parseFloat(columns[i].width.toString());\n      }\n\n      const colData = this.getColData(col, parseFloat(col.width) * mousemove / totalWidth);\n      const colWidth = this.getWidth(colData.width, colData.minWidth, colData.maxWidth);\n\n      if (colWidth !== parseFloat(col.width.toString())) {\n        if (isUpdate) {\n          col.width = formatUnit(colWidth < 1 ? 1 : colWidth);\n        }\n\n        finalColumns.push(col);\n      }\n    }\n\n    return finalColumns;\n  }\n\n  getSubColumns(column, subColumns) {\n    for (const col of column.columns) {\n      if (col.visible !== false && col.allowResizing) {\n        if (col.columns) {\n          this.getSubColumns(col, subColumns);\n        } else {\n          subColumns.push(col);\n        }\n      }\n    }\n\n    return subColumns;\n  }\n\n  resizeEnd(e) {\n    if (!this.helper || this.parent.isDestroyed) {\n      return;\n    }\n\n    EventHandler.remove(this.parent.element, Browser.touchMoveEvent, this.resizing);\n    EventHandler.remove(document, Browser.touchEndEvent, this.resizeEnd);\n    this.updateCursor('remove');\n    detach(this.helper);\n    const args = {\n      e: e,\n      column: this.column\n    };\n    const content$$1 = this.parent.getContent().querySelector('.' + content);\n    const cTable = content$$1.querySelector('.' + movableContent) ? content$$1.querySelector('.' + movableContent) : content$$1;\n\n    if (cTable.scrollHeight > cTable.clientHeight) {\n      this.parent.scrollModule.setPadding();\n      cTable.style.overflowY = 'scroll';\n    }\n\n    this.parent.trigger(resizeStop, args);\n    closest(this.element, '.e-headercell').classList.add('e-resized');\n\n    if (parentsUntil(this.element, 'e-frozenheader')) {\n      this.isFrozenColResized = true;\n    } else {\n      this.isFrozenColResized = false;\n    }\n\n    if (this.parent.isFrozenGrid()) {\n      this.parent.notify(freezeRender, {\n        case: 'textwrap'\n      });\n    }\n\n    if (this.parent.allowTextWrap) {\n      this.updateResizeEleHeight();\n      this.parent.notify(textWrapRefresh, {\n        case: 'textwrap'\n      });\n    }\n\n    this.refresh();\n    this.doubleTapEvent(e);\n    this.isDblClk = true;\n  }\n\n  getPointX(e) {\n    if (e.touches && e.touches.length) {\n      return e.touches[0].pageX;\n    } else {\n      return e.pageX;\n    }\n  }\n\n  refreshColumnWidth() {\n    const columns = this.parent.getColumns();\n\n    for (const ele of [].slice.apply(this.parent.getHeaderContent().querySelectorAll('th.e-headercell'))) {\n      for (const column of columns) {\n        if (ele.querySelector('[e-mappinguid]') && ele.querySelector('[e-mappinguid]').getAttribute('e-mappinguid') === column.uid && column.visible) {\n          column.width = ele.getBoundingClientRect().width;\n          break;\n        }\n      }\n    }\n\n    return columns;\n  }\n\n  refreshStackedColumnWidth() {\n    for (const stackedColumn of this.parent.getStackedColumns(this.parent.columns)) {\n      stackedColumn.width = this.getStackedWidth(stackedColumn, 0);\n    }\n  }\n\n  getStackedWidth(column, width) {\n    for (const col of column.columns) {\n      if (col.visible !== false) {\n        if (col.columns) {\n          this.getStackedWidth(col, width);\n        } else {\n          width += col.width;\n        }\n      }\n    }\n\n    return width;\n  }\n\n  getTargetColumn(e) {\n    let cell = closest(e.target, resizeClassList.header);\n    cell = cell.querySelector('.e-headercelldiv') || cell.querySelector('.e-stackedheadercelldiv');\n    const uid = cell.getAttribute('e-mappinguid');\n    return this.parent.getColumnByUid(uid);\n  }\n\n  updateCursor(action) {\n    const headerRows = [].slice.call(this.parent.getHeaderContent().querySelectorAll('th'));\n    headerRows.push(this.parent.element);\n\n    for (const row$$1 of headerRows) {\n      row$$1.classList[action](resizeClassList.cursor);\n    }\n  }\n\n  refresh() {\n    this.column = null;\n    this.pageX = null;\n    this.element = null;\n    this.helper = null;\n  }\n\n  appendHelper() {\n    this.helper = this.parent.createElement('div', {\n      className: resizeClassList.helper\n    });\n    this.parent.element.appendChild(this.helper);\n    this.setHelperHeight();\n  }\n\n  setHelperHeight() {\n    const isFrozen = this.parent.isFrozenGrid();\n    let height = isFrozen ? this.parent.getContent().querySelector('.' + content).offsetHeight : this.parent.getContent().offsetHeight - this.getScrollBarWidth();\n    const rect = closest(this.element, resizeClassList.header);\n    let tr = [].slice.call(this.parent.getHeaderContent().querySelectorAll('tr'));\n    const right = this.parent.getFrozenRightColumnsCount();\n\n    if (isFrozen) {\n      if (parentsUntil(rect, movableHeader)) {\n        tr = [].slice.call(this.parent.getHeaderContent().querySelector('.' + movableHeader).querySelectorAll('tr'));\n      } else if (right && parentsUntil(rect, 'e-frozen-right-header')) {\n        tr = [].slice.call(this.parent.getHeaderContent().querySelector('.e-frozen-right-header').querySelectorAll('tr'));\n      } else {\n        tr = [].slice.call(this.parent.getHeaderContent().querySelector('.e-frozen-left-header').querySelectorAll('tr'));\n      }\n    }\n\n    for (let i = tr.indexOf(rect.parentElement); i < tr.length && i > -1; i++) {\n      height += tr[i].offsetHeight;\n    }\n\n    const pos = this.calcPos(rect);\n\n    if (parentsUntil(rect, 'e-frozen-right-header')) {\n      pos.left += this.parent.enableRtl ? rect.offsetWidth - 2 : 0 - 1;\n    } else {\n      pos.left += this.parent.enableRtl ? 0 - 1 : rect.offsetWidth - 2;\n    }\n\n    this.helper.style.cssText = 'height: ' + height + 'px; top: ' + pos.top + 'px; left:' + Math.floor(pos.left) + 'px;';\n\n    if (this.parent.enableVirtualization) {\n      this.helper.classList.add('e-virtual-rhandler');\n    }\n  }\n\n  getScrollBarWidth(height) {\n    const ele = this.parent.getContent().firstChild;\n    return ele.scrollHeight > ele.clientHeight && height || ele.scrollWidth > ele.clientWidth ? getScrollBarWidth() : 0;\n  }\n\n  removeHelper(e) {\n    const cls = e.target.classList;\n\n    if (!(cls.contains(resizeClassList.root) || cls.contains(resizeClassList.icon)) && this.helper) {\n      EventHandler.remove(document, Browser.touchStartEvent, this.removeHelper);\n      EventHandler.remove(this.helper, Browser.touchStartEvent, this.resizeStart);\n      detach(this.helper);\n      this.refresh();\n    }\n  }\n\n  updateHelper() {\n    const rect = closest(this.element, resizeClassList.header);\n    let left;\n\n    if (parentsUntil(rect, 'e-frozen-right-header')) {\n      left = Math.floor(this.calcPos(rect).left + (this.parent.enableRtl ? rect.offsetWidth - 2 : 0 - 1));\n    } else {\n      left = Math.floor(this.calcPos(rect).left + (this.parent.enableRtl ? 0 - 1 : rect.offsetWidth - 2));\n    }\n\n    const borderWidth = 2; // to maintain the helper inside of grid element.\n\n    if (left > this.parentElementWidth) {\n      left = this.parentElementWidth - borderWidth;\n    }\n\n    if (this.parent.isFrozenGrid()) {\n      const table$$1 = closest(rect, '.' + table);\n      const fLeft = table$$1.offsetLeft;\n\n      if (left < fLeft) {\n        left = fLeft;\n      }\n    }\n\n    this.helper.style.left = left + 'px';\n  }\n\n  calcPos(elem) {\n    let parentOffset = {\n      top: 0,\n      left: 0\n    };\n    const offset = elem.getBoundingClientRect();\n    const doc = elem.ownerDocument;\n    let offsetParent = parentsUntil(elem, 'e-grid') || doc.documentElement;\n\n    while (offsetParent && (offsetParent === doc.body || offsetParent === doc.documentElement) && offsetParent.style.position === 'static') {\n      offsetParent = offsetParent.parentNode;\n    }\n\n    if (offsetParent && offsetParent !== elem && offsetParent.nodeType === 1) {\n      parentOffset = offsetParent.getBoundingClientRect();\n    }\n\n    return {\n      top: offset.top - parentOffset.top,\n      left: offset.left - parentOffset.left\n    };\n  }\n\n  doubleTapEvent(e) {\n    if (this.getUserAgent() && this.isDblClk) {\n      if (!this.tapped) {\n        this.tapped = setTimeout(() => {\n          this.tapped = null;\n        }, 300);\n      } else {\n        clearTimeout(this.tapped);\n        this.callAutoFit(e);\n        this.tapped = null;\n      }\n    }\n  }\n\n  getUserAgent() {\n    const userAgent = Browser.userAgent.toLowerCase();\n    return /iphone|ipod|ipad/.test(userAgent);\n  }\n\n  timeoutHandler() {\n    this.tapped = null;\n  }\n\n}\n/**\n *\n * The `Reorder` module is used for reordering columns.\n */\n\n\nclass Reorder {\n  /**\n   * Constructor for the Grid reorder module\n   *\n   * @param {IGrid} parent - specifies the IGrid\n   * @hidden\n   */\n  constructor(parent) {\n    this.parent = parent;\n\n    if (this.parent.isDestroyed) {\n      return;\n    }\n\n    this.parent.on(headerDrop, this.headerDrop, this);\n    this.parent.on(uiUpdate, this.enableAfterRender, this);\n    this.parent.on(reorderComplete, this.onActionComplete, this);\n    this.parent.on(columnDrag, this.drag, this);\n    this.parent.on(columnDragStart, this.dragStart, this);\n    this.parent.on(columnDragStop, this.dragStop, this);\n    this.parent.on(headerDrop, this.headerDrop, this);\n    this.parent.on(headerRefreshed, this.createReorderElement, this);\n    this.parent.on(keyPressed, this.keyPressHandler, this);\n    this.parent.on(destroy, this.destroy, this);\n  }\n\n  chkDropPosition(srcElem, destElem) {\n    const col = this.parent.getColumnByUid(destElem.firstElementChild.getAttribute('e-mappinguid'));\n    const bool = col ? !col.lockColumn : true;\n    return (srcElem.parentElement.isEqualNode(destElem.parentElement) || this.parent.enableColumnVirtualization || this.parent.isFrozenGrid() && Array.prototype.indexOf.call(closest(srcElem, 'thead').children, srcElem.parentElement) === Array.prototype.indexOf.call(closest(destElem, 'thead').children, destElem.parentElement)) && this.targetParentContainerIndex(srcElem, destElem) > -1 && bool;\n  }\n\n  chkDropAllCols(srcElem, destElem) {\n    let isFound;\n    const headers = this.getHeaderCells();\n    let header;\n\n    while (!isFound && headers.length > 0) {\n      header = headers.pop();\n      isFound = srcElem !== header && this.targetParentContainerIndex(srcElem, destElem) > -1;\n    }\n\n    return isFound;\n  }\n\n  findColParent(col, cols, parent) {\n    // eslint-disable-next-line no-self-assign\n    parent = parent;\n\n    for (let i = 0, len = cols.length; i < len; i++) {\n      if (col === cols[i]) {\n        return true;\n      } else if (cols[i].columns) {\n        const cnt = parent.length;\n        parent.push(cols[i]);\n\n        if (!this.findColParent(col, cols[i].columns, parent)) {\n          parent.splice(cnt, parent.length - cnt);\n        } else {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  }\n\n  getColumnsModel(cols) {\n    let columnModel = [];\n    let subCols = [];\n\n    if (!this.parent.getFrozenColumns() && this.parent.isFrozenGrid()) {\n      return this.parent.getColumns();\n    } else {\n      for (let i = 0, len = cols.length; i < len; i++) {\n        columnModel.push(cols[i]);\n\n        if (cols[i].columns) {\n          subCols = subCols.concat(cols[i].columns);\n        }\n      }\n\n      if (subCols.length) {\n        columnModel = columnModel.concat(this.getColumnsModel(subCols));\n      }\n    }\n\n    return columnModel;\n  }\n\n  headerDrop(e) {\n    const gObj = this.parent;\n    const dropElement = this.element.querySelector('.e-headercelldiv') || this.element.querySelector('.e-stackedheadercelldiv');\n    const uId = dropElement.getAttribute('e-mappinguid');\n    const column = gObj.getColumnByUid(uId);\n\n    if (!closest(e.target, 'th') || !isNullOrUndefined(column) && (!column.allowReordering || column.lockColumn)) {\n      this.parent.log('action_disabled_column', {\n        moduleName: this.getModuleName(),\n        column\n      });\n      return;\n    }\n\n    const destElem = closest(e.target, '.e-headercell');\n    const destElemDiv = destElem.querySelector('.e-headercelldiv') || destElem.querySelector('.e-stackedheadercelldiv');\n    const destElemUid = destElemDiv.getAttribute('e-mappinguid');\n\n    if (!isNullOrUndefined(destElemUid)) {\n      const destColumn = gObj.getColumnByUid(destElemUid);\n\n      if (isNullOrUndefined(destColumn) || !destColumn.allowReordering || destColumn.lockColumn) {\n        this.parent.log('action_disabled_column', {\n          moduleName: this.getModuleName(),\n          column,\n          destColumn\n        });\n        return;\n      }\n    }\n\n    if (destElem && !(!this.chkDropPosition(this.element, destElem) || !this.chkDropAllCols(this.element, destElem))) {\n      if (this.parent.enableColumnVirtualization) {\n        const columns = this.parent.columns;\n        const sourceUid = this.element.querySelector('.e-headercelldiv').getAttribute('e-mappinguid');\n        const col = this.parent.columns.filter(col => col.uid === sourceUid);\n        let colMatchIndex = null;\n        const column = col[0];\n        const destUid = destElem.querySelector('.e-headercelldiv').getAttribute('e-mappinguid');\n        columns.some((col, index) => {\n          if (col.uid === destUid) {\n            colMatchIndex = index;\n            return col.uid === destUid;\n          }\n\n          return false;\n        });\n\n        if (!isNullOrUndefined(colMatchIndex)) {\n          this.moveColumns(colMatchIndex, column);\n        }\n      } else {\n        const newIndex = this.targetParentContainerIndex(this.element, destElem);\n        const uid = this.element.firstElementChild.getAttribute('e-mappinguid');\n        this.destElement = destElem;\n        this.parent.notify(setReorderDestinationElement, {\n          ele: destElem\n        });\n\n        if (uid) {\n          this.moveColumns(newIndex, this.parent.getColumnByUid(uid));\n        } else {\n          const headers = this.getHeaderCells();\n          const oldIdx = getElementIndex(this.element, headers);\n          const columns = this.getColumnsModel(this.parent.columns);\n          this.moveColumns(newIndex, columns[oldIdx]);\n        }\n      }\n    }\n  }\n\n  isActionPrevent(gObj) {\n    return isActionPrevent(gObj);\n  }\n\n  moveColumns(destIndex, column, reorderByColumn, preventRefresh) {\n    const gObj = this.parent;\n\n    if (this.isActionPrevent(gObj)) {\n      gObj.notify(preventBatch, {\n        instance: this,\n        handler: this.moveColumns,\n        arg1: destIndex,\n        arg2: column\n      });\n      return;\n    }\n\n    const isFrozen = !gObj.getFrozenColumns() && gObj.isFrozenGrid();\n    const parent = this.getColParent(column, this.parent.columns);\n    const cols = parent ? parent.columns : isFrozen ? this.parent.getColumns() : this.parent.columns;\n    let srcIdx = inArray(column, cols);\n\n    if ((this.parent.isFrozenGrid() && parent || this.parent.lockcolPositionCount) && !reorderByColumn && !this.parent.enableColumnVirtualization) {\n      for (let i = 0; i < cols.length; i++) {\n        if (cols[i].field === column.field) {\n          srcIdx = i;\n          break;\n        }\n      }\n\n      const col = this.parent.getColumnByUid(this.destElement.firstElementChild.getAttribute('e-mappinguid'));\n\n      if (col) {\n        for (let i = 0; i < cols.length; i++) {\n          if (cols[i].field === col.field) {\n            destIndex = i;\n            break;\n          }\n        }\n      } else {\n        for (let i = 0; i < cols.length; i++) {\n          if (cols[i].headerText === this.destElement.innerText.trim()) {\n            destIndex = i;\n          }\n        }\n      }\n    }\n\n    if (!gObj.allowReordering || srcIdx === destIndex || srcIdx === -1 || destIndex === -1) {\n      return;\n    }\n\n    cols.splice(destIndex, 0, cols.splice(srcIdx, 1)[0]);\n    const args = {\n      column: column,\n      destIndex: destIndex,\n      columns: cols,\n      parent: parent,\n      cancel: false\n    };\n    gObj.notify(refreshFrozenColumns, args);\n\n    if (args.cancel) {\n      return;\n    }\n\n    gObj.getColumns(true);\n    gObj.notify(columnPositionChanged, {\n      fromIndex: destIndex,\n      toIndex: srcIdx\n    });\n\n    if (preventRefresh !== false) {\n      gObj.notify(modelChanged, {\n        type: actionBegin,\n        requestType: 'reorder',\n        fromIndex: destIndex,\n        toIndex: srcIdx,\n        toColumnUid: column.uid\n      });\n    }\n  }\n\n  targetParentContainerIndex(srcElem, destElem) {\n    let cols = !this.parent.getFrozenColumns() && this.parent.isFrozenGrid() ? this.parent.getColumns() : this.parent.columns;\n    const headers = this.getHeaderCells();\n    const flatColumns = this.getColumnsModel(cols);\n    const parent = this.getColParent(flatColumns[getElementIndex(srcElem, headers)], cols);\n    cols = parent ? parent.columns : cols;\n    return inArray(flatColumns[getElementIndex(destElem, headers)], cols);\n  }\n\n  getHeaderCells() {\n    const frozenColumns = this.parent.getFrozenColumns();\n\n    if (frozenColumns || this.parent.lockcolPositionCount) {\n      let fTh;\n      let mTh;\n      let fHeaders = [];\n      const fRows = [].slice.call(this.parent.getHeaderTable().getElementsByClassName('e-columnheader'));\n\n      if (frozenColumns) {\n        const mRows = [].slice.call(this.parent.getHeaderContent().querySelector('.' + movableHeader).getElementsByClassName('e-columnheader'));\n\n        for (let i = 0; i < fRows.length; i++) {\n          fTh = [].slice.call(fRows[i].getElementsByClassName('e-headercell'));\n          mTh = [].slice.call(mRows[i].getElementsByClassName('e-headercell'));\n          let isAvail;\n\n          for (let k = 0; k < fTh.length; k++) {\n            for (let j = 0; j < mTh.length; j++) {\n              if (mTh[j].innerText === fTh[k].innerText) {\n                isAvail = true;\n                break;\n              }\n            }\n\n            if (!isAvail) {\n              fHeaders = fHeaders.concat([fTh[k]]);\n            }\n          }\n\n          for (let j = 0; j < mTh.length; j++) {\n            fHeaders.push(mTh[j]);\n          }\n        }\n      } else {\n        for (let i = 0; i < fRows.length; i++) {\n          mTh = [].slice.call(fRows[i].getElementsByClassName('e-headercell'));\n\n          for (let k = 0; k < mTh.length; k++) {\n            let isAvail;\n\n            for (let j = k + 1; j < mTh.length; j++) {\n              if (mTh[j].innerText === mTh[k].innerText) {\n                isAvail = true;\n                break;\n              }\n            }\n\n            if (!isAvail) {\n              fHeaders = fHeaders.concat([mTh[k]]);\n            }\n          }\n        }\n      }\n\n      return fHeaders;\n    } else {\n      return [].slice.call(this.parent.element.getElementsByClassName('e-headercell'));\n    }\n  }\n\n  getColParent(column, columns) {\n    const parents$$1 = [];\n    this.findColParent(column, columns, parents$$1);\n    return parents$$1[parents$$1.length - 1];\n  }\n\n  reorderSingleColumn(fromFName, toFName) {\n    const fColumn = this.parent.enableColumnVirtualization ? this.parent.columns.filter(col => col.field === fromFName)[0] : this.parent.getColumnByField(fromFName);\n    const toColumn = this.parent.enableColumnVirtualization ? this.parent.columns.filter(col => col.field === toFName)[0] : this.parent.getColumnByField(toFName);\n\n    if (!isNullOrUndefined(fColumn) && (!fColumn.allowReordering || fColumn.lockColumn) || !isNullOrUndefined(toColumn) && (!toColumn.allowReordering || fColumn.lockColumn)) {\n      this.parent.log('action_disabled_column', {\n        moduleName: this.getModuleName(),\n        column: fColumn,\n        destColumn: toColumn\n      });\n      return;\n    }\n\n    const column = toColumn;\n    const parent = this.getColParent(column, this.parent.columns);\n    const columns = parent ? parent.columns : this.parent.columns;\n    const destIndex = inArray(column, columns);\n\n    if (destIndex > -1) {\n      this.moveColumns(destIndex, fColumn, true);\n    }\n  }\n\n  reorderMultipleColumns(fromFNames, toFName) {\n    let toIndex = this.parent.getColumnIndexByField(toFName);\n    const toColumn = this.parent.getColumnByField(toFName);\n\n    if (toIndex < 0 || !isNullOrUndefined(toColumn) && (!toColumn.allowReordering || toColumn.lockColumn)) {\n      return;\n    }\n\n    for (let i = 0; i < fromFNames.length; i++) {\n      const column = this.parent.getColumnByField(fromFNames[i]);\n\n      if (!isNullOrUndefined(column) && (!column.allowReordering || column.lockColumn)) {\n        return;\n      }\n    }\n\n    for (let i = 0; i < fromFNames.length; i++) {\n      const column = this.parent.getColumnByIndex(toIndex);\n      const parent = this.getColParent(column, this.parent.columns);\n      const columns = parent ? parent.columns : this.parent.columns;\n      const destIndex = inArray(column, columns);\n\n      if (destIndex > -1) {\n        this.moveColumns(destIndex, this.parent.getColumnByField(fromFNames[i]), true, true);\n      }\n\n      if (this.parent.getColumnIndexByField(fromFNames[i + 1]) >= destIndex) {\n        toIndex++; //R to L\n      }\n    }\n  }\n\n  moveTargetColumn(column, toIndex) {\n    if (toIndex > -1) {\n      this.moveColumns(toIndex, column, true);\n    }\n  }\n\n  reorderSingleColumnByTarget(fieldName, toIndex) {\n    this.moveTargetColumn(this.parent.getColumnByField(fieldName), toIndex);\n  }\n\n  reorderMultipleColumnByTarget(fieldName, toIndex) {\n    for (let i = 0; i < fieldName.length; i++) {\n      this.reorderSingleColumnByTarget(fieldName[i], toIndex);\n    }\n  }\n  /**\n   * Changes the position of the Grid columns by field names.\n   *\n   * @param  {string | string[]} fromFName - Defines the origin field names.\n   * @param  {string} toFName - Defines the destination field name.\n   * @returns {void}\n   */\n\n\n  reorderColumns(fromFName, toFName) {\n    if (typeof fromFName === 'string') {\n      this.reorderSingleColumn(fromFName, toFName);\n      this.fromCol = fromFName;\n    } else {\n      this.reorderMultipleColumns(fromFName, toFName);\n      this.fromCol = fromFName[0];\n    }\n  }\n  /**\n   * Changes the position of the Grid columns by field index.\n   *\n   * @param  {number} fromIndex - Defines the origin field index.\n   * @param  {number} toIndex - Defines the destination field index.\n   * @returns {void}\n   */\n\n\n  reorderColumnByIndex(fromIndex, toIndex) {\n    this.moveTargetColumn(this.parent.getColumnByIndex(fromIndex), toIndex);\n  }\n  /**\n   * Changes the position of the Grid columns by field index.\n   *\n   * @param  {string | string[]} fieldName - Defines the field name.\n   * @param  {number} toIndex - Defines the destination field index.\n   * @returns {void}\n   */\n\n\n  reorderColumnByTargetIndex(fieldName, toIndex) {\n    if (typeof fieldName === 'string') {\n      this.reorderSingleColumnByTarget(fieldName, toIndex);\n    } else {\n      this.reorderMultipleColumnByTarget(fieldName, toIndex);\n    }\n  }\n\n  enableAfterRender(e) {\n    if (e.module === this.getModuleName() && e.enable) {\n      this.createReorderElement();\n    }\n  }\n\n  createReorderElement(e) {\n    if (e && e.args.isXaxis) {\n      this.setDisplay('none');\n    }\n\n    const header = this.parent.element.querySelector('.' + headerContent);\n    this.upArrow = header.appendChild(this.parent.createElement('div', {\n      className: 'e-icons e-icon-reorderuparrow e-reorderuparrow',\n      attrs: {\n        style: 'display:none'\n      }\n    }));\n    this.downArrow = header.appendChild(this.parent.createElement('div', {\n      className: 'e-icons e-icon-reorderdownarrow e-reorderdownarrow',\n      attrs: {\n        style: 'display:none'\n      }\n    }));\n  }\n  /**\n   * The function used to trigger onActionComplete\n   *\n   * @param {NotifyArgs} e - specified the NotifyArgs\n   * @returns {void}\n   * @hidden\n   */\n\n\n  onActionComplete(e) {\n    this.parent.trigger(actionComplete, extend(e, {\n      type: actionComplete\n    }));\n    const target = this.fromCol && this.parent.getColumnHeaderByField(this.fromCol);\n\n    if (target) {\n      this.parent.focusModule.onClick({\n        target\n      }, true);\n    }\n  }\n  /**\n   * To destroy the reorder\n   *\n   * @returns {void}\n   * @hidden\n   */\n\n\n  destroy() {\n    const gridElement = this.parent.element;\n\n    if (this.parent.isDestroyed || !gridElement || !gridElement.querySelector('.' + gridHeader) && !gridElement.querySelector('.' + gridContent)) {\n      return;\n    }\n\n    if (this.upArrow.parentNode) {\n      remove(this.upArrow);\n    }\n\n    if (this.downArrow.parentNode) {\n      remove(this.downArrow);\n    }\n\n    this.parent.off(headerDrop, this.headerDrop);\n    this.parent.off(uiUpdate, this.enableAfterRender);\n    this.parent.off(reorderComplete, this.onActionComplete);\n    this.parent.off(columnDrag, this.drag);\n    this.parent.off(columnDragStart, this.dragStart);\n    this.parent.off(columnDragStop, this.dragStop);\n    this.parent.off(headerRefreshed, this.createReorderElement);\n    this.parent.off(keyPressed, this.keyPressHandler);\n    this.parent.off(destroy, this.destroy); //call ejdrag and drop destroy\n  }\n\n  keyPressHandler(e) {\n    const gObj = this.parent;\n\n    switch (e.action) {\n      case 'ctrlLeftArrow':\n      case 'ctrlRightArrow':\n        // eslint-disable-next-line no-case-declarations\n        const element = gObj.focusModule.currentInfo.element;\n\n        if (element && element.classList.contains('e-headercell')) {\n          const column = gObj.getColumnByUid(element.firstElementChild.getAttribute('e-mappinguid'));\n          const visibleCols = gObj.getVisibleColumns();\n          const index = visibleCols.indexOf(column);\n          const toCol = e.action === 'ctrlLeftArrow' ? visibleCols[index - 1] : visibleCols[index + 1];\n\n          if (toCol && toCol.field && column.field) {\n            this.reorderColumns(column.field, toCol.field);\n          }\n        }\n\n        break;\n    }\n  }\n\n  drag(e) {\n    const gObj = this.parent;\n    let target = e.target;\n\n    if (!e.column.allowReordering || e.column.lockColumn) {\n      return;\n    }\n\n    const closest$$1 = closest(target, '.e-headercell:not(.e-stackedHeaderCell)');\n    const cloneElement = gObj.element.querySelector('.e-cloneproperties');\n    const content$$1 = gObj.isFrozenGrid() ? gObj.getMovableVirtualContent() : gObj.getContent().firstElementChild;\n    const isLeft = this.x > getPosition(e.event).x + content$$1.scrollLeft;\n    removeClass([].slice.call(gObj.getHeaderTable().getElementsByClassName('e-reorderindicate')), ['e-reorderindicate']);\n    this.setDisplay('none');\n    this.stopTimer();\n    classList(cloneElement, ['e-defaultcur'], ['e-notallowedcur']);\n    this.updateScrollPostion(e.event);\n\n    if (closest$$1 && !closest$$1.isEqualNode(this.element)) {\n      target = closest$$1; //consider stacked, detail header cell\n\n      if (!(!this.chkDropPosition(this.element, target) || !this.chkDropAllCols(this.element, target))) {\n        this.updateArrowPosition(target, isLeft);\n        classList(target, ['e-allowDrop', 'e-reorderindicate'], []);\n      } else if (!(gObj.allowGrouping && parentsUntil(e.target, 'e-groupdroparea'))) {\n        classList(cloneElement, ['e-notallowedcur'], ['e-defaultcur']);\n      }\n    }\n\n    gObj.trigger(columnDrag, {\n      target: target,\n      draggableType: 'headercell',\n      column: e.column\n    });\n  }\n\n  updateScrollPostion(e) {\n    const x = getPosition(e).x;\n    const cliRect = this.parent.element.getBoundingClientRect();\n    const cliRectBaseRight = cliRect.right;\n\n    if (this.parent.isFrozenGrid()) {\n      this.updateFrozenScrollPosition(x, cliRect);\n    } else {\n      const cliRectBaseLeft = cliRect.left;\n      const scrollElem = this.parent.getContent().firstElementChild;\n\n      if (x > cliRectBaseLeft && x < cliRectBaseLeft + 35) {\n        this.timer = window.setInterval(() => {\n          this.setScrollLeft(scrollElem, true);\n        }, 50);\n      } else if (x < cliRectBaseRight && x > cliRectBaseRight - 35) {\n        this.timer = window.setInterval(() => {\n          this.setScrollLeft(scrollElem, false);\n        }, 50);\n      }\n    }\n  }\n\n  updateFrozenScrollPosition(x, cliRect) {\n    const scrollElem = this.parent.getContent().querySelector('.' + movableContent);\n    const mhdrCliRect = this.parent.element.querySelector('.' + movableHeader).getBoundingClientRect();\n    const left = this.parent.getFrozenLeftCount();\n    const right = this.parent.getFrozenRightColumnsCount();\n    const cliRectBaseRight = right ? mhdrCliRect.right : cliRect.right;\n    const cliRectBaseLeft = left ? mhdrCliRect.left : cliRect.left;\n\n    if (x > cliRectBaseLeft && x < cliRectBaseLeft + 35) {\n      this.timer = window.setInterval(() => {\n        this.setScrollLeft(scrollElem, true);\n      }, 50);\n    } else if (x < cliRectBaseRight && x > cliRectBaseRight - 35) {\n      this.timer = window.setInterval(() => {\n        this.setScrollLeft(scrollElem, false);\n      }, 50);\n    }\n  }\n\n  setScrollLeft(scrollElem, isLeft) {\n    const scrollLeft = scrollElem.scrollLeft;\n    scrollElem.scrollLeft = scrollElem.scrollLeft + (isLeft ? -5 : 5);\n\n    if (scrollLeft !== scrollElem.scrollLeft) {\n      this.setDisplay('none');\n    }\n  }\n\n  stopTimer() {\n    window.clearInterval(this.timer);\n  }\n\n  updateArrowPosition(target, isLeft) {\n    const cliRect = target.getBoundingClientRect();\n    const cliRectBase = this.parent.element.getBoundingClientRect();\n\n    if (isLeft && cliRect.left < cliRectBase.left || !isLeft && cliRect.right > cliRectBase.right) {\n      return;\n    }\n\n    if (this.parent.isFrozenGrid() && target.classList.contains('e-headercell')) {\n      const left = this.parent.getFrozenLeftCount();\n      const right = this.parent.getFrozenRightColumnsCount();\n      const dropEle = this.element.querySelector('.e-headercelldiv');\n      const dropCol = dropEle ? this.parent.getColumnByUid(dropEle.getAttribute('data-uid')) : null;\n      const col = this.parent.getColumnByUid(target.firstElementChild.getAttribute('e-mappinguid'));\n      const fhdrWidth = Math.round(this.parent.getFrozenVirtualHeader().getBoundingClientRect().right);\n      const mhdrRight = Math.round(this.parent.getMovableVirtualHeader().getBoundingClientRect().right);\n\n      if (col) {\n        if (left && !right && this.parent.getNormalizedColumnIndex(col.uid) >= left && (isLeft && Math.round(cliRect.left) < fhdrWidth || !isLeft && mhdrRight < cliRect.right)) {\n          return;\n        }\n\n        if (!left && right && dropCol && dropCol.getFreezeTableName() !== col.getFreezeTableName() && !isLeft && Math.round(cliRect.right) < fhdrWidth) {\n          return;\n        }\n      }\n    }\n\n    let isSticky = this.parent.getHeaderContent().classList.contains('e-sticky');\n    this.upArrow.style.top = isSticky ? cliRect.top + cliRect.height + 'px' : cliRect.top + cliRect.height - cliRectBase.top + 'px';\n    this.downArrow.style.top = isSticky ? cliRect.top - 7 + 'px' : cliRect.top - cliRectBase.top - 7 + 'px';\n    this.upArrow.style.left = this.downArrow.style.left = isSticky ? (isLeft ? cliRect.left : cliRect.right) - 4 + 'px' : (isLeft ? cliRect.left : cliRect.right) - cliRectBase.left - 4 + 'px';\n    this.setDisplay('');\n  }\n\n  dragStart(e) {\n    const gObj = this.parent;\n    const target = e.target;\n    this.element = target.classList.contains('e-headercell') ? target : parentsUntil(target, 'e-headercell');\n\n    if (!e.column.allowReordering || e.column.lockColumn) {\n      return;\n    }\n\n    const content$$1 = gObj.isFrozenGrid() ? gObj.getMovableVirtualContent() : gObj.getContent().firstElementChild;\n    this.x = getPosition(e.event).x + content$$1.scrollLeft;\n    gObj.trigger(columnDragStart, {\n      target: target,\n      draggableType: 'headercell',\n      column: e.column\n    });\n  }\n\n  dragStop(e) {\n    const gObj = this.parent;\n    this.setDisplay('none');\n    this.stopTimer();\n\n    if (!e.cancel) {\n      gObj.trigger(columnDrop, {\n        target: e.target,\n        draggableType: 'headercell',\n        column: e.column\n      });\n    }\n\n    removeClass([].slice.call(gObj.getHeaderTable().getElementsByClassName('e-reorderindicate')), ['e-reorderindicate']);\n  }\n\n  setDisplay(display) {\n    this.upArrow.style.display = display;\n    this.downArrow.style.display = display;\n  }\n  /**\n   * For internal use only - Get the module name.\n   *\n   * @returns {string} return the module name\n   * @private\n   */\n\n\n  getModuleName() {\n    return 'reorder';\n  }\n\n} // eslint-disable-next-line valid-jsdoc\n\n/**\n *\n * Reorder module is used to handle row reordering.\n *\n * @hidden\n */\n\n\nclass RowDD {\n  /**\n   * Constructor for the Grid print module\n   *\n   * @param {IGrid} parent - specifies the IGrid\n   * @hidden\n   */\n  constructor(parent) {\n    this.selectedRows = [];\n    this.isOverflowBorder = true;\n    this.selectedRowColls = [];\n    this.isRefresh = true;\n    this.isReplaceDragEle = true;\n    this.istargetGrid = false; // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n    this.helper = e => {\n      const gObj = this.parent;\n      const target = this.draggable.currentStateTarget;\n      const visualElement = this.parent.createElement('div', {\n        className: 'e-cloneproperties e-draganddrop e-grid e-dragclone',\n        styles: 'height:\"auto\", z-index:2, width:' + gObj.element.offsetWidth\n      });\n      const table$$1 = this.parent.createElement('table', {\n        styles: 'width:' + gObj.element.offsetWidth\n      });\n      const tbody$$1 = this.parent.createElement(tbody);\n\n      if (document.getElementsByClassName('e-griddragarea').length || gObj.rowDropSettings.targetID && (!target.classList.contains('e-selectionbackground') && gObj.selectionSettings.type !== 'Single' || !parentsUntil(target, 'e-rowcell')) || !gObj.rowDropSettings.targetID && !parentsUntil(target, 'e-rowdragdrop')) {\n        return false;\n      }\n\n      if (gObj.rowDropSettings.targetID && gObj.selectionSettings.mode === 'Row' && gObj.selectionSettings.type === 'Single') {\n        gObj.selectRow(parseInt(this.draggable.currentStateTarget.parentElement.getAttribute(ariaRowIndex), 10));\n      }\n\n      this.startedRow = closest(target, 'tr').cloneNode(true);\n      const frzCols = this.parent.isFrozenGrid();\n\n      if (frzCols) {\n        const rowIndex = parseInt(closest(target, 'tr').getAttribute(ariaRowIndex), 10);\n        this.startedRow.innerHTML = '';\n        this.startedRow.innerHTML += gObj.getRowByIndex(rowIndex).innerHTML;\n        this.startedRow.innerHTML += gObj.getMovableRowByIndex(rowIndex).innerHTML;\n\n        if (gObj.getFrozenMode() === leftRight) {\n          this.startedRow.innerHTML += gObj.getFrozenRightRowByIndex(rowIndex).innerHTML;\n        }\n      }\n\n      this.processArgs(target);\n      const args = {\n        selectedRow: this.rows,\n        dragelement: target,\n        cloneElement: visualElement,\n        cancel: false,\n        data: this.rowData\n      };\n      const selectedRows = gObj.getSelectedRows();\n      gObj.trigger(rowDragStartHelper, args);\n      const cancel = 'cancel';\n\n      if (args[cancel]) {\n        return false;\n      }\n\n      removeElement(this.startedRow, '.e-indentcell');\n      removeElement(this.startedRow, '.e-detailrowcollapse');\n      removeElement(this.startedRow, '.e-detailrowexpand');\n      this.removeCell(this.startedRow, gridChkBox);\n      const exp = new RegExp('e-active', 'g'); //high contrast issue\n\n      this.startedRow.innerHTML = this.startedRow.innerHTML.replace(exp, '');\n      tbody$$1.appendChild(this.startedRow);\n\n      if (gObj.getSelectedRowIndexes().length > 1 && this.startedRow.hasAttribute('aria-selected')) {\n        const index = gObj.getFrozenMode() === leftRight ? 3 : 2;\n        const dropCountEle = this.parent.createElement('span', {\n          className: 'e-dropitemscount',\n          innerHTML: frzCols ? '' + selectedRows.length / index : '' + selectedRows.length\n        });\n        visualElement.appendChild(dropCountEle);\n      }\n\n      const ele = closest(target, 'tr').querySelector('.e-icon-rowdragicon');\n\n      if (ele) {\n        ele.classList.add('e-dragstartrow');\n      }\n\n      table$$1.appendChild(tbody$$1);\n      visualElement.appendChild(table$$1);\n      gObj.element.appendChild(visualElement);\n      return visualElement;\n    };\n\n    this.dragStart = e => {\n      const gObj = this.parent;\n\n      if (document.getElementsByClassName('e-griddragarea').length) {\n        return;\n      }\n\n      const target = e.target;\n      const spanCssEle = this.parent.element.querySelector('.e-dropitemscount');\n\n      if (this.parent.getSelectedRecords().length > 1 && spanCssEle) {\n        spanCssEle.style.left = this.parent.element.querySelector('.e-cloneproperties table').offsetWidth - 5 + 'px';\n      }\n\n      this.processArgs(target);\n      gObj.trigger(rowDragStart, {\n        rows: this.rows,\n        target: e.target,\n        draggableType: 'rows',\n        fromIndex: parseInt(this.rows[0].getAttribute(ariaRowIndex), 10),\n        data: Object.keys(this.rowData[0]).length > 0 ? this.rowData : this.currentViewData()\n      });\n      this.dragStartData = this.rowData;\n      const dropElem = document.getElementById(gObj.rowDropSettings.targetID);\n\n      if (gObj.rowDropSettings.targetID && dropElem && dropElem.ej2_instances && dropElem.ej2_instances[0].getModuleName() === 'grid') {\n        dropElem.ej2_instances[0].getContent().classList.add('e-allowRowDrop');\n      }\n    };\n\n    this.drag = e => {\n      const gObj = this.parent;\n      this.isDropGrid = this.parent;\n      this.istargetGrid = false;\n\n      if (this.parent.rowDropSettings.targetID) {\n        const dropElement = document.getElementById(gObj.rowDropSettings.targetID);\n        this.isDropGrid = dropElement.ej2_instances[0];\n\n        if (parentsUntil(e.target, 'e-grid')) {\n          this.istargetGrid = this.parent.rowDropSettings.targetID === parentsUntil(e.target, 'e-grid').id;\n        }\n      }\n\n      const cloneElement = this.parent.element.querySelector('.e-cloneproperties');\n      const target = this.getElementFromPosition(cloneElement, e.event);\n      classList(cloneElement, ['e-defaultcur'], ['e-notallowedcur', 'e-movecur', 'e-grabcur']);\n      this.isOverflowBorder = true;\n      this.hoverState = gObj.enableHover;\n      const trElement = parentsUntil(target, 'e-grid') ? closest(e.target, 'tr') : null;\n      gObj.enableHover = false;\n\n      if (!e.target) {\n        return;\n      }\n\n      this.processArgs(target);\n      const args = {\n        rows: this.rows,\n        target: target,\n        draggableType: 'rows',\n        data: this.rowData,\n        originalEvent: e,\n        cancel: false\n      };\n      gObj.trigger(rowDrag, args);\n      this.stopTimer();\n\n      if (args.cancel) {\n        return;\n      }\n\n      gObj.element.classList.add('e-rowdrag');\n      this.dragTarget = trElement && parentsUntil(target, 'e-grid').id === cloneElement.parentElement.id ? parseInt(trElement.getAttribute(ariaRowIndex), 10) : parseInt(this.startedRow.getAttribute(ariaRowIndex), 10);\n\n      if (gObj.rowDropSettings.targetID) {\n        if (!parentsUntil(target, 'e-grid') || parentsUntil(cloneElement.parentElement, 'e-grid').id === parentsUntil(target, 'e-grid').id) {\n          classList(cloneElement, ['e-notallowedcur'], ['e-defaultcur']);\n        } else {\n          classList(cloneElement, ['e-grabcur'], ['e-notallowedcur']);\n        }\n      } else {\n        const elem = parentsUntil(target, 'e-grid');\n\n        if (elem && elem.id === cloneElement.parentElement.id) {\n          classList(cloneElement, ['e-movecur'], ['e-defaultcur']);\n        } else {\n          classList(cloneElement, ['e-notallowedcur'], ['e-movecur']);\n        }\n      }\n\n      if (parentsUntil(this.isDropGrid.element, 'e-grid')) {\n        if ((!this.isDropGrid.groupSettings.columns.length || e.target.classList.contains('e-selectionbackground')) && !this.isDropGrid.element.querySelector('.e-emptyrow')) {\n          if (parentsUntil(target, 'e-grid') && parentsUntil(target, 'e-grid').id === this.isDropGrid.element.id) {\n            this.updateScrollPostion(e.event);\n          }\n\n          if ((this.isOverflowBorder || this.parent.frozenRows > this.dragTarget) && (parseInt(this.startedRow.getAttribute(ariaRowIndex), 10) !== this.dragTarget || this.istargetGrid) || this.istargetGrid && trElement && this.isDropGrid.getRowByIndex(this.isDropGrid.getCurrentViewRecords().length - 1).getAttribute('data-uid') === trElement.getAttribute('data-uid')) {\n            this.moveDragRows(e, this.startedRow, trElement);\n          } else {\n            let islastRowIndex;\n\n            if (this.parent.enableVirtualization) {\n              islastRowIndex = trElement && parseInt(trElement.getAttribute(ariaRowIndex), 10) === this.parent.renderModule.data.dataManager.dataSource.json.length - 1;\n            } else {\n              const lastRowUid = this.parent.getRowByIndex(this.parent.getCurrentViewRecords().length - 1).getAttribute('data-uid');\n              islastRowIndex = trElement && lastRowUid === trElement.getAttribute('data-uid') && lastRowUid !== this.startedRow.getAttribute('data-uid');\n            }\n\n            if (islastRowIndex && !this.parent.rowDropSettings.targetID) {\n              const bottomborder = this.parent.createElement('div', {\n                className: 'e-lastrow-dragborder'\n              });\n              const gridcontentEle = this.parent.getContent();\n              bottomborder.style.width = this.parent.element.offsetWidth - this.getScrollWidth() + 'px';\n\n              if (this.parent.enableVirtualization) {\n                bottomborder.style.zIndex = '1';\n              }\n\n              if (!gridcontentEle.getElementsByClassName('e-lastrow-dragborder').length) {\n                gridcontentEle.classList.add('e-grid-relative');\n                gridcontentEle.appendChild(bottomborder);\n                bottomborder.style.bottom = this.getScrollWidth() + 'px';\n              }\n            }\n\n            this.removeBorder(trElement);\n          }\n        }\n\n        if (target && target.classList.contains(content) && !this.isDropGrid.element.querySelector('.e-emptyrow') && this.istargetGrid) {\n          this.removeBorder(trElement);\n          const rowIndex = this.isDropGrid.getCurrentViewRecords().length - 1;\n          const selector = '.e-rowcell,.e-rowdragdrop,.e-detailrowcollapse';\n          let rowElement = [];\n          rowElement = [].slice.call(this.isDropGrid.getRowByIndex(rowIndex).querySelectorAll(selector));\n\n          if (this.isDropGrid.isFrozenGrid()) {\n            rowElement = this.borderRowElement(rowIndex, selector);\n          }\n\n          if (rowElement.length > 0) {\n            addRemoveActiveClasses(rowElement, true, 'e-dragborder');\n          }\n        }\n      }\n    };\n\n    this.dragStop = e => {\n      if (isActionPrevent(this.parent)) {\n        this.parent.notify(preventBatch, {\n          instance: this,\n          handler: this.processDragStop,\n          arg1: e\n        });\n      } else {\n        this.processDragStop(e);\n      }\n    };\n\n    this.processDragStop = e => {\n      const gObj = this.parent;\n\n      if (this.parent.isDestroyed) {\n        return;\n      }\n\n      const targetEle = this.getElementFromPosition(e.helper, e.event);\n      const target = targetEle && !targetEle.classList.contains('e-dlg-overlay') ? targetEle : e.target;\n      gObj.element.classList.remove('e-rowdrag');\n      const dropElement = document.getElementById(gObj.rowDropSettings.targetID);\n\n      if (gObj.rowDropSettings.targetID && dropElement && dropElement.ej2_instances && dropElement.ej2_instances[0].getModuleName() === 'grid') {\n        dropElement.ej2_instances[0].getContent().classList.remove('e-allowRowDrop');\n      }\n\n      if (parentsUntil(this.isDropGrid.element, 'e-grid')) {\n        this.stopTimer();\n        this.isDropGrid.enableHover = this.hoverState;\n        this.isDropGrid.getContent().classList.remove('e-grid-relative');\n        this.removeBorder(targetEle);\n        const stRow = this.isDropGrid.element.querySelector('.e-dragstartrow');\n\n        if (stRow) {\n          stRow.classList.remove('e-dragstartrow');\n        }\n      }\n\n      this.processArgs(target);\n      const args = {\n        target: target,\n        draggableType: 'rows',\n        cancel: false,\n        fromIndex: parseInt(this.rows[0].getAttribute(ariaRowIndex), 10),\n        dropIndex: this.dragTarget,\n        rows: this.rows,\n        data: Object.keys(this.dragStartData[0]).length > 0 ? this.dragStartData : this.currentViewData()\n      };\n      gObj.trigger(rowDrop, args, () => {\n        if (!(parentsUntil(target, row) || parentsUntil(target, 'e-emptyrow') || parentsUntil(target, gridContent)) || args.cancel) {\n          this.dragTarget = null;\n          remove(e.helper);\n          return;\n        }\n\n        this.isRefresh = false;\n        const selectedIndexes = this.parent.getSelectedRowIndexes();\n\n        if (gObj.isRowDragable()) {\n          if (!this.parent.rowDropSettings.targetID && this.startedRow.querySelector('td.e-selectionbackground') && selectedIndexes.length > 1 && selectedIndexes.length !== this.parent.getCurrentViewRecords().length) {\n            this.reorderRows(selectedIndexes, args.dropIndex);\n          } else {\n            this.reorderRows([parseInt(this.startedRow.getAttribute(ariaRowIndex), 10)], this.dragTarget);\n          }\n\n          this.dragTarget = null;\n\n          if (!gObj.rowDropSettings.targetID) {\n            remove(e.helper);\n\n            if (gObj.enableVirtualization) {\n              gObj.refresh();\n            } else {\n              this.rowOrder(args);\n            }\n          }\n        }\n\n        this.isRefresh = true;\n      });\n    };\n\n    this.removeCell = (targetRow, className) => {\n      return [].slice.call(targetRow.querySelectorAll('td')).filter(cell => {\n        if (cell.classList.contains(className)) {\n          targetRow.deleteCell(cell.cellIndex);\n        }\n      });\n    };\n\n    this.parent = parent;\n\n    if (this.parent.isDestroyed) {\n      return;\n    }\n\n    this.parent.on(initialEnd, this.initializeDrag, this);\n    this.parent.on(columnDrop, this.columnDrop, this);\n    this.onDataBoundFn = this.onDataBound.bind(this);\n    this.parent.addEventListener(dataBound, this.onDataBoundFn);\n    this.parent.on(uiUpdate, this.enableAfterRender, this);\n    this.parent.on(destroy, this.destroy, this);\n  }\n\n  refreshRow(args, tbody$$1, mtbody, frTbody, target, mTarget, frTarget) {\n    const gObj = this.parent;\n    const frzCols = gObj.isFrozenGrid();\n    const isLeftRight = gObj.getFrozenMode() === leftRight;\n    let tbodyMovableHeader;\n    let tbodyMovableContent;\n    let frHdr;\n    let frCnt;\n    const tbodyContent = gObj.getContentTable().querySelector(tbody);\n    const tbodyHeader = gObj.getHeaderTable().querySelector(tbody);\n\n    if (frzCols) {\n      tbodyMovableHeader = gObj.getMovableHeaderTbody();\n      tbodyMovableContent = gObj.getMovableContentTbody();\n\n      if (isLeftRight) {\n        frHdr = gObj.getFrozenRightHeaderTbody();\n        frCnt = gObj.getFrozenRightContentTbody();\n      }\n    }\n\n    const index = gObj.getFrozenMode() === leftRight ? 3 : 2;\n\n    for (let i = 0, len = args.rows.length; i < len; i++) {\n      if (frzCols) {\n        if (i % index === 0) {\n          tbody$$1.insertBefore(args.rows[i], target);\n        } else if (i % index === 1) {\n          mtbody.insertBefore(args.rows[i], mTarget);\n        } else {\n          frTbody.insertBefore(args.rows[i], frTarget);\n        }\n      } else {\n        tbody$$1.insertBefore(args.rows[i], target);\n      }\n    }\n\n    const tr = [].slice.call(tbody$$1.getElementsByClassName(row));\n    let mtr;\n    let frTr;\n\n    if (frzCols) {\n      mtr = [].slice.call(mtbody.getElementsByClassName(row));\n\n      if (isLeftRight) {\n        frTr = [].slice.call(frTbody.getElementsByClassName(row));\n      }\n    }\n\n    this.refreshData(tr, mtr, frTr);\n\n    if (this.parent.frozenRows) {\n      for (let i = 0, len = tr.length; i < len; i++) {\n        if (i < this.parent.frozenRows) {\n          setRowsInTbody(tbodyHeader, tbodyMovableHeader, frHdr, tr, mtr, frTr, (tbody$$1, rows) => {\n            tbody$$1.appendChild(rows[i]);\n          });\n        } else {\n          setRowsInTbody(tbodyContent, tbodyMovableContent, frCnt, tr, mtr, frTr, (tbody$$1, rows) => {\n            tbody$$1.appendChild(rows[i]);\n          });\n        }\n      }\n    }\n  }\n\n  updateFrozenRowreOrder(args) {\n    const gObj = this.parent;\n    let tbodyMovH;\n    let tbodyMovC;\n    let tbodyFrH;\n    let tbodyFrC;\n    const frzCols = this.parent.isFrozenGrid();\n    const isLeftRight = gObj.getFrozenMode() === leftRight;\n    const tbodyC = gObj.getContentTable().querySelector(tbody);\n    const tbodyH = gObj.getHeaderTable().querySelector(tbody);\n\n    if (frzCols) {\n      tbodyMovH = gObj.getMovableHeaderTbody();\n      tbodyMovC = gObj.getMovableContentTbody();\n\n      if (isLeftRight) {\n        tbodyFrH = gObj.getFrozenRightHeaderTbody();\n        tbodyFrC = gObj.getFrozenRightContentTbody();\n      }\n    }\n\n    const tr = [].slice.call(tbodyH.getElementsByClassName(row)).concat([].slice.call(tbodyC.getElementsByClassName(row)));\n    let mtr;\n    let frTr;\n\n    if (frzCols) {\n      mtr = [].slice.call(tbodyMovH.getElementsByClassName(row)).concat([].slice.call(tbodyMovC.getElementsByClassName(row)));\n\n      if (isLeftRight) {\n        frTr = [].slice.call(tbodyFrH.getElementsByClassName(row)).concat([].slice.call(tbodyFrC.getElementsByClassName(row)));\n      }\n    }\n\n    const tbody$$1 = gObj.createElement(tbody);\n    const mtbody = gObj.createElement(tbody);\n    const frTbody = gObj.createElement(tbody);\n    this.parent.clearSelection();\n    const targetRows = this.refreshRowTarget(args);\n\n    for (let i = 0, len = tr.length; i < len; i++) {\n      tbody$$1.appendChild(tr[i]);\n\n      if (frzCols) {\n        mtbody.appendChild(mtr[i]);\n\n        if (isLeftRight) {\n          frTbody.appendChild(frTr[i]);\n        }\n      }\n    }\n\n    this.refreshRow(args, tbody$$1, mtbody, frTbody, targetRows.target, targetRows.mTarget, targetRows.frTarget);\n  }\n\n  refreshRowTarget(args) {\n    const gObj = this.parent;\n    let mTr;\n    let frTr;\n    let targetIdx = parseInt(args.target.parentElement.getAttribute(ariaRowIndex), 10);\n\n    if (args.fromIndex < args.dropIndex || args.fromIndex === args.dropIndex) {\n      targetIdx = targetIdx + 1;\n    }\n\n    const tr = gObj.getRowByIndex(targetIdx);\n\n    if (gObj.isFrozenGrid()) {\n      mTr = gObj.getMovableRowByIndex(targetIdx);\n\n      if (gObj.getFrozenMode() === leftRight) {\n        frTr = gObj.getFrozenRightRowByIndex(targetIdx);\n      }\n    }\n\n    const rows = {\n      target: tr,\n      mTarget: mTr,\n      frTarget: frTr\n    };\n    return rows;\n  }\n\n  updateFrozenColumnreOrder(args) {\n    const gObj = this.parent;\n    let mtbody;\n    let frTbody;\n    const frzCols = this.parent.isFrozenGrid();\n    const tbody$$1 = gObj.getContentTable().querySelector(tbody);\n\n    if (frzCols) {\n      mtbody = gObj.getMovableContentTbody();\n\n      if (gObj.getFrozenMode() === leftRight) {\n        frTbody = gObj.getFrozenRightContentTbody();\n      }\n    }\n\n    this.parent.clearSelection();\n    const targetRows = this.refreshRowTarget(args);\n    this.refreshRow(args, tbody$$1, mtbody, frTbody, targetRows.target, targetRows.mTarget, targetRows.frTarget);\n  }\n\n  refreshData(tr, mtr, frTr) {\n    const rowObj = {};\n    const movobj = {};\n    const frObj = {};\n    const recordobj = {};\n    const rowObjects = this.parent.getRowsObject();\n    const movbObject = this.parent.getMovableRowsObject();\n    const frRightObject = this.parent.getFrozenRightRowsObject();\n    const currentViewData = this.parent.getCurrentViewRecords();\n\n    for (let i = 0, len = tr.length; i < len; i++) {\n      const index = parseInt(tr[i].getAttribute(ariaRowIndex), 10);\n      rowObj[i] = rowObjects[index];\n      recordobj[i] = currentViewData[index];\n\n      if (this.parent.isFrozenGrid()) {\n        movobj[i] = movbObject[index];\n\n        if (frTr) {\n          frObj[i] = frRightObject[index];\n        }\n      }\n    }\n\n    const rows = this.parent.getRows();\n    let movbRows;\n    let frRightRows;\n\n    if (this.parent.isFrozenGrid()) {\n      movbRows = this.parent.getMovableRows();\n\n      if (frTr) {\n        frRightRows = this.parent.getFrozenRightRows();\n      }\n    }\n\n    for (let i = 0, len = tr.length; i < len; i++) {\n      rows[i] = tr[i];\n      rowObjects[i] = rowObj[i];\n      currentViewData[i] = recordobj[i];\n\n      if (this.parent.isFrozenGrid()) {\n        movbRows[i] = mtr[i];\n        movbObject[i] = movobj[i];\n\n        if (frTr) {\n          frRightRows[i] = frTr[i];\n          frRightObject[i] = frObj[i];\n        }\n      }\n    }\n\n    resetRowIndex(this.parent, rowObjects, tr);\n\n    if (this.parent.isFrozenGrid()) {\n      resetRowIndex(this.parent, movbObject, mtr);\n\n      if (frTr) {\n        resetRowIndex(this.parent, frRightObject, frTr);\n      }\n    }\n  }\n\n  rowOrder(args) {\n    if (args.dropIndex === args.fromIndex || isNaN(args.dropIndex)) {\n      return;\n    }\n\n    if (this.parent.isDetail()) {\n      this.parent.detailCollapseAll();\n      const rows = [].slice.call(this.parent.getContentTable().querySelector(tbody).children);\n      const rowObjects = this.parent.getRowsObject();\n      rows.filter(row$$1 => {\n        if (row$$1.classList.contains('e-detailrow')) {\n          row$$1.remove();\n        }\n      });\n\n      for (let i = 0, len = rowObjects.length; i < len; i++) {\n        if (!rowObjects[i]) {\n          break;\n        }\n\n        if (rowObjects[i].isDetailRow) {\n          this.parent.getRowsObject().splice(i, 1);\n          i--;\n        }\n      }\n    }\n\n    if (args.target.classList.contains('e-rowcelldrag')) {\n      args.target = args.target.parentElement;\n    }\n\n    if (this.parent.frozenRows) {\n      this.updateFrozenRowreOrder(args);\n    } else {\n      this.updateFrozenColumnreOrder(args);\n    }\n\n    if (this.selectedRowColls.length > 0) {\n      this.parent.selectRows(this.selectedRowColls);\n      const indexes = [];\n\n      if (this.parent.filterSettings.columns.length || this.parent.sortSettings.columns.length) {\n        for (let i = 0, len = args.rows.length; i < len; i++) {\n          indexes.push(parseInt(args.rows[i].getAttribute(ariaRowIndex), 10));\n        }\n\n        this.selectedRowColls = indexes;\n      }\n\n      this.selectedRowColls = [];\n    }\n  }\n\n  currentViewData() {\n    const selectedIndexes = this.parent.getSelectedRowIndexes();\n    const currentVdata = [];\n    const fromIdx = parseInt(this.startedRow.getAttribute(ariaRowIndex), 10);\n\n    for (let i = 0, n = selectedIndexes.length; i < n; i++) {\n      const currentV = 'currentViewData';\n      currentVdata[i] = this.parent[currentV][selectedIndexes[i]];\n    }\n\n    if (!this.parent.rowDropSettings.targetID && selectedIndexes.length === 0) {\n      currentVdata[0] = this.parent.currentViewData[fromIdx];\n    }\n\n    return currentVdata;\n  }\n\n  saveChange(changeRecords, query) {\n    this.parent.getDataModule().saveChanges(changeRecords, this.parent.getPrimaryKeyFieldNames()[0], {}, query).then(() => {\n      this.parent.notify(modelChanged, {\n        type: actionBegin,\n        requestType: 'rowdraganddrop'\n      });\n    }).catch(e => {\n      const error = 'error';\n      const message = 'message';\n\n      if (!isNullOrUndefined(e[error]) && !isNullOrUndefined(e[error][message])) {\n        e[error] = e[error][message];\n      }\n\n      this.parent.trigger(actionFailure, e);\n    });\n  }\n\n  reorderRows(fromIndexes, toIndex) {\n    const selectedIndexes = this.parent.getSelectedRowIndexes();\n    const selectedRecords = [];\n    const draggedRecords = [];\n    const currentViewData = this.parent.renderModule.data.dataManager.dataSource.json;\n    const skip = this.parent.allowPaging ? this.parent.pageSettings.currentPage * this.parent.pageSettings.pageSize - this.parent.pageSettings.pageSize : 0;\n    let dropIdx = toIndex + skip;\n    let actualIdx = fromIndexes[0] + skip;\n\n    for (let i = 0, len = fromIndexes.length; i < len; i++) {\n      draggedRecords[i] = currentViewData[fromIndexes[i] + skip];\n    }\n\n    for (let i = 0, len = selectedIndexes.length; i < len; i++) {\n      selectedRecords[i] = currentViewData[selectedIndexes[i] + skip];\n    }\n\n    for (let i = 0, len = draggedRecords.length; i < len; i++) {\n      if (i !== 0) {\n        for (let j = 0, len1 = currentViewData.length; j < len1; j++) {\n          if (JSON.stringify(this.parent.renderModule.data.dataManager.dataSource.json[j]) === JSON.stringify(draggedRecords[i])) {\n            actualIdx = j;\n            break;\n          }\n        }\n\n        for (let j = 0, len1 = currentViewData.length; j < len1; j++) {\n          if (JSON.stringify(this.parent.renderModule.data.dataManager.dataSource.json[j]) === JSON.stringify(draggedRecords[i - 1])) {\n            if (actualIdx > j) {\n              dropIdx = j + 1;\n            }\n\n            break;\n          }\n        }\n      }\n\n      this.reorderRow(actualIdx - skip, dropIdx - skip);\n    }\n\n    if (this.isRefresh) {\n      this.parent.notify(modelChanged, {\n        type: actionBegin,\n        requestType: 'rowdraganddrop'\n      });\n    }\n\n    for (let i = 0, len = selectedRecords.length; i < len; i++) {\n      for (let j = 0, len1 = currentViewData.length; j < len1; j++) {\n        if (JSON.stringify(this.parent.renderModule.data.dataManager.dataSource.json[j]) === JSON.stringify(selectedRecords[i])) {\n          selectedIndexes[i] = j - skip;\n          break;\n        }\n      }\n    }\n\n    this.selectedRowColls = selectedIndexes;\n  }\n\n  stopTimer() {\n    window.clearInterval(this.timer);\n  }\n\n  initializeDrag() {\n    const gObj = this.parent;\n    this.draggable = new Draggable(gObj.element, {\n      dragTarget: '.e-rowcelldrag, .e-rowdragdrop, .e-rowcell',\n      distance: 5,\n      helper: this.helper,\n      dragStart: this.dragStart,\n      drag: this.drag,\n      dragStop: this.dragStop,\n      isReplaceDragEle: this.isReplaceDragEle\n    });\n  }\n\n  updateScrollPostion(e) {\n    const y = getPosition(e).y;\n    const cliRect = this.isDropGrid.getContent().getBoundingClientRect();\n    const rowHeight = this.isDropGrid.getRowHeight() - 15;\n    const scrollElem = this.isDropGrid.getContent().firstElementChild;\n    const virtualScrollbtm = this.parent.enableVirtualization ? 20 : 0;\n\n    if (cliRect.top >= y) {\n      const scrollPixel = -this.isDropGrid.getRowHeight();\n      this.isOverflowBorder = false;\n      this.timer = window.setInterval(() => {\n        this.setScrollDown(scrollElem, scrollPixel);\n      }, 200);\n    } else if (cliRect.top + this.isDropGrid.getContent().clientHeight - rowHeight - 33 - virtualScrollbtm <= y) {\n      const scrollPixel = this.isDropGrid.getRowHeight();\n      this.isOverflowBorder = false;\n      this.timer = window.setInterval(() => {\n        this.setScrollDown(scrollElem, scrollPixel);\n      }, 200);\n    }\n  }\n\n  setScrollDown(scrollElem, scrollPixel) {\n    scrollElem.scrollTop = scrollElem.scrollTop + scrollPixel;\n  }\n\n  moveDragRows(e, startedRow, targetRow) {\n    const cloneElement = this.parent.element.querySelector('.e-cloneproperties');\n    const element = closest(e.target, 'tr');\n\n    if (parentsUntil(element, 'e-grid') && (parentsUntil(cloneElement.parentElement, 'e-grid').id === parentsUntil(element, 'e-grid').id || this.istargetGrid)) {\n      const targetElement = element ? element : this.startedRow;\n      this.setBorder(targetElement, e.event, startedRow, targetRow);\n    }\n  }\n\n  setBorder(element, event, startedRow, targetRow) {\n    let node = this.parent.element;\n\n    if (this.istargetGrid) {\n      node = this.isDropGrid.element;\n    }\n\n    const cloneElement = this.parent.element.querySelector('.e-cloneproperties');\n    this.removeFirstRowBorder(element);\n    this.removeLastRowBorder(element);\n\n    if (parentsUntil(element, 'e-grid') && element.classList.contains(row) && (!this.parent.rowDropSettings.targetID && parentsUntil(cloneElement.parentElement, 'e-grid').id === parentsUntil(element, 'e-grid').id || this.istargetGrid)) {\n      removeClass(node.querySelectorAll('.e-rowcell,.e-rowdragdrop,.e-detailrowcollapse'), ['e-dragborder']);\n      let rowElement = [];\n      const targetRowIndex = parseInt(targetRow.getAttribute(ariaRowIndex), 10);\n\n      if (targetRow && targetRowIndex === 0) {\n        const div = this.parent.createElement('div', {\n          className: 'e-firstrow-dragborder'\n        });\n        const gridheaderEle = this.isDropGrid.getHeaderContent();\n        gridheaderEle.classList.add('e-grid-relative');\n        div.style.width = node.offsetWidth - this.getScrollWidth() + 'px';\n\n        if (!gridheaderEle.getElementsByClassName('e-firstrow-dragborder').length) {\n          gridheaderEle.appendChild(div);\n        }\n      } else if (this.parent.rowDropSettings.targetID && targetRow) {\n        element = this.isDropGrid.getRowByIndex(targetRowIndex - 1);\n        rowElement = [].slice.call(element.querySelectorAll('.e-rowcell,.e-rowdragdrop,.e-detailrowcollapse'));\n      } else if (targetRow && parseInt(startedRow.getAttribute(ariaRowIndex), 10) > targetRowIndex) {\n        element = this.parent.getRowByIndex(targetRowIndex - 1);\n        rowElement = [].slice.call(element.querySelectorAll('.e-rowcell,.e-rowdragdrop,.e-detailrowcollapse'));\n      } else {\n        rowElement = [].slice.call(element.querySelectorAll('.e-rowcell,.e-rowdragdrop,.e-detailrowcollapse'));\n      }\n\n      const frzCols = this.parent.isFrozenGrid();\n\n      if (targetRow && targetRowIndex !== 0 && frzCols) {\n        const rowIndex = parseInt(element.getAttribute(ariaRowIndex), 10);\n        const selector = '.e-rowcell,.e-rowdragdrop,.e-detailrowcollapse';\n        rowElement = this.borderRowElement(rowIndex, selector);\n      }\n\n      if (rowElement.length > 0) {\n        addRemoveActiveClasses(rowElement, true, 'e-dragborder');\n      }\n    }\n  }\n\n  borderRowElement(rowIndex, selector) {\n    let lastRow = [];\n    lastRow = [].slice.call(this.isDropGrid.getRowByIndex(rowIndex).querySelectorAll(selector)).concat([].slice.call(this.isDropGrid.getMovableRowByIndex(rowIndex).querySelectorAll(selector)));\n\n    if (this.isDropGrid.getFrozenMode() === leftRight) {\n      lastRow = lastRow.concat([].slice.call(this.isDropGrid.getFrozenRightRowByIndex(rowIndex).querySelectorAll(selector)));\n    }\n\n    return lastRow;\n  }\n\n  getScrollWidth() {\n    const scrollElem = this.parent.getContent().firstElementChild;\n    return scrollElem.scrollWidth > scrollElem.offsetWidth ? Scroll.getScrollBarWidth() : 0;\n  }\n\n  removeFirstRowBorder(element) {\n    if (this.isDropGrid.element.getElementsByClassName('e-firstrow-dragborder').length > 0 && element && element.rowIndex !== 0) {\n      remove(this.isDropGrid.element.getElementsByClassName('e-firstrow-dragborder')[0]);\n    }\n  }\n\n  removeLastRowBorder(element) {\n    let islastRowIndex;\n\n    if (this.parent.enableVirtualization) {\n      islastRowIndex = element && parseInt(element.getAttribute(ariaRowIndex), 10) !== this.parent.renderModule.data.dataManager.dataSource.json.length - 1;\n    } else {\n      islastRowIndex = element && this.parent.getRowByIndex(this.parent.getCurrentViewRecords().length - 1).getAttribute('data-uid') !== element.getAttribute('data-uid');\n    }\n\n    if (this.parent.element.getElementsByClassName('e-lastrow-dragborder').length > 0 && element && islastRowIndex) {\n      remove(this.parent.element.getElementsByClassName('e-lastrow-dragborder')[0]);\n    }\n  }\n\n  removeBorder(element) {\n    this.removeFirstRowBorder(element);\n\n    if (!this.parent.rowDropSettings.targetID) {\n      this.removeLastRowBorder(element);\n    }\n\n    element = (this.isDropGrid.isFrozenGrid() ? this.isDropGrid.getMovableRows() : this.isDropGrid.getRows()).filter(row$$1 => row$$1.querySelector('td.e-dragborder'))[0];\n\n    if (element) {\n      let rowElement = [].slice.call(element.getElementsByClassName('e-dragborder'));\n\n      if (this.parent.isFrozenGrid()) {\n        const rowIndex = parseInt(element.getAttribute(ariaRowIndex), 10);\n        const selector = '.e-dragborder';\n        rowElement = this.borderRowElement(rowIndex, selector);\n      }\n\n      addRemoveActiveClasses(rowElement, false, 'e-dragborder');\n    }\n  }\n\n  getElementFromPosition(element, event) {\n    const position = getPosition(event);\n    element.style.display = 'none';\n    const target = document.elementFromPoint(position.x, position.y);\n    element.style.display = '';\n    return target;\n  }\n\n  onDataBound() {\n    if (this.selectedRowColls.length > 0 && this.parent.enableVirtualization) {\n      this.parent.selectRows(this.selectedRowColls);\n      this.selectedRowColls = [];\n    }\n  }\n\n  getTargetIdx(targetRow) {\n    return targetRow ? parseInt(targetRow.getAttribute(ariaRowIndex), 10) : 0;\n  }\n\n  singleRowDrop(e) {\n    const targetRow = closest(e.target, 'tr');\n    const srcControl = e.droppedElement.parentElement.ej2_instances[0];\n    const currentIndex = targetRow ? targetRow.rowIndex : srcControl.currentViewData.length - 1;\n    this.reorderRow(this.startedRowIndex, currentIndex);\n  }\n\n  columnDrop(e) {\n    const gObj = this.parent;\n\n    if (e.droppedElement.getAttribute('action') !== 'grouping' && (parentsUntil(e.target, row) || parentsUntil(e.target, 'e-emptyrow') || parentsUntil(e.target, gridContent))) {\n      const targetRow = closest(e.target, 'tr');\n      let srcControl;\n      let currentIndex;\n\n      if (e.droppedElement.querySelector('tr').getAttribute('single-dragrow') !== 'true' && e.droppedElement.parentElement.id === gObj.element.id || e.droppedElement.querySelector('tr').getAttribute('single-dragrow') === 'true' && e.droppedElement.parentElement.id !== gObj.element.id) {\n        return;\n      }\n\n      if (e.droppedElement.parentElement.id !== gObj.element.id) {\n        srcControl = e.droppedElement.parentElement.ej2_instances[0];\n      } else if (this.isSingleRowDragDrop || e.droppedElement.querySelector('tr').getAttribute('single-dragrow') === 'true') {\n        this.singleRowDrop(e);\n        return;\n      }\n\n      if (srcControl.element.id !== gObj.element.id && srcControl.rowDropSettings.targetID !== gObj.element.id) {\n        return;\n      }\n\n      const records = srcControl.getSelectedRecords();\n      let targetIndex = currentIndex = this.getTargetIdx(targetRow);\n\n      if (isNaN(targetIndex)) {\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n        targetIndex = currentIndex = 0;\n      }\n\n      if (gObj.allowPaging) {\n        targetIndex = targetIndex + gObj.pageSettings.currentPage * gObj.pageSettings.pageSize - gObj.pageSettings.pageSize;\n      } //Todo: drag and drop mapper & BatchChanges\n\n\n      gObj.notify(rowsAdded, {\n        toIndex: targetIndex,\n        records: records\n      });\n      gObj.notify(modelChanged, {\n        type: actionBegin,\n        requestType: 'rowdraganddrop'\n      });\n      const selectedRows = srcControl.getSelectedRowIndexes();\n      const skip = srcControl.allowPaging ? srcControl.pageSettings.currentPage * srcControl.pageSettings.pageSize - srcControl.pageSettings.pageSize : 0;\n      this.selectedRows = [];\n\n      for (let i = 0, len = records.length; i < len; i++) {\n        this.selectedRows.push(skip + selectedRows[i]);\n      }\n\n      srcControl.notify(rowsRemoved, {\n        indexes: this.selectedRows,\n        records: records\n      });\n      srcControl.notify(modelChanged, {\n        type: actionBegin,\n        requestType: 'rowdraganddrop'\n      });\n    }\n  }\n\n  reorderRow(fromIndexes, toIndex) {\n    const gObj = this.parent;\n\n    if (!gObj.sortSettings.columns.length && !gObj.groupSettings.columns.length && !gObj.filterSettings.columns.length) {\n      //Todo: drag and drop mapper & BatchChanges\n      const skip = gObj.allowPaging ? gObj.pageSettings.currentPage * gObj.pageSettings.pageSize - gObj.pageSettings.pageSize : 0; // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n      toIndex = toIndex + skip;\n      this.selectedRows = gObj.getSelectedRowIndexes();\n      gObj.notify(rowPositionChanged, {\n        fromIndex: fromIndexes + skip,\n        toIndex: toIndex\n      });\n    }\n  }\n\n  enableAfterRender(e) {\n    if (e.module === this.getModuleName() && e.enable) {\n      this.initializeDrag();\n    }\n  }\n  /**\n   * To destroy the print\n   *\n   * @returns {void}\n   * @hidden\n   */\n\n\n  destroy() {\n    const gridElement = this.parent.element;\n\n    if (this.parent.isDestroyed || !gridElement || !gridElement.querySelector('.' + gridHeader) && !gridElement.querySelector('.' + gridContent)) {\n      return;\n    }\n\n    this.draggable.destroy();\n    this.parent.off(initialEnd, this.initializeDrag);\n    this.parent.off(columnDrop, this.columnDrop);\n    this.parent.removeEventListener(dataBound, this.onDataBoundFn);\n    this.parent.off(uiUpdate, this.enableAfterRender);\n    this.parent.off(destroy, this.destroy); //destory ejdrag and drop\n  }\n  /**\n   * For internal use only - Get the module name.\n   *\n   * @returns {string} returns the module name\n   * @private\n   */\n\n\n  getModuleName() {\n    return 'rowDragAndDrop';\n  } // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  processArgs(target) {\n    const gObj = this.parent;\n    const dragIdx = parseInt(this.startedRow.getAttribute(ariaRowIndex), 10);\n\n    if (gObj.getSelectedRecords().length > 0 && this.startedRow.cells[0].classList.contains('e-selectionbackground') === false || gObj.getSelectedRecords().length === 0) {\n      if (this.parent.enableVirtualization) {\n        this.rows = [this.startedRow];\n      } else {\n        this.rows = [this.parent.getRowByIndex(dragIdx)];\n\n        if (gObj.isFrozenGrid()) {\n          this.rows = [gObj.getRowByIndex(dragIdx), gObj.getMovableRowByIndex(dragIdx)];\n\n          if (gObj.getFrozenMode() === leftRight) {\n            this.rows = [gObj.getRowByIndex(dragIdx), gObj.getMovableRowByIndex(dragIdx), gObj.getFrozenRightRowByIndex(dragIdx)];\n          }\n        }\n      }\n\n      this.rowData = [this.parent.getRowInfo(this.startedRow.querySelector('.' + rowCell)).rowData];\n    } else {\n      this.rows = gObj.getSelectedRows();\n      this.rowData = gObj.getSelectedRecords();\n    }\n  }\n\n} // eslint-disable-next-line valid-jsdoc\n\n/**\n *\n * The `Group` module is used to handle group action.\n */\n\n\nclass Group {\n  /**\n   * Constructor for Grid group module\n   *\n   * @param {IGrid} parent - specifies the IGrid\n   * @param {GroupSettingsModel} groupSettings - specifies the GroupSettingsModel\n   * @param {string[]} sortedColumns - specifies the sortedColumns\n   * @param {ServiceLocator} serviceLocator - specifies the serviceLocator\n   * @hidden\n   */\n  constructor(parent, groupSettings, sortedColumns, serviceLocator) {\n    //Internal variables\n    this.sortRequired = true;\n    this.isAppliedGroup = false;\n    this.isAppliedUnGroup = false;\n    this.reorderingColumns = [];\n    this.visualElement = createElement('div', {\n      className: 'e-cloneproperties e-dragclone e-gdclone',\n      styles: 'line-height:23px',\n      attrs: {\n        action: 'grouping'\n      }\n    });\n\n    this.helper = e => {\n      const gObj = this.parent;\n      const target = e.sender.target;\n      const element = target.classList.contains('e-groupheadercell') ? target : parentsUntil(target, 'e-groupheadercell');\n\n      if (!element || !target.classList.contains('e-drag') && this.groupSettings.allowReordering) {\n        return false;\n      }\n\n      this.column = gObj.getColumnByField(element.firstElementChild.getAttribute('ej-mappingname'));\n      this.visualElement.textContent = element.textContent;\n      this.visualElement.style.width = element.offsetWidth + 2 + 'px';\n      this.visualElement.style.height = element.offsetHeight + 2 + 'px';\n      this.visualElement.setAttribute('e-mappinguid', this.column.uid);\n      gObj.element.appendChild(this.visualElement);\n      return this.visualElement;\n    }; // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n    this.dragStart = e => {\n      this.parent.element.classList.add('e-ungroupdrag');\n    };\n\n    this.drag = e => {\n      if (this.groupSettings.allowReordering) {\n        this.animateDropper(e);\n      }\n\n      const target = e.target;\n      const cloneElement = this.parent.element.querySelector('.e-cloneproperties');\n      this.parent.trigger(columnDrag, {\n        target: target,\n        draggableType: 'headercell',\n        column: this.column\n      });\n\n      if (!this.groupSettings.allowReordering) {\n        classList(cloneElement, ['e-defaultcur'], ['e-notallowedcur']);\n\n        if (!(parentsUntil(target, gridContent) || parentsUntil(target, 'e-headercell'))) {\n          classList(cloneElement, ['e-notallowedcur'], ['e-defaultcur']);\n        }\n      }\n    };\n\n    this.dragStop = e => {\n      this.parent.element.classList.remove('e-ungroupdrag');\n      const preventDrop = !(parentsUntil(e.target, gridContent) || parentsUntil(e.target, 'e-gridheader'));\n\n      if (this.groupSettings.allowReordering && preventDrop) {\n        remove(e.helper);\n\n        if (parentsUntil(e.target, 'e-groupdroparea')) {\n          this.rearrangeGroup();\n        } else if (!parentsUntil(e.target, 'e-grid')) {\n          const field = this.parent.getColumnByUid(e.helper.getAttribute('e-mappinguid')).field;\n\n          if (this.groupSettings.columns.indexOf(field) !== -1) {\n            this.ungroupColumn(field);\n          }\n        }\n\n        return;\n      } else if (preventDrop) {\n        remove(e.helper);\n        return;\n      }\n    };\n\n    this.animateDropper = e => {\n      const uid = this.parent.element.querySelector('.e-cloneproperties').getAttribute('e-mappinguid');\n      const dragField = this.parent.getColumnByUid(uid).field;\n      const parent = parentsUntil(e.target, 'e-groupdroparea');\n      const dropTarget = parentsUntil(e.target, 'e-group-animator');\n      const grouped = [].slice.call(this.element.getElementsByClassName('e-groupheadercell')).map(e => e.querySelector('div').getAttribute('ej-mappingname'));\n      const cols = JSON.parse(JSON.stringify(grouped));\n\n      if (dropTarget || parent) {\n        if (dropTarget) {\n          const dropField = dropTarget.querySelector('div[ej-mappingname]').getAttribute('ej-mappingname');\n          const dropIndex = +dropTarget.getAttribute('index');\n\n          if (dropField !== dragField) {\n            const dragIndex = cols.indexOf(dragField);\n\n            if (dragIndex !== -1) {\n              cols.splice(dragIndex, 1);\n            }\n\n            const flag = dropIndex !== -1 && dragIndex === dropIndex;\n            cols.splice(dropIndex + (flag ? 1 : 0), 0, dragField);\n          }\n        } else if (parent && cols.indexOf(dragField) === -1) {\n          cols.push(dragField);\n        }\n\n        this.element.innerHTML = '';\n\n        if (cols.length && !this.element.classList.contains('e-grouped')) {\n          this.element.classList.add('e-grouped');\n        }\n\n        this.reorderingColumns = cols;\n\n        for (let c = 0; c < cols.length; c++) {\n          this.addColToGroupDrop(cols[c]);\n        }\n      } else {\n        this.addLabel();\n        this.removeColFromGroupDrop(dragField);\n      }\n    };\n\n    this.drop = e => {\n      const gObj = this.parent;\n      const column = gObj.getColumnByUid(e.droppedElement.getAttribute('e-mappinguid'));\n      this.element.classList.remove('e-hover');\n      remove(e.droppedElement);\n      this.aria.setDropTarget(this.parent.element.querySelector('.e-groupdroparea'), false);\n      this.aria.setGrabbed(this.parent.getHeaderTable().querySelector('[aria-grabbed=true]'), false);\n\n      if (isNullOrUndefined(column) || column.allowGrouping === false || parentsUntil(gObj.getColumnHeaderByUid(column.uid), 'e-grid').getAttribute('id') !== gObj.element.getAttribute('id')) {\n        this.parent.log('action_disabled_column', {\n          moduleName: this.getModuleName(),\n          columnName: column.headerText\n        });\n        return;\n      }\n\n      this.groupColumn(column.field);\n    };\n\n    this.contentRefresh = true;\n    this.aria = new AriaService();\n    this.parent = parent;\n    this.groupSettings = groupSettings;\n    this.serviceLocator = serviceLocator;\n    this.sortedColumns = sortedColumns;\n    this.focus = serviceLocator.getService('focus');\n    this.addEventListener();\n    this.groupGenerator = new GroupModelGenerator(this.parent);\n  }\n\n  addLabel() {\n    if (!this.element.getElementsByClassName('e-group-animator').length) {\n      const dragLabel = this.l10n.getConstant('GroupDropArea');\n      this.element.innerHTML = dragLabel;\n      this.element.classList.remove('e-grouped');\n    }\n  }\n\n  rearrangeGroup() {\n    this.sortRequired = false;\n    this.updateModel();\n  }\n\n  columnDrag(e) {\n    if (this.groupSettings.allowReordering && e.column.allowGrouping) {\n      this.animateDropper(e);\n    }\n\n    const cloneElement = this.parent.element.querySelector('.e-cloneproperties');\n    classList(cloneElement, ['e-defaultcur'], ['e-notallowedcur']);\n\n    if (!parentsUntil(e.target, 'e-groupdroparea') && !(this.parent.allowReordering && parentsUntil(e.target, 'e-headercell'))) {\n      classList(cloneElement, ['e-notallowedcur'], ['e-defaultcur']);\n    }\n\n    if (e.target.classList.contains('e-groupdroparea')) {\n      this.element.classList.add('e-hover');\n    } else {\n      this.element.classList.remove('e-hover');\n    }\n  }\n\n  columnDragStart(e) {\n    if (e.target.classList.contains('e-stackedheadercell')) {\n      return;\n    }\n\n    const dropArea = this.parent.element.querySelector('.e-groupdroparea');\n    this.aria.setDropTarget(dropArea, e.column.allowGrouping);\n    const element = e.target.classList.contains('e-headercell') ? e.target : parentsUntil(e.target, 'e-headercell');\n    this.aria.setGrabbed(element, true, !e.column.allowGrouping);\n  }\n\n  columnDrop(e) {\n    const gObj = this.parent;\n\n    if (e.droppedElement.getAttribute('action') === 'grouping') {\n      const column = gObj.getColumnByUid(e.droppedElement.getAttribute('e-mappinguid'));\n\n      if (isNullOrUndefined(column) || column.allowGrouping === false || parentsUntil(gObj.getColumnHeaderByUid(column.uid), 'e-grid').getAttribute('id') !== gObj.element.getAttribute('id')) {\n        return;\n      }\n\n      this.ungroupColumn(column.field);\n    }\n  }\n  /**\n   * @returns {void}\n   * @hidden\n   */\n\n\n  addEventListener() {\n    if (this.parent.isDestroyed) {\n      return;\n    }\n\n    this.parent.on(uiUpdate, this.enableAfterRender, this);\n    this.parent.on(groupComplete, this.onActionComplete, this);\n    this.parent.on(ungroupComplete, this.onActionComplete, this);\n    this.parent.on(inBoundModelChanged, this.onPropertyChanged, this);\n    this.parent.on(click, this.clickHandler, this);\n    this.parent.on(columnDrag, this.columnDrag, this);\n    this.parent.on(columnDragStart, this.columnDragStart, this);\n    this.parent.on(headerDrop, this.columnDrop, this);\n    this.parent.on(columnDrop, this.columnDrop, this);\n    this.parent.on(headerRefreshed, this.refreshSortIcons, this);\n    this.parent.on(sortComplete, this.refreshSortIcons, this);\n    this.parent.on(keyPressed, this.keyPressHandler, this);\n    this.parent.on(contentReady, this.initialEnd, this);\n    this.parent.on(onEmpty, this.initialEnd, this);\n    this.parent.on(initialEnd, this.render, this);\n    this.parent.on(groupAggregates, this.onGroupAggregates, this);\n    this.parent.on(destroy, this.destroy, this);\n    this.parent.on('group-expand-collapse', this.updateExpand, this);\n    this.parent.on('persist-data-changed', this.initialEnd, this);\n  }\n  /**\n   * @returns {void}\n   * @hidden\n   */\n\n\n  removeEventListener() {\n    if (this.parent.isDestroyed) {\n      return;\n    }\n\n    this.parent.off(initialEnd, this.render);\n    this.parent.off(uiUpdate, this.enableAfterRender);\n    this.parent.off(groupComplete, this.onActionComplete);\n    this.parent.off(ungroupComplete, this.onActionComplete);\n    this.parent.off(inBoundModelChanged, this.onPropertyChanged);\n    this.parent.off(click, this.clickHandler);\n    this.parent.off(columnDrag, this.columnDrag);\n    this.parent.off(columnDragStart, this.columnDragStart);\n    this.parent.off(columnDrop, this.columnDrop);\n    this.parent.off(headerDrop, this.columnDrop);\n    this.parent.off(headerRefreshed, this.refreshSortIcons);\n    this.parent.off(sortComplete, this.refreshSortIcons);\n    this.parent.off(keyPressed, this.keyPressHandler);\n    this.parent.off(groupAggregates, this.onGroupAggregates);\n    this.parent.off(destroy, this.destroy);\n    this.parent.off('group-expand-collapse', this.updateExpand);\n  }\n\n  initialEnd() {\n    const gObj = this.parent;\n    this.parent.off(contentReady, this.initialEnd);\n    this.parent.off(onEmpty, this.initialEnd);\n\n    if (this.parent.getColumns().length && this.groupSettings.columns.length) {\n      this.contentRefresh = false;\n\n      for (const col of gObj.groupSettings.columns) {\n        this.groupColumn(col);\n      }\n\n      this.contentRefresh = true;\n    }\n  }\n\n  keyPressHandler(e) {\n    const gObj = this.parent;\n\n    if (e.action !== 'ctrlSpace' && (!this.groupSettings.columns.length || ['altDownArrow', 'altUpArrow', 'ctrlDownArrow', 'ctrlUpArrow', 'enter'].indexOf(e.action) === -1)) {\n      return;\n    }\n\n    e.preventDefault();\n\n    switch (e.action) {\n      case 'altDownArrow':\n      case 'altUpArrow':\n        // eslint-disable-next-line no-case-declarations\n        const selected = gObj.allowSelection ? gObj.getSelectedRowIndexes() : [];\n\n        if (selected.length) {\n          const rows = gObj.getContentTable().querySelector(tbody).children;\n          const dataRow = gObj.getDataRows()[selected[selected.length - 1]];\n          let grpRow;\n\n          for (let i = dataRow.rowIndex; i >= 0; i--) {\n            if (!rows[i].classList.contains(row) && !rows[i].classList.contains('e-detailrow')) {\n              grpRow = rows[i];\n              break;\n            }\n          }\n\n          this.expandCollapseRows(grpRow.querySelector(e.action === 'altUpArrow' ? '.e-recordplusexpand' : '.e-recordpluscollapse'));\n        }\n\n        break;\n\n      case 'ctrlDownArrow':\n        this.expandAll();\n        break;\n\n      case 'ctrlUpArrow':\n        this.collapseAll();\n        break;\n\n      case 'enter':\n        if (this.parent.isEdit || closest(e.target, '#' + this.parent.element.id + '_searchbar') !== null) {\n          return;\n        } // eslint-disable-next-line no-case-declarations\n\n\n        const element = this.focus.getFocusedElement(); // eslint-disable-next-line no-case-declarations\n\n        const row$$1 = element ? element.parentElement.querySelector('[class^=\"e-record\"]') : null;\n\n        if (!row$$1) {\n          break;\n        }\n\n        this.expandCollapseRows(row$$1);\n        break;\n\n      case 'ctrlSpace':\n        // eslint-disable-next-line no-case-declarations\n        const elem = gObj.focusModule.currentInfo.element;\n\n        if (elem && elem.classList.contains('e-headercell')) {\n          const column = gObj.getColumnByUid(elem.firstElementChild.getAttribute('e-mappinguid'));\n\n          if (column.field && gObj.groupSettings.columns.indexOf(column.field) < 0) {\n            this.groupColumn(column.field);\n          } else {\n            this.ungroupColumn(column.field);\n          }\n        }\n\n        break;\n    }\n  }\n\n  clickHandler(e) {\n    this.expandCollapseRows(e.target);\n    this.applySortFromTarget(e.target);\n    this.unGroupFromTarget(e.target);\n    this.toogleGroupFromHeader(e.target);\n  }\n\n  unGroupFromTarget(target) {\n    if (target.classList.contains('e-ungroupbutton')) {\n      this.ungroupColumn(target.parentElement.getAttribute('ej-mappingname'));\n    }\n  }\n\n  toogleGroupFromHeader(target) {\n    if (this.groupSettings.showToggleButton) {\n      if (target.classList.contains('e-grptogglebtn')) {\n        if (target.classList.contains('e-toggleungroup')) {\n          this.ungroupColumn(this.parent.getColumnByUid(target.parentElement.getAttribute('e-mappinguid')).field);\n        } else {\n          this.groupColumn(this.parent.getColumnByUid(target.parentElement.getAttribute('e-mappinguid')).field);\n        }\n      } else {\n        if (target.classList.contains('e-toggleungroup')) {\n          this.ungroupColumn(target.parentElement.getAttribute('ej-mappingname'));\n        }\n      }\n    }\n  }\n\n  applySortFromTarget(target) {\n    const gObj = this.parent;\n    const gHeader = closest(target, '.e-groupheadercell');\n\n    if (gObj.allowSorting && gHeader && !target.classList.contains('e-ungroupbutton') && !target.classList.contains('e-toggleungroup')) {\n      const field = gHeader.firstElementChild.getAttribute('ej-mappingname');\n\n      if (gObj.getColumnHeaderByField(field).getElementsByClassName('e-ascending').length) {\n        gObj.sortColumn(field, 'Descending', true);\n      } else {\n        gObj.sortColumn(field, 'Ascending', true);\n      }\n    }\n  }\n  /**\n   * Expands or collapses grouped rows by target element.\n   *\n   * @param  {Element} target - Defines the target element of the grouped row.\n   * @returns {void}\n   */\n\n\n  expandCollapseRows(target) {\n    const trgt = parentsUntil(target, 'e-recordplusexpand') || parentsUntil(target, 'e-recordpluscollapse');\n\n    if (trgt) {\n      const rowNodes = this.parent.getContentTable().querySelector(tbody).children;\n      let isHide;\n      let dataManager;\n      let query;\n      const gObj = this.parent;\n      const indent = trgt.parentElement.getElementsByClassName('e-indentcell').length;\n      const uid = trgt.parentElement.getAttribute('data-uid');\n      const captionRow = gObj.getRowObjectFromUID(uid);\n      let expand = false;\n\n      if (trgt.classList.contains('e-recordpluscollapse')) {\n        addClass([trgt], 'e-recordplusexpand');\n        removeClass([trgt], 'e-recordpluscollapse');\n        trgt.firstElementChild.className = 'e-icons e-gdiagonaldown e-icon-gdownarrow';\n        expand = true;\n        captionRow.isExpand = true;\n\n        if (isGroupAdaptive(gObj)) {\n          this.updateVirtualRows(gObj, target, expand, query, dataManager);\n        }\n\n        if (this.parent.groupSettings.enableLazyLoading) {\n          this.parent.contentModule.captionExpand(trgt.parentElement);\n        }\n      } else {\n        isHide = true;\n        captionRow.isExpand = false;\n        removeClass([trgt], 'e-recordplusexpand');\n        addClass([trgt], 'e-recordpluscollapse');\n        trgt.firstElementChild.className = 'e-icons e-gnextforward e-icon-grightarrow';\n\n        if (isGroupAdaptive(gObj)) {\n          this.updateVirtualRows(gObj, target, !isHide, query, dataManager);\n        }\n\n        if (this.parent.groupSettings.enableLazyLoading) {\n          this.parent.contentModule.captionCollapse(trgt.parentElement);\n        }\n      }\n\n      this.aria.setExpand(trgt, expand);\n\n      if (!isGroupAdaptive(gObj) && !this.parent.groupSettings.enableLazyLoading) {\n        const rowObjs = gObj.getRowsObject();\n        const startIdx = rowObjs.indexOf(captionRow);\n        const rowsState = {};\n\n        for (let i = startIdx; i < rowObjs.length; i++) {\n          if (i > startIdx && rowObjs[i].indent === indent) {\n            break;\n          }\n\n          if (rowObjs[i].isDetailRow) {\n            const visible = rowObjs[i - 1].isExpand && rowObjs[i - 1].visible;\n            rowNodes[i].style.display = visible ? '' : 'none';\n          } else if (rowsState[rowObjs[i].parentUid] === false) {\n            rowObjs[i].visible = false;\n            rowNodes[i].style.display = 'none';\n          } else {\n            if (!(rowObjs[i].isDataRow || rowObjs[i].isCaptionRow || rowObjs[i].isDetailRow)) {\n              const visible = rowObjs[i].cells.some(cell => cell.isDataCell && cell.visible);\n\n              if (visible === rowObjs[i].visible) {\n                continue;\n              }\n            }\n\n            rowObjs[i].visible = true;\n            rowNodes[i].style.display = '';\n            rowNodes[i].classList.remove('e-hide');\n          }\n\n          if (rowObjs[i].isCaptionRow) {\n            rowsState[rowObjs[i].uid] = rowObjs[i].isExpand && rowObjs[i].visible;\n          }\n        }\n\n        this.parent.notify(refreshExpandandCollapse, {\n          rows: this.parent.getRowsObject()\n        });\n      }\n\n      this.parent.notify(captionActionComplete, {\n        isCollapse: isHide,\n        parentUid: uid\n      });\n    }\n  }\n\n  updateVirtualRows(gObj, target, isExpand, query, dataManager) {\n    const rObj = gObj.getRowObjectFromUID(target.closest('tr').getAttribute('data-uid'));\n    rObj.isExpand = isExpand;\n    updatecloneRow(gObj);\n    this.parent.notify(refreshVirtualMaxPage, {});\n    query = gObj.getDataModule().generateQuery(false);\n    query.queries = gObj.getDataModule().aggregateQuery(gObj.getQuery().clone()).queries;\n    const args = {\n      requestType: 'virtualscroll',\n      rowObject: rObj\n    };\n\n    if (gObj.contentModule) {\n      args.virtualInfo = gObj.contentModule.prevInfo;\n    }\n\n    dataManager = gObj.getDataModule().getData(args, query.requiresCount());\n    dataManager.then(e => gObj.renderModule.dataManagerSuccess(e, args));\n  }\n\n  expandCollapse(isExpand) {\n    if (!isExpand) {\n      this.parent.notify(initialCollapse, isExpand);\n    }\n\n    const rowNodes = this.parent.getContentTable().querySelector(tbody).children;\n    const rowObjs = this.parent.getRowsObject();\n    let row$$1;\n\n    for (let i = 0, len = rowNodes.length; i < len; i++) {\n      if (rowNodes[i].querySelectorAll('.e-recordplusexpand, .e-recordpluscollapse').length) {\n        row$$1 = rowNodes[i].querySelector(isExpand ? '.e-recordpluscollapse' : '.e-recordplusexpand');\n\n        if (row$$1) {\n          row$$1.className = isExpand ? 'e-recordplusexpand' : 'e-recordpluscollapse';\n          row$$1.firstElementChild.className = isExpand ? 'e-icons e-gdiagonaldown e-icon-gdownarrow' : 'e-icons e-gnextforward e-icon-grightarrow';\n        }\n\n        if (!(rowNodes[i].firstElementChild.classList.contains('e-recordplusexpand') || rowNodes[i].firstElementChild.classList.contains('e-recordpluscollapse'))) {\n          rowNodes[i].style.display = isExpand ? '' : 'none';\n        }\n      } else {\n        rowNodes[i].style.display = isExpand ? '' : 'none';\n      }\n\n      if (rowObjs[i].isCaptionRow) {\n        rowObjs[i].isExpand = isExpand ? true : false;\n      }\n    }\n\n    this.parent.updateVisibleExpandCollapseRows();\n    this.parent.notify(refreshExpandandCollapse, {\n      rows: this.parent.getRowsObject()\n    });\n  }\n  /**\n   * Expands all the grouped rows of the Grid.\n   *\n   * @returns {void}\n   */\n\n\n  expandAll() {\n    this.expandCollapse(true);\n  }\n  /**\n   * Collapses all the grouped rows of the Grid.\n   *\n   * @returns {void}\n   */\n\n\n  collapseAll() {\n    this.expandCollapse(false);\n  }\n  /**\n   * The function is used to render grouping\n   *\n   * @returns {void}\n   * @hidden\n   */\n\n\n  render() {\n    this.l10n = this.serviceLocator.getService('localization');\n    this.renderGroupDropArea();\n    this.initDragAndDrop();\n    this.refreshToggleBtn();\n  }\n\n  renderGroupDropArea() {\n    const groupElem = this.parent.element.querySelector('.e-groupdroparea');\n\n    if (groupElem) {\n      remove(groupElem);\n    }\n\n    this.element = this.parent.createElement('div', {\n      className: 'e-groupdroparea',\n      attrs: {\n        'tabindex': '-1'\n      }\n    });\n\n    if (this.groupSettings.allowReordering) {\n      this.element.classList.add('e-group-animate');\n    }\n\n    this.updateGroupDropArea();\n    this.parent.element.insertBefore(this.element, this.parent.element.firstChild);\n\n    if (!this.groupSettings.showDropArea) {\n      this.element.style.display = 'none';\n    }\n  }\n\n  updateGroupDropArea(clear) {\n    if (this.groupSettings.showDropArea && !this.groupSettings.columns.length) {\n      const dragLabel = this.l10n.getConstant('GroupDropArea');\n      this.element.innerHTML = dragLabel;\n      this.element.classList.remove('e-grouped');\n    } else {\n      if (this.element.innerHTML === this.l10n.getConstant('GroupDropArea') && (this.groupSettings.columns.length === 1 || !this.isAppliedGroup && !this.isAppliedUnGroup) || clear) {\n        this.element.innerHTML = '';\n      }\n\n      this.element.classList.add('e-grouped');\n    }\n  }\n\n  initDragAndDrop() {\n    this.initializeGHeaderDrop();\n    this.initializeGHeaderDrag();\n  }\n\n  initializeGHeaderDrag() {\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    const drag = new Draggable(this.element, {\n      dragTarget: this.groupSettings.allowReordering ? '.e-drag' : '.e-groupheadercell',\n      distance: this.groupSettings.allowReordering ? -10 : 5,\n      helper: this.helper,\n      dragStart: this.dragStart,\n      drag: this.drag,\n      dragStop: this.dragStop\n    });\n  }\n\n  initializeGHeaderDrop() {\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    const drop = new Droppable(this.element, {\n      accept: '.e-dragclone',\n      drop: this.drop\n    });\n  }\n  /**\n   * Groups a column by column name.\n   *\n   * @param  {string} columnName - Defines the column name to group.\n   * @returns {void}\n   */\n\n\n  groupColumn(columnName) {\n    const gObj = this.parent;\n    const column = gObj.getColumnByField(columnName);\n\n    if (isNullOrUndefined(column) || column.allowGrouping === false || this.contentRefresh && this.groupSettings.columns.indexOf(columnName) > -1) {\n      this.parent.log('action_disabled_column', {\n        moduleName: this.getModuleName(),\n        columnName: column.headerText\n      });\n      return;\n    }\n\n    if (isActionPrevent(gObj)) {\n      gObj.notify(preventBatch, {\n        instance: this,\n        handler: this.groupColumn,\n        arg1: columnName\n      });\n      return;\n    }\n\n    column.visible = gObj.groupSettings.showGroupedColumn;\n    this.colName = columnName;\n    this.isAppliedGroup = true;\n\n    if (this.contentRefresh) {\n      this.updateModel();\n    } else {\n      this.addColToGroupDrop(columnName);\n    }\n\n    this.updateGroupDropArea();\n    this.isAppliedGroup = false;\n  }\n  /**\n   * Ungroups a column by column name.\n   *\n   * @param  {string} columnName - Defines the column name to ungroup.\n   * @returns {void}\n   */\n\n\n  ungroupColumn(columnName) {\n    const gObj = this.parent;\n    const column = this.parent.enableColumnVirtualization ? this.parent.columns.filter(c => c.field === columnName)[0] : gObj.getColumnByField(columnName);\n\n    if (isNullOrUndefined(column) || column.allowGrouping === false || this.groupSettings.columns.indexOf(columnName) < 0) {\n      return;\n    }\n\n    if (isActionPrevent(gObj)) {\n      gObj.notify(preventBatch, {\n        instance: this,\n        handler: this.ungroupColumn,\n        arg1: columnName\n      });\n      return;\n    }\n\n    column.visible = true;\n    this.colName = column.field;\n    const columns = JSON.parse(JSON.stringify(this.groupSettings.columns));\n    columns.splice(columns.indexOf(this.colName), 1);\n\n    if (this.sortedColumns.indexOf(columnName) < 0) {\n      for (let i = 0, len = gObj.sortSettings.columns.length; i < len; i++) {\n        if (columnName === gObj.sortSettings.columns[i].field) {\n          gObj.sortSettings.columns.splice(i, 1);\n          break;\n        }\n      }\n    }\n\n    if (this.groupSettings.allowReordering) {\n      this.reorderingColumns = columns;\n    }\n\n    this.groupSettings.columns = columns;\n\n    if (gObj.allowGrouping) {\n      this.isAppliedUnGroup = true;\n      this.parent.dataBind();\n    }\n  }\n  /**\n   * The function used to update groupSettings\n   *\n   * @returns {void}\n   * @hidden\n   */\n\n\n  updateModel() {\n    let columns = JSON.parse(JSON.stringify(this.groupSettings.columns));\n    columns = this.reorderingColumns.length ? JSON.parse(JSON.stringify(this.reorderingColumns)) : columns;\n\n    if (this.sortRequired) {\n      if (columns.indexOf(this.colName) === -1) {\n        columns.push(this.colName);\n      }\n\n      this.groupAddSortingQuery(this.colName);\n    }\n\n    this.sortRequired = true;\n    this.parent.groupSettings.columns = columns;\n    this.parent.dataBind();\n  }\n  /**\n   * The function used to trigger onActionComplete\n   *\n   * @param {NotifyArgs} e - specifies the NotifyArgs\n   * @returns {void}\n   * @hidden\n   */\n\n\n  onActionComplete(e) {\n    if (e.requestType === 'grouping') {\n      this.addColToGroupDrop(this.colName);\n    } else {\n      this.removeColFromGroupDrop(this.colName);\n    }\n\n    const args = this.groupSettings.columns.indexOf(this.colName) > -1 ? {\n      columnName: this.colName,\n      requestType: 'grouping',\n      type: actionComplete\n    } : {\n      requestType: 'ungrouping',\n      type: actionComplete\n    };\n    this.parent.trigger(actionComplete, extend(e, args));\n    this.colName = null;\n  }\n\n  groupAddSortingQuery(colName) {\n    let i = 0;\n\n    while (i < this.parent.sortSettings.columns.length) {\n      if (this.parent.sortSettings.columns[i].field === colName) {\n        break;\n      }\n\n      i++;\n    }\n\n    if (this.parent.sortSettings.columns.length === i) {\n      this.parent.sortSettings.columns.push({\n        field: colName,\n        direction: 'Ascending',\n        isFromGroup: true\n      });\n    } else if (!this.parent.allowSorting) {\n      this.parent.sortSettings.columns[i].direction = 'Ascending';\n    }\n  }\n\n  createElement(field) {\n    const gObj = this.parent;\n    let direction = 'Ascending';\n    const animator = this.parent.createElement('div', {\n      className: 'e-grid-icon e-group-animator'\n    });\n    let groupedColumn = this.parent.createElement('div', {\n      className: 'e-grid-icon e-groupheadercell'\n    });\n    const childDiv = this.parent.createElement('div', {\n      attrs: {\n        'ej-mappingname': field\n      }\n    });\n\n    if (isComplexField(field)) {\n      childDiv.setAttribute('ej-complexname', getComplexFieldID(field));\n    }\n\n    const column = this.parent.getColumnByField(field); //Todo headerTemplateID for grouped column, disableHtmlEncode\n\n    const headerCell = gObj.getColumnHeaderByUid(column.uid); // if (!isNullOrUndefined(column.headerTemplate)) {\n    //     if (column.headerTemplate.indexOf('#') !== -1) {\n    //         childDiv.innerHTML = document.querySelector(column.headerTemplate).innerHTML.trim();\n    //     } else {\n    //         childDiv.innerHTML = column.headerTemplate;\n    //     }\n    //     childDiv.firstElementChild.classList.add('e-grouptext');\n    // } else {\n\n    if (this.groupSettings.allowReordering) {\n      childDiv.appendChild(this.parent.createElement('span', {\n        className: 'e-drag e-icons e-icon-drag',\n        innerHTML: '&nbsp;',\n        attrs: {\n          title: 'Drag',\n          tabindex: '-1',\n          'aria-label': 'Drag the grouped column'\n        }\n      }));\n    }\n\n    childDiv.appendChild(this.parent.createElement('span', {\n      className: 'e-grouptext',\n      innerHTML: column.headerText,\n      attrs: {\n        tabindex: '-1',\n        'aria-label': 'sort the grouped column'\n      }\n    })); // }\n\n    if (this.groupSettings.showToggleButton) {\n      childDiv.appendChild(this.parent.createElement('span', {\n        className: 'e-togglegroupbutton e-icons e-icon-ungroup e-toggleungroup',\n        innerHTML: '&nbsp;',\n        attrs: {\n          tabindex: '-1',\n          'aria-label': 'ungroup button'\n        }\n      }));\n    }\n\n    if (headerCell.querySelectorAll('.e-ascending,.e-descending').length) {\n      direction = headerCell.querySelector('.e-ascending') ? 'Ascending' : 'Descending';\n    }\n\n    childDiv.appendChild(this.parent.createElement('span', {\n      className: 'e-groupsort e-icons ' + ('e-' + direction.toLowerCase() + ' e-icon-' + direction.toLowerCase()),\n      innerHTML: '&nbsp;',\n      attrs: {\n        tabindex: '-1',\n        'aria-label': 'sort the grouped column'\n      }\n    }));\n    childDiv.appendChild(this.parent.createElement('span', {\n      className: 'e-ungroupbutton e-icons e-icon-hide',\n      innerHTML: '&nbsp;',\n      attrs: {\n        title: this.l10n.getConstant('UnGroup'),\n        tabindex: '-1',\n        'aria-label': 'ungroup the grouped column'\n      },\n      styles: this.groupSettings.showUngroupButton ? '' : 'display:none'\n    }));\n    groupedColumn.appendChild(childDiv);\n\n    if (this.groupSettings.allowReordering) {\n      animator.appendChild(groupedColumn);\n      animator.appendChild(this.createSeparator());\n      groupedColumn = animator;\n    }\n\n    return groupedColumn;\n  }\n\n  addColToGroupDrop(field) {\n    const groupElem = isComplexField(field) ? this.parent.element.querySelector('.e-groupdroparea div[ej-complexname=' + getComplexFieldID(field) + ']') : this.parent.element.querySelector('.e-groupdroparea div[ej-mappingname=' + field + ']');\n\n    if (this.groupSettings.allowReordering && groupElem) {\n      return;\n    }\n\n    const column = this.parent.getColumnByField(field);\n\n    if (isNullOrUndefined(column)) {\n      return;\n    }\n\n    const groupedColumn = this.createElement(field);\n\n    if (this.groupSettings.allowReordering) {\n      const index = this.element.getElementsByClassName('e-group-animator').length;\n      groupedColumn.setAttribute('index', index.toString());\n    }\n\n    this.element.appendChild(groupedColumn); //Todo:  rtl\n  }\n\n  createSeparator() {\n    return this.parent.createElement('span', {\n      className: 'e-nextgroup e-icons e-icon-next',\n      innerHTML: '&nbsp;',\n      attrs: {\n        tabindex: '-1',\n        'aria-label': 'Separator for the grouped columns'\n      },\n      styles: this.groupSettings.showUngroupButton ? '' : 'display:none'\n    });\n  }\n\n  refreshToggleBtn(isRemove) {\n    if (this.groupSettings.showToggleButton) {\n      const headers = [].slice.call(this.parent.getHeaderTable().getElementsByClassName('e-headercelldiv'));\n\n      for (let i = 0, len = headers.length; i < len; i++) {\n        if (!(headers[i].classList.contains('e-emptycell') || headers[i].classList.contains('e-headerchkcelldiv'))) {\n          const column = this.parent.getColumnByUid(headers[i].getAttribute('e-mappinguid'));\n\n          if (!this.parent.showColumnMenu || this.parent.showColumnMenu && !column.showColumnMenu) {\n            if (headers[i].getElementsByClassName('e-grptogglebtn').length) {\n              remove(headers[i].querySelectorAll('.e-grptogglebtn')[0]);\n            }\n\n            if (!isRemove) {\n              headers[i].appendChild(this.parent.createElement('span', {\n                className: 'e-grptogglebtn e-icons ' + (this.groupSettings.columns.indexOf(column.field) > -1 ? 'e-toggleungroup e-icon-ungroup' : 'e-togglegroup e-icon-group'),\n                attrs: {\n                  tabindex: '-1',\n                  'aria-label': 'Group button'\n                }\n              }));\n            }\n          }\n        }\n      }\n    }\n  }\n\n  removeColFromGroupDrop(field) {\n    if (!isNullOrUndefined(this.getGHeaderCell(field))) {\n      const elem = this.getGHeaderCell(field);\n\n      if (this.groupSettings.allowReordering) {\n        const parent = parentsUntil(elem, 'e-group-animator');\n        remove(parent);\n      } else {\n        remove(elem);\n      }\n\n      this.updateGroupDropArea();\n    }\n\n    this.isAppliedUnGroup = false;\n  }\n\n  onPropertyChanged(e) {\n    if (e.module !== this.getModuleName()) {\n      return;\n    }\n\n    for (const prop of Object.keys(e.properties)) {\n      switch (prop) {\n        case 'columns':\n          // eslint-disable-next-line no-case-declarations\n          let args;\n\n          if (this.contentRefresh) {\n            if (!this.isAppliedUnGroup) {\n              if (!this.isAppliedGroup) {\n                this.updateGroupDropArea(true);\n\n                for (let j = 0; j < this.parent.sortSettings.columns.length; j++) {\n                  if (this.parent.sortSettings.columns[j].isFromGroup) {\n                    this.parent.sortSettings.columns.splice(j, 1);\n                    j--;\n                  }\n                }\n\n                for (let i = 0; i < this.groupSettings.columns.length; i++) {\n                  this.colName = this.groupSettings.columns[i];\n                  const col = this.parent.getColumnByField(this.colName);\n                  col.visible = this.parent.groupSettings.showGroupedColumn;\n                  this.groupAddSortingQuery(this.colName);\n\n                  if (i < this.groupSettings.columns.length - 1) {\n                    this.addColToGroupDrop(this.groupSettings.columns[i]);\n                  }\n                }\n              }\n\n              args = {\n                columnName: this.colName,\n                requestType: e.properties[prop].length ? 'grouping' : 'ungrouping',\n                type: actionBegin\n              };\n            } else {\n              args = {\n                columnName: this.colName,\n                requestType: 'ungrouping',\n                type: actionBegin\n              };\n            }\n\n            if (!this.groupSettings.showGroupedColumn) {\n              const columns = e.oldProperties[prop];\n\n              for (let i = 0; i < columns.length; i++) {\n                if (e.properties[prop].indexOf(columns[i]) === -1) {\n                  this.parent.getColumnByField(columns[i]).visible = true;\n                }\n              }\n            }\n\n            this.parent.notify(modelChanged, args);\n          }\n\n          break;\n\n        case 'showDropArea':\n          this.updateGroupDropArea();\n\n          if (this.groupSettings.showDropArea) {\n            this.element.style.display = '';\n          } else {\n            this.element.style.display = 'none';\n          }\n\n          break;\n\n        case 'showGroupedColumn':\n          this.updateGroupedColumn(this.groupSettings.showGroupedColumn);\n          this.parent.notify(modelChanged, {\n            requestType: 'refresh'\n          });\n          break;\n\n        case 'showUngroupButton':\n          this.updateButtonVisibility(this.groupSettings.showUngroupButton, 'e-ungroupbutton');\n          break;\n\n        case 'showToggleButton':\n          this.updateButtonVisibility(this.groupSettings.showToggleButton, 'e-togglegroupbutton ');\n          this.parent.refreshHeader();\n          break;\n\n        case 'enableLazyLoading':\n          this.parent.freezeRefresh();\n          break;\n      }\n    }\n  }\n\n  updateGroupedColumn(isVisible) {\n    for (let i = 0; i < this.groupSettings.columns.length; i++) {\n      this.parent.getColumnByField(this.groupSettings.columns[i]).visible = isVisible;\n    }\n  }\n\n  updateButtonVisibility(isVisible, className) {\n    const gHeader = [].slice.call(this.element.getElementsByClassName(className));\n\n    for (let i = 0; i < gHeader.length; i++) {\n      gHeader[i].style.display = isVisible ? '' : 'none';\n    }\n  }\n\n  enableAfterRender(e) {\n    if (e.module === this.getModuleName() && e.enable) {\n      this.render();\n    }\n  }\n  /**\n   * To destroy the reorder\n   *\n   * @returns {void}\n   * @hidden\n   */\n\n\n  destroy() {\n    const gridElement = this.parent.element;\n\n    if (!gridElement || !gridElement.querySelector('.' + gridHeader) && !gridElement.querySelector('.' + gridContent)) {\n      return;\n    } // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n\n    if ((this.parent.isDestroyed || !this.parent.allowGrouping) && !this.parent.refreshing) {\n      this.clearGrouping();\n    }\n\n    this.removeEventListener();\n    this.refreshToggleBtn(true);\n\n    if (this.element.parentNode) {\n      remove(this.element);\n    } //call ejdrag and drop destroy\n\n  }\n  /**\n   * Clears all the grouped columns of the Grid.\n   *\n   * @returns {void}\n   */\n\n\n  clearGrouping() {\n    const cols = JSON.parse(JSON.stringify(this.groupSettings.columns));\n    this.contentRefresh = false;\n\n    for (let i = 0, len = cols.length; i < len; i++) {\n      if (i === len - 1) {\n        this.contentRefresh = true;\n      }\n\n      this.ungroupColumn(cols[i]);\n    }\n\n    this.contentRefresh = true;\n  }\n  /**\n   * For internal use only - Get the module name.\n   *\n   * @returns {string} returns the module name\n   * @private\n   */\n\n\n  getModuleName() {\n    return 'group';\n  }\n\n  refreshSortIcons() {\n    const gObj = this.parent;\n    let header;\n    const cols = gObj.sortSettings.columns;\n    const gCols = gObj.groupSettings.columns;\n    const fieldNames = this.parent.getColumns().map(c => c.field);\n    this.refreshToggleBtn();\n\n    for (let i = 0, len = cols.length; i < len; i++) {\n      if (fieldNames.indexOf(cols[i].field) === -1) {\n        continue;\n      }\n\n      header = gObj.getColumnHeaderByField(cols[i].field);\n\n      if (!gObj.allowSorting && (this.sortedColumns.indexOf(cols[i].field) > -1 || this.groupSettings.columns.indexOf(cols[i].field) > -1)) {\n        classList(header.querySelector('.e-sortfilterdiv'), ['e-ascending', 'e-icon-ascending'], []);\n\n        if (cols.length > 1) {\n          header.querySelector('.e-headercelldiv').appendChild(this.parent.createElement('span', {\n            className: 'e-sortnumber',\n            innerHTML: (i + 1).toString()\n          }));\n        }\n      } else if (this.getGHeaderCell(cols[i].field) && this.getGHeaderCell(cols[i].field).getElementsByClassName('e-groupsort').length) {\n        if (cols[i].direction === 'Ascending') {\n          classList(this.getGHeaderCell(cols[i].field).querySelector('.e-groupsort'), ['e-ascending', 'e-icon-ascending'], ['e-descending', 'e-icon-descending']);\n        } else {\n          classList(this.getGHeaderCell(cols[i].field).querySelector('.e-groupsort'), ['e-descending', 'e-icon-descending'], ['e-ascending', 'e-icon-ascending']);\n        }\n      }\n    }\n\n    for (let i = 0, len = gCols.length; i < len; i++) {\n      if (fieldNames.indexOf(gCols[i]) === -1) {\n        continue;\n      }\n\n      gObj.getColumnHeaderByField(gCols[i]).setAttribute('aria-grouped', 'true');\n    }\n  }\n\n  getGHeaderCell(field) {\n    if (this.element && this.element.querySelector('[ej-mappingname=\"' + field + '\"]')) {\n      return this.element.querySelector('[ej-mappingname=\"' + field + '\"]').parentElement;\n    }\n\n    return null;\n  }\n\n  onGroupAggregates(editedData) {\n    const aggregates = this.iterateGroupAggregates(editedData);\n    const rowData = this.groupGenerator.generateRows(aggregates, {});\n    const summaryRows = this.parent.getRowsObject().filter(row$$1 => !row$$1.isDataRow);\n    const updateSummaryRows = rowData.filter(data => !data.isDataRow);\n\n    if (this.parent.isReact || this.parent.isVue) {\n      this.parent.destroyTemplate(['groupFooterTemplate', 'groupCaptionTemplate', 'footerTemplate']);\n    }\n\n    for (let i = 0; i < updateSummaryRows.length; i++) {\n      const row$$1 = updateSummaryRows[i];\n      const cells = row$$1.cells.filter(cell => cell.isDataCell);\n      const args = {\n        cells: cells,\n        data: row$$1.data,\n        dataUid: summaryRows[i] ? summaryRows[i].uid : ''\n      };\n      this.parent.notify(refreshAggregateCell, args);\n    }\n  }\n\n  iterateGroupAggregates(editedData) {\n    const updatedData = editedData instanceof Array ? editedData : [];\n    const rows = this.parent.getRowsObject();\n    const initData = this.parent.getCurrentViewRecords();\n    const deletedCols = [];\n    let changeds = rows.map(row$$1 => {\n      if (row$$1.edit === 'delete') {\n        deletedCols.push(row$$1.data);\n      }\n\n      return row$$1.changes instanceof Object ? row$$1.changes : row$$1.data;\n    });\n    const field = this.parent.getPrimaryKeyFieldNames()[0];\n    changeds = updatedData.length === 0 ? changeds : updatedData;\n    const mergeData = initData.map(item => {\n      const pKeyVal = DataUtil.getObject(field, item);\n      let value;\n      const hasVal = changeds.some(cItem => {\n        value = cItem;\n        return pKeyVal === DataUtil.getObject(field, cItem);\n      });\n      return hasVal ? value : item;\n    });\n    const eData = editedData;\n\n    if (!(eData.type && eData.type === 'cancel') && deletedCols.length > 0) {\n      for (let i = 0; i < deletedCols.length; i++) {\n        const index = mergeData.indexOf(deletedCols[i]);\n        mergeData.splice(index, 1);\n      }\n    }\n\n    const aggregates = [];\n    const aggregateRows = this.parent.aggregates;\n\n    for (let j = 0; j < aggregateRows.length; j++) {\n      const row$$1 = aggregateRows[j];\n\n      for (let k = 0; k < row$$1.columns.length; k++) {\n        let aggr = {};\n        const type = row$$1.columns[k].type.toString();\n        aggr = {\n          type: type.toLowerCase(),\n          field: row$$1.columns[k].field\n        };\n        aggregates.push(aggr);\n      }\n    }\n\n    let result;\n    let aggrds;\n    const groupedCols = this.parent.groupSettings.columns;\n\n    for (let l = 0; l < groupedCols.length; l++) {\n      aggrds = result ? result : mergeData;\n      result = DataUtil.group(aggrds, groupedCols[l], aggregates, null, null);\n    }\n\n    return result;\n  }\n\n  updateExpand(args) {\n    const uid = args.uid;\n    const isExpand = args.isExpand;\n    const rows = this.parent.getRowsObject();\n\n    for (let i = 0; i < rows.length; i++) {\n      const row$$1 = rows[i];\n\n      if (row$$1.uid === uid || isNullOrUndefined(uid)) {\n        row$$1.isExpand = isExpand;\n\n        for (let j = i + 1; j < rows.length; j++) {\n          const childRow = rows[j];\n          let closestParent;\n\n          if (childRow.parentUid !== row$$1.uid) {\n            closestParent = rows.filter(x => x.uid === childRow.parentUid)[0];\n          }\n\n          if (childRow.parentUid === row$$1.uid) {\n            childRow.visible = row$$1.isExpand;\n          } else if (!isNullOrUndefined(closestParent) && childRow.parentUid === closestParent.uid) {\n            if (closestParent.isExpand && closestParent.visible === true) {\n              childRow.visible = true;\n            } else if (closestParent.isExpand && closestParent.visible === false) {\n              childRow.visible = false;\n            }\n          }\n\n          if (isNullOrUndefined(uid)) {\n            break;\n          }\n        }\n      }\n    }\n\n    this.parent.notify(contentReady, {\n      rows: rows,\n      args: {\n        isFrozen: false,\n        rows: rows\n      }\n    });\n  }\n\n}\n/**\n * The `DetailRow` module is used to handle detail template and hierarchy Grid operations.\n */\n\n\nclass DetailRow {\n  /**\n   * Constructor for the Grid detail template module\n   *\n   * @param {IGrid} parent - specifies the IGrid\n   * @param {ServiceLocator} locator - specifes the serviceLocator\n   * @hidden\n   */\n  constructor(parent, locator) {\n    //Internal variables\n    this.aria = new AriaService();\n    this.childRefs = [];\n    this.parent = parent;\n\n    if (this.parent.isDestroyed) {\n      return;\n    }\n\n    this.focus = locator.getService('focus');\n    this.parent.on(click, this.clickHandler, this);\n    this.parent.on(destroy, this.destroy, this);\n    this.parent.on(keyPressed, this.keyPressHandler, this);\n    this.parent.on(expandChildGrid, this.expand, this);\n    this.parent.on(columnVisibilityChanged, this.refreshColSpan, this);\n    this.parent.on(destroy, this.destroyChildGrids, this);\n    this.parent.on(destroyChildGrid, this.destroyChildGrids, this);\n  }\n\n  clickHandler(e) {\n    this.toogleExpandcollapse(closest(e.target, 'td'));\n  }\n\n  toogleExpandcollapse(target) {\n    const gObj = this.parent;\n    const table$$1 = this.parent.getContentTable();\n    const lastrowIdx = this.parent.getCurrentViewRecords().length - 1;\n    const parent = 'parentDetails';\n    let childGrid;\n    const isExpanded = target && target.classList.contains('e-detailrowcollapse');\n\n    if (!(target && (target.classList.contains('e-detailrowcollapse') || target.classList.contains('e-detailrowexpand')))) {\n      return;\n    }\n\n    const tr = target.parentElement;\n    const uid = tr.getAttribute('data-uid');\n    const rowObj = gObj.getRowObjectFromUID(uid);\n    const nextRow = this.parent.getContentTable().querySelector(tbody).children[tr.rowIndex + 1];\n\n    if (target.classList.contains('e-detailrowcollapse')) {\n      const data = rowObj.data;\n\n      if (this.isDetailRow(nextRow)) {\n        nextRow.style.display = '';\n        gObj.notify(detailStateChange, {\n          data: data,\n          childGrid: gObj.childGrid,\n          detailElement: target,\n          isExpanded: isExpanded\n        });\n      } else if (gObj.getDetailTemplate() || gObj.childGrid) {\n        const rowId = getUid('grid-row');\n        const detailRow = this.parent.createElement('tr', {\n          className: 'e-detailrow',\n          attrs: {\n            'data-uid': rowId\n          }\n        });\n        const detailCell = this.parent.createElement('td', {\n          className: 'e-detailcell'\n        });\n        let colSpan = this.parent.getVisibleColumns().length;\n\n        if (this.parent.allowRowDragAndDrop) {\n          colSpan++;\n        }\n\n        detailCell.setAttribute('colspan', colSpan.toString());\n        const row$$1 = new Row({\n          isDataRow: true,\n          isExpand: true,\n          uid: rowId,\n          isDetailRow: true,\n          cells: [new Cell({\n            cellType: CellType.Indent\n          }), new Cell({\n            isDataCell: true,\n            visible: true\n          })]\n        });\n        row$$1.parentUid = rowObj.uid;\n\n        for (let i = 0, len = gObj.groupSettings.columns.length; i < len; i++) {\n          detailRow.appendChild(this.parent.createElement('td', {\n            className: 'e-indentcell'\n          }));\n          row$$1.cells.unshift(new Cell({\n            cellType: CellType.Indent\n          }));\n        }\n\n        detailRow.appendChild(this.parent.createElement('td', {\n          className: 'e-detailindentcell'\n        }));\n        detailRow.appendChild(detailCell);\n        tr.parentNode.insertBefore(detailRow, tr.nextSibling);\n\n        if (gObj.detailTemplate) {\n          const isReactCompiler = this.parent.isReact && typeof gObj.detailTemplate !== 'string';\n          const detailTemplateID = gObj.element.id + 'detailTemplate';\n\n          if (isReactCompiler) {\n            gObj.getDetailTemplate()(data, gObj, 'detailTemplate', detailTemplateID, null, null, detailCell);\n            this.parent.renderTemplates();\n          } else {\n            appendChildren(detailCell, gObj.getDetailTemplate()(data, gObj, 'detailTemplate', detailTemplateID));\n          }\n        } else {\n          childGrid = new Grid(this.getGridModel(gObj, rowObj, gObj.printMode));\n          this.childRefs.push(childGrid);\n\n          if (childGrid.query) {\n            childGrid.query = childGrid.query.clone();\n          }\n\n          childGrid[parent] = {\n            parentID: gObj.element.id,\n            parentPrimaryKeys: gObj.getPrimaryKeyFieldNames(),\n            parentKeyField: gObj.childGrid.queryString,\n            parentKeyFieldValue: data[gObj.childGrid.queryString],\n            parentRowData: data\n          };\n          childGrid.isLegacyTemplate = gObj.isReact || gObj.isLegacyTemplate;\n\n          if (gObj.isPrinting) {\n            childGrid.isPrinting = true;\n            childGrid.on(contentReady, this.promiseResolve(childGrid), this);\n            childGrid.on(onEmpty, this.promiseResolve(childGrid), this);\n          }\n\n          rowObj.childGrid = childGrid;\n          const modules = childGrid.getInjectedModules();\n          const injectedModues = gObj.getInjectedModules();\n\n          if (!modules || modules.length !== injectedModues.length) {\n            childGrid.setInjectedModules(injectedModues);\n          }\n\n          const gridElem = this.parent.createElement('div', {\n            id: 'child' + parents(tr, 'e-grid').length + '_grid' + tr.rowIndex + getUid('')\n          });\n          detailCell.appendChild(gridElem);\n          childGrid.appendTo(gridElem);\n        }\n\n        detailRow.appendChild(detailCell);\n\n        if (tr.nextSibling) {\n          tr.parentNode.insertBefore(detailRow, tr.nextSibling);\n        } else {\n          tr.parentNode.appendChild(detailRow);\n        }\n\n        const rowElems = gObj.getRows();\n        const rowObjs = gObj.getRowsObject();\n        rowElems.splice(rowElems.indexOf(tr) + 1, 0, detailRow);\n        rowObjs.splice(rowObjs.indexOf(rowObj) + 1, 0, row$$1);\n        gObj.trigger(detailDataBound, {\n          detailElement: detailCell,\n          data: data,\n          childGrid: childGrid\n        });\n        gObj.notify(detailDataBound, {\n          rows: rowObjs\n        });\n      }\n\n      classList(target, ['e-detailrowexpand'], ['e-detailrowcollapse']);\n      classList(target.firstElementChild, ['e-dtdiagonaldown', 'e-icon-gdownarrow'], ['e-dtdiagonalright', 'e-icon-grightarrow']);\n      rowObj.isExpand = true;\n\n      if (target.classList.contains('e-lastrowcell') && this.parent.getContent().clientHeight > table$$1.scrollHeight) {\n        removeClass(target.parentElement.querySelectorAll('td'), 'e-lastrowcell');\n        const detailrowIdx = table$$1.querySelector(tbody).getElementsByClassName('e-detailrow').length - 1;\n        addClass(table$$1.querySelector(tbody).getElementsByClassName('e-detailrow')[detailrowIdx].childNodes, ['e-lastrowcell']);\n        this.lastrowcell = true;\n      }\n\n      this.aria.setExpand(target, true);\n    } else {\n      if (this.isDetailRow(nextRow)) {\n        nextRow.style.display = 'none';\n        gObj.notify(detailStateChange, {\n          data: rowObj.data,\n          childGrid: gObj.childGrid,\n          detailElement: target,\n          isExpanded: isExpanded\n        });\n      }\n\n      classList(target, ['e-detailrowcollapse'], ['e-detailrowexpand']);\n      classList(target.firstElementChild, ['e-dtdiagonalright', 'e-icon-grightarrow'], ['e-dtdiagonaldown', 'e-icon-gdownarrow']);\n\n      if (parseInt(tr.getAttribute(ariaRowIndex), 10) === lastrowIdx && this.lastrowcell) {\n        addClass(target.parentElement.querySelectorAll('td'), 'e-lastrowcell');\n        this.lastrowcell = false;\n      }\n\n      rowObj.isExpand = false;\n      this.aria.setExpand(target, false);\n    }\n\n    if (!isNullOrUndefined(gObj.detailTemplate)) {\n      gObj.updateVisibleExpandCollapseRows();\n      gObj.notify(refreshExpandandCollapse, {\n        rows: gObj.getRowsObject()\n      });\n    }\n  }\n  /**\n   * @hidden\n   * @param {IGrid} gObj - specifies the grid Object\n   * @param {Row<Column>}rowObj - specifies the row object\n   * @param {string} printMode - specifies the printmode\n   * @returns {Object} returns the object\n   */\n\n\n  getGridModel(gObj, rowObj, printMode) {\n    let gridModel;\n\n    if (gObj.isPrinting && rowObj.isExpand && gObj.expandedRows && gObj.expandedRows[rowObj.index] && gObj.expandedRows[rowObj.index].gridModel) {\n      gObj.expandedRows[rowObj.index].gridModel.hierarchyPrintMode = gObj.childGrid.hierarchyPrintMode;\n      gridModel = gObj.expandedRows[rowObj.index].gridModel;\n    } else {\n      if (gObj.isPrinting && gObj.childGrid.allowPaging) {\n        gObj.childGrid.allowPaging = printMode === 'CurrentPage';\n      }\n\n      gridModel = extend({}, {}, gObj.childGrid, true);\n    }\n\n    return gridModel;\n  }\n\n  promiseResolve(grid) {\n    return () => {\n      grid.off(contentReady, this.promiseResolve);\n      grid.off(onEmpty, this.promiseResolve);\n      grid.notify(hierarchyPrint, {});\n    };\n  }\n\n  isDetailRow(row$$1) {\n    return row$$1 && row$$1.classList.contains('e-detailrow');\n  }\n\n  destroy() {\n    const gridElement = this.parent.element;\n\n    if (this.parent.isDestroyed || !gridElement || !gridElement.querySelector('.' + gridHeader) && !gridElement.querySelector('.' + gridContent)) {\n      return;\n    }\n\n    this.parent.off(click, this.clickHandler);\n    this.parent.off(destroy, this.destroy);\n    this.parent.off(keyPressed, this.keyPressHandler);\n    this.parent.off(expandChildGrid, this.expand);\n    this.parent.off(columnVisibilityChanged, this.refreshColSpan);\n    this.parent.off(destroy, this.destroyChildGrids);\n    this.parent.off(destroyChildGrid, this.destroyChildGrids);\n  }\n\n  getTDfromIndex(index, className) {\n    const tr = this.parent.getDataRows()[index];\n\n    if (tr && tr.querySelector(className)) {\n      return tr.querySelector(className);\n    }\n\n    return null;\n  }\n  /**\n   * Expands a detail row with the given target.\n   *\n   * @param  {Element} target - Defines the collapsed element to expand.\n   * @returns {void}\n   */\n\n\n  expand(target) {\n    if (!isNaN(target)) {\n      target = this.getTDfromIndex(target, '.e-detailrowcollapse');\n    }\n\n    if (target && target.classList.contains('e-detailrowcollapse')) {\n      this.toogleExpandcollapse(target);\n    }\n  }\n  /**\n   * Collapses a detail row with the given target.\n   *\n   * @param  {Element} target - Defines the expanded element to collapse.\n   * @returns {void}\n   */\n\n\n  collapse(target) {\n    if (!isNaN(target)) {\n      target = this.getTDfromIndex(target, '.e-detailrowexpand');\n    }\n\n    if (target && target.classList.contains('e-detailrowexpand')) {\n      this.toogleExpandcollapse(target);\n    }\n  }\n  /**\n   * Expands all the detail rows of the Grid.\n   *\n   * @returns {void}\n   */\n\n\n  expandAll() {\n    this.expandCollapse(true);\n    this.parent.trigger(actionComplete, {\n      requestType: 'expandAllComplete',\n      type: actionComplete,\n      moduleObj: this\n    });\n  }\n  /**\n   * Collapses all the detail rows of the Grid.\n   *\n   * @returns {void}\n   */\n\n\n  collapseAll() {\n    this.expandCollapse(false);\n    this.parent.trigger(actionComplete, {\n      requestType: 'collapseAllComplete',\n      type: actionComplete,\n      moduleObj: this\n    });\n  }\n\n  expandCollapse(isExpand) {\n    let td;\n    const rows = this.parent.getDataRows();\n\n    for (let i = 0, len = rows.length; i < len; i++) {\n      td = rows[i].querySelector('.e-detailrowcollapse, .e-detailrowexpand');\n\n      if (isExpand) {\n        this.expand(td);\n      } else {\n        this.collapse(td);\n      }\n    }\n  }\n\n  keyPressHandler(e) {\n    const gObj = this.parent;\n\n    switch (e.action) {\n      case 'ctrlDownArrow':\n        this.expandAll();\n        break;\n\n      case 'ctrlUpArrow':\n        this.collapseAll();\n        break;\n\n      case 'altUpArrow':\n      case 'altDownArrow':\n        // eslint-disable-next-line no-case-declarations\n        const selected = gObj.allowSelection ? gObj.getSelectedRowIndexes() : [];\n\n        if (selected.length) {\n          const dataRow = gObj.getDataRows()[selected[selected.length - 1]];\n          const td = dataRow.querySelector('.e-detailrowcollapse, .e-detailrowexpand');\n\n          if (e.action === 'altDownArrow') {\n            this.expand(td);\n          } else {\n            this.collapse(td);\n          }\n        }\n\n        break;\n\n      case 'enter':\n        if (this.parent.isEdit) {\n          return;\n        } // eslint-disable-next-line no-case-declarations\n\n\n        const element = this.focus.getFocusedElement();\n\n        if (!e.target.classList.contains('e-detailrowcollapse') && !e.target.classList.contains('e-detailrowexpand')) {\n          break;\n        }\n\n        this.toogleExpandcollapse(element);\n        break;\n    }\n  }\n\n  refreshColSpan() {\n    const detailrows = this.parent.contentModule.getTable().querySelectorAll('tr.e-detailrow');\n    const colSpan = this.parent.getVisibleColumns().length;\n\n    for (let i = 0; i < detailrows.length; i++) {\n      detailrows[i].querySelector('.e-detailcell').setAttribute('colspan', colSpan + '');\n    }\n  }\n\n  destroyChildGrids() {\n    const rows = this.parent.getRowsObject();\n\n    for (let i = 0; i < rows.length; i++) {\n      rows[i].childGrid = null;\n    }\n\n    for (let i = 0; i < this.childRefs.length; i++) {\n      if (!this.childRefs[i].isDestroyed) {\n        this.childRefs[i].destroy();\n      }\n    }\n\n    this.childRefs = [];\n  }\n  /**\n   * For internal use only - Get the module name.\n   *\n   * @returns {string} returns the module name\n   * @private\n   */\n\n\n  getModuleName() {\n    return 'detailRow';\n  }\n\n}\n/**\n * The `Toolbar` module is used to handle ToolBar actions.\n *\n * @hidden\n */\n\n\nclass Toolbar$1 {\n  constructor(parent, serviceLocator) {\n    this.predefinedItems = {};\n    this.items = ['Add', 'Edit', 'Update', 'Delete', 'Cancel', 'Print', 'Search', 'ColumnChooser', 'PdfExport', 'ExcelExport', 'CsvExport', 'WordExport'];\n    this.parent = parent;\n    this.gridID = parent.element.id;\n    this.serviceLocator = serviceLocator;\n    this.addEventListener();\n  }\n\n  render() {\n    this.l10n = this.serviceLocator.getService('localization');\n    const preItems = ['Add', 'Edit', 'Update', 'Delete', 'Cancel', 'Print', 'PdfExport', 'ExcelExport', 'WordExport', 'CsvExport'];\n    const isAdaptive = this.parent.enableAdaptiveUI;\n    const excludingItems = ['Edit', 'Delete', 'Update', 'Cancel'];\n\n    for (const item of preItems) {\n      const itemStr = item.toLowerCase();\n      const localeName = itemStr[0].toUpperCase() + itemStr.slice(1);\n      this.predefinedItems[item] = {\n        id: this.gridID + '_' + itemStr,\n        prefixIcon: 'e-' + itemStr,\n        text: this.l10n.getConstant(localeName),\n        tooltipText: this.l10n.getConstant(localeName)\n      };\n\n      if (isAdaptive) {\n        this.predefinedItems[item].text = '';\n        this.predefinedItems[item].visible = excludingItems.indexOf(item) === -1;\n      }\n    }\n\n    this.predefinedItems.Search = {\n      id: this.gridID + '_search',\n      tooltipText: this.l10n.getConstant('Search'),\n      align: 'Right',\n      cssClass: 'e-search-wrapper',\n      type: 'Input'\n    };\n    this.predefinedItems.ColumnChooser = {\n      id: this.gridID + '_' + 'columnchooser',\n      cssClass: 'e-cc e-ccdiv e-cc-toolbar',\n      suffixIcon: 'e-' + 'columnchooser-btn',\n      text: isAdaptive ? '' : this.l10n.getConstant('Columnchooser'),\n      tooltipText: this.l10n.getConstant('Columnchooser'),\n      align: 'Right'\n    };\n\n    if (this.parent.rowRenderingMode === 'Vertical') {\n      if (this.parent.allowFiltering && this.parent.filterSettings.type !== 'FilterBar') {\n        this.predefinedItems.responsiveFilter = {\n          id: this.gridID + '_' + 'responsivefilter',\n          cssClass: 'e-gridresponsiveicons e-icons',\n          suffixIcon: 'e-' + 'resfilter-icon',\n          tooltipText: this.l10n.getConstant('FilterButton')\n        };\n      }\n\n      if (this.parent.allowSorting) {\n        this.predefinedItems.responsiveSort = {\n          id: this.gridID + '_' + 'responsivesort',\n          cssClass: 'e-gridresponsiveicons e-icons',\n          suffixIcon: 'e-' + 'ressort-icon',\n          tooltipText: this.l10n.getConstant('Sort')\n        };\n      }\n    }\n\n    if (this.parent.enableAdaptiveUI && this.parent.toolbar.indexOf('Search') > -1) {\n      this.predefinedItems.responsiveBack = {\n        id: this.gridID + '_' + 'responsiveback',\n        cssClass: 'e-gridresponsiveicons e-icons',\n        suffixIcon: 'e-' + 'resback-icon',\n        visible: false\n      };\n    }\n\n    this.createToolbar();\n  }\n  /**\n   * Gets the toolbar of the Grid.\n   *\n   * @returns {Element} returns the element\n   * @hidden\n   */\n\n\n  getToolbar() {\n    return this.toolbar.element;\n  }\n  /**\n   * Destroys the ToolBar.\n   *\n   * @function destroy\n   * @returns {void}\n   */\n\n\n  destroy() {\n    if (this.toolbar && !this.toolbar.isDestroyed) {\n      if (!this.toolbar.element) {\n        this.parent.destroyTemplate(['toolbarTemplate']);\n\n        if (this.parent.isReact) {\n          this.parent.renderTemplates();\n        }\n      } else {\n        this.toolbar.off('render-react-toolbar-template', this.addReactToolbarPortals);\n        this.toolbar.destroy();\n      }\n\n      this.unWireEvent();\n      this.removeEventListener();\n\n      if (this.element.parentNode) {\n        remove(this.element);\n      }\n    }\n  }\n\n  bindSearchEvents() {\n    this.searchElement = select('#' + this.gridID + '_searchbar', this.element);\n    this.wireEvent();\n    this.refreshToolbarItems();\n\n    if (this.parent.searchSettings) {\n      this.updateSearchBox();\n    }\n  }\n\n  toolbarCreated(isNormal) {\n    if (this.element.querySelector('.e-search-wrapper')) {\n      if (!this.parent.enableAdaptiveUI || isNormal) {\n        this.element.querySelector('.e-search-wrapper').innerHTML = '<div class=\"e-input-group e-search\" role=\"search\">\\\n                    <input id=\"' + this.gridID + '_searchbar\" class=\"e-input\" name=\"input\" type=\"search\" \\\n                    placeholder= \"' + this.l10n.getConstant('Search') + '\"/>\\\n                    <span id=\"' + this.gridID + '_searchbutton\" class=\"e-input-group-icon e-search-icon e-icons\" \\\n                    tabindex=\"-1\" title=\"' + this.l10n.getConstant('Search') + '\" aria-label= \"search\"></span> \\\n                    </div>';\n      } else {\n        this.element.querySelector('.e-search-wrapper').innerHTML = '<span id=\"' + this.gridID + '_searchbutton\" class=\"e-input-group-icon e-search-icon e-icons\" \\\n                    tabindex=\"-1\" title=\"' + this.l10n.getConstant('Search') + '\" aria-label= \"search\"></span> \\\n                    </div>';\n      }\n    }\n\n    this.bindSearchEvents();\n  }\n\n  createToolbar() {\n    const items = this.getItems();\n    this.toolbar = new Toolbar({\n      items: items,\n      clicked: this.toolbarClickHandler.bind(this),\n      enablePersistence: this.parent.enablePersistence,\n      enableRtl: this.parent.enableRtl,\n      created: this.toolbarCreated.bind(this)\n    });\n    this.toolbar.isReact = this.parent.isReact;\n    this.toolbar.on('render-react-toolbar-template', this.addReactToolbarPortals, this);\n    const isStringTemplate = 'isStringTemplate';\n    this.toolbar[isStringTemplate] = true;\n    const viewStr = 'viewContainerRef';\n    const registerTemp = 'registeredTemplate';\n\n    if (this.parent[viewStr]) {\n      this.toolbar[registerTemp] = {};\n      this.toolbar[viewStr] = this.parent[viewStr];\n    }\n\n    this.element = this.parent.createElement('div', {\n      id: this.gridID + '_toolbarItems'\n    });\n\n    if (this.parent.enableAdaptiveUI) {\n      this.element.classList.add('e-res-toolbar');\n    }\n\n    if (this.parent.toolbarTemplate) {\n      if (typeof this.parent.toolbarTemplate === 'string') {\n        this.toolbar.appendTo(this.parent.toolbarTemplate);\n        this.element = this.toolbar.element;\n      } else {\n        const isReactCompiler = this.parent.isReact && typeof this.parent.toolbarTemplate !== 'string';\n        const ID = this.parent.element.id + 'toolbarTemplate';\n\n        if (isReactCompiler) {\n          templateCompiler(this.parent.toolbarTemplate)({}, this.parent, 'toolbarTemplate', ID, null, null, this.element);\n          this.parent.renderTemplates();\n        } else {\n          appendChildren(this.element, templateCompiler(this.parent.toolbarTemplate)({}, this.parent, 'toolbarTemplate'));\n        }\n      }\n    } else {\n      this.toolbar.appendTo(this.element);\n    }\n\n    this.parent.element.insertBefore(this.element, this.parent.getHeaderContent());\n  }\n\n  addReactToolbarPortals(args) {\n    if (this.parent.isReact && args) {\n      this.parent.portals = this.parent.portals.concat(args);\n      this.parent.renderTemplates();\n    }\n  }\n\n  renderResponsiveSearch(isRender) {\n    if (isRender) {\n      this.toolbarCreated(true);\n      this.refreshResponsiveToolbarItems(ResponsiveToolbarAction.isSearch);\n      this.searchElement = select('#' + this.gridID + '_searchbar', this.element);\n      const right = parentsUntil(this.searchElement, 'e-toolbar-right');\n      right.classList.add('e-responsive-right');\n\n      if (this.parent.searchSettings) {\n        this.updateSearchBox();\n      }\n\n      this.searchBoxObj.searchFocus({\n        target: this.searchElement\n      });\n      this.searchElement.focus();\n    } else {\n      this.refreshResponsiveToolbarItems(ResponsiveToolbarAction.isInitial);\n    }\n  }\n\n  refreshResponsiveToolbarItems(action) {\n    if (action === ResponsiveToolbarAction.isInitial) {\n      const id = this.parent.element.id;\n      const items = [id + '_edit', id + '_delete'];\n      const selectedRecords = this.parent.getSelectedRowIndexes();\n      const excludingItems = [id + '_responsiveback', id + '_update', id + '_cancel'];\n\n      for (const item of this.toolbar.items) {\n        const toolbarEle = this.toolbar.element.querySelector('#' + item.id);\n\n        if (toolbarEle) {\n          if (items.indexOf(item.id) > -1) {\n            if (selectedRecords.length) {\n              toolbarEle.parentElement.classList.remove('e-hidden');\n            } else {\n              toolbarEle.parentElement.classList.add('e-hidden');\n            }\n          } else {\n            if (excludingItems.indexOf(item.id) === -1) {\n              toolbarEle.parentElement.classList.remove('e-hidden');\n            } else {\n              toolbarEle.parentElement.classList.add('e-hidden');\n            }\n          }\n        }\n      }\n\n      if (this.searchElement) {\n        const right = parentsUntil(this.searchElement, 'e-toolbar-right');\n        right.classList.remove('e-responsive-right');\n        this.toolbarCreated(false);\n        this.unWireEvent();\n        this.searchElement = undefined;\n      }\n    }\n\n    if (action === ResponsiveToolbarAction.isSearch) {\n      const items = [this.parent.element.id + '_responsiveback', this.parent.element.id + '_search'];\n\n      for (const item of this.toolbar.items) {\n        const toolbarEle = this.toolbar.element.querySelector('#' + item.id);\n\n        if (toolbarEle) {\n          if (items.indexOf(item.id) > -1) {\n            toolbarEle.parentElement.classList.remove('e-hidden');\n          } else {\n            toolbarEle.parentElement.classList.add('e-hidden');\n          }\n        }\n      }\n    }\n  } // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  refreshToolbarItems(args) {\n    const gObj = this.parent;\n    let enableItems = [];\n    let disableItems = [];\n    const edit = gObj.editSettings;\n    const hasData = gObj.currentViewData && gObj.currentViewData.length;\n\n    if (edit.allowAdding) {\n      enableItems.push(this.gridID + '_add');\n    } else {\n      disableItems.push(this.gridID + '_add');\n    }\n\n    if (edit.allowEditing && hasData) {\n      enableItems.push(this.gridID + '_edit');\n    } else {\n      disableItems.push(this.gridID + '_edit');\n    }\n\n    if (edit.allowDeleting && hasData) {\n      enableItems.push(this.gridID + '_delete');\n    } else {\n      disableItems.push(this.gridID + '_delete');\n    }\n\n    if (gObj.editSettings.mode === 'Batch') {\n      if (gObj.element.getElementsByClassName('e-updatedtd').length && (edit.allowAdding || edit.allowEditing)) {\n        enableItems.push(this.gridID + '_update');\n        enableItems.push(this.gridID + '_cancel');\n      } else {\n        disableItems.push(this.gridID + '_update');\n        disableItems.push(this.gridID + '_cancel');\n      }\n    } else {\n      if (gObj.isEdit && (edit.allowAdding || edit.allowEditing)) {\n        enableItems = [this.gridID + '_update', this.gridID + '_cancel'];\n        disableItems = [this.gridID + '_add', this.gridID + '_edit', this.gridID + '_delete'];\n      } else {\n        disableItems.push(this.gridID + '_update');\n        disableItems.push(this.gridID + '_cancel');\n      }\n    }\n\n    this.enableItems(enableItems, true);\n    this.enableItems(disableItems, false);\n  }\n\n  getItems() {\n    const items = [];\n    const toolbarItems = this.parent.toolbar || [];\n\n    if (typeof this.parent.toolbar === 'string') {\n      return [];\n    }\n\n    if (this.parent.rowRenderingMode === 'Vertical') {\n      if (this.parent.allowFiltering && this.parent.filterSettings.type !== 'FilterBar') {\n        items.push(this.getItemObject('responsiveFilter'));\n      }\n\n      if (this.parent.allowSorting) {\n        items.push(this.getItemObject('responsiveSort'));\n      }\n    }\n\n    for (const item of toolbarItems) {\n      switch (typeof item) {\n        case 'number':\n          items.push(this.getItemObject(this.items[item]));\n          break;\n\n        case 'string':\n          items.push(this.getItemObject(item));\n          break;\n\n        default:\n          items.push(this.getItem(item));\n      }\n    }\n\n    if (this.parent.enableAdaptiveUI && this.parent.toolbar.indexOf('Search') > -1) {\n      items.push(this.getItemObject('responsiveBack'));\n    }\n\n    return items;\n  }\n\n  getItem(itemObject) {\n    const item = this.predefinedItems[itemObject.text];\n    return item ? extend(item, item, itemObject) : itemObject;\n  }\n\n  getItemObject(itemName) {\n    return this.predefinedItems[itemName] || {\n      text: itemName,\n      id: this.gridID + '_' + itemName\n    };\n  }\n  /**\n   * Enables or disables ToolBar items.\n   *\n   * @param {string[]} items - Defines the collection of itemID of ToolBar items.\n   * @param {boolean} isEnable - Defines the items to be enabled or disabled.\n   * @returns {void}\n   * @hidden\n   */\n\n\n  enableItems(items, isEnable) {\n    for (const item of items) {\n      const element = select('#' + item, this.element);\n\n      if (element) {\n        this.toolbar.enableItems(element.parentElement, isEnable);\n      }\n    }\n  }\n\n  toolbarClickHandler(args) {\n    const gObj = this.parent;\n    const gID = this.gridID;\n    extend(args, {\n      cancel: false\n    });\n    const newArgs = args;\n    const originalEvent = args.originalEvent;\n    gObj.trigger(toolbarClick, newArgs, toolbarargs => {\n      toolbarargs.originalEvent = toolbarargs.originalEvent ? toolbarargs.originalEvent : originalEvent;\n\n      if (!toolbarargs.cancel) {\n        switch (!isNullOrUndefined(toolbarargs.item) && toolbarargs.item.id) {\n          case gID + '_print':\n            gObj.print();\n            break;\n\n          case gID + '_edit':\n            gObj.startEdit();\n            break;\n\n          case gID + '_update':\n            gObj.endEdit();\n            break;\n\n          case gID + '_cancel':\n            gObj.closeEdit();\n            break;\n\n          case gID + '_add':\n            gObj.addRecord();\n            break;\n\n          case gID + '_delete':\n            gObj.deleteRecord();\n            break;\n\n          case gID + '_search':\n            if (toolbarargs.originalEvent.target.id === gID + '_searchbutton' && this.searchElement) {\n              this.search();\n            } else if (gObj.enableAdaptiveUI && !this.searchElement && (toolbarargs.originalEvent.target.classList.contains('e-search-wrapper') || toolbarargs.originalEvent.target.id === gID + '_searchbutton')) {\n              this.renderResponsiveSearch(true);\n            }\n\n            break;\n\n          case gID + '_columnchooser':\n            /* eslint-disable */\n            const tarElement = this.parent.element.querySelector('.e-ccdiv');\n            let y = tarElement.getBoundingClientRect().top;\n            const x = tarElement.getBoundingClientRect().left;\n            const targetEle = toolbarargs.originalEvent.target;\n            /* eslint-enable */\n\n            y = tarElement.getBoundingClientRect().top + tarElement.offsetTop;\n            gObj.createColumnchooser(x, y, targetEle);\n            break;\n\n          case gID + '_responsivefilter':\n            gObj.showResponsiveCustomFilter();\n            break;\n\n          case gID + '_responsivesort':\n            gObj.showResponsiveCustomSort();\n            break;\n\n          case gID + '_responsiveback':\n            this.renderResponsiveSearch(false);\n            break;\n        }\n      }\n    });\n  }\n\n  modelChanged(e) {\n    if (e.module === 'edit') {\n      this.refreshToolbarItems();\n    }\n  }\n\n  onPropertyChanged(e) {\n    if (e.module !== this.getModuleName() || !this.parent.toolbar) {\n      return;\n    }\n\n    if (this.element) {\n      remove(this.element);\n    }\n\n    this.render();\n  }\n\n  keyUpHandler(e) {\n    if (e.keyCode === 13) {\n      this.search();\n    }\n  }\n\n  search() {\n    this.parent.search(this.searchElement.value);\n  }\n\n  updateSearchBox() {\n    if (this.searchElement) {\n      this.searchElement.value = this.parent.searchSettings.key;\n    }\n  }\n\n  wireEvent() {\n    if (this.searchElement) {\n      this.searchBoxObj = new SearchBox(this.searchElement);\n      EventHandler.add(this.searchElement, 'keyup', this.keyUpHandler, this);\n      this.searchBoxObj.wireEvent();\n    }\n  }\n\n  unWireEvent() {\n    if (this.searchElement) {\n      EventHandler.remove(this.searchElement, 'keyup', this.keyUpHandler);\n      this.searchBoxObj.unWireEvent();\n    }\n  }\n\n  reRenderToolbar() {\n    if (this.element) {\n      remove(this.element);\n    }\n\n    this.render();\n  }\n\n  addEventListener() {\n    if (this.parent.isDestroyed) {\n      return;\n    }\n\n    this.evtHandlers = [{\n      event: setFullScreenDialog,\n      handler: this.reRenderToolbar\n    }, {\n      event: initialEnd,\n      handler: this.render\n    }, {\n      event: uiUpdate,\n      handler: this.onPropertyChanged\n    }, {\n      event: inBoundModelChanged,\n      handler: this.updateSearchBox.bind(this)\n    }, {\n      event: modelChanged,\n      handler: this.refreshToolbarItems\n    }, {\n      event: toolbarRefresh,\n      handler: this.refreshToolbarItems\n    }, {\n      event: inBoundModelChanged,\n      handler: this.modelChanged\n    }, {\n      event: dataBound,\n      handler: this.refreshToolbarItems\n    }, {\n      event: click,\n      handler: this.removeResponsiveSearch\n    }, {\n      event: rowModeChange,\n      handler: this.reRenderToolbar\n    }, {\n      event: destroy,\n      handler: this.destroy\n    }];\n    addRemoveEventListener(this.parent, this.evtHandlers, true, this);\n    this.rowSelectedFunction = this.rowSelected.bind(this);\n    this.rowDeSelectedFunction = this.rowSelected.bind(this);\n    this.parent.addEventListener(rowSelected, this.rowSelectedFunction);\n    this.parent.addEventListener(rowDeselected, this.rowDeSelectedFunction);\n  }\n\n  removeEventListener() {\n    if (this.parent.isDestroyed) {\n      return;\n    }\n\n    addRemoveEventListener(this.parent, this.evtHandlers, false);\n    this.parent.removeEventListener(rowSelected, this.rowSelectedFunction);\n    this.parent.removeEventListener(rowDeselected, this.rowDeSelectedFunction);\n  }\n\n  removeResponsiveSearch(e) {\n    const target = e.target;\n    const isSearch = target.classList.contains('e-search-icon') || target.classList.contains('e-search-wrapper');\n\n    if (this.parent.enableAdaptiveUI && !isSearch && this.searchElement && !parentsUntil(e.target, 'e-res-toolbar')) {\n      this.renderResponsiveSearch(false);\n    }\n  }\n\n  rowSelected() {\n    if (this.parent.enableAdaptiveUI) {\n      this.refreshResponsiveToolbarItems(ResponsiveToolbarAction.isInitial);\n    }\n  }\n  /**\n   * For internal use only - Get the module name.\n   *\n   * @returns {string} returns the module name\n   */\n\n\n  getModuleName() {\n    return 'toolbar';\n  }\n\n}\n/**\n * Footer module is used to render grid content\n *\n * @hidden\n */\n\n\nclass FooterRenderer extends ContentRender {\n  constructor(gridModule, serviceLocator) {\n    super(gridModule, serviceLocator);\n    this.aggregates = {};\n    this.parent = gridModule;\n    this.locator = serviceLocator;\n    this.modelGenerator = new SummaryModelGenerator(this.parent);\n    this.addEventListener();\n  }\n  /**\n   * The function is used to render grid footer div\n   *\n   * @returns {void}\n   */\n\n\n  renderPanel() {\n    const div = this.parent.createElement('div', {\n      className: gridFooter\n    });\n    const innerDiv = this.parent.createElement('div', {\n      className: 'e-summarycontent'\n    });\n    let movableContent$$1 = innerDiv;\n\n    if (this.parent.isFrozenGrid()) {\n      const fDiv = this.parent.createElement('div', {\n        className: 'e-frozenfootercontent e-frozen-left-footercontent'\n      });\n      const mDiv = this.parent.createElement('div', {\n        className: 'e-movablefootercontent'\n      });\n      const frDiv = this.parent.createElement('div', {\n        className: 'e-frozenfootercontent e-frozen-right-footercontent'\n      });\n\n      if (this.parent.getFrozenColumns() || this.parent.getFrozenLeftColumnsCount()) {\n        innerDiv.appendChild(fDiv);\n        this.frozenContent = fDiv;\n      }\n\n      innerDiv.appendChild(mDiv);\n      this.movableContent = mDiv;\n      movableContent$$1 = mDiv;\n\n      if (this.parent.getFrozenRightColumnsCount()) {\n        innerDiv.appendChild(frDiv);\n        this.frozenRightContent = frDiv;\n      }\n    }\n\n    if (Browser.isDevice) {\n      movableContent$$1.style.overflowX = 'scroll';\n    }\n\n    div.appendChild(innerDiv);\n    this.setPanel(div);\n\n    if (this.parent.getPager() != null) {\n      this.parent.element.insertBefore(div, this.parent.getPager());\n    } else {\n      this.parent.element.appendChild(div);\n    }\n  }\n  /**\n   * The function is used to render grid footer table\n   *\n   * @returns {void}\n   */\n\n\n  renderTable() {\n    const frzCols = this.parent.getFrozenColumns() || this.parent.getFrozenLeftColumnsCount();\n    const innerDiv = this.createContentTable('_footer_table');\n    const table$$1 = innerDiv.querySelector('.' + table);\n    const tFoot = this.parent.createElement('tfoot');\n    table$$1.appendChild(tFoot);\n\n    if (this.parent.isFrozenGrid()) {\n      const freezeTable = table$$1.cloneNode(true);\n      const frTable = table$$1.cloneNode(true);\n\n      if (frzCols) {\n        this.frozenContent.appendChild(freezeTable);\n        this.freezeTable = freezeTable;\n      }\n\n      if (this.parent.getFrozenRightColumnsCount()) {\n        remove(frTable.querySelector(colGroup));\n        const hdr = this.parent.getHeaderContent().querySelector('.e-frozen-right-header');\n        const frCol = hdr.querySelector(colGroup).cloneNode(true);\n        frTable.insertBefore(frCol, frTable.querySelector(tbody));\n        this.frozenRightContent.appendChild(frTable);\n        this.frTable = frTable;\n      }\n\n      this.movableContent.appendChild(table$$1);\n      remove(table$$1.querySelector(colGroup));\n      const colGroup$$1 = this.parent.getHeaderContent().querySelector('.' + movableHeader).querySelector(colGroup).cloneNode(true);\n      table$$1.insertBefore(colGroup$$1, table$$1.querySelector(tbody));\n      this.setColGroup(colGroup$$1);\n    }\n\n    this.setTable(table$$1);\n  }\n\n  renderSummaryContent(e, table$$1, cStart, cEnd) {\n    const input = this.parent.dataSource instanceof Array ? this.parent.dataSource : this.parent.currentViewData;\n    const summaries = this.modelGenerator.getData();\n    const dummies = isNullOrUndefined(cStart) ? this.modelGenerator.getColumns() : this.modelGenerator.getColumns(cStart, cEnd); // eslint-disable-next-line max-len\n\n    const rows = isNullOrUndefined(cStart) ? this.modelGenerator.generateRows(input, e || this.aggregates) : this.modelGenerator.generateRows(input, e || this.aggregates, cStart, cEnd);\n    const fragment = document.createDocumentFragment();\n    const rowrenderer = new RowRenderer(this.locator, null, this.parent);\n    rowrenderer.element = this.parent.createElement('TR', {\n      className: 'e-summaryrow'\n    });\n\n    for (let srow = 0, len = summaries.length; srow < len; srow++) {\n      const row$$1 = rows[srow];\n\n      if (!row$$1) {\n        continue;\n      }\n\n      const tr = rowrenderer.render(row$$1, dummies);\n      fragment.appendChild(tr);\n    }\n\n    table$$1.tFoot.appendChild(fragment);\n    this.aggregates = !isNullOrUndefined(e) ? e : this.aggregates;\n  }\n\n  refresh(e) {\n    const frzCols = this.parent.getFrozenColumns() || this.parent.getFrozenLeftColumnsCount();\n    const movable = this.parent.getMovableColumnsCount();\n    const right = this.parent.getFrozenRightColumnsCount();\n\n    if (this.parent.isFrozenGrid()) {\n      remove(this.getPanel());\n      this.renderPanel();\n      this.renderTable();\n\n      if (frzCols) {\n        this.freezeTable.tFoot.innerHTML = '';\n        this.renderSummaryContent(e, this.freezeTable, 0, frzCols);\n      }\n    }\n\n    this.getTable().tFoot.innerHTML = '';\n    this.renderSummaryContent(e, this.getTable(), frzCols, right ? frzCols + movable : undefined);\n\n    if (this.parent.getFrozenRightColumnsCount()) {\n      this.frTable.tFoot.innerHTML = '';\n      this.renderSummaryContent(e, this.frTable, frzCols + movable, frzCols + movable + right);\n      const movableLastCell = [].slice.call(this.getTable().getElementsByClassName('e-lastsummarycell'));\n\n      if (movableLastCell.length) {\n        for (let i = 0; i < movableLastCell.length; i++) {\n          movableLastCell[i].style.borderRight = '0px';\n        }\n      }\n    } // check freeze content have no row case\n\n\n    if (this.parent.isFrozenGrid()) {\n      const movableCnt = [].slice.call(this.parent.element.querySelector('.e-movablefootercontent').getElementsByClassName('e-summaryrow'));\n      let frozenCnt;\n\n      if (frzCols) {\n        frozenCnt = [].slice.call(this.parent.element.querySelector('.e-frozen-left-footercontent').getElementsByClassName('e-summaryrow'));\n        this.refreshHeight(frozenCnt, movableCnt);\n        const frozenDiv = this.frozenContent;\n\n        if (!frozenDiv.offsetHeight) {\n          frozenDiv.style.height = this.getTable().offsetHeight + 'px';\n        }\n      }\n\n      if (right) {\n        const frCnt = [].slice.call(this.parent.element.querySelector('.e-frozen-right-footercontent').getElementsByClassName('e-summaryrow'));\n        this.refreshHeight(frCnt, movableCnt);\n\n        if (frozenCnt) {\n          this.refreshHeight(frCnt, frozenCnt);\n        }\n\n        const frDiv = this.frTable;\n\n        if (!frDiv.offsetHeight) {\n          frDiv.style.height = this.getTable().offsetHeight + 'px';\n        }\n      }\n\n      if (this.parent.allowResizing) {\n        this.updateFooterTableWidth(this.getTable());\n      }\n    }\n\n    this.onScroll();\n  }\n\n  refreshHeight(frozenCnt, movableCnt) {\n    for (let i = 0; i < frozenCnt.length; i++) {\n      const frozenHeight$$1 = frozenCnt[i].getBoundingClientRect().height;\n      const movableHeight = movableCnt[i].getBoundingClientRect().height;\n\n      if (frozenHeight$$1 < movableHeight) {\n        frozenCnt[i].classList.remove('e-hide');\n        frozenCnt[i].style.height = movableHeight + 'px';\n      } else if (frozenHeight$$1 > movableHeight) {\n        movableCnt[i].classList.remove('e-hide');\n        movableCnt[i].style.height = frozenHeight$$1 + 'px';\n      }\n    }\n  }\n\n  refreshCol() {\n    // frozen table\n    let mheaderCol;\n    const fheaderCol = mheaderCol = this.parent.element.querySelector('.' + gridHeader).querySelector(colGroup).cloneNode(true);\n\n    if (this.parent.getFrozenColumns()) {\n      // eslint-disable-next-line max-len\n      const isXaxis = this.parent.enableColumnVirtualization && this.parent.contentModule.isXaxis();\n\n      if (isXaxis) {\n        mheaderCol = this.parent.getMovableVirtualHeader().querySelector(colGroup).cloneNode(true);\n      } else {\n        mheaderCol = renderMovable(fheaderCol, this.parent.getFrozenColumns(), this.parent);\n        this.freezeTable.replaceChild(fheaderCol, this.freezeTable.querySelector(colGroup));\n      }\n    }\n\n    this.getTable().replaceChild(mheaderCol, this.getColGroup());\n    this.setColGroup(mheaderCol);\n  }\n\n  onWidthChange(args) {\n    this.getColFromIndex(args.index).style.width = formatUnit(args.width);\n\n    if (this.parent.allowResizing && args.module === 'resize') {\n      this.updateFooterTableWidth(this.getTable());\n    }\n  }\n\n  onScroll(e = {\n    left: this.parent.isFrozenGrid() ? this.parent.getContent().querySelector('.' + movableContent).scrollLeft : this.parent.getContent().firstChild.scrollLeft\n  }) {\n    this.getTable().parentElement.scrollLeft = e.left;\n  }\n\n  getColFromIndex(index) {\n    const left = this.parent.getVisibleFrozenLeftCount() || this.parent.getFrozenColumns();\n    const movable = this.parent.getVisibleMovableCount();\n    const right = this.parent.getVisibleFrozenRightCount();\n    const isDrag = this.parent.isRowDragable() && !(this.parent.getFrozenMode() === 'Right') ? 1 : 0;\n\n    if (left && index < left + isDrag) {\n      return this.freezeTable.querySelector(colGroup).children[index];\n    } else if (right && index >= left + movable + isDrag) {\n      return this.frTable.querySelector(colGroup).children[index - (left ? left + movable + isDrag : left + movable)];\n    }\n\n    return this.getColGroup().children[index - (left ? left + isDrag : left)];\n  }\n\n  columnVisibilityChanged() {\n    this.refresh();\n  }\n\n  addEventListener() {\n    this.evtHandlers = [{\n      event: colGroupRefresh,\n      handler: this.refreshCol\n    }, {\n      event: columnWidthChanged,\n      handler: this.onWidthChange\n    }, {\n      event: scroll,\n      handler: this.onScroll\n    }, {\n      event: columnVisibilityChanged,\n      handler: this.columnVisibilityChanged\n    }, {\n      event: refreshFooterRenderer,\n      handler: this.refreshFooterRenderer\n    }];\n    addRemoveEventListener(this.parent, this.evtHandlers, true, this);\n  }\n\n  removeEventListener() {\n    addRemoveEventListener(this.parent, this.evtHandlers, false);\n  }\n\n  updateFooterTableWidth(tFoot) {\n    const tHead = this.parent.getHeaderTable();\n\n    if (tHead && tFoot) {\n      tFoot.style.width = tHead.style.width;\n    }\n  }\n\n  refreshFooterRenderer(editedData) {\n    const aggregates = this.onAggregates(editedData);\n    this.refresh(aggregates);\n  }\n\n  getIndexByKey(data, ds) {\n    const key = this.parent.getPrimaryKeyFieldNames()[0];\n\n    for (let i = 0; i < ds.length; i++) {\n      if (ds[i][key] === data[key]) {\n        return i;\n      }\n    }\n\n    return -1;\n  }\n\n  onAggregates(editedData) {\n    editedData = editedData instanceof Array ? editedData : [];\n    const field = this.parent.getPrimaryKeyFieldNames()[0];\n    let dataSource = [];\n    let isModified = false;\n    let batchChanges = {};\n    const gridData = 'dataSource';\n    let isFiltered = false;\n\n    if (!this.parent.renderModule.data.isRemote() && this.parent.allowFiltering && this.parent.filterSettings.columns.length) {\n      isFiltered = true;\n    }\n\n    const currentViewData = this.parent.dataSource instanceof Array ? isFiltered ? this.parent.getFilteredRecords() : this.parent.dataSource : this.parent.dataSource[gridData].json.length ? this.parent.dataSource[gridData].json : this.parent.getCurrentViewRecords();\n\n    if (this.parent.editModule) {\n      batchChanges = this.parent.editModule.getBatchChanges();\n    }\n\n    if (Object.keys(batchChanges).length) {\n      for (let i = 0; i < currentViewData.length; i++) {\n        isModified = false; // eslint-disable-next-line max-len\n\n        if (batchChanges[changedRecords].length && this.getIndexByKey(currentViewData[i], batchChanges[changedRecords]) > -1) {\n          isModified = true; // eslint-disable-next-line max-len\n\n          dataSource.push(batchChanges[changedRecords][this.getIndexByKey(currentViewData[i], batchChanges[changedRecords])]);\n        } // eslint-disable-next-line max-len\n\n\n        if (batchChanges[deletedRecords].length && this.getIndexByKey(currentViewData[i], batchChanges[deletedRecords]) > -1) {\n          isModified = true;\n        } else if (!isModified) {\n          dataSource.push(currentViewData[i]);\n        }\n      }\n\n      if (batchChanges[addedRecords].length) {\n        for (let i = 0; i < batchChanges[addedRecords].length; i++) {\n          dataSource.push(batchChanges[addedRecords][i]);\n        }\n      }\n    } else {\n      if (editedData.length) {\n        const data = iterateExtend(currentViewData);\n        dataSource = data.map(item => {\n          const idVal = DataUtil.getObject(field, item);\n          let value;\n          const hasVal = editedData.some(cItem => {\n            value = cItem;\n            return idVal === DataUtil.getObject(field, cItem);\n          });\n          return hasVal ? value : item;\n        });\n      } else {\n        dataSource = currentViewData;\n      }\n    }\n\n    const eData = editedData;\n\n    if (eData.type && eData.type === 'cancel') {\n      dataSource = currentViewData;\n    }\n\n    const aggregate = {};\n    let agrVal;\n    const aggregateRows = this.parent.aggregates;\n\n    for (let i = 0; i < aggregateRows.length; i++) {\n      for (let j = 0; j < aggregateRows[i].columns.length; j++) {\n        let data = [];\n        const type = aggregateRows[i].columns[j].type.toString();\n        data = dataSource;\n        agrVal = calculateAggregate(type, data, aggregateRows[i].columns[j], this.parent);\n        aggregate[aggregateRows[i].columns[j].field + ' - ' + type.toLowerCase()] = agrVal;\n      }\n    }\n\n    const result = {\n      result: dataSource,\n      count: dataSource.length,\n      aggregates: aggregate\n    };\n    return result;\n  }\n\n}\n/**\n * SummaryCellRenderer class which responsible for building summary cell content.\n *\n * @hidden\n */\n\n\nclass SummaryCellRenderer extends CellRenderer {\n  constructor() {\n    super(...arguments);\n    this.element = this.parent.createElement('TD', {\n      className: 'e-summarycell',\n      attrs: {\n        role: 'gridcell',\n        tabindex: '-1'\n      }\n    });\n  }\n\n  getValue(field, data, column) {\n    const key = !isNullOrUndefined(column.type) ? column.field + ' - ' + (typeof column.type === 'string' ? column.type.toLowerCase() : '') : column.columnName;\n    return data[column.columnName] ? data[column.columnName][key] : '';\n  } // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  evaluate(node, cell, data, attributes$$1) {\n    const column = cell.column;\n    this.parent.on(refreshAggregateCell, this.refreshWithAggregate(node, cell), this);\n\n    if (!(column.footerTemplate || column.groupFooterTemplate || column.groupCaptionTemplate)) {\n      if (this.parent.rowRenderingMode === 'Vertical') {\n        node.style.display = 'none';\n      }\n\n      return true;\n    } else {\n      if (this.parent.rowRenderingMode === 'Vertical') {\n        node.classList.add('e-lastsummarycell');\n      }\n    }\n\n    const tempObj = column.getTemplate(cell.cellType);\n    const tempID = '';\n    const gColumn = this.parent.getColumnByField(data[column.columnName].field);\n\n    if (!isNullOrUndefined(gColumn)) {\n      data[column.columnName].headerText = gColumn.headerText;\n\n      if (gColumn.isForeignColumn()) {\n        const fData = gColumn.columnData.filter(e => {\n          return e[gColumn.foreignKeyField] === data[column.columnName].key;\n        })[0];\n\n        if (fData) {\n          data[column.columnName].foreignKey = fData[gColumn.foreignKeyValue];\n        }\n      }\n    }\n\n    const isReactCompiler = this.parent.isReact && (column.footerTemplate ? typeof column.footerTemplate !== 'string' : column.groupFooterTemplate ? typeof column.groupFooterTemplate !== 'string' : column.groupCaptionTemplate ? typeof column.groupCaptionTemplate !== 'string' : false);\n\n    if (isReactCompiler) {\n      const prop = data[column.columnName];\n\n      if (tempObj.property === 'groupCaptionTemplate' || tempObj.property === 'groupFooterTemplate') {\n        const groupKey = 'groupKey';\n        const key = 'key';\n        prop[groupKey] = prop[key];\n      }\n\n      tempObj.fn(prop, this.parent, tempObj.property, tempID, null, null, node);\n      this.parent.renderTemplates();\n    } else {\n      appendChildren(node, tempObj.fn(data[column.columnName], this.parent, tempObj.property, tempID));\n    }\n\n    return false;\n  }\n\n  refreshWithAggregate(node, cell) {\n    const cellNode = cell;\n    return args => {\n      const cell = cellNode;\n      const field = cell.column.columnName ? cell.column.columnName : null;\n      const curCell = !isNullOrUndefined(field) ? args.cells.filter(cell => cell.column.columnName === field)[0] : null;\n\n      if (node.parentElement && node.parentElement.getAttribute('data-uid') === args.dataUid && field && field === curCell.column.columnName) {\n        this.refreshTD(node, curCell, args.data);\n      }\n    };\n  }\n\n}\n/**\n * Summary Action controller.\n */\n\n\nclass Aggregate {\n  constructor(parent, locator) {\n    this.parent = parent;\n    this.locator = locator;\n    this.addEventListener();\n  }\n\n  getModuleName() {\n    return 'aggregate';\n  }\n\n  initiateRender() {\n    const cellFac = this.locator.getService('cellRendererFactory');\n    const instance = new SummaryCellRenderer(this.parent, this.locator);\n    const type = [CellType.Summary, CellType.CaptionSummary, CellType.GroupSummary];\n\n    for (let i = 0; i < type.length; i++) {\n      cellFac.addCellRenderer(type[i], instance);\n    }\n\n    this.footerRenderer = new FooterRenderer(this.parent, this.locator);\n    this.footerRenderer.renderPanel();\n    this.footerRenderer.renderTable();\n    const footerContent = this.footerRenderer.getPanel();\n\n    if (this.parent.element.scrollHeight >= this.parent.getHeight(this.parent.height) && footerContent) {\n      addClass([footerContent], ['e-footerpadding']);\n    }\n\n    this.locator.register('footerRenderer', this.footerRenderer);\n\n    const fn = () => {\n      this.prepareSummaryInfo();\n      this.parent.off(dataReady, fn);\n    };\n\n    this.parent.on(dataReady, fn, this);\n    this.parent.on(dataReady, this.footerRenderer.refresh, this.footerRenderer);\n  }\n  /**\n   * @returns {void}\n   * @hidden\n   */\n\n\n  prepareSummaryInfo() {\n    summaryIterator(this.parent.aggregates, column => {\n      const cFormat = getValue('customFormat', column);\n\n      if (!isNullOrUndefined(cFormat)) {\n        column.setPropertiesSilent({\n          format: cFormat\n        });\n      }\n\n      if (typeof column.format === 'object') {\n        const valueFormatter = new ValueFormatter();\n        column.setFormatter(valueFormatter.getFormatFunction(extend({}, column.format)));\n      } else if (typeof column.format === 'string') {\n        const fmtr = this.locator.getService('valueFormatter');\n        column.setFormatter(fmtr.getFormatFunction({\n          format: column.format\n        }));\n      }\n\n      column.setPropertiesSilent({\n        columnName: column.columnName || column.field\n      });\n    });\n  }\n\n  onPropertyChanged(e) {\n    if (e.module !== this.getModuleName()) {\n      return;\n    }\n\n    if (isNullOrUndefined(this.footerRenderer)) {\n      this.initiateRender();\n    }\n\n    this.prepareSummaryInfo();\n    this.footerRenderer.refresh();\n    const cModel = new CaptionSummaryModelGenerator(this.parent);\n    const gModel = new GroupSummaryModelGenerator(this.parent);\n\n    if (gModel.getData().length !== 0 || !cModel.isEmpty()) {\n      this.parent.notify(modelChanged, {});\n    }\n  }\n\n  addEventListener() {\n    if (this.parent.isDestroyed) {\n      return;\n    }\n\n    this.parent.on(initialEnd, this.initiateRender, this);\n    this.parent.on(uiUpdate, this.onPropertyChanged, this);\n    this.parent.on(refreshAggregates, this.refresh, this);\n    this.parent.on(destroy, this.destroy, this);\n  }\n\n  removeEventListener() {\n    if (this.parent.isDestroyed) {\n      return;\n    }\n\n    this.footerRenderer.removeEventListener();\n    this.parent.off(initialEnd, this.initiateRender);\n    this.parent.off(dataReady, this.footerRenderer.refresh);\n    this.parent.off(uiUpdate, this.onPropertyChanged);\n    this.parent.off(refreshAggregates, this.refresh);\n    this.parent.off(destroy, this.destroy);\n    remove(this.parent.element.querySelector('.' + gridFooter));\n  }\n\n  destroy() {\n    this.removeEventListener();\n  }\n\n  refresh(data) {\n    const editedData = data instanceof Array ? data : [data];\n    this.parent.notify(refreshFooterRenderer, editedData);\n\n    if (this.parent.groupSettings.columns.length > 0) {\n      this.parent.notify(groupAggregates, editedData);\n    }\n  }\n\n}\n/**\n * @param {AggregateRowModel[]} aggregates - specifies the AggregateRowModel\n * @param {Function} callback - specifies the Function\n * @returns {void}\n * @private\n */\n\n\nfunction summaryIterator(aggregates, callback) {\n  for (let i = 0; i < aggregates.length; i++) {\n    for (let j = 0; j < aggregates[i].columns.length; j++) {\n      callback(aggregates[i].columns[j], aggregates[i]);\n    }\n  }\n}\n/**\n * InterSectionObserver - class watch whether it enters the viewport.\n *\n * @hidden\n */\n\n\nclass InterSectionObserver {\n  constructor(element, options, movableEle) {\n    this.fromWheel = false;\n    this.touchMove = false;\n    this.options = {};\n    this.sentinelInfo = {\n      'up': {\n        check: (rect, info) => {\n          const top = rect.top - this.containerRect.top;\n          info.entered = top >= 0;\n          return top + this.options.pageHeight / 2 >= 0;\n        },\n        axis: 'Y'\n      },\n      'down': {\n        check: (rect, info) => {\n          const bottom = rect.bottom;\n          info.entered = rect.bottom <= this.containerRect.bottom;\n          return bottom - this.containerRect.top - this.options.pageHeight / 2 <= this.options.pageHeight / 2;\n        },\n        axis: 'Y'\n      },\n      'right': {\n        check: (rect, info) => {\n          const right = rect.right;\n\n          if (this.movableEle) {\n            info.entered = right < this.movableContainerRect.right;\n            return right - this.movableContainerRect.width <= this.movableContainerRect.right;\n          }\n\n          info.entered = right < this.containerRect.right;\n          return right - this.containerRect.width <= this.containerRect.right;\n        },\n        axis: 'X'\n      },\n      'left': {\n        check: (rect, info) => {\n          const left = rect.left;\n          info.entered = left > 0;\n\n          if (this.movableEle) {\n            return left + this.movableContainerRect.width >= this.movableContainerRect.left;\n          }\n\n          return left + this.containerRect.width >= this.containerRect.left;\n        },\n        axis: 'X'\n      }\n    };\n    this.element = element;\n    this.options = options;\n    this.movableEle = movableEle;\n  }\n\n  observe(callback, onEnterCallback) {\n    this.containerRect = this.options.container.getBoundingClientRect();\n    EventHandler.add(this.options.container, 'wheel', () => this.fromWheel = true, this);\n    EventHandler.add(this.options.container, 'scroll', this.virtualScrollHandler(callback, onEnterCallback), this);\n\n    if (this.options.movableContainer) {\n      this.movableContainerRect = this.options.movableContainer.getBoundingClientRect();\n      EventHandler.add(this.options.scrollbar, 'wheel', () => this.fromWheel = true, this);\n      EventHandler.add(this.options.scrollbar, 'scroll', this.virtualScrollHandler(callback, onEnterCallback), this);\n    }\n  }\n\n  check(direction) {\n    const info = this.sentinelInfo[direction];\n\n    if (this.movableContainerRect && (direction === 'left' || direction === 'right')) {\n      return info.check(this.movableEle.getBoundingClientRect(), info);\n    }\n\n    return info.check(this.element.getBoundingClientRect(), info);\n  }\n\n  virtualScrollHandler(callback, onEnterCallback) {\n    const delay = Browser.info.name === 'chrome' ? 200 : 100;\n    const debounced100 = debounce(callback, delay);\n    const debounced50 = debounce(callback, 50);\n    this.options.prevTop = this.options.prevLeft = 0;\n    return e => {\n      const top = this.options.movableContainer ? this.options.container.scrollTop : e.target.scrollTop;\n      const left = this.options.movableContainer ? this.options.scrollbar.scrollLeft : e.target.scrollLeft;\n      let direction = this.options.prevTop < top ? 'down' : 'up';\n      direction = this.options.prevLeft === left ? direction : this.options.prevLeft < left ? 'right' : 'left';\n      this.options.prevTop = top;\n      this.options.prevLeft = left;\n      const current = this.sentinelInfo[direction];\n\n      if (this.options.axes.indexOf(current.axis) === -1) {\n        return;\n      }\n\n      const check = this.check(direction);\n\n      if (current.entered) {\n        if (this.movableEle && (direction === 'right' || direction === 'left')) {\n          onEnterCallback(this.movableEle, current, direction, {\n            top: top,\n            left: left\n          }, this.fromWheel, check);\n        } else {\n          onEnterCallback(this.element, current, direction, {\n            top: top,\n            left: left\n          }, this.fromWheel, check);\n        }\n      }\n\n      if (check) {\n        let fn = debounced100; //this.fromWheel ? this.options.debounceEvent ? debounced100 : callback : debounced100;\n\n        if (current.axis === 'X') {\n          fn = debounced50;\n        }\n\n        fn({\n          direction: direction,\n          sentinel: current,\n          offset: {\n            top: top,\n            left: left\n          },\n          focusElement: document.activeElement\n        });\n      }\n\n      this.fromWheel = false;\n    };\n  }\n\n  setPageHeight(value) {\n    this.options.pageHeight = value;\n  }\n\n}\n/**\n * Content module is used to render grid content\n */\n\n\nclass VirtualRowModelGenerator {\n  constructor(parent) {\n    this.cOffsets = {};\n    this.cache = {};\n    this.movableCache = {};\n    this.frozenRightCache = {};\n    this.rowCache = {};\n    this.data = {};\n    this.groups = {};\n    this.currentInfo = {};\n    this.parent = parent;\n    this.model = this.parent.pageSettings;\n    this.rowModelGenerator = this.parent.allowGrouping ? new GroupModelGenerator(this.parent) : new RowModelGenerator(this.parent);\n  }\n\n  generateRows(data, e) {\n    const isFrozen = this.parent.isFrozenGrid();\n    let isManualRefresh = false;\n    const info = e.virtualInfo = e.virtualInfo || this.getData();\n    const xAxis = info.sentinelInfo && info.sentinelInfo.axis === 'X';\n    const page = !xAxis && info.loadNext && !info.loadSelf ? info.nextInfo.page : info.page;\n    let result = [];\n    let indexes = this.getBlockIndexes(page);\n    const loadedBlocks = [];\n\n    if (this.currentInfo.blockIndexes) {\n      indexes = info.blockIndexes = e.virtualInfo.blockIndexes = this.includePrevPage ? this.currentInfo.blockIndexes.slice(1) : this.currentInfo.blockIndexes.slice(0, this.currentInfo.blockIndexes.length - 1);\n      isManualRefresh = true;\n    }\n\n    if (isFrozen && this.parent.getFrozenMode() !== leftRight && !e.renderMovableContent || this.parent.getFrozenMode() === leftRight && !e.renderMovableContent && !e.renderFrozenRightContent || !isFrozen) {\n      this.checkAndResetCache(e.requestType);\n    }\n\n    if (isGroupAdaptive(this.parent) && this.parent.vcRows.length) {\n      return result = this.parent.vcRows;\n    }\n\n    if (this.parent.enableColumnVirtualization) {\n      for (let i = 0; i < info.blockIndexes.length; i++) {\n        if (this.isBlockAvailable(info.blockIndexes[i])) {\n          this.cache[info.blockIndexes[i]] = this.rowModelGenerator.refreshRows(this.cache[info.blockIndexes[i]]);\n        }\n\n        if (e.renderMovableContent && this.isMovableBlockAvailable(info.blockIndexes[i]) || e.renderFrozenRightContent && this.isFrozenRightBlockAvailable(info.blockIndexes[i])) {\n          const cache = e.renderMovableContent ? this.movableCache : this.frozenRightCache;\n          cache[info.blockIndexes[i]] = this.rowModelGenerator.refreshRows(cache[info.blockIndexes[i]]);\n        }\n      }\n    }\n\n    const values = info.blockIndexes;\n\n    for (let i = 0; i < values.length; i++) {\n      if (!this.isBlockAvailable(values[i])) {\n        const startIdx = !isNullOrUndefined(this.startIndex) ? this.startIndex : this.getStartIndex(values[i], data);\n        const rows = this.rowModelGenerator.generateRows(data, {\n          virtualInfo: info,\n          startIndex: startIdx\n        });\n\n        if (isGroupAdaptive(this.parent) && !this.parent.vcRows.length) {\n          this.parent.vRows = rows;\n          this.parent.vcRows = rows;\n          this.parent.notify(refreshVirtualMaxPage, {});\n        }\n\n        let median;\n\n        if (isGroupAdaptive(this.parent)) {\n          this.getGroupVirtualRecordsByIndex(rows);\n        } else {\n          if (isManualRefresh) {\n            this.setBlockForManualRefresh(this.cache, indexes, rows);\n          } else {\n            median = ~~Math.max(rows.length, this.model.pageSize) / 2;\n\n            if (!this.isBlockAvailable(indexes[0])) {\n              this.cache[indexes[0]] = rows.slice(0, median);\n            }\n\n            if (!this.isBlockAvailable(indexes[1])) {\n              this.cache[indexes[1]] = rows.slice(median);\n            }\n          }\n        }\n      }\n\n      if (this.parent.groupSettings.columns.length && !xAxis && this.cache[values[i]]) {\n        this.cache[values[i]] = this.updateGroupRow(this.cache[values[i]], values[i]);\n      }\n\n      if (e.renderMovableContent && !this.isMovableBlockAvailable(values[i]) || e.renderFrozenRightContent && !this.isFrozenRightBlockAvailable(values[i])) {\n        const cache = e.renderMovableContent ? this.movableCache : this.frozenRightCache;\n        const startIdx = !isNullOrUndefined(this.startIndex) ? this.startIndex : this.getStartIndex(values[i], data);\n        const rows = this.rowModelGenerator.generateRows(data, {\n          virtualInfo: info,\n          startIndex: startIdx\n        });\n\n        if (isManualRefresh) {\n          this.setBlockForManualRefresh(cache, indexes, rows);\n        } else {\n          const median = ~~Math.max(rows.length, this.model.pageSize) / 2;\n\n          if (e.renderFrozenRightContent && !this.isFrozenRightBlockAvailable(indexes[0]) || e.renderMovableContent && !this.isMovableBlockAvailable(indexes[0])) {\n            cache[indexes[0]] = rows.slice(0, median);\n          }\n\n          if (e.renderFrozenRightContent && !this.isFrozenRightBlockAvailable(indexes[1]) || e.renderMovableContent && !this.isMovableBlockAvailable(indexes[1])) {\n            cache[indexes[1]] = rows.slice(median);\n          }\n        }\n      }\n\n      if (!e.renderMovableContent && !e.renderFrozenRightContent && this.cache[values[i]]) {\n        result.push(...this.cache[values[i]]);\n      } else {\n        const cache = e.renderMovableContent ? this.movableCache : this.frozenRightCache;\n\n        if (cache[values[i]]) {\n          result.push(...cache[values[i]]);\n        }\n      }\n\n      if (this.isBlockAvailable(values[i])) {\n        loadedBlocks.push(values[i]);\n      }\n    }\n\n    info.blockIndexes = loadedBlocks;\n    const grouping = 'records';\n\n    if (this.parent.allowGrouping && this.parent.groupSettings.columns.length) {\n      this.parent.currentViewData[grouping] = result.map(m => m.data);\n    } else if (isFrozen) {\n      if (e.renderMovableContent && (this.parent.getFrozenMode() === 'Left' || this.parent.getFrozenMode() === 'Right' || this.parent.getFrozenColumns()) || e.renderFrozenRightContent) {\n        this.parent.currentViewData = result.map(m => m.data);\n      }\n    } else {\n      this.parent.currentViewData = result.map(m => m.data);\n    }\n\n    return result;\n  }\n\n  setBlockForManualRefresh(cache, blocks, rows) {\n    const size = this.model.pageSize / 2;\n\n    if (this.includePrevPage) {\n      cache[blocks[0] - 1] = rows.slice(0, size);\n      cache[blocks[0]] = rows.slice(size, size * 2);\n      cache[blocks[1]] = rows.slice(size * 2, size * 3);\n      cache[blocks[2]] = rows.slice(size * 3, size * 4);\n    } else {\n      cache[blocks[0]] = rows.slice(0, size);\n      cache[blocks[1]] = rows.slice(size, size * 2);\n      cache[blocks[2]] = rows.slice(size * 2, size * 3);\n      cache[blocks[2] + 1] = rows.slice(size * 3, size * 4);\n    }\n  }\n\n  getBlockIndexes(page) {\n    return [page + (page - 1), page * 2];\n  }\n\n  getPage(block) {\n    return block % 2 === 0 ? block / 2 : (block + 1) / 2;\n  }\n\n  isBlockAvailable(value) {\n    return value in this.cache;\n  }\n\n  isMovableBlockAvailable(value) {\n    return value in this.movableCache;\n  }\n\n  isFrozenRightBlockAvailable(value) {\n    return value in this.frozenRightCache;\n  }\n\n  getData() {\n    return {\n      page: this.model.currentPage,\n      blockIndexes: this.getBlockIndexes(this.model.currentPage),\n      direction: 'down',\n      columnIndexes: this.parent.getColumnIndexesInView()\n    };\n  }\n\n  getStartIndex(blk, data, full = true) {\n    const page = this.getPage(blk);\n    const even = blk % 2 === 0;\n    const index = (page - 1) * this.model.pageSize;\n    return full || !even ? index : index + ~~(this.model.pageSize / 2);\n  }\n\n  getColumnIndexes(content$$1 = this.parent.getHeaderContent().querySelector('.' + headerContent)) {\n    if (this.parent.isFrozenGrid()) {\n      content$$1 = content$$1.querySelector('.' + movableHeader);\n    }\n\n    const indexes = [];\n    let sLeft = content$$1.scrollLeft | 0;\n    const keys = Object.keys(this.cOffsets);\n    const cWidth = content$$1.getBoundingClientRect().width;\n    sLeft = Math.min(this.cOffsets[keys.length - 1] - cWidth, sLeft);\n    const calWidth = Browser.isDevice ? 2 * cWidth : cWidth / 2;\n    const left = sLeft + cWidth + (sLeft === 0 ? calWidth : 0);\n    keys.some(offset => {\n      const iOffset = Number(offset);\n      const offsetVal = this.cOffsets[offset];\n      const border = sLeft - calWidth <= offsetVal && left + calWidth >= offsetVal;\n\n      if (border) {\n        indexes.push(iOffset);\n      }\n\n      return left + calWidth < offsetVal;\n    });\n    this.addFrozenIndex(indexes);\n    return indexes;\n  }\n\n  addFrozenIndex(indexes) {\n    if (this.parent.getFrozenColumns() && this.parent.enableColumnVirtualization && indexes[0] === 0) {\n      for (let i = 0; i < this.parent.getFrozenColumns(); i++) {\n        indexes.push(indexes[indexes.length - 1] + 1);\n      }\n    }\n  }\n\n  checkAndResetCache(action) {\n    const actions = ['paging', 'refresh', 'sorting', 'filtering', 'searching', 'grouping', 'ungrouping', 'reorder', 'save', 'delete'];\n\n    if (this.parent.getFrozenColumns() && this.parent.frozenRows && this.parent.enableColumnVirtualization && action === 'reorder') {\n      actions.splice(actions.indexOf(action), 1);\n    }\n\n    const clear = actions.some(value => action === value);\n\n    if (clear) {\n      this.cache = {};\n      this.data = {};\n      this.groups = {};\n      this.movableCache = {};\n      this.frozenRightCache = {};\n    }\n\n    return clear;\n  }\n\n  refreshColOffsets() {\n    let col = 0;\n    this.cOffsets = {};\n    const gLen = this.parent.groupSettings.columns.length;\n    const cols = this.parent.columns;\n    const cLen = cols.length;\n\n    const isVisible = column => column.visible && (!this.parent.groupSettings.showGroupedColumn ? this.parent.groupSettings.columns.indexOf(column.field) < 0 : column.visible);\n\n    const c = this.parent.groupSettings.columns;\n\n    for (let i = 0; i < c.length; i++) {\n      this.cOffsets[i] = (this.cOffsets[i - 1] | 0) + 30;\n    } // eslint-disable-next-line prefer-spread\n\n\n    const blocks = Array.apply(null, Array(cLen)).map(() => col++);\n\n    for (let j = 0; j < blocks.length; j++) {\n      blocks[j] = blocks[j] + gLen;\n      this.cOffsets[blocks[j]] = (this.cOffsets[blocks[j] - 1] | 0) + (isVisible(cols[j]) ? parseInt(cols[j].width, 10) : 0);\n    }\n  }\n\n  updateGroupRow(current, block) {\n    const currentFirst = current[0];\n    let rows = [];\n    const keys = Object.keys(this.cache);\n\n    for (let i = 0; i < keys.length; i++) {\n      if (Number(keys[i]) < block) {\n        rows = [...rows, ...this.cache[keys[i]]];\n      }\n    }\n\n    if (currentFirst && currentFirst.isDataRow || block % 2 === 0) {\n      return current;\n    }\n\n    return this.iterateGroup(current, rows);\n  }\n\n  iterateGroup(current, rows) {\n    const currentFirst = current[0];\n    let offset = 0;\n\n    if (currentFirst && currentFirst.isDataRow) {\n      return current;\n    }\n\n    const isPresent = current.some(row$$1 => {\n      return rows.some((oRow, index) => {\n        const res = oRow && oRow.data.field !== undefined && oRow.data.field === row$$1.data.field && oRow.data.key === row$$1.data.key;\n\n        if (res) {\n          offset = index;\n        }\n\n        return res;\n      });\n    });\n\n    if (isPresent) {\n      current.shift();\n      current = this.iterateGroup(current, rows.slice(offset));\n    }\n\n    return current;\n  }\n\n  getRows() {\n    let rows = [];\n    const keys = Object.keys(this.cache);\n\n    for (let i = 0; i < keys.length; i++) {\n      rows = [...rows, ...this.cache[keys[i]]];\n    }\n\n    return rows;\n  }\n\n  generateCells(foreignKeyData$$1) {\n    const cells = [];\n    const cols = this.parent.columnModel;\n\n    for (let i = 0; i < cols.length; i++) {\n      cells.push(this.rowModelGenerator.generateCell(cols[i], null, null, null, null, foreignKeyData$$1));\n    }\n\n    return cells;\n  }\n\n  getGroupVirtualRecordsByIndex(rows) {\n    const blocks = this.parent.contentModule.getGroupedTotalBlocks();\n    const blockSize = this.parent.contentModule.getBlockSize();\n\n    for (let i = 1; i <= blocks; i++) {\n      let count = 0;\n      this.cache[i] = [];\n\n      for (let j = (i - 1) * blockSize; j < rows.length; j++) {\n        if (count === blockSize) {\n          break;\n        }\n\n        this.cache[i].push(rows[j]);\n\n        if (rows[j].isDataRow) {\n          count++;\n        }\n      }\n    }\n  }\n\n}\n/**\n * VirtualContentRenderer\n *\n * @hidden\n */\n\n\nclass VirtualContentRenderer extends ContentRender {\n  constructor(parent, locator) {\n    super(parent, locator);\n    this.prevHeight = 0;\n    /** @hidden */\n\n    this.startIndex = 0;\n    this.preStartIndex = 0;\n    this.preventEvent = false;\n    this.actions = ['filtering', 'searching', 'grouping', 'ungrouping'];\n    /** @hidden */\n\n    this.offsets = {};\n    this.tmpOffsets = {};\n    /** @hidden */\n\n    this.virtualEle = new VirtualElementHandler();\n    this.offsetKeys = [];\n    this.isFocused = false;\n    this.isSelection = false;\n    this.isBottom = false;\n    this.rndrCount = 0;\n    this.empty = undefined;\n    this.isCancel = false;\n    this.requestTypes = ['beginEdit', 'cancel', 'delete', 'add', 'save'];\n    this.isNormaledit = this.parent.editSettings.mode === 'Normal';\n    /** @hidden */\n\n    this.virtualData = {};\n    this.emptyRowData = {};\n    this.vfColIndex = [];\n    this.frzIdx = 1;\n    this.isContextMenuOpen = false;\n    this.isSelectionScroll = false;\n    this.validationCheck = false;\n    this.locator = locator;\n    this.eventListener('on');\n    this.parent.on(columnVisibilityChanged, this.setVisible, this);\n    this.vgenerator = this.generator;\n  }\n\n  renderTable() {\n    this.header = this.locator.getService('rendererFactory').getRenderer(RenderType.Header);\n    super.renderTable();\n    this.virtualEle.table = this.getTable();\n    this.virtualEle.content = this.content = this.getPanel().querySelector('.' + content);\n    this.virtualEle.renderWrapper(this.parent.height);\n    this.virtualEle.renderPlaceHolder();\n    this.virtualEle.wrapper.style.position = 'absolute';\n    const debounceEvent = this.parent.dataSource instanceof DataManager && !this.parent.dataSource.dataSource.offline;\n    const opt = {\n      container: this.content,\n      pageHeight: this.getBlockHeight() * 2,\n      debounceEvent: debounceEvent,\n      axes: this.parent.enableColumnVirtualization ? ['X', 'Y'] : ['Y']\n    };\n    this.observer = new InterSectionObserver(this.virtualEle.wrapper, opt);\n  }\n\n  renderEmpty(tbody$$1) {\n    this.getTable().appendChild(tbody$$1);\n    this.virtualEle.adjustTable(0, 0);\n  }\n\n  getReorderedFrozenRows(args) {\n    const blockIndex = args.virtualInfo.blockIndexes;\n    const colsIndex = args.virtualInfo.columnIndexes;\n    const page = args.virtualInfo.page;\n    args.virtualInfo.blockIndexes = [1, 2];\n    args.virtualInfo.page = 1;\n\n    if (!args.renderMovableContent) {\n      args.virtualInfo.columnIndexes = [];\n    }\n\n    const recordslength = this.parent.getCurrentViewRecords().length;\n    const firstRecords = this.parent.renderModule.data.dataManager.dataSource.json.slice(0, recordslength);\n    const virtualRows = this.vgenerator.generateRows(firstRecords, args);\n    args.virtualInfo.blockIndexes = blockIndex;\n    args.virtualInfo.columnIndexes = colsIndex;\n    args.virtualInfo.page = page;\n    return virtualRows.splice(0, this.parent.frozenRows);\n  }\n\n  scrollListener(scrollArgs) {\n    this.scrollAfterEdit();\n\n    if (this.parent.enablePersistence) {\n      this.parent.scrollPosition = scrollArgs.offset;\n    }\n\n    if (this.preventEvent || this.parent.isDestroyed) {\n      this.preventEvent = false;\n      return;\n    }\n\n    if (isNullOrUndefined(document.activeElement)) {\n      this.isFocused = false;\n    } else {\n      this.isFocused = this.content === closest(document.activeElement, '.' + content) || this.content === document.activeElement;\n    }\n\n    const info = scrollArgs.sentinel;\n    const viewInfo = this.currentInfo = this.getInfoFromView(scrollArgs.direction, info, scrollArgs.offset);\n\n    if (isGroupAdaptive(this.parent)) {\n      if (viewInfo.blockIndexes && this.prevInfo.blockIndexes.toString() === viewInfo.blockIndexes.toString()) {\n        return;\n      } else {\n        viewInfo.event = 'refresh-virtual-block';\n\n        if (!isNullOrUndefined(viewInfo.offsets)) {\n          viewInfo.offsets.top = this.content.scrollTop;\n        }\n\n        this.parent.pageSettings.currentPage = viewInfo.page;\n        this.parent.notify(viewInfo.event, {\n          requestType: 'virtualscroll',\n          virtualInfo: viewInfo,\n          focusElement: scrollArgs.focusElement\n        });\n        return;\n      }\n    }\n\n    if (this.prevInfo && (info.axis === 'Y' && this.prevInfo.blockIndexes.toString() === viewInfo.blockIndexes.toString() || info.axis === 'X' && this.prevInfo.columnIndexes.toString() === viewInfo.columnIndexes.toString())) {\n      if (Browser.isIE) {\n        this.parent.hideSpinner();\n      }\n\n      this.requestType = this.requestType === 'virtualscroll' ? this.empty : this.requestType;\n\n      if (info.axis === 'Y') {\n        this.restoreEdit();\n      }\n\n      return;\n    }\n\n    this.parent.setColumnIndexesInView(this.parent.enableColumnVirtualization ? viewInfo.columnIndexes : []);\n    this.parent.pageSettings.currentPage = viewInfo.loadNext && !viewInfo.loadSelf ? viewInfo.nextInfo.page : viewInfo.page;\n    this.requestType = 'virtualscroll';\n    this.parent.notify(viewInfo.event, {\n      requestType: 'virtualscroll',\n      virtualInfo: viewInfo,\n      focusElement: scrollArgs.focusElement\n    });\n  }\n\n  block(blk) {\n    return this.vgenerator.isBlockAvailable(blk);\n  }\n\n  getInfoFromView(direction, info, e) {\n    let isBlockAdded = false;\n    let tempBlocks = [];\n    const infoType = {\n      direction: direction,\n      sentinelInfo: info,\n      offsets: e,\n      startIndex: this.preStartIndex,\n      endIndex: this.preEndIndex\n    };\n    infoType.page = this.getPageFromTop(e.top, infoType);\n    infoType.blockIndexes = tempBlocks = this.vgenerator.getBlockIndexes(infoType.page);\n    infoType.loadSelf = !this.vgenerator.isBlockAvailable(tempBlocks[infoType.block]);\n    const blocks = this.ensureBlocks(infoType);\n\n    if (this.activeKey === 'upArrow' && infoType.blockIndexes.toString() !== blocks.toString()) {\n      // To avoid dupilcate row index problem in key focus support\n      const newBlock = blocks[blocks.length - 1];\n\n      if (infoType.blockIndexes.indexOf(newBlock) === -1) {\n        isBlockAdded = true;\n      }\n    }\n\n    infoType.blockIndexes = blocks;\n    infoType.loadNext = !blocks.filter(val => tempBlocks.indexOf(val) === -1).every(this.block.bind(this));\n    infoType.event = infoType.loadNext || infoType.loadSelf ? modelChanged : refreshVirtualBlock;\n    infoType.nextInfo = infoType.loadNext ? {\n      page: Math.max(1, infoType.page + (direction === 'down' ? 1 : -1))\n    } : {};\n\n    if (isBlockAdded) {\n      infoType.blockIndexes = [infoType.blockIndexes[0] - 1, infoType.blockIndexes[0], infoType.blockIndexes[0] + 1];\n    }\n\n    if (this.activeKey === 'downArrow') {\n      const firstBlock = Math.ceil(this.rowIndex / this.getBlockSize());\n\n      if (firstBlock !== 1 && (infoType.blockIndexes[1] !== firstBlock || infoType.blockIndexes.length < 3)) {\n        infoType.blockIndexes = [firstBlock - 1, firstBlock, firstBlock + 1];\n      }\n    }\n\n    infoType.columnIndexes = info.axis === 'X' ? this.vgenerator.getColumnIndexes() : this.parent.getColumnIndexesInView();\n\n    if (this.parent.enableColumnVirtualization && info.axis === 'X') {\n      infoType.event = refreshVirtualBlock;\n    }\n\n    return infoType;\n  }\n\n  setKeyboardNavIndex() {\n    this.blazorDataLoad = true;\n\n    if (this.activeKey === 'downArrow' || this.activeKey === 'upArrow') {\n      this.blzRowIndex = this.activeKey === 'downArrow' ? this.rowIndex + 1 : this.rowIndex - 1;\n      document.activeElement.blur();\n    }\n  }\n\n  ensureBlocks(info) {\n    let index = info.blockIndexes[info.block];\n    let mIdx;\n    const old = index;\n    const max = Math.max;\n    let indexes = info.direction === 'down' ? [max(index, 1), ++index, ++index] : [max(index - 1, 1), index, index + 1];\n\n    if (this.parent.enableColumnVirtualization && this.parent.isFrozenGrid()) {\n      // To avoid frozen content white space issue\n      if (info.sentinelInfo.axis === 'X' || info.sentinelInfo.axis === 'Y' && info.page === this.prevInfo.page) {\n        indexes = this.prevInfo.blockIndexes;\n      }\n    }\n\n    indexes = indexes.filter((val, ind) => indexes.indexOf(val) === ind);\n\n    if (this.prevInfo.blockIndexes.toString() === indexes.toString()) {\n      return indexes;\n    }\n\n    if (info.loadSelf || info.direction === 'down' && this.isEndBlock(old)) {\n      indexes = this.vgenerator.getBlockIndexes(info.page);\n    }\n\n    indexes.some((val, ind) => {\n      const result = val === (isGroupAdaptive(this.parent) ? this.getGroupedTotalBlocks() : this.getTotalBlocks());\n\n      if (result) {\n        mIdx = ind;\n      }\n\n      return result;\n    });\n\n    if (mIdx !== undefined) {\n      indexes = indexes.slice(0, mIdx + 1);\n\n      if (info.block === 0 && indexes.length === 1 && this.vgenerator.isBlockAvailable(indexes[0] - 1)) {\n        indexes = [indexes[0] - 1, indexes[0]];\n      }\n    }\n\n    return indexes;\n  } // tslint:disable-next-line:max-func-body-length\n\n\n  appendContent(target, newChild, e) {\n    // currentInfo value will be used if there are multiple dom updates happened due to mousewheel\n    const isFrozen = this.parent.isFrozenGrid();\n    const frzCols = this.parent.getFrozenColumns() || this.parent.getFrozenLeftColumnsCount();\n    const colVFtable = this.parent.enableColumnVirtualization && isFrozen;\n    this.checkFirstBlockColIndexes(e);\n    const info = e.virtualInfo.sentinelInfo && e.virtualInfo.sentinelInfo.axis === 'Y' && this.currentInfo.page && this.currentInfo.page !== e.virtualInfo.page ? this.currentInfo : e.virtualInfo;\n    this.prevInfo = this.prevInfo || e.virtualInfo;\n    let cBlock = info.columnIndexes[0] - 1;\n\n    if (colVFtable && info.columnIndexes[0] === frzCols) {\n      cBlock = info.columnIndexes[0] - frzCols - 1;\n    }\n\n    const cOffset = this.getColumnOffset(cBlock);\n    let width;\n    const blocks = info.blockIndexes;\n\n    if (this.parent.groupSettings.columns.length) {\n      this.refreshOffsets();\n    }\n\n    if (this.parent.height === '100%') {\n      this.parent.element.style.height = '100%';\n    }\n\n    const vHeight = this.parent.height.toString().indexOf('%') < 0 ? this.content.getBoundingClientRect().height : this.parent.element.getBoundingClientRect().height;\n\n    if (!this.requestTypes.some(value => value === this.requestType)) {\n      const translate = this.getTranslateY(this.content.scrollTop, vHeight, info);\n      this.virtualEle.adjustTable(colVFtable ? 0 : cOffset, translate);\n\n      if (colVFtable) {\n        this.virtualEle.adjustMovableTable(cOffset, 0);\n      }\n    }\n\n    if (this.parent.enableColumnVirtualization) {\n      this.header.virtualEle.adjustTable(colVFtable ? 0 : cOffset, 0);\n\n      if (colVFtable) {\n        this.header.virtualEle.adjustMovableTable(cOffset, 0);\n      }\n    }\n\n    if (this.parent.enableColumnVirtualization) {\n      const cIndex = info.columnIndexes;\n      width = this.getColumnOffset(cIndex[cIndex.length - 1]) - this.getColumnOffset(cIndex[0] - 1) + '';\n\n      if (colVFtable) {\n        this.header.virtualEle.setMovableWrapperWidth(width);\n      } else {\n        this.header.virtualEle.setWrapperWidth(width);\n      }\n    }\n\n    if (colVFtable) {\n      this.virtualEle.setMovableWrapperWidth(width, Browser.isIE || Browser.info.name === 'edge');\n    } else {\n      this.virtualEle.setWrapperWidth(width, Browser.isIE || Browser.info.name === 'edge');\n    }\n\n    if (!isNullOrUndefined(target.parentNode)) {\n      remove(target);\n    }\n\n    let tbody$$1;\n\n    if (isFrozen) {\n      if (e.renderFrozenRightContent) {\n        tbody$$1 = this.parent.getContent().querySelector('.e-frozen-right-content').querySelector(tbody);\n      } else if (!e.renderMovableContent) {\n        tbody$$1 = this.parent.getFrozenVirtualContent().querySelector(tbody);\n      } else if (e.renderMovableContent) {\n        tbody$$1 = this.parent.getMovableVirtualContent().querySelector(tbody);\n      }\n    } else {\n      tbody$$1 = this.parent.element.querySelector('.' + content).querySelector(tbody);\n    }\n\n    if (tbody$$1) {\n      remove(tbody$$1);\n      target = null;\n    }\n\n    const isReact = this.parent.isReact && !isNullOrUndefined(this.parent.rowTemplate);\n\n    if (!isReact) {\n      target = this.parent.createElement(tbody);\n      target.appendChild(newChild);\n    } else {\n      target = newChild;\n    }\n\n    if (this.parent.frozenRows && e.requestType === 'virtualscroll' && this.parent.pageSettings.currentPage === 1) {\n      for (let i = 0; i < this.parent.frozenRows; i++) {\n        target.children[0].remove();\n      }\n    }\n\n    if (isFrozen) {\n      if (e.renderFrozenRightContent) {\n        this.parent.getContent().querySelector('.e-frozen-right-content').querySelector('.' + table).appendChild(target);\n        this.requestType = this.requestType === 'virtualscroll' ? this.empty : this.requestType;\n      } else if (!e.renderMovableContent) {\n        this.parent.getFrozenVirtualContent().querySelector('.' + table).appendChild(target);\n      } else if (e.renderMovableContent) {\n        this.parent.getMovableVirtualContent().querySelector('.' + table).appendChild(target);\n\n        if (this.parent.getFrozenMode() !== leftRight) {\n          this.requestType = this.requestType === 'virtualscroll' ? this.empty : this.requestType;\n        }\n      }\n\n      if (this.vfColIndex.length) {\n        e.virtualInfo.columnIndexes = info.columnIndexes = extend([], this.vfColIndex);\n        this.vfColIndex = e.renderMovableContent ? [] : this.vfColIndex;\n      }\n    } else {\n      this.getTable().appendChild(target);\n      this.requestType = this.requestType === 'virtualscroll' ? this.empty : this.requestType;\n    }\n\n    if (this.parent.groupSettings.columns.length) {\n      if (!isGroupAdaptive(this.parent) && info.direction === 'up') {\n        const blk = this.offsets[this.getTotalBlocks()] - this.prevHeight;\n        this.preventEvent = true;\n        const sTop = this.content.scrollTop;\n        this.content.scrollTop = sTop + blk;\n      }\n\n      this.setVirtualHeight();\n      this.observer.setPageHeight(this.getOffset(blocks[blocks.length - 1]) - this.getOffset(blocks[0] - 1));\n    }\n\n    this.prevInfo = info;\n\n    if (this.isFocused && this.activeKey !== 'downArrow' && this.activeKey !== 'upArrow') {\n      this.content.focus();\n    }\n\n    const lastPage = Math.ceil(this.getTotalBlocks() / 2);\n\n    if (this.isBottom) {\n      this.isBottom = false;\n      this.parent.getContent().firstElementChild.scrollTop = this.offsets[this.offsetKeys.length - 1];\n    }\n\n    if (this.parent.pageSettings.currentPage === lastPage && blocks.length === 1) {\n      this.isBottom = true;\n      this.parent.getContent().firstElementChild.scrollTop = this.offsets[this.offsetKeys.length - 2];\n    }\n\n    if (e.requestType === 'virtualscroll' && e.virtualInfo.sentinelInfo.axis === 'X') {\n      this.parent.notify(autoCol, {});\n    }\n\n    this.focusCell(e);\n    this.restoreEdit(e);\n    this.restoreAdd(e);\n    this.ensureSelectedRowPosition();\n    this.validationScrollLeft(e, isFrozen);\n\n    if (!this.initialRowTop) {\n      const gridTop = this.parent.element.getBoundingClientRect().top;\n      this.initialRowTop = this.parent.getRowByIndex(0).getBoundingClientRect().top - gridTop;\n    }\n\n    const tableName = e.tableName;\n    const isLoaded = this.parent.getFrozenMode() === 'Left-Right' ? tableName === 'frozen-right' : tableName === 'movable';\n\n    if (!isFrozen || isLoaded) {\n      this.vgenerator.startIndex = null;\n      this.vgenerator.currentInfo = {};\n      this.vgenerator.includePrevPage = null;\n    }\n  }\n\n  validationScrollLeft(e, isFrozen) {\n    const left = this.parent.getFrozenColumns();\n    const table$$1 = this.parent.getFrozenMode();\n    const trigger = !isFrozen || e && (left || table$$1 === 'Left' || table$$1 === 'Right' ? e.renderMovableContent : e.renderFrozenRightContent);\n\n    if (this.validationCheck && trigger) {\n      if (this.validationCol) {\n        const offset = this.vgenerator.cOffsets[this.validationCol.index - this.parent.getVisibleFrozenColumns() - 1];\n        this.validationCol = null;\n\n        if (this.parent.isFrozenGrid()) {\n          this.movableContent.scrollLeft = offset;\n        } else {\n          this.content.scrollLeft = offset;\n        }\n      } else {\n        this.validationCheck = false;\n        this.parent.editModule.editFormValidate();\n      }\n    }\n  }\n\n  ensureSelectedRowPosition() {\n    if (!this.isSelection && this.isSelectionScroll && !isNullOrUndefined(this.selectRowIndex)) {\n      this.isSelectionScroll = false;\n      const row$$1 = this.parent.getRowByIndex(this.selectRowIndex);\n\n      if (row$$1 && !this.isRowInView(row$$1)) {\n        this.rowSelected({\n          rowIndex: this.selectRowIndex,\n          row: row$$1\n        }, true);\n      }\n    }\n  }\n\n  checkFirstBlockColIndexes(e) {\n    if (this.parent.enableColumnVirtualization && this.parent.isFrozenGrid() && e.virtualInfo.columnIndexes[0] === 0) {\n      const indexes = [];\n      const frozenCols = this.parent.getFrozenColumns() || this.parent.getFrozenLeftColumnsCount();\n\n      if (!e.renderMovableContent && e.virtualInfo.columnIndexes.length > frozenCols) {\n        this.vfColIndex = e.virtualInfo.columnIndexes;\n\n        for (let i = 0; i < frozenCols; i++) {\n          indexes.push(i);\n        }\n\n        e.virtualInfo.columnIndexes = indexes;\n      } else if (e.renderMovableContent) {\n        if (!this.vfColIndex.length) {\n          this.vfColIndex = extend([], e.virtualInfo.columnIndexes);\n        }\n\n        e.virtualInfo.columnIndexes = extend([], this.vfColIndex);\n        e.virtualInfo.columnIndexes.splice(0, frozenCols);\n      }\n    }\n  } // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  focusCell(e) {\n    if (this.activeKey !== 'upArrow' && this.activeKey !== 'downArrow') {\n      return;\n    }\n\n    const row$$1 = this.parent.getRowByIndex(this.rowIndex); // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n    const cell = row$$1.cells[this.cellIndex];\n    cell.focus({\n      preventScroll: true\n    });\n    this.parent.selectRow(parseInt(row$$1.getAttribute(ariaRowIndex), 10));\n    this.activeKey = this.empty;\n  }\n\n  restoreEdit(e) {\n    if (this.isNormaledit) {\n      const left = this.parent.getFrozenColumns();\n      const isFrozen = e && this.parent.isFrozenGrid();\n      const table$$1 = this.parent.getFrozenMode();\n      const trigger = e && (left || table$$1 === 'Left' || table$$1 === 'Right' ? e.renderMovableContent : e.renderFrozenRightContent);\n\n      if ((!isFrozen || isFrozen && trigger) && this.parent.editSettings.allowEditing && this.parent.editModule && !isNullOrUndefined(this.editedRowIndex)) {\n        let row$$1 = this.getRowByIndex(this.editedRowIndex);\n        let content$$1 = this.content;\n        const keys = Object.keys(this.virtualData);\n        const isXaxis = e && e.virtualInfo && e.virtualInfo.sentinelInfo.axis === 'X';\n\n        if (isFrozen && isXaxis) {\n          row$$1 = this.parent.getMovableRowByIndex(this.editedRowIndex);\n          content$$1 = this.movableContent;\n        }\n\n        if (keys.length && row$$1 && !content$$1.querySelector('.' + editedRow)) {\n          const top = row$$1.getBoundingClientRect().top;\n\n          if (isXaxis || top < this.content.offsetHeight && top > this.parent.getRowHeight()) {\n            this.parent.isEdit = false;\n            this.parent.editModule.startEdit(row$$1);\n          }\n        }\n\n        if (row$$1 && this.content.querySelector('.' + editedRow) && !keys.length) {\n          const rowData = extend({}, this.getRowObjectByIndex(this.editedRowIndex));\n          this.virtualData = this.getVirtualEditedData(rowData);\n        }\n      }\n\n      this.restoreAdd(e);\n    }\n  }\n\n  getVirtualEditedData(rowData) {\n    const editForms = [].slice.call(this.parent.element.getElementsByClassName('e-gridform'));\n    const isFormDestroyed = this.parent.editModule && this.parent.editModule.formObj && this.parent.editModule.formObj.isDestroyed;\n\n    if (!isFormDestroyed) {\n      for (let i = 0; i < editForms.length; i++) {\n        rowData = this.parent.editModule.getCurrentEditedData(editForms[i], rowData);\n      }\n    }\n\n    return rowData;\n  }\n\n  restoreAdd(e) {\n    const left = this.parent.getFrozenColumns();\n    const isFrozen = e && this.parent.isFrozenGrid();\n    const table$$1 = this.parent.getFrozenMode();\n    const isXaxis = e && e.virtualInfo && e.virtualInfo.sentinelInfo && e.virtualInfo.sentinelInfo.axis === 'X';\n    const startAdd = isXaxis && isFrozen ? !(this.parent.getMovableVirtualHeader().querySelector('.' + addedRow) || this.parent.getMovableVirtualContent().querySelector('.' + addedRow)) : !this.parent.element.querySelector('.' + addedRow);\n    const trigger = e && (left || table$$1 === 'Left' || table$$1 === 'Right' ? e.renderMovableContent : e.renderFrozenRightContent);\n\n    if ((!isFrozen || isFrozen && trigger) && this.isNormaledit && this.isAdd && startAdd) {\n      const isTop = this.parent.editSettings.newRowPosition === 'Top' && this.content.scrollTop < this.parent.getRowHeight();\n      const isBottom = this.parent.editSettings.newRowPosition === 'Bottom' && this.parent.pageSettings.currentPage === this.maxPage;\n\n      if (isTop || isBottom) {\n        this.parent.isEdit = false;\n        this.parent.addRecord();\n      }\n    }\n  }\n\n  onDataReady(e) {\n    if (!isNullOrUndefined(e.count)) {\n      this.count = e.count;\n      this.maxPage = Math.ceil(e.count / this.parent.pageSettings.pageSize);\n    }\n\n    this.vgenerator.checkAndResetCache(e.requestType);\n\n    if (['refresh', 'filtering', 'searching', 'grouping', 'ungrouping', 'reorder', undefined].some(value => {\n      return e.requestType === value;\n    })) {\n      this.refreshOffsets();\n    }\n\n    this.setVirtualHeight();\n    this.resetScrollPosition(e.requestType);\n  }\n  /**\n   * @param {number} height - specifies the height\n   * @returns {void}\n   * @hidden\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  setVirtualHeight(height) {\n    const width = this.parent.enableColumnVirtualization ? this.getColumnOffset(this.parent.columns.length + this.parent.groupSettings.columns.length - 1) + 'px' : '100%';\n\n    if (this.parent.isFrozenGrid()) {\n      let virtualHeightTemp = this.parent.pageSettings.currentPage === 1 && Object.keys(this.offsets).length <= 2 ? this.offsets[1] : this.offsets[this.getTotalBlocks() - 2];\n      const scrollableElementHeight = this.content.clientHeight;\n      virtualHeightTemp = virtualHeightTemp > scrollableElementHeight ? virtualHeightTemp : 0; // To overcome the white space issue in last page (instead of position absolute)\n\n      this.virtualEle.setVirtualHeight(virtualHeightTemp, width);\n    } else {\n      const virtualHeight = this.offsets[isGroupAdaptive(this.parent) ? this.getGroupedTotalBlocks() : this.getTotalBlocks()];\n      this.virtualEle.setVirtualHeight(virtualHeight, width);\n    }\n\n    if (this.parent.enableColumnVirtualization) {\n      this.header.virtualEle.setVirtualHeight(1, width);\n\n      if (this.parent.isFrozenGrid()) {\n        this.virtualEle.setMovableVirtualHeight(1, width);\n        this.header.virtualEle.setMovableVirtualHeight(1, width);\n      }\n    }\n  }\n\n  getPageFromTop(sTop, info) {\n    const total = isGroupAdaptive(this.parent) ? this.getGroupedTotalBlocks() : this.getTotalBlocks();\n    let page = 0;\n    this.offsetKeys.some(offset => {\n      let iOffset = Number(offset);\n      const border = sTop <= this.offsets[offset] || iOffset === total && sTop > this.offsets[offset];\n\n      if (border) {\n        if (this.offsetKeys.length % 2 !== 0 && iOffset.toString() === this.offsetKeys[this.offsetKeys.length - 2] && sTop <= this.offsets[this.offsetKeys.length - 1]) {\n          iOffset = iOffset + 1;\n        }\n\n        info.block = iOffset % 2 === 0 ? 1 : 0;\n        page = Math.max(1, Math.min(this.vgenerator.getPage(iOffset), this.maxPage));\n      }\n\n      return border;\n    });\n    return page;\n  }\n\n  getTranslateY(sTop, cHeight, info, isOnenter) {\n    if (info === undefined) {\n      info = {\n        page: this.getPageFromTop(sTop, {})\n      };\n      info.blockIndexes = this.vgenerator.getBlockIndexes(info.page);\n    }\n\n    const block = (info.blockIndexes[0] || 1) - 1;\n    const translate = this.getOffset(block);\n    const endTranslate = this.getOffset(info.blockIndexes[info.blockIndexes.length - 1]);\n\n    if (isOnenter) {\n      info = this.prevInfo;\n    }\n\n    let result = translate > sTop ? this.getOffset(block - 1) : endTranslate < sTop + cHeight ? this.getOffset(block + 1) : translate;\n    const blockHeight = this.offsets[info.blockIndexes[info.blockIndexes.length - 1]] - this.tmpOffsets[info.blockIndexes[0]];\n    const totalBlocks = isGroupAdaptive(this.parent) ? this.getGroupedTotalBlocks() : this.getTotalBlocks();\n\n    if (result + blockHeight > this.offsets[totalBlocks]) {\n      result -= result + blockHeight - this.offsets[totalBlocks];\n    }\n\n    return result;\n  }\n\n  getOffset(block) {\n    return Math.min(this.offsets[block] | 0, this.offsets[this.maxBlock] | 0);\n  }\n\n  onEntered() {\n    return (element, current, direction, e, isWheel, check) => {\n      if (Browser.isIE && !isWheel && check && !this.preventEvent) {\n        this.parent.showSpinner();\n      }\n\n      const colVFtable = this.parent.enableColumnVirtualization && this.parent.isFrozenGrid();\n      const xAxis = current.axis === 'X';\n      const top = this.prevInfo.offsets ? this.prevInfo.offsets.top : null;\n      const height = this.content.getBoundingClientRect().height;\n      let x = this.getColumnOffset(xAxis ? this.vgenerator.getColumnIndexes()[0] - 1 : this.prevInfo.columnIndexes[0] - 1);\n\n      if (xAxis && !colVFtable) {\n        const idx = Object.keys(this.vgenerator.cOffsets).length - this.prevInfo.columnIndexes.length;\n        const maxLeft = this.vgenerator.cOffsets[idx - 1];\n        x = x > maxLeft ? maxLeft : x; //TODO: This fix horizontal scrollbar jumping issue in column virtualization.\n      }\n\n      const y = this.getTranslateY(e.top, height, xAxis && top === e.top ? this.prevInfo : undefined, true);\n      this.virtualEle.adjustTable(colVFtable ? 0 : x, Math.min(y, this.offsets[this.maxBlock]));\n\n      if (colVFtable) {\n        this.virtualEle.adjustMovableTable(x, 0);\n      }\n\n      if (this.parent.enableColumnVirtualization) {\n        this.header.virtualEle.adjustTable(colVFtable ? 0 : x, 0);\n\n        if (colVFtable) {\n          this.header.virtualEle.adjustMovableTable(x, 0);\n        }\n      }\n    };\n  }\n\n  dataBound() {\n    this.parent.notify(refreshVirtualFrozenHeight, {});\n\n    if (this.isSelection && this.activeKey !== 'upArrow' && this.activeKey !== 'downArrow') {\n      this.parent.selectRow(this.selectedRowIndex);\n    } else {\n      this.activeKey = this.empty;\n    }\n  }\n\n  rowSelected(args, isSelection) {\n    if ((this.isSelection || isSelection) && !this.isLastBlockRow(args.rowIndex)) {\n      const transform = getTransformValues(this.content.firstElementChild);\n      const gridTop = this.parent.element.getBoundingClientRect().top;\n      const rowTop = args.row.getBoundingClientRect().top - gridTop;\n      const height = this.content.getBoundingClientRect().height;\n      const isBottom = height < rowTop;\n      const remainHeight = isBottom ? rowTop - height : this.initialRowTop - rowTop;\n      let translateY = isBottom ? transform.height - remainHeight : transform.height + remainHeight;\n      this.virtualEle.adjustTable(transform.width, translateY);\n      const lastRowTop = this.content.querySelector('tbody').lastElementChild.getBoundingClientRect().top - gridTop;\n\n      if (lastRowTop < height) {\n        translateY = translateY + (height - (args.row.getBoundingClientRect().top - gridTop));\n        this.virtualEle.adjustTable(transform.width, translateY - this.parent.getRowHeight() / 2);\n      }\n    }\n\n    this.isSelection = false;\n  }\n\n  isLastBlockRow(index) {\n    const scrollEle = this.parent.getContent().firstElementChild;\n    const visibleRowCount = Math.floor(scrollEle.offsetHeight / this.parent.getRowHeight()) - 1;\n    const startIdx = this.maxPage * this.parent.pageSettings.pageSize - visibleRowCount;\n    return index >= startIdx;\n  }\n\n  refreshMaxPage() {\n    if (this.parent.groupSettings.columns.length && this.parent.vcRows.length) {\n      this.maxPage = Math.ceil(this.parent.vcRows.length / this.parent.pageSettings.pageSize);\n    }\n  }\n\n  setVirtualPageQuery(args) {\n    const row$$1 = this.parent.getContent().querySelector('.e-row');\n\n    if (row$$1 && this.parent.isManualRefresh && this.currentInfo.blockIndexes && this.currentInfo.blockIndexes.length === 3) {\n      this.vgenerator.startIndex = parseInt(row$$1.getAttribute('aria-rowindex'), 10);\n      this.vgenerator.currentInfo = extend({}, this.currentInfo);\n      this.vgenerator.currentInfo.blockIndexes = this.currentInfo.blockIndexes.slice();\n      const includePrevPage = this.vgenerator.includePrevPage = this.currentInfo.blockIndexes[0] % 2 === 0;\n\n      if (includePrevPage) {\n        this.vgenerator.startIndex = this.vgenerator.startIndex - this.getBlockSize();\n        this.vgenerator.currentInfo.blockIndexes.unshift(this.currentInfo.blockIndexes[0] - 1);\n      } else {\n        this.vgenerator.currentInfo.blockIndexes.push(this.currentInfo.blockIndexes[this.currentInfo.blockIndexes.length - 1] + 1);\n      }\n\n      const skip = (this.vgenerator.currentInfo.blockIndexes[0] - 1) * this.getBlockSize();\n      const take = this.vgenerator.currentInfo.blockIndexes.length * this.getBlockSize();\n      args.query.skip(skip);\n      args.query.take(take);\n      args.skipPage = true;\n    }\n  }\n\n  eventListener(action) {\n    this.parent[action](dataReady, this.onDataReady, this);\n    this.parent.addEventListener(dataBound, this.dataBound.bind(this));\n    this.parent.addEventListener(actionBegin, this.actionBegin.bind(this));\n    this.parent.addEventListener(actionComplete, this.actionComplete.bind(this));\n    this.parent.addEventListener(rowSelected, this.rowSelected.bind(this));\n    this.parent[action](refreshVirtualBlock, this.refreshContentRows, this);\n    this.parent[action](selectVirtualRow, this.selectVirtualRow, this);\n    this.parent[action](virtaulCellFocus, this.virtualCellFocus, this);\n    this.parent[action](virtualScrollEditActionBegin, this.editActionBegin, this);\n    this.parent[action](virtualScrollAddActionBegin, this.addActionBegin, this);\n    this.parent[action](virtualScrollEdit, this.restoreEdit, this);\n    this.parent[action](virtualScrollEditSuccess, this.editSuccess, this);\n    this.parent[action](refreshVirtualCache, this.refreshCache, this);\n    this.parent[action](editReset, this.resetIsedit, this);\n    this.parent[action](getVirtualData, this.getVirtualData, this);\n    this.parent[action](virtualScrollEditCancel, this.editCancel, this);\n    this.parent[action](refreshVirtualMaxPage, this.refreshMaxPage, this);\n    this.parent[action](setVirtualPageQuery, this.setVirtualPageQuery, this);\n    this.parent[action](selectRowOnContextOpen, this.selectRowOnContextOpen, this);\n    this.parent[action](resetVirtualFocus, this.resetVirtualFocus, this);\n    this.parent[action](refreshVirtualEditFormCells, this.refreshCells, this);\n    this.parent[action](scrollToEdit, this.scrollToEdit, this);\n    const event = this.actions;\n\n    for (let i = 0; i < event.length; i++) {\n      this.parent[action](`${event[i]}-begin`, this.onActionBegin, this);\n    }\n\n    const fn = () => {\n      this.observer.observe(scrollArgs => this.scrollListener(scrollArgs), this.onEntered());\n      const gObj = this.parent;\n\n      if (gObj.enablePersistence && gObj.scrollPosition) {\n        this.content.scrollTop = gObj.scrollPosition.top;\n        const scrollValues = {\n          direction: 'down',\n          sentinel: this.observer.sentinelInfo.down,\n          offset: gObj.scrollPosition,\n          focusElement: gObj.element\n        };\n        this.scrollListener(scrollValues);\n\n        if (gObj.enableColumnVirtualization) {\n          this.content.scrollLeft = gObj.scrollPosition.left;\n        }\n      }\n\n      this.parent.off(contentReady, fn);\n    };\n\n    this.parent.on(contentReady, fn, this);\n  }\n\n  scrollToEdit(col) {\n    const isFrozen = this.parent.isFrozenGrid();\n    let allowScroll = true;\n    this.validationCheck = true;\n\n    if (this.isAdd && this.content.scrollTop > 0) {\n      allowScroll = false;\n      const keys = Object.keys(this.offsets);\n      this.content.scrollTop = this.parent.editSettings.newRowPosition === 'Top' ? 0 : this.offsets[keys.length - 1];\n    }\n\n    const row$$1 = this.parent.getRowByIndex(this.editedRowIndex);\n\n    if (!row$$1 && !isNullOrUndefined(this.editedRowIndex)) {\n      if (!row$$1 || !this.isRowInView(row$$1)) {\n        const rowIndex = this.parent.getRowHeight();\n        const scrollTop = this.editedRowIndex * rowIndex;\n\n        if (!isNullOrUndefined(scrollTop)) {\n          allowScroll = false;\n          this.content.scrollTop = scrollTop;\n        }\n      }\n    }\n\n    if (col && allowScroll) {\n      let offset = this.vgenerator.cOffsets[col.index - this.parent.getVisibleFrozenColumns() - 1];\n\n      if (!this.parent.enableColumnVirtualization) {\n        const header = this.parent.getHeaderContent().querySelector('.e-headercelldiv[e-mappinguid=\"' + col.uid + '\"]');\n        offset = isFrozen ? header.parentElement.offsetLeft - this.parent.getFrozenVirtualHeader().offsetWidth : header.parentElement.offsetLeft;\n      }\n\n      if (isFrozen) {\n        this.parent.getMovableVirtualContent().scrollLeft = this.parent.enableRtl ? -Math.abs(offset) : offset;\n      } else {\n        this.content.scrollLeft = this.parent.enableRtl ? -Math.abs(offset) : offset;\n      }\n    }\n\n    if (col && !allowScroll) {\n      this.validationCol = col;\n    }\n  }\n\n  refreshCells(rowObj) {\n    rowObj.cells = this.vgenerator.generateCells(rowObj.foreignKeyData);\n  }\n\n  resetVirtualFocus(e) {\n    this.isCancel = e.isCancel;\n  }\n  /**\n   * @param {Object} data - specifies the data\n   * @param {Object} data.virtualData -specifies the data\n   * @param {boolean} data.isAdd - specifies isAdd\n   * @param {boolean} data.isCancel - specifies boolean in cancel\n   * @param {boolean} data.isScroll - specifies boolean for scroll\n   * @returns {void}\n   * @hidden\n   */\n\n\n  getVirtualData(data) {\n    if (this.isNormaledit) {\n      const error = this.parent.element.querySelector('.e-griderror:not([style*=\"display: none\"])');\n      const keys = Object.keys(this.virtualData);\n      data.isScroll = keys.length !== 0 && this.currentInfo.sentinelInfo && this.currentInfo.sentinelInfo.axis === 'X';\n\n      if (error) {\n        return;\n      }\n\n      this.virtualData = keys.length ? this.virtualData : data.virtualData;\n      this.getVirtualEditedData(this.virtualData);\n      data.virtualData = this.virtualData;\n      data.isAdd = this.isAdd;\n      data.isCancel = this.isCancel;\n    }\n  }\n\n  selectRowOnContextOpen(args) {\n    this.isContextMenuOpen = args.isOpen;\n  }\n\n  editCancel(args) {\n    const dataIndex = getEditedDataIndex(this.parent, args.data);\n\n    if (!isNullOrUndefined(dataIndex)) {\n      args.data = this.parent.getCurrentViewRecords()[dataIndex];\n    }\n  }\n\n  editSuccess(args) {\n    if (this.isNormaledit) {\n      if (!this.isAdd && args.data) {\n        this.updateCurrentViewData(args.data);\n      }\n\n      this.isAdd = false;\n    }\n  }\n\n  updateCurrentViewData(data) {\n    const dataIndex = getEditedDataIndex(this.parent, data);\n\n    if (!isNullOrUndefined(dataIndex)) {\n      this.parent.getCurrentViewRecords()[dataIndex] = data;\n    }\n  }\n\n  actionBegin(args) {\n    if (args.requestType !== 'virtualscroll') {\n      this.requestType = args.requestType;\n    }\n\n    if (!args.cancel) {\n      this.parent.notify(refreshVirtualFrozenRows, args);\n    }\n  }\n\n  virtualCellFocus(e) {\n    // To decide the action (select or scroll), when using arrow keys for cell focus\n    const ele = document.activeElement;\n\n    if (ele.classList.contains(rowCell) && e && (e.action === 'upArrow' || e.action === 'downArrow')) {\n      let rowIndex = parseInt(ele.parentElement.getAttribute(ariaRowIndex), 10);\n\n      if (e && (e.action === 'downArrow' || e.action === 'upArrow')) {\n        const scrollEle = this.parent.getContent().firstElementChild;\n\n        if (e.action === 'downArrow') {\n          rowIndex += 1;\n        } else {\n          rowIndex -= 1;\n        }\n\n        this.rowIndex = rowIndex;\n        this.cellIndex = parseInt(ele.getAttribute(ariaColIndex), 10);\n        const row$$1 = this.parent.getRowByIndex(rowIndex);\n        const page = this.parent.pageSettings.currentPage;\n        const visibleRowCount = Math.floor(scrollEle.offsetHeight / this.parent.getRowHeight()) - 1;\n        let emptyRow = false;\n\n        if (isNullOrUndefined(row$$1)) {\n          emptyRow = true;\n\n          if (e.action === 'downArrow' && page === this.maxPage - 1 || e.action === 'upArrow' && page === 1) {\n            emptyRow = false;\n          }\n        }\n\n        if (emptyRow || ensureLastRow(row$$1, this.parent) && e.action === 'downArrow' || ensureFirstRow(row$$1, this.parent.getRowHeight() * 2) && e.action === 'upArrow') {\n          this.activeKey = e.action;\n          scrollEle.scrollTop = e.action === 'downArrow' ? (rowIndex - visibleRowCount) * this.parent.getRowHeight() : rowIndex * this.parent.getRowHeight();\n        } else {\n          this.activeKey = this.empty;\n        }\n\n        this.parent.selectRow(rowIndex);\n      }\n    }\n  }\n\n  editActionBegin(e) {\n    this.editedRowIndex = e.index;\n    const rowData = extend({}, this.getRowObjectByIndex(e.index));\n    const keys = Object.keys(this.virtualData);\n    e.data = keys.length ? this.virtualData : rowData;\n    e.isScroll = keys.length !== 0 && this.currentInfo.sentinelInfo && this.currentInfo.sentinelInfo.axis === 'X';\n  }\n\n  refreshCache(args) {\n    const block = Math.ceil((this.editedRowIndex + 1) / this.getBlockSize());\n    const index = this.editedRowIndex - (block - 1) * this.getBlockSize();\n    this.vgenerator.cache[block][index].data = args.data;\n\n    if (this.vgenerator.movableCache[block]) {\n      this.vgenerator.movableCache[block][index].data = args.data;\n    }\n\n    if (this.vgenerator.frozenRightCache[block]) {\n      this.vgenerator.frozenRightCache[block][index].data = args.data;\n    }\n  }\n\n  actionComplete(args) {\n    const editRequestTypes = ['delete', 'save', 'cancel'];\n    const dataActionRequestTypes = ['sorting', 'filtering', 'grouping', 'refresh', 'searching', 'ungrouping', 'reorder'];\n\n    if (editRequestTypes.some(value => value === args.requestType)) {\n      this.refreshOffsets();\n\n      if (this.parent.isFrozenGrid()) {\n        this.vgenerator.refreshColOffsets();\n        this.parent.contentModule.virtualRenderer.virtualEle.setVirtualHeight();\n      } else {\n        this.refreshVirtualElement();\n      }\n    }\n\n    if (this.isNormaledit && (dataActionRequestTypes.some(value => value === args.requestType) || editRequestTypes.some(value => value === args.requestType))) {\n      this.isCancel = true;\n      this.isAdd = false;\n      this.editedRowIndex = this.empty;\n      this.virtualData = {};\n\n      if (this.parent.editModule) {\n        this.parent.editModule.editModule.previousData = undefined;\n      }\n    }\n\n    if (this.parent.enableColumnVirtualization && args.requestType === 'filterafteropen' && this.currentInfo.columnIndexes && this.currentInfo.columnIndexes[0] > 0) {\n      this.parent.resetFilterDlgPosition(args.columnName);\n    }\n  }\n\n  resetIsedit() {\n    if (this.parent.enableVirtualization && this.isNormaledit) {\n      if (this.parent.editSettings.allowEditing && Object.keys(this.virtualData).length || this.parent.editSettings.allowAdding && this.isAdd) {\n        this.parent.isEdit = true;\n      }\n    }\n  }\n\n  scrollAfterEdit() {\n    if (this.parent.editModule && this.parent.editSettings.allowEditing && this.isNormaledit) {\n      if (this.parent.element.querySelector('.e-gridform')) {\n        const editForm = this.parent.element.querySelector('.' + editedRow);\n        const addForm = this.parent.element.querySelector('.' + addedRow);\n\n        if (editForm || addForm) {\n          const rowData = editForm ? extend({}, this.getRowObjectByIndex(this.editedRowIndex)) : extend({}, this.emptyRowData);\n          const keys = Object.keys(this.virtualData);\n          this.virtualData = keys.length ? this.getVirtualEditedData(this.virtualData) : this.getVirtualEditedData(rowData);\n        }\n      }\n    }\n  }\n\n  createEmptyRowdata() {\n    this.parent.columnModel.filter(e => {\n      this.emptyRowData[e.field] = this.empty;\n    });\n  }\n\n  addActionBegin(args) {\n    if (this.isNormaledit) {\n      if (!Object.keys(this.emptyRowData).length) {\n        this.createEmptyRowdata();\n      }\n\n      this.isAdd = true;\n      const page = this.parent.pageSettings.currentPage;\n\n      if (!this.parent.frozenRows && this.content.scrollTop > 0 && this.parent.editSettings.newRowPosition === 'Top') {\n        this.isAdd = true;\n        this.onActionBegin();\n        args.startEdit = false;\n        this.content.scrollTop = 0;\n      }\n\n      if (page < this.maxPage - 1 && this.parent.editSettings.newRowPosition === 'Bottom') {\n        this.isAdd = true;\n        this.parent.setProperties({\n          pageSettings: {\n            currentPage: this.maxPage - 1\n          }\n        }, true);\n        args.startEdit = false;\n        this.content.scrollTop = this.offsets[this.offsetKeys.length];\n      }\n    }\n  }\n  /**\n   * @param {number} index - specifies the index\n   * @returns {Object} returns the object\n   * @hidden\n   */\n\n\n  getRowObjectByIndex(index) {\n    const data = this.getRowCollection(index, false, true);\n    return data;\n  }\n\n  getBlockSize() {\n    return this.parent.pageSettings.pageSize >> 1;\n  }\n\n  getBlockHeight() {\n    return this.getBlockSize() * this.parent.getRowHeight();\n  }\n\n  isEndBlock(index) {\n    const totalBlocks = isGroupAdaptive(this.parent) ? this.getGroupedTotalBlocks() : this.getTotalBlocks();\n    return index >= totalBlocks || index === totalBlocks - 1;\n  }\n\n  getGroupedTotalBlocks() {\n    const rows = this.parent.vcRows;\n    return Math.floor(rows.length / this.getBlockSize() < 1 ? 1 : rows.length / this.getBlockSize());\n  }\n\n  getTotalBlocks() {\n    return Math.ceil(this.count / this.getBlockSize());\n  }\n\n  getColumnOffset(block) {\n    return this.vgenerator.cOffsets[block] | 0;\n  }\n\n  getModelGenerator() {\n    return new VirtualRowModelGenerator(this.parent);\n  }\n\n  resetScrollPosition(action) {\n    if (this.actions.some(value => value === action)) {\n      this.preventEvent = this.content.scrollTop !== 0;\n      this.content.scrollTop = 0;\n    }\n\n    if (action !== 'virtualscroll') {\n      this.isAdd = false;\n    }\n  } // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  onActionBegin(e) {\n    //Update property silently..\n    this.parent.setProperties({\n      pageSettings: {\n        currentPage: 1\n      }\n    }, true);\n  }\n\n  getRows() {\n    return this.vgenerator.getRows();\n  }\n\n  getRowByIndex(index) {\n    let row$$1;\n\n    if (isGroupAdaptive(this.parent)) {\n      row$$1 = this.parent.getDataRows()[index];\n    }\n\n    if (this.prevInfo) {\n      row$$1 = this.getRowCollection(index, false);\n    }\n\n    return row$$1;\n  }\n\n  getMovableVirtualRowByIndex(index) {\n    return this.getRowCollection(index, true);\n  }\n\n  getFrozenRightVirtualRowByIndex(index) {\n    return this.getRowCollection(index, false, false, true);\n  }\n\n  getRowCollection(index, isMovable, isRowObject, isFrozenRight) {\n    const prev = this.prevInfo.blockIndexes;\n    let startIdx = (prev[0] - 1) * this.getBlockSize();\n    let rowCollection = isMovable ? this.parent.getMovableDataRows() : this.parent.getDataRows();\n    rowCollection = isFrozenRight ? this.parent.getFrozenRightDataRows() : rowCollection;\n    let collection = isRowObject ? this.parent.getCurrentViewRecords() : rowCollection;\n\n    if (isRowObject && this.parent.allowGrouping && this.parent.groupSettings.columns.length) {\n      startIdx = parseInt(this.parent.getRows()[0].getAttribute(ariaRowIndex), 10);\n      collection = collection.filter(m => {\n        return isNullOrUndefined(m.items);\n      });\n    }\n\n    let selectedRow = collection[index - startIdx];\n\n    if (this.parent.frozenRows && this.parent.pageSettings.currentPage > 1) {\n      if (!isRowObject) {\n        selectedRow = index <= this.parent.frozenRows ? rowCollection[index] : rowCollection[index - startIdx + this.parent.frozenRows];\n      } else {\n        selectedRow = index <= this.parent.frozenRows ? this.parent.getRowsObject()[index].data : selectedRow;\n      }\n    }\n\n    return selectedRow;\n  }\n\n  getVirtualRowIndex(index) {\n    const prev = this.prevInfo.blockIndexes;\n    const startIdx = (prev[0] - 1) * this.getBlockSize();\n    return startIdx + index;\n  }\n  /**\n   * @returns {void}\n   * @hidden */\n\n\n  refreshOffsets() {\n    const gObj = this.parent;\n    let row$$1 = 0;\n    const bSize = this.getBlockSize();\n    const total = isGroupAdaptive(this.parent) ? this.getGroupedTotalBlocks() : this.getTotalBlocks();\n    this.prevHeight = this.offsets[total];\n    this.maxBlock = total % 2 === 0 ? total - 2 : total - 1;\n    this.offsets = {}; //Row offset update\n    // eslint-disable-next-line prefer-spread\n\n    const blocks = Array.apply(null, Array(total)).map(() => ++row$$1);\n\n    for (let i = 0; i < blocks.length; i++) {\n      const tmp = (this.vgenerator.cache[blocks[i]] || []).length;\n      const rem = !isGroupAdaptive(this.parent) ? this.count % bSize : gObj.vcRows.length % bSize;\n      const size = !isGroupAdaptive(this.parent) && blocks[i] in this.vgenerator.cache ? tmp * this.parent.getRowHeight() : rem && blocks[i] === total ? rem * this.parent.getRowHeight() : this.getBlockHeight(); // let size: number = this.parent.groupSettings.columns.length && block in this.vgenerator.cache ?\n      // tmp * getRowHeight() : this.getBlockHeight();\n\n      this.offsets[blocks[i]] = (this.offsets[blocks[i] - 1] | 0) + size;\n      this.tmpOffsets[blocks[i]] = this.offsets[blocks[i] - 1] | 0;\n    }\n\n    this.offsetKeys = Object.keys(this.offsets);\n\n    if (isGroupAdaptive(this.parent)) {\n      this.parent.vGroupOffsets = this.offsets;\n    } //Column offset update\n\n\n    if (this.parent.enableColumnVirtualization) {\n      this.vgenerator.refreshColOffsets();\n    }\n  }\n\n  refreshVirtualElement() {\n    this.vgenerator.refreshColOffsets();\n    this.setVirtualHeight();\n  }\n\n  setVisible(columns) {\n    const gObj = this.parent;\n    const frozenCols = this.parent.getFrozenColumns();\n    let fcntColGrp;\n    let mcntColGrp;\n\n    if (frozenCols) {\n      fcntColGrp = [].slice.call(this.parent.getFrozenVirtualContent().querySelectorAll('col'));\n      mcntColGrp = [].slice.call(this.parent.getMovableVirtualContent().querySelectorAll('col'));\n    }\n\n    let rows = [];\n    rows = this.getRows();\n    let testRow;\n    rows.some(r => {\n      if (r.isDataRow) {\n        testRow = r;\n      }\n\n      return r.isDataRow;\n    });\n    let isRefresh = true;\n\n    if (!gObj.groupSettings.columns.length && testRow) {\n      isRefresh = false;\n    }\n\n    let tr = gObj.getDataRows();\n\n    for (let c = 0, clen = columns.length; c < clen; c++) {\n      const column = columns[c];\n      let idx = gObj.getNormalizedColumnIndex(column.uid);\n      const displayVal = column.visible === true ? '' : 'none';\n      let colGrp;\n\n      if (fcntColGrp && mcntColGrp) {\n        if (idx >= frozenCols) {\n          colGrp = mcntColGrp;\n          tr = this.parent.getMovableRows();\n          idx = idx - frozenCols;\n        } else {\n          colGrp = fcntColGrp;\n        }\n      } else {\n        colGrp = this.getColGroup().children;\n      }\n\n      if (idx !== -1 && testRow && idx < testRow.cells.length) {\n        setStyleAttribute(colGrp[idx], {\n          'display': displayVal\n        });\n      }\n\n      if (!isRefresh) {\n        let width;\n\n        if (column.width) {\n          if (column.visible) {\n            width = this.virtualEle.wrapper.offsetWidth + parseInt(column.width.toString(), 10);\n          } else {\n            width = this.virtualEle.wrapper.offsetWidth - parseInt(column.width.toString(), 10);\n          }\n        }\n\n        if (width > gObj.width) {\n          this.setDisplayNone(tr, idx, displayVal, rows);\n\n          if (this.parent.enableColumnVirtualization) {\n            this.virtualEle.setWrapperWidth(width + '');\n          }\n\n          this.refreshVirtualElement();\n        } else {\n          isRefresh = true;\n        }\n      }\n\n      if (!this.parent.invokedFromMedia && column.hideAtMedia) {\n        this.parent.updateMediaColumns(column);\n      }\n\n      this.parent.invokedFromMedia = false;\n    }\n\n    if (isRefresh || frozenCols) {\n      this.refreshContentRows({\n        requestType: 'refresh'\n      });\n    } else {\n      this.parent.notify(partialRefresh, {\n        rows: rows,\n        args: {\n          isFrozen: false,\n          rows: rows\n        }\n      });\n    }\n  }\n\n  selectVirtualRow(args) {\n    args.isAvailable = args.selectedIndex < this.count;\n\n    if (args.isAvailable && !this.isContextMenuOpen && this.activeKey !== 'upArrow' && this.activeKey !== 'downArrow' && !this.isSelection && !this.requestTypes.some(value => value === this.requestType) && !this.parent.selectionModule.isInteracted) {\n      const selectedRow = this.parent.getRowByIndex(args.selectedIndex);\n      const rowHeight = this.parent.getRowHeight();\n\n      if (!selectedRow || !this.isRowInView(selectedRow)) {\n        this.isSelection = true;\n        this.selectedRowIndex = args.selectedIndex;\n        const scrollTop = (args.selectedIndex + 1) * rowHeight;\n\n        if (!isNullOrUndefined(scrollTop)) {\n          const direction = this.content.scrollTop < scrollTop ? 'down' : 'up';\n          this.selectRowIndex = args.selectedIndex;\n          this.content.scrollTop = scrollTop;\n          this.isSelectionScroll = this.observer.check(direction);\n        }\n      }\n    }\n\n    if (this.parent.isFrozenGrid() && this.requestType) {\n      if (this.parent.getTablesCount() === this.frzIdx) {\n        this.requestType = this.empty;\n        this.frzIdx = 1;\n      } else {\n        this.frzIdx++;\n      }\n    } else {\n      this.requestType = this.empty;\n    }\n  }\n\n  isRowInView(row$$1) {\n    const top = row$$1.getBoundingClientRect().top;\n    const bottom = row$$1.getBoundingClientRect().bottom;\n    return top >= this.content.getBoundingClientRect().top && bottom <= this.content.getBoundingClientRect().bottom;\n  }\n\n}\n/**\n * @hidden\n */\n\n\nclass VirtualHeaderRenderer extends HeaderRender {\n  constructor(parent, locator) {\n    super(parent, locator);\n    this.virtualEle = new VirtualElementHandler();\n    this.isMovable = false;\n    this.gen = new VirtualRowModelGenerator(this.parent);\n    this.parent.on(columnVisibilityChanged, this.setVisible, this);\n    this.parent.on(refreshVirtualBlock, e => e.virtualInfo.sentinelInfo.axis === 'X' ? this.refreshUI() : null, this);\n  }\n\n  renderTable() {\n    this.gen.refreshColOffsets();\n    this.parent.setColumnIndexesInView(this.gen.getColumnIndexes(this.getPanel().querySelector('.' + headerContent)));\n    super.renderTable();\n    this.virtualEle.table = this.getTable();\n    this.virtualEle.content = this.getPanel().querySelector('.' + headerContent);\n    this.virtualEle.content.style.position = 'relative';\n    this.virtualEle.renderWrapper();\n    this.virtualEle.renderPlaceHolder('absolute');\n  }\n\n  appendContent(table$$1) {\n    if (!this.isMovable) {\n      this.virtualEle.wrapper.appendChild(table$$1);\n    } else {\n      this.virtualEle.movableWrapper.appendChild(table$$1);\n      this.isMovable = false;\n    }\n  }\n\n  refreshUI() {\n    this.isMovable = this.parent.isFrozenGrid();\n    this.setFrozenTable(this.parent.getMovableVirtualContent());\n    this.gen.refreshColOffsets();\n    this.parent.setColumnIndexesInView(this.gen.getColumnIndexes(this.getPanel().querySelector('.' + headerContent)));\n    super.refreshUI();\n    this.setFrozenTable(this.parent.getFrozenVirtualContent());\n  }\n\n  setVisible(columns) {\n    const gObj = this.parent;\n    let displayVal;\n    let idx;\n    let needFullRefresh;\n    const frozenCols = this.parent.getFrozenColumns();\n    let fhdrColGrp;\n    let mhdrColGrp;\n\n    if (frozenCols) {\n      fhdrColGrp = [].slice.call(this.parent.getFrozenVirtualHeader().querySelectorAll('col'));\n      mhdrColGrp = [].slice.call(this.parent.getMovableVirtualHeader().querySelectorAll('col'));\n    }\n\n    for (let c = 0, clen = columns.length; c < clen; c++) {\n      const column = columns[c];\n      idx = gObj.getNormalizedColumnIndex(column.uid);\n      displayVal = column.visible ? '' : 'none';\n      let colGrp;\n\n      if (fhdrColGrp && mhdrColGrp) {\n        if (idx >= frozenCols) {\n          colGrp = mhdrColGrp;\n          idx = idx - frozenCols;\n        } else {\n          colGrp = fhdrColGrp;\n        }\n      } else {\n        colGrp = this.getColGroup().children;\n      }\n\n      setStyleAttribute(colGrp[idx], {\n        'display': displayVal\n      });\n\n      if (gObj.enableColumnVirtualization && !gObj.groupSettings.columns.length) {\n        let tablewidth;\n\n        if (column.visible) {\n          tablewidth = this.virtualEle.wrapper.offsetWidth + parseInt(column.width.toString(), 10);\n        } else {\n          tablewidth = this.virtualEle.wrapper.offsetWidth - parseInt(column.width.toString(), 10);\n        }\n\n        if (tablewidth > gObj.width) {\n          this.setDisplayNone(column, displayVal);\n          this.virtualEle.setWrapperWidth(tablewidth + '');\n          this.gen.refreshColOffsets();\n        } else {\n          needFullRefresh = true;\n        }\n      } else {\n        needFullRefresh = true;\n      }\n\n      if (needFullRefresh && !frozenCols) {\n        this.refreshUI();\n      }\n    }\n\n    if (frozenCols) {\n      this.parent.notify(columnPositionChanged, {});\n    }\n  }\n\n  setFrozenTable(content$$1) {\n    if (this.parent.isFrozenGrid() && this.parent.enableColumnVirtualization && this.parent.contentModule.isXaxis()) {\n      this.parent.contentModule.setTable(content$$1.querySelector('.' + table));\n    }\n  }\n\n  setDisplayNone(col, displayVal) {\n    const frozenCols = this.parent.isFrozenGrid();\n    let table$$1 = this.getTable();\n\n    if (frozenCols && col.getFreezeTableName() === 'movable') {\n      table$$1 = this.parent.getMovableVirtualHeader().querySelector('.' + table);\n    }\n\n    for (const ele of [].slice.apply(table$$1.querySelectorAll('th.e-headercell'))) {\n      if (ele.querySelector('[e-mappinguid]') && ele.querySelector('[e-mappinguid]').getAttribute('e-mappinguid') === col.uid) {\n        setStyleAttribute(ele, {\n          'display': displayVal\n        });\n\n        if (displayVal === '') {\n          removeClass([ele], 'e-hide');\n        }\n\n        break;\n      }\n    }\n  }\n\n}\n/**\n * @hidden\n */\n\n\nclass VirtualElementHandler {\n  renderWrapper(height) {\n    this.wrapper = createElement('div', {\n      className: 'e-virtualtable',\n      styles: `min-height:${formatUnit(height)}`\n    });\n    this.wrapper.appendChild(this.table);\n    this.content.appendChild(this.wrapper);\n  }\n\n  renderPlaceHolder(position = 'relative') {\n    this.placeholder = createElement('div', {\n      className: 'e-virtualtrack',\n      styles: `position:${position}`\n    });\n    this.content.appendChild(this.placeholder);\n  }\n\n  renderFrozenWrapper(height) {\n    this.wrapper = createElement('div', {\n      className: 'e-virtualtable',\n      styles: `min-height:${formatUnit(height)}; display: flex`\n    });\n    this.content.appendChild(this.wrapper);\n  }\n\n  renderFrozenPlaceHolder() {\n    this.placeholder = createElement('div', {\n      className: 'e-virtualtrack'\n    });\n    this.content.appendChild(this.placeholder);\n  }\n\n  renderMovableWrapper(height) {\n    this.movableWrapper = createElement('div', {\n      className: 'e-virtualtable',\n      styles: `min-height:${formatUnit(height)}`\n    });\n    this.movableContent.appendChild(this.movableWrapper);\n  }\n\n  renderMovablePlaceHolder() {\n    this.movablePlaceholder = createElement('div', {\n      className: 'e-virtualtrack'\n    });\n    this.movableContent.appendChild(this.movablePlaceholder);\n  }\n\n  adjustTable(xValue, yValue) {\n    this.wrapper.style.transform = `translate(${xValue}px, ${yValue}px)`;\n  }\n\n  adjustMovableTable(xValue, yValue) {\n    this.movableWrapper.style.transform = `translate(${xValue}px, ${yValue}px)`;\n  }\n\n  setMovableWrapperWidth(width, full) {\n    this.movableWrapper.style.width = width ? `${width}px` : full ? '100%' : '';\n  }\n\n  setMovableVirtualHeight(height, width) {\n    this.movablePlaceholder.style.height = `${height}px`;\n    this.movablePlaceholder.style.width = width;\n  }\n\n  setWrapperWidth(width, full) {\n    this.wrapper.style.width = width ? `${width}px` : full ? '100%' : '';\n  }\n\n  setVirtualHeight(height, width) {\n    this.placeholder.style.height = `${height}px`;\n    this.placeholder.style.width = width;\n  }\n\n  setFreezeWrapperWidth(wrapper, width, full) {\n    wrapper.style.width = width ? `${width}px` : full ? '100%' : '';\n  }\n\n}\n/**\n * Virtual Scrolling class\n */\n\n\nclass VirtualScroll {\n  constructor(parent, locator) {\n    this.parent = parent;\n    this.locator = locator;\n    this.addEventListener();\n  }\n\n  getModuleName() {\n    return 'virtualscroll';\n  }\n\n  instantiateRenderer() {\n    this.parent.log(['limitation', 'virtual_height'], 'virtualization');\n    const renderer = this.locator.getService('rendererFactory');\n\n    if (!this.parent.isFrozenGrid()) {\n      if (this.parent.enableColumnVirtualization) {\n        renderer.addRenderer(RenderType.Header, new VirtualHeaderRenderer(this.parent, this.locator));\n      }\n\n      renderer.addRenderer(RenderType.Content, new VirtualContentRenderer(this.parent, this.locator));\n    }\n\n    this.ensurePageSize();\n  }\n\n  ensurePageSize() {\n    const rowHeight = this.parent.getRowHeight();\n    const vHeight = this.parent.height.toString().indexOf('%') < 0 ? this.parent.height : this.parent.element.getBoundingClientRect().height;\n    this.blockSize = ~~(vHeight / rowHeight);\n    const height = this.blockSize * 2;\n    const size = this.parent.pageSettings.pageSize;\n    this.parent.setProperties({\n      pageSettings: {\n        pageSize: size < height ? height : size\n      }\n    }, true);\n  }\n\n  addEventListener() {\n    if (this.parent.isDestroyed) {\n      return;\n    }\n\n    this.parent.on(initialLoad, this.instantiateRenderer, this);\n    this.parent.on(columnWidthChanged, this.refreshVirtualElement, this);\n    this.parent.on(createVirtualValidationForm, this.createVirtualValidationForm, this);\n    this.parent.on(validateVirtualForm, this.virtualEditFormValidation, this);\n    this.parent.on(destroy, this.destroy, this);\n  }\n\n  removeEventListener() {\n    if (this.parent.isDestroyed) {\n      return;\n    }\n\n    this.parent.off(initialLoad, this.instantiateRenderer);\n    this.parent.off(columnWidthChanged, this.refreshVirtualElement);\n    this.parent.off(createVirtualValidationForm, this.createVirtualValidationForm);\n    this.parent.off(validateVirtualForm, this.virtualEditFormValidation);\n    this.parent.off(destroy, this.destroy);\n  }\n\n  getCurrentEditedData(prevData) {\n    const data = {\n      virtualData: extend({}, {}, prevData, true),\n      isAdd: false,\n      isScroll: false,\n      endEdit: true\n    };\n    this.parent.notify(getVirtualData, data);\n    return data.virtualData;\n  }\n\n  createVirtualValidationForm(e) {\n    const gObj = this.parent;\n\n    if (gObj.enableVirtualization && gObj.editSettings.mode === 'Normal') {\n      const cols = gObj.columns;\n      const rowRenderer = new RowRenderer(this.locator, null, this.parent);\n      const rowObj = extend({}, {}, gObj.getRowObjectFromUID(e.uid), true);\n      gObj.notify(refreshVirtualEditFormCells, rowObj);\n      const args = e.argsCreator(this.getCurrentEditedData(e.prevData), {}, false);\n      args.isCustomFormValidation = true;\n      args.row = rowRenderer.render(rowObj, cols);\n      e.renderer.update(args);\n      const rules = {};\n\n      for (let i = 0; i < cols.length; i++) {\n        if (!cols[i].visible) {\n          continue;\n        }\n\n        if (cols[i].validationRules) {\n          setValidationRuels(cols[i], 0, rules, {}, {}, cols.length, true);\n        }\n      }\n\n      args.form.classList.add('e-virtual-validation');\n      gObj.editModule.virtualFormObj = gObj.editModule.createFormObj(args.form, rules);\n    }\n  }\n\n  virtualEditFormValidation(args) {\n    const gObj = this.parent;\n    const error = gObj.element.querySelector('.e-griderror:not([style*=\"display: none\"])');\n\n    if (gObj.editModule.virtualFormObj) {\n      if (error && error.style.display !== 'none') {\n        const errorDomRect = error.getBoundingClientRect();\n        const forms = gObj.element.querySelectorAll('.e-gridform');\n        let form = forms[0];\n        let contentLeft = gObj.getContent().getBoundingClientRect().left;\n\n        if (forms.length > 1) {\n          form = gObj.getFrozenMode() !== 'Right' ? forms[1] : forms[0];\n          contentLeft = gObj.getMovableVirtualContent().getBoundingClientRect().left;\n        }\n\n        if (errorDomRect.left < contentLeft || errorDomRect.right > gObj.element.offsetWidth) {\n          const tooltip = form.querySelector('.e-tooltip-wrap:not([style*=\"display: none\"])');\n          this.scrollToEdit(tooltip, {\n            editIdx: args.editIdx,\n            addIdx: args.addIdx\n          }, true);\n        }\n      } else if (gObj.editModule.virtualFormObj && (!error || error.style.display === 'none')) {\n        const existingErrors = gObj.editModule.virtualFormObj.element.querySelectorAll('.e-tooltip-wrap:not([style*=\"display: none\"])');\n\n        for (let i = 0; i < existingErrors.length; i++) {\n          remove(existingErrors[i]);\n        }\n\n        this.setEditedDataToValidationForm(gObj.editModule.virtualFormObj.element, this.getCurrentEditedData(args.prevData));\n        args.isValid = gObj.editModule.virtualFormObj.validate();\n\n        if (!args.isValid) {\n          const tooltip = gObj.editModule.virtualFormObj.element.querySelector('.e-tooltip-wrap:not([style*=\"display: none\"])');\n          this.scrollToEdit(tooltip, {\n            editIdx: args.editIdx,\n            addIdx: args.addIdx\n          });\n        }\n      }\n    }\n  }\n\n  scrollToEdit(tooltip, args, isRenderer) {\n    const gObj = this.parent;\n\n    if (tooltip) {\n      const cols = gObj.columnModel;\n      const field = setComplexFieldID(tooltip.id).split('_')[0];\n      const col = gObj.getColumnByField(field);\n      const scrollTop = this.parent.getContent().firstElementChild.scrollTop;\n      const row = gObj.getRowByIndex(args.editIdx);\n\n      if (isRenderer || !col || !isNullOrUndefined(args.addIdx) && scrollTop > 0 || !isNullOrUndefined(args.editIdx) && !row) {\n        let validationCol;\n\n        for (let i = 0; i < cols.length && !col; i++) {\n          if (cols[i].field === field) {\n            validationCol = cols[i];\n            break;\n          }\n        }\n\n        if (isRenderer) {\n          validationCol = col;\n        }\n\n        this.parent.notify(scrollToEdit, validationCol);\n      }\n    }\n  }\n\n  setEditedDataToValidationForm(form, editedData) {\n    const inputs = [].slice.call(form.getElementsByClassName('e-field'));\n\n    for (let i = 0, len = inputs.length; i < len; i++) {\n      const col = getColumnModelByUid(this.parent, inputs[i].getAttribute('e-mappinguid'));\n      let value = getValue(col.field, editedData);\n      value = isNullOrUndefined(value) ? '' : value;\n      inputs[i].value = value;\n    }\n  }\n\n  refreshVirtualElement(args) {\n    if (this.parent.enableColumnVirtualization && args.module === 'resize') {\n      const renderer = this.locator.getService('rendererFactory');\n      renderer.getRenderer(RenderType.Content).refreshVirtualElement();\n    }\n  }\n\n  destroy() {\n    this.removeEventListener();\n  }\n\n}\n/**\n * Edit render module is used to render grid edit row.\n *\n * @hidden\n */\n\n\nclass InlineEditRender {\n  /**\n   * Constructor for render module\n   *\n   * @param {IGrid} parent - returns the IGrid\n   */\n  constructor(parent) {\n    this.parent = parent;\n  }\n\n  addNew(elements, args) {\n    this.isEdit = false;\n    let tbody$$1;\n    const mTbody = getMovableTbody(this.parent);\n    const frTbody = getFrozenRightTbody(this.parent);\n    const isFrozenGrid = this.parent.isFrozenGrid();\n    const isVirtualFrozen = isFrozenGrid && this.parent.enableColumnVirtualization && args.isScroll;\n\n    if (this.parent.frozenRows && this.parent.editSettings.newRowPosition === 'Top') {\n      tbody$$1 = isVirtualFrozen ? this.parent.getMovableHeaderTbody() : this.parent.getHeaderTable().querySelector(tbody);\n    } else {\n      tbody$$1 = isVirtualFrozen ? this.parent.getMovableContentTbody() : this.parent.getContentTable().querySelector(tbody);\n    }\n\n    args.row = this.parent.createElement('tr', {\n      className: 'e-row e-addedrow'\n    });\n\n    if (tbody$$1.querySelector('.e-emptyrow')) {\n      const emptyRow = tbody$$1.querySelector('.e-emptyrow');\n      emptyRow.parentNode.removeChild(emptyRow);\n\n      if (isFrozenGrid && !isVirtualFrozen) {\n        const moveTbody = this.parent.getContent().querySelector('.' + movableContent).querySelector(tbody);\n        moveTbody.firstElementChild.parentNode.removeChild(moveTbody.firstElementChild);\n\n        if (this.parent.getFrozenMode() === leftRight) {\n          const frTbody = this.parent.getContent().querySelector('.e-frozen-right-content').querySelector(tbody);\n          frTbody.firstElementChild.parentNode.removeChild(frTbody.firstElementChild);\n        }\n      }\n    }\n\n    if (this.parent.editSettings.newRowPosition === 'Top') {\n      tbody$$1.insertBefore(args.row, tbody$$1.firstChild);\n    } else {\n      tbody$$1.appendChild(args.row);\n    }\n\n    args.row.appendChild(this.getEditElement(elements, false, undefined, args, true));\n    this.parent.editModule.checkLastRow(args.row, args);\n\n    if (isFrozenGrid && !isVirtualFrozen) {\n      const mEle = this.renderMovableform(args.row, args);\n\n      if (this.parent.editSettings.newRowPosition === 'Top') {\n        mTbody.insertBefore(mEle, mTbody.firstChild);\n      } else {\n        mTbody.appendChild(mEle);\n      }\n\n      args.row.querySelector('.e-normaledit').setAttribute('colspan', this.parent.getVisibleFrozenColumns() + '');\n      mEle.setAttribute('colspan', '' + (this.parent.getVisibleColumns().length - this.parent.getVisibleFrozenColumns()));\n\n      if (frTbody) {\n        const frEle = this.renderFrozenRightForm(args.row, args);\n\n        if (this.parent.editSettings.newRowPosition === 'Top') {\n          frTbody.insertBefore(frEle, frTbody.firstChild);\n        } else {\n          frTbody.appendChild(frEle);\n        }\n\n        const colSpan = this.parent.getVisibleFrozenColumns() - this.parent.getFrozenRightColumnsCount();\n        args.row.querySelector('.e-normaledit').setAttribute('colspan', colSpan + '');\n        frEle.querySelector('.e-normaledit').setAttribute('colspan', '' + this.parent.getFrozenRightColumnsCount());\n      }\n\n      if (this.parent.height === 'auto') {\n        this.parent.notify(frozenHeight, {});\n      }\n    }\n  }\n\n  renderFrozenRightForm(ele, args) {\n    const frEle = ele.cloneNode(true);\n    const form = args.frozenRightForm = frEle.querySelector('form');\n\n    if (this.parent.editSettings.template) {\n      form.innerHTML = '';\n      this.appendChildren(form, args.rowData, false);\n      return frEle;\n    }\n\n    this.renderRightFrozen(ele, frEle);\n    frEle.querySelector(colGroup).innerHTML = this.parent.getHeaderContent().querySelector('.e-frozen-right-header').querySelector(colGroup).innerHTML;\n    return frEle;\n  }\n\n  renderMovableform(ele, args) {\n    const mEle = ele.cloneNode(true);\n    const form = args.movableForm = mEle.querySelector('form');\n\n    if (this.parent.editSettings.template) {\n      form.innerHTML = '';\n      this.appendChildren(form, args.rowData, false);\n      return mEle;\n    }\n\n    this.renderMovable(ele, mEle);\n    mEle.querySelector(colGroup).innerHTML = this.parent.getHeaderContent().querySelector('.' + movableHeader).querySelector(colGroup).innerHTML;\n    return mEle;\n  }\n\n  updateFreezeEdit(row$$1, td) {\n    td = td.concat([].slice.call(this.getFreezeRow(row$$1).querySelectorAll('td.e-rowcell')));\n\n    if (this.parent.getFrozenMode() === leftRight) {\n      td = td.concat([].slice.call(this.getFreezeRightRow(row$$1).querySelectorAll('td.e-rowcell')));\n    }\n\n    return td;\n  }\n\n  getFreezeRightRow(row$$1) {\n    const idx = parseInt(row$$1.getAttribute(ariaRowIndex), 10);\n    const fCont = this.parent.getFrozenLeftContentTbody();\n    const fHdr = this.parent.getFrozenHeaderTbody();\n    const frHdr = this.parent.getFrozenRightHeaderTbody();\n    const frCont = this.parent.getFrozenRightContentTbody();\n\n    if (fCont.contains(row$$1) || fHdr.contains(row$$1)) {\n      return this.parent.getFrozenRightRowByIndex(idx);\n    } else if (frCont.contains(row$$1) || frHdr.contains(row$$1)) {\n      return this.parent.getRowByIndex(idx);\n    }\n\n    return row$$1;\n  }\n\n  getFreezeRow(row$$1) {\n    if (this.parent.isFrozenGrid()) {\n      const idx = parseInt(row$$1.getAttribute(ariaRowIndex), 10);\n      const fCont = this.parent.getFrozenLeftContentTbody();\n      const mCont = this.parent.getMovableContentTbody();\n      const fHdr = this.parent.getFrozenHeaderTbody();\n      const mHdr = this.parent.getMovableHeaderTbody();\n\n      if (fCont.contains(row$$1) || fHdr.contains(row$$1)) {\n        return this.parent.getMovableRowByIndex(idx);\n      } else if (mCont.contains(row$$1) || mHdr.contains(row$$1)) {\n        return this.parent.getRowByIndex(idx);\n      }\n    }\n\n    return row$$1;\n  }\n\n  update(elements, args) {\n    this.isEdit = true;\n    const isCustomFormValidation = args.isCustomFormValidation;\n    const isScroll = args.isScroll;\n\n    if (!isScroll && (closest(args.row, '.' + movableContent) || closest(args.row, '.' + movableHeader))) {\n      args.row = this.getFreezeRow(args.row);\n    }\n\n    if (closest(args.row, '.e-frozen-right-content') || closest(args.row, '.e-frozen-right-header')) {\n      args.row = this.getFreezeRightRow(args.row);\n    }\n\n    const isVirtualFrozen = this.parent.isFrozenGrid() && this.parent.enableColumnVirtualization && isScroll;\n    let tdElement = [].slice.call(args.row.querySelectorAll('td.e-rowcell'));\n    args.row.innerHTML = '';\n\n    if (!isVirtualFrozen && !isCustomFormValidation) {\n      tdElement = this.updateFreezeEdit(args.row, tdElement);\n    }\n\n    args.row.appendChild(this.getEditElement(elements, true, tdElement, args, true));\n    args.row.classList.add(editedRow);\n    this.parent.editModule.checkLastRow(args.row, args);\n\n    if (!isVirtualFrozen && !isCustomFormValidation) {\n      this.refreshFreezeEdit(args.row, args);\n    }\n  }\n\n  refreshFreezeEdit(row$$1, args) {\n    const td = row$$1.firstChild;\n\n    if (this.parent.getVisibleFrozenColumns() && this.parent.editSettings.template) {\n      td.querySelector(colGroup).innerHTML = this.parent.getHeaderContent().querySelector('.' + frozenHeader).querySelector(colGroup).innerHTML;\n    }\n\n    let fCls;\n    let cont;\n    const idx = parseInt(row$$1.getAttribute(ariaRowIndex), 10);\n\n    if (this.parent.isFrozenGrid()) {\n      if (idx < this.parent.frozenRows) {\n        cont = this.parent.getHeaderContent();\n        fCls = '.' + frozenHeader;\n      } else {\n        cont = this.parent.getContent();\n        fCls = '.' + frozenContent;\n      }\n\n      const mTd = td.cloneNode(true);\n      const frTd = td.cloneNode(true);\n      const form = args.movableForm = mTd.querySelector('form');\n\n      if (this.parent.editSettings.template) {\n        this.refreshEditForm(form, args.rowData);\n      }\n\n      let fRows;\n      let frRows;\n\n      if (cont.querySelector(fCls).contains(row$$1)) {\n        fRows = this.parent.getMovableRowByIndex(idx);\n        this.updateFrozenCont(fRows, td, mTd);\n\n        if (this.parent.getFrozenMode() === leftRight) {\n          args.frozenRightForm = frTd.querySelector('form');\n          this.refreshEditForm(args.frozenRightForm, args.rowData);\n          frRows = this.parent.getFrozenRightRowByIndex(idx);\n          this.updateFrozenRightCont(frRows, td, frTd);\n        }\n      } else {\n        fRows = this.parent.getRowByIndex(idx);\n        this.updateFrozenCont(fRows, mTd, td);\n\n        if (this.parent.getFrozenMode() === leftRight) {\n          args.frozenRightForm = frTd.querySelector('form');\n          this.refreshEditForm(args.frozenRightForm, args.rowData);\n          frRows = this.parent.getFrozenRightRowByIndex(idx);\n          this.updateFrozenRightCont(frRows, frTd, td);\n        }\n      }\n\n      fRows.appendChild(mTd);\n      fRows.classList.add(editedRow);\n\n      if (this.parent.getFrozenMode() === leftRight) {\n        frRows.appendChild(frTd);\n        frRows.classList.add(editedRow);\n        alignFrozenEditForm(args.frozenRightForm.querySelector('td:not(.e-hide)'), args.form.querySelector('td:not(.e-hide)'));\n      }\n\n      alignFrozenEditForm(args.movableForm.querySelector('td:not(.e-hide)'), args.form.querySelector('td:not(.e-hide)'));\n    }\n  }\n\n  refreshEditForm(form, data) {\n    if (this.parent.editSettings.template) {\n      form.innerHTML = '';\n      this.appendChildren(form, data, false);\n    }\n  }\n\n  updateFrozenRightCont(row$$1, ele, frEle) {\n    row$$1.innerHTML = '';\n    this.renderRightFrozen(ele, frEle);\n    frEle.querySelector(colGroup).innerHTML = this.parent.getHeaderContent().querySelector('.e-frozen-right-header').querySelector(colGroup).innerHTML;\n    ele.setAttribute('colspan', this.parent.getVisibleFrozenColumns() - this.parent.getFrozenRightColumnsCount() + '');\n    frEle.setAttribute('colspan', this.parent.getFrozenRightColumnsCount() + '');\n  }\n\n  updateFrozenCont(row$$1, ele, mEle) {\n    row$$1.innerHTML = '';\n    this.renderMovable(ele, mEle);\n    mEle.querySelector(colGroup).innerHTML = this.parent.getHeaderContent().querySelector('.' + movableHeader).querySelector(colGroup).innerHTML;\n    ele.setAttribute('colspan', this.parent.getVisibleFrozenColumns() + '');\n    mEle.setAttribute('colspan', this.parent.getCurrentVisibleColumns(this.parent.enableColumnVirtualization).length - this.parent.getVisibleFrozenColumns() + '');\n  }\n\n  renderRightFrozen(ele, frEle) {\n    frEle.querySelector('tr').innerHTML = '';\n    const cols = this.parent.getColumns();\n    let k = 0;\n\n    for (let i = 0; i < cols.length; i++, k++) {\n      if (cols[i].getFreezeTableName() === frozenRight) {\n        const index = k - this.parent.getMovableColumnsCount();\n        frEle.querySelector('tr').appendChild(ele.querySelector('tr').removeChild(ele.querySelector('tr').children[index]));\n        k--;\n      }\n    }\n  }\n\n  renderMovable(ele, mEle) {\n    mEle.querySelector('tr').innerHTML = '';\n    const cols = this.parent.getColumns();\n    let k = 0;\n\n    for (let i = 0; i < cols.length; i++, k++) {\n      if (cols[i].getFreezeTableName() === 'movable') {\n        mEle.querySelector('tr').appendChild(ele.querySelector('tr').removeChild(ele.querySelector('tr').children[k]));\n        k--;\n      }\n    }\n  } // eslint-disable-next-line max-len\n\n\n  getEditElement(elements, isEdit, tdElement, args, isFrozen) {\n    const gObj = this.parent;\n    let gLen = 0;\n    const isDetail = !isNullOrUndefined(gObj.detailTemplate) || !isNullOrUndefined(gObj.childGrid) ? 1 : 0;\n\n    if (gObj.allowGrouping) {\n      gLen = gObj.groupSettings.columns.length;\n    }\n\n    const td = this.parent.createElement('td', {\n      className: 'e-editcell e-normaledit',\n      attrs: {\n        colspan: (gObj.getCurrentVisibleColumns(this.parent.enableColumnVirtualization).length - gObj.getVisibleFrozenColumns() + this.parent.getIndentCount()).toString()\n      }\n    });\n    const form = args.form = this.parent.createElement('form', {\n      id: gObj.element.id + 'EditForm',\n      className: 'e-gridform'\n    });\n\n    if (this.parent.editSettings.template) {\n      this.appendChildren(form, args.rowData, isFrozen);\n      td.appendChild(form);\n      return td;\n    }\n\n    const table$$1 = this.parent.createElement('table', {\n      className: 'e-table e-inline-edit',\n      attrs: {\n        cellspacing: '0.25'\n      }\n    });\n    table$$1.appendChild(gObj.getContentTable().querySelector(colGroup).cloneNode(true));\n    const tbody$$1 = this.parent.createElement(tbody);\n    const tr = this.parent.createElement('tr');\n    let i = 0;\n\n    if (isDetail) {\n      tr.insertBefore(this.parent.createElement('td', {\n        className: 'e-detailrowcollapse'\n      }), tr.firstChild);\n    }\n\n    if (gObj.isRowDragable()) {\n      tr.appendChild(this.parent.createElement('td', {\n        className: 'e-dragindentcell'\n      }));\n    }\n\n    while (i < gLen) {\n      tr.appendChild(this.parent.createElement('td', {\n        className: 'e-indentcell'\n      }));\n      i++;\n    }\n\n    let m = 0;\n    i = 0;\n    const isVirtualFrozen = gObj.isFrozenGrid() && gObj.enableColumnVirtualization && args.isScroll;\n    const cols = args.isCustomFormValidation ? this.parent.columnModel : gObj.getColumns();\n\n    while (isEdit && m < tdElement.length && i < cols.length || i < cols.length) {\n      const span = isEdit ? tdElement[m].getAttribute('colspan') : null;\n      const col = cols[i];\n\n      if (isVirtualFrozen && col.getFreezeTableName() !== 'movable' || args.isCustomFormValidation && (col.commands || col.commandsTemplate || !col.field)) {\n        i++;\n        continue;\n      }\n\n      const td = this.parent.createElement('td', {\n        className: rowCell,\n        attrs: {\n          style: 'text-align:' + (col.textAlign ? col.textAlign : ''),\n          'colspan': span ? span : ''\n        }\n      });\n\n      if (col.visible) {\n        td.appendChild(elements[col.uid]);\n\n        if (this.parent.rowRenderingMode === 'Vertical') {\n          setStyleAndAttributes(td, {\n            'data-cell': col.headerText\n          });\n\n          if (i === 0) {\n            td.classList.add('e-responsive-editcell');\n          }\n        }\n\n        if (col.editType === 'booleanedit') {\n          td.classList.add('e-boolcell');\n        } else if (col.commands || col.commandsTemplate) {\n          addClass([td], 'e-unboundcell');\n        }\n      } else {\n        td.classList.add('e-hide');\n      }\n\n      tr.appendChild(td);\n      i = span ? i + parseInt(span, 10) : i + 1;\n      m++;\n    }\n\n    tbody$$1.appendChild(tr);\n    table$$1.appendChild(tbody$$1);\n    form.appendChild(table$$1);\n    td.appendChild(form);\n    return td;\n  }\n\n  removeEventListener() {//To destroy the renderer\n  }\n\n  appendChildren(form, data, isFrozen) {\n    const dummyData = extend({}, data, {\n      isAdd: !this.isEdit,\n      isFrozen: isFrozen\n    }, true);\n    const editTemplateID = this.parent.element.id + 'editSettingsTemplate';\n\n    if (this.parent.isReact && typeof this.parent.editSettings.template !== 'string') {\n      this.parent.getEditTemplate()(dummyData, this.parent, 'editSettingsTemplate', editTemplateID, null, null, form);\n      this.parent.renderTemplates();\n    } else {\n      appendChildren(form, this.parent.getEditTemplate()(dummyData, this.parent, 'editSettingsTemplate', editTemplateID));\n    } // eslint-disable-next-line\n\n  }\n\n}\n/**\n * Edit render module is used to render grid edit row.\n *\n * @hidden\n */\n\n\nclass BatchEditRender {\n  /**\n   * Constructor for render module\n   *\n   * @param {IGrid} parent - specifies the IGrid\n   */\n  constructor(parent) {\n    this.parent = parent;\n  }\n\n  update(elements, args) {\n    if (this.parent.isReact && args.columnObject && args.columnObject.template) {\n      const parentRow = args.cell.parentElement;\n      const newTd = args.cell.cloneNode(true);\n      parentRow.insertBefore(newTd, args.cell);\n      newTd.focus();\n      args.cell.remove();\n      args.cell = newTd;\n    }\n\n    args.cell.innerHTML = '';\n    args.cell.appendChild(this.getEditElement(elements, args));\n    args.cell.classList.remove('e-ellipsistooltip');\n    args.cell.classList.add('e-editedbatchcell');\n    classList(args.row, [editedRow, 'e-batchrow'], []);\n  }\n\n  getEditElement(elements, args) {\n    const gObj = this.parent;\n    const form = this.parent.createElement('form', {\n      id: gObj.element.id + 'EditForm',\n      className: 'e-gridform'\n    });\n    form.appendChild(elements[args.columnObject.uid]);\n\n    if (args.columnObject.editType === 'booleanedit') {\n      args.cell.classList.add('e-boolcell');\n    }\n\n    if (!args.columnObject.editType) {\n      args.cell.classList.add('e-inputbox');\n    }\n\n    return form;\n  }\n\n  removeEventListener() {//To destroy the renderer\n  }\n\n}\n/**\n * Edit render module is used to render grid edit row.\n *\n * @hidden\n */\n\n\nclass DialogEditRender {\n  /**\n   * Constructor for render module\n   *\n   * @param {IGrid} parent - specifies the IGrid\n   * @param {ServiceLocator} serviceLocator - specifies the serviceLocator\n   */\n  constructor(parent, serviceLocator) {\n    this.parent = parent;\n    this.serviceLocator = serviceLocator;\n\n    if (this.parent.isDestroyed) {\n      return;\n    }\n\n    this.parent.on(dialogDestroy, this.destroy, this);\n    this.parent.on(destroy, this.destroy, this);\n  }\n\n  setLocaleObj() {\n    this.l10n = this.serviceLocator.getService('localization');\n  }\n\n  addNew(elements, args) {\n    this.isEdit = false;\n    this.createDialog(elements, args);\n  }\n\n  update(elements, args) {\n    this.isEdit = true;\n    this.createDialog(elements, args);\n  }\n\n  createDialogHeader(args) {\n    const gObj = this.parent;\n    let header;\n\n    if (this.parent.enableAdaptiveUI) {\n      const responsiveDlgRenderer = new ResponsiveDialogRenderer(this.parent, this.serviceLocator);\n      responsiveDlgRenderer.action = this.isEdit ? ResponsiveDialogAction.isEdit : ResponsiveDialogAction.isAdd;\n      return responsiveDlgRenderer.renderResponsiveHeader(undefined, args);\n    } else {\n      if (gObj.editSettings.headerTemplate) {\n        header = this.getDialogEditTemplateElement('HeaderTemplate', args);\n      } else if (this.isEdit) {\n        header = this.l10n.getConstant('EditFormTitle') + args.primaryKeyValue[0];\n      } else {\n        header = this.l10n.getConstant('AddFormTitle');\n      }\n    }\n\n    return header;\n  }\n\n  createDialog(elements, args) {\n    const gObj = this.parent;\n    this.dialog = this.parent.createElement('div', {\n      id: gObj.element.id + '_dialogEdit_wrapper',\n      styles: 'width: auto'\n    });\n\n    if (gObj.enableAdaptiveUI) {\n      this.dialog.classList.add('e-responsive-dialog');\n    }\n\n    this.dialog.setAttribute('aria-label', 'Dialog edit');\n    gObj.element.appendChild(this.dialog);\n    this.setLocaleObj(); // let position: PositionDataModel = this.parent.element.getBoundingClientRect().height < 400 ?\n    //     { X: 'center', Y: 'top' } : { X: 'center', Y: 'center' };\n\n    this.dialogObj = new Dialog(extend({\n      header: this.createDialogHeader(args),\n      isModal: true,\n      visible: true,\n      cssClass: 'e-edit-dialog',\n      content: this.getEditElement(elements, args),\n      showCloseIcon: true,\n      allowDragging: true,\n      // position: position,\n      close: this.dialogClose.bind(this),\n      created: this.dialogCreated.bind(this),\n      closeOnEscape: true,\n      width: gObj.editSettings.template ? 'auto' : '330px',\n      target: args.target ? args.target : document.body,\n      animationSettings: {\n        effect: 'None'\n      },\n      footerTemplate: gObj.editSettings.footerTemplate ? this.getDialogEditTemplateElement('FooterTemplate', args) : null,\n      buttons: [{\n        click: this.btnClick.bind(this),\n        buttonModel: {\n          content: this.l10n.getConstant('SaveButton'),\n          cssClass: 'e-primary',\n          isPrimary: true\n        }\n      }, {\n        click: this.btnClick.bind(this),\n        buttonModel: {\n          cssClass: 'e-flat',\n          content: this.l10n.getConstant('CancelButton')\n        }\n      }]\n    }, gObj.editSettings.dialog ? gObj.editSettings.dialog.params || {} : {}));\n    args.dialog = this.dialogObj;\n    const isStringTemplate = 'isStringTemplate';\n    this.dialogObj[isStringTemplate] = true;\n    this.renderResponsiveDialog();\n    this.dialogObj.appendTo(this.dialog);\n    applyBiggerTheme(this.parent.element, this.dialogObj.element.parentElement);\n\n    if (gObj.enableAdaptiveUI) {\n      this.dialogObj.show(true);\n    }\n  }\n\n  dialogCreated() {\n    addBiggerDialog(this.parent);\n  }\n\n  renderResponsiveDialog() {\n    if (this.parent.enableAdaptiveUI) {\n      if (this.parent.adaptiveDlgTarget) {\n        this.dialogObj.target = this.parent.adaptiveDlgTarget;\n      }\n\n      this.dialogObj.buttons = [{}];\n      this.dialogObj.showCloseIcon = true;\n      this.dialogObj.visible = false;\n      this.dialogObj.width = '100%';\n\n      this.dialogObj.open = () => {\n        this.dialogObj.element.style.maxHeight = '100%';\n      };\n    }\n  }\n\n  btnClick(e) {\n    if (this.l10n.getConstant('CancelButton').toLowerCase() === e.target.innerText.trim().toLowerCase()) {\n      this.dialogClose();\n    } else {\n      this.parent.endEdit();\n    }\n  }\n\n  dialogClose() {\n    this.parent.closeEdit();\n  } // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  destroy(args) {\n    const dialogEditTemplates = ['template', 'headerTemplate', 'footerTemplate'];\n\n    for (let i = 0; i < dialogEditTemplates.length; i++) {\n      if (this.parent.editSettings[dialogEditTemplates[i]]) {\n        const templateName = dialogEditTemplates[i].charAt(0).toUpperCase() + dialogEditTemplates[i].slice(1);\n        const editTemplateID = this.parent.element.id + 'editSettings' + templateName;\n        updateBlazorTemplate(editTemplateID, templateName, this.parent.editSettings);\n      }\n    }\n\n    this.parent.notify(destroyForm, {});\n    this.parent.isEdit = false;\n    this.parent.notify(toolbarRefresh, {});\n\n    if (this.dialog && !this.dialogObj.isDestroyed) {\n      this.dialogObj.destroy();\n      remove(this.dialog);\n    }\n  }\n\n  getDialogEditTemplateElement(dialogTemp, args) {\n    const tempDiv = this.parent.createElement('div', {\n      className: 'e-dialog' + dialogTemp\n    });\n    const dummyData = extend({}, args.rowData, {\n      isAdd: !this.isEdit\n    }, true);\n    const templateID = this.parent.element.id + 'editSettings' + dialogTemp;\n    appendChildren(tempDiv, (dialogTemp === 'HeaderTemplate' ? this.parent.getEditHeaderTemplate() : this.parent.getEditFooterTemplate())(dummyData, this.parent, 'editSettings' + dialogTemp, templateID));\n    updateBlazorTemplate(templateID, dialogTemp, this.parent.editSettings);\n    return tempDiv;\n  }\n\n  getEditElement(elements, args) {\n    const gObj = this.parent;\n    const div = this.parent.createElement('div', {\n      className: this.isEdit ? editedRow : 'e-insertedrow'\n    });\n    const form = args.form = this.parent.createElement('form', {\n      id: gObj.element.id + 'EditForm',\n      className: 'e-gridform'\n    });\n\n    if (this.parent.editSettings.template) {\n      const editTemplateID = this.parent.element.id + 'editSettingsTemplate';\n      const dummyData = extend({}, args.rowData, {\n        isAdd: !this.isEdit\n      }, true);\n      const isReactCompiler = this.parent.isReact && typeof this.parent.editSettings.template !== 'string';\n\n      if (isReactCompiler) {\n        this.parent.getEditTemplate()(dummyData, this.parent, 'editSettingsTemplate', editTemplateID, null, null, form);\n        this.parent.renderTemplates();\n      } else {\n        appendChildren(form, this.parent.getEditTemplate()(dummyData, this.parent, 'editSettingsTemplate', editTemplateID));\n      }\n\n      const setRules = () => {\n        const columns = this.parent.getColumns();\n\n        for (let i = 0; i < columns.length; i++) {\n          if (columns[i].validationRules) {\n            this.parent.editModule.formObj.rules[columns[i].field] = columns[i].validationRules;\n          }\n        }\n      };\n\n      updateBlazorTemplate(editTemplateID, 'Template', this.parent.editSettings, true, setRules);\n      div.appendChild(form);\n      return div;\n    }\n\n    const table$$1 = this.parent.createElement('table', {\n      className: table,\n      attrs: {\n        cellspacing: '6px'\n      }\n    });\n    const tbody$$1 = this.parent.createElement(tbody);\n    const cols = gObj.getColumns();\n\n    for (let i = 0; i < cols.length; i++) {\n      if (this.parent.editModule.checkColumnIsGrouped(cols[i]) || cols[i].commands || cols[i].commandsTemplate || cols[i].type === 'checkbox') {\n        continue;\n      }\n\n      const tr = this.parent.createElement('tr');\n      const dataCell = this.parent.createElement('td', {\n        className: rowCell,\n        attrs: {\n          style: 'text-align:' + (this.parent.enableRtl ? 'right' : 'left') + ';width:190px'\n        }\n      });\n      elements[cols[i].uid].classList.remove('e-input');\n      dataCell.appendChild(elements[cols[i].uid]);\n      tr.appendChild(dataCell);\n      tbody$$1.appendChild(tr);\n    }\n\n    table$$1.appendChild(tbody$$1);\n    form.appendChild(table$$1);\n    div.appendChild(form);\n    return div;\n  }\n\n  removeEventListener() {\n    if (this.parent.isDestroyed) {\n      return;\n    }\n\n    this.parent.off(dialogDestroy, this.destroy);\n    this.parent.off(destroy, this.destroy);\n  }\n\n}\n/**\n * Edit render module is used to render grid edit row.\n *\n * @hidden\n */\n\n\nclass EditRender {\n  /**\n   * Constructor for render module\n   *\n   * @param {IGrid} parent -specifies the IGrid\n   * @param {ServiceLocator} serviceLocator - specifies the serviceLocator\n   */\n  constructor(parent, serviceLocator) {\n    //Internal variables\n    this.editType = {\n      'Inline': InlineEditRender,\n      'Normal': InlineEditRender,\n      'Batch': BatchEditRender,\n      'Dialog': DialogEditRender\n    };\n    this.parent = parent;\n    this.serviceLocator = serviceLocator;\n    this.renderer = new this.editType[this.parent.editSettings.mode](parent, serviceLocator);\n    this.focus = serviceLocator.getService('focus');\n  }\n\n  addNew(args) {\n    this.renderer.addNew(this.getEditElements(args), args);\n    this.convertWidget(args);\n  }\n\n  update(args) {\n    this.renderer.update(this.getEditElements(args), args);\n    const isCustomFormValidation = args.isCustomFormValidation;\n\n    if (!isCustomFormValidation) {\n      this.parent.notify(beforeStartEdit, args);\n      this.convertWidget(args);\n    }\n  }\n\n  convertWidget(args) {\n    const gObj = this.parent;\n    let isFocused;\n    let cell;\n    let value;\n    let fForm;\n    let frForm;\n    const frzCols = gObj.isFrozenGrid();\n    const index = gObj.getFrozenMode() === 'Right' && gObj.editSettings.mode === 'Normal' ? 1 : 0;\n    const form = gObj.editSettings.mode === 'Dialog' ? select('#' + gObj.element.id + '_dialogEdit_wrapper .e-gridform', document) : gObj.element.getElementsByClassName('e-gridform')[index];\n    const isVirtualFrozen = frzCols && this.parent.enableColumnVirtualization && args.isScroll;\n\n    if (frzCols && gObj.editSettings.mode === 'Normal') {\n      const rowIndex = parseInt(args.row.getAttribute(ariaRowIndex), 10);\n\n      if (gObj.frozenRows && (args.requestType === 'add' && gObj.editSettings.newRowPosition === 'Top' || rowIndex < gObj.frozenRows)) {\n        fForm = gObj.element.querySelector('.' + movableHeader).querySelector('.e-gridform');\n\n        if (this.parent.getFrozenMode() === leftRight) {\n          frForm = args.frozenRightForm;\n        }\n      } else {\n        fForm = gObj.element.querySelector('.' + movableContent).querySelector('.e-gridform');\n\n        if (this.parent.getFrozenMode() === leftRight) {\n          frForm = args.frozenRightForm;\n        }\n      }\n    }\n\n    const cols = gObj.editSettings.mode !== 'Batch' ? gObj.getColumns() : [gObj.getColumnByField(args.columnName)];\n\n    for (const col of cols) {\n      if (isVirtualFrozen && col.getFreezeTableName() !== 'movable') {\n        continue;\n      }\n\n      if (this.parent.editSettings.template && !isNullOrUndefined(col.field)) {\n        const cellArgs = extend({}, args);\n        cellArgs.element = form.querySelector('[name=' + getComplexFieldID(col.field) + ']');\n\n        if (isNullOrUndefined(cellArgs.element) && frzCols) {\n          cellArgs.element = fForm.querySelector('[name=' + getComplexFieldID(col.field) + ']');\n        }\n\n        if (typeof col.edit.write === 'string') {\n          getObject(col.edit.write, window)(cellArgs);\n        } else {\n          col.edit.write(cellArgs);\n        }\n\n        continue;\n      }\n\n      if (this.parent.editModule.checkColumnIsGrouped(col) || col.commands) {\n        continue;\n      } // eslint-disable-next-line\n\n\n      value = col.valueAccessor(col.field, args.rowData, col);\n\n      if (col.getFreezeTableName() === 'movable' && gObj.editSettings.mode === 'Normal') {\n        cell = fForm.querySelector('[e-mappinguid=' + col.uid + ']');\n      } else if (frForm && col.getFreezeTableName() === frozenRight && gObj.editSettings.mode === 'Normal') {\n        cell = frForm.querySelector('[e-mappinguid=' + col.uid + ']');\n      } else {\n        cell = form.querySelector('[e-mappinguid=' + col.uid + ']');\n      }\n\n      let temp = col.edit.write;\n\n      if (!isNullOrUndefined(cell)) {\n        if (typeof temp === 'string') {\n          temp = getObject(temp, window);\n          temp({\n            rowData: args.rowData,\n            element: cell,\n            column: col,\n            requestType: args.requestType,\n            row: args.row,\n            foreignKeyData: col.isForeignColumn() && getObject(col.field, args.foreignKeyData)\n          });\n        } else {\n          col.edit.write({\n            rowData: args.rowData,\n            element: cell,\n            column: col,\n            requestType: args.requestType,\n            row: args.row,\n            foreignKeyData: col.isForeignColumn() && getObject(col.field, args.foreignKeyData)\n          });\n        }\n\n        if (!isFocused && !cell.getAttribute('disabled') && !parentsUntil(cell, 'e-checkbox-disabled')) {\n          this.focusElement(cell, args.type);\n          isFocused = true;\n        }\n      }\n    }\n\n    if (frzCols && !this.parent.allowTextWrap && (args.requestType === 'add' || args.requestType === 'beginEdit') && this.parent.editSettings.mode !== 'Dialog' && !isNullOrUndefined(form) && !isNullOrUndefined(fForm)) {\n      const mTdElement = fForm.querySelector('tr').children[0];\n      const fTdElement = form.querySelector('tr').children[0];\n\n      if (fTdElement.offsetHeight > mTdElement.offsetHeight) {\n        mTdElement.style.height = fTdElement.offsetHeight + 'px';\n\n        if (frForm) {\n          const frTdElement = fForm.querySelector('tr').children[0];\n          frTdElement.style.height = fTdElement.offsetHeight + 'px';\n        }\n      } else {\n        fTdElement.style.height = mTdElement.offsetHeight + 'px';\n\n        if (frForm) {\n          const frTdElement = fForm.querySelector('tr').children[0];\n          frTdElement.style.height = mTdElement.offsetHeight + 'px';\n        }\n      }\n    }\n  } // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  focusElement(elem, type) {\n    const chkBox = this.parent.element.querySelector('.e-edit-checkselect');\n\n    if (!isNullOrUndefined(chkBox)) {\n      chkBox.nextElementSibling.classList.add('e-focus');\n    }\n\n    if (this.parent.editSettings.mode === 'Batch') {\n      this.focus.onClick({\n        target: closest(elem, 'td')\n      }, true);\n    } else {\n      const isFocus = this.parent.enableVirtualization && this.parent.editSettings.mode === 'Normal' ? false : true;\n\n      if (isFocus || this.parent.enableVirtualization && this.parent.editSettings.newRowPosition === 'Bottom' && parentsUntil(elem, addedRow)) {\n        elem.focus();\n      } else {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        elem.focus({\n          preventScroll: true\n        });\n      }\n    }\n\n    if (elem.classList.contains('e-defaultcell')) {\n      elem.setSelectionRange(elem.value.length, elem.value.length);\n    }\n  }\n\n  getEditElements(args) {\n    const gObj = this.parent;\n    const elements = {};\n    let cols = gObj.editSettings.mode !== 'Batch' ? gObj.getColumns() : [gObj.getColumnByField(args.columnName)];\n\n    if (args.isCustomFormValidation) {\n      cols = this.parent.columnModel;\n    }\n\n    if (this.parent.editSettings.template) {\n      return {};\n    }\n\n    const isVirtualFrozen = gObj.isFrozenGrid() && gObj.enableColumnVirtualization && args.isScroll;\n\n    for (let i = 0, len = cols.length; i < len; i++) {\n      const col = cols[i];\n\n      if (this.parent.editModule.checkColumnIsGrouped(col) || isVirtualFrozen && cols[i].getFreezeTableName() !== 'movable' || args.isCustomFormValidation && (col.commands || col.commandsTemplate || !col.field)) {\n        continue;\n      }\n\n      if (col.commands || col.commandsTemplate) {\n        const cellRendererFact = this.serviceLocator.getService('cellRendererFactory');\n        const model = new RowModelGenerator(this.parent);\n        const cellRenderer = cellRendererFact.getCellRenderer(CellType.CommandColumn);\n        const cells = model.generateRows(args.rowData)[0].cells;\n        const cell = cells.filter(cell => cell.rowID);\n        const td = cellRenderer.render(cell[i], args.rowData, {\n          'index': args.row ? args.row.getAttribute(ariaRowIndex) : 0\n        }, this.parent.enableVirtualization);\n        const div = td.firstElementChild;\n        div.setAttribute('textAlign', td.getAttribute('textAlign'));\n        elements[col.uid] = div;\n        continue;\n      }\n\n      const value = col.valueAccessor(col.field, args.rowData, col);\n      const tArgs = {\n        column: col,\n        value: value,\n        type: args.requestType,\n        data: args.rowData\n      };\n      let temp = col.edit.create;\n      let input;\n\n      if (col.editTemplate) {\n        input = this.parent.createElement('span', {\n          attrs: {\n            'e-mappinguid': col.uid\n          }\n        });\n        const tempID = this.parent.element.id + col.uid + 'editTemplate';\n        const tempData = extendObjWithFn({}, args.rowData, {\n          column: col\n        });\n        const isReactCompiler = this.parent.isReact && typeof col.editTemplate !== 'string';\n\n        if (isReactCompiler) {\n          col.getEditTemplate()(extend({\n            'index': args.rowIndex\n          }, tempData), this.parent, 'editTemplate', tempID, null, null, input);\n          this.parent.renderTemplates();\n        } else {\n          const template = col.getEditTemplate()(extend({\n            'index': args.rowIndex\n          }, tempData), this.parent, 'editTemplate', tempID);\n          appendChildren(input, template);\n        }\n      } else {\n        if (typeof temp === 'string') {\n          temp = getObject(temp, window);\n          input = temp(tArgs);\n        } else {\n          input = col.edit.create(tArgs);\n        }\n\n        if (typeof input === 'string') {\n          const div = this.parent.createElement('div');\n          div.innerHTML = input;\n          input = div.firstChild;\n        }\n\n        const isInput = input.tagName !== 'input' && input.querySelectorAll('input').length;\n        const complexFieldName = getComplexFieldID(col.field);\n        attributes(isInput ? input.querySelector('input') : input, {\n          name: complexFieldName,\n          'e-mappinguid': col.uid,\n          id: gObj.element.id + complexFieldName\n        });\n        classList(input, ['e-input', 'e-field'], []);\n\n        if (col.textAlign === 'Right') {\n          input.classList.add('e-ralign');\n        }\n\n        if ((col.isPrimaryKey || col.isIdentity) && args.requestType === 'beginEdit' || col.isIdentity && args.requestType === 'add') {\n          // already disabled in cell plugins\n          input.setAttribute('disabled', '');\n        }\n      }\n\n      elements[col.uid] = input;\n    }\n\n    return elements;\n  }\n\n  destroy() {\n    this.renderer.removeEventListener();\n  }\n\n}\n/**\n * `DropDownEditCell` is used to handle dropdown cell type editing.\n *\n * @hidden\n */\n\n\nclass EditCellBase {\n  constructor(parent) {\n    this.parent = parent;\n  }\n\n  create(args) {\n    return createEditElement(this.parent, args.column, 'e-field', {\n      type: 'text'\n    });\n  }\n\n  read(element) {\n    return element.ej2_instances[0].value;\n  }\n\n  destroy() {\n    if (this.obj && !this.obj.isDestroyed) {\n      if (this.removeEventHandler) {\n        this.removeEventHandler();\n      }\n\n      this.obj.destroy();\n    }\n  }\n\n}\n/**\n * `BooleanEditCell` is used to handle boolean cell type editing.\n *\n * @hidden\n */\n\n\nclass BooleanEditCell extends EditCellBase {\n  constructor() {\n    super(...arguments);\n    this.activeClasses = ['e-selectionbackground', 'e-active'];\n  }\n\n  create(args) {\n    const col = args.column;\n    let classNames = 'e-field e-boolcell';\n\n    if (col.type === 'checkbox') {\n      classNames = 'e-field e-boolcell e-edit-checkselect';\n    }\n\n    this.removeEventHandler = this.removeEventListener;\n    return createEditElement(this.parent, args.column, classNames, {\n      type: 'checkbox',\n      value: args.value\n    });\n  }\n\n  read(element) {\n    return element.checked;\n  }\n\n  write(args) {\n    let selectChkBox;\n    let chkState;\n\n    if (!isNullOrUndefined(args.row)) {\n      selectChkBox = args.row.querySelector('.e-edit-checkselect');\n    }\n\n    if (getObject(args.column.field, args.rowData)) {\n      chkState = JSON.parse(getObject(args.column.field, args.rowData).toString().toLowerCase());\n    }\n\n    if (!isNullOrUndefined(selectChkBox) && args.column.type === 'checkbox') {\n      this.editType = this.parent.editSettings.mode;\n      this.editRow = args.row;\n\n      if (args.requestType !== 'add') {\n        const row$$1 = this.parent.getRowObjectFromUID(args.row.getAttribute('data-uid'));\n        chkState = row$$1 ? row$$1.isSelected : false;\n      }\n\n      addRemoveActiveClasses([].slice.call(args.row.getElementsByClassName(rowCell)), chkState, ...this.activeClasses);\n    }\n\n    this.obj = new CheckBox(extend({\n      label: this.parent.editSettings.mode !== 'Dialog' ? ' ' : args.column.headerText,\n      checked: chkState,\n      disabled: !isEditable(args.column, args.requestType, args.element),\n      enableRtl: this.parent.enableRtl\n    }, args.column.edit.params));\n    this.addEventListener();\n    this.obj.appendTo(args.element);\n  }\n\n  addEventListener() {\n    this.cbChange = this.checkBoxChange.bind(this);\n    this.obj.addEventListener(change, this.cbChange);\n  }\n\n  removeEventListener() {\n    if (this.obj.isDestroyed) {\n      return;\n    }\n\n    this.obj.removeEventListener(change, this.cbChange);\n  }\n\n  checkBoxChange(args) {\n    if (this.editRow && this.editType !== 'Dialog') {\n      let add = false;\n\n      if (!args.checked) {\n        this.editRow.removeAttribute('aria-selected');\n      } else {\n        add = true;\n        this.editRow.setAttribute('aria-selected', add.toString());\n      }\n\n      addRemoveActiveClasses([].slice.call(this.editRow.getElementsByClassName(rowCell)), add, ...this.activeClasses);\n    }\n  }\n\n}\n/**\n * `DropDownEditCell` is used to handle dropdown cell type editing.\n *\n * @hidden\n */\n\n\nclass DropDownEditCell extends EditCellBase {\n  constructor(parent) {\n    //constructor\n    super();\n    this.parent = parent;\n    this.flag = false;\n    this.removeEventHandler = this.removeEventListener;\n  }\n\n  write(args) {\n    const isInline = this.parent.editSettings.mode !== 'Dialog';\n    this.column = args.column;\n    const pred = new Predicate(args.column.field, 'notequal', null, true, false);\n    const params = {};\n\n    if (args.column.edit.params) {\n      const keys = Object.keys(args.column.edit.params);\n\n      for (let i = 0; i < keys.length; i++) {\n        params[keys[i]] = keys[i] === 'query' ? args.column.edit.params[keys[i]].clone() : args.column.edit.params[keys[i]];\n      }\n    }\n\n    this.obj = new DropDownList(extend({\n      dataSource: this.parent.dataSource instanceof DataManager ? this.parent.dataSource : new DataManager(this.parent.dataSource),\n      query: new Query().where(pred).select(args.column.field),\n      enabled: isEditable(args.column, args.requestType, args.element),\n      fields: {\n        value: args.column.field\n      },\n      value: getObject(args.column.field, args.rowData),\n      enableRtl: this.parent.enableRtl,\n      placeholder: isInline ? '' : args.column.headerText,\n      popupHeight: '200px',\n      floatLabelType: isInline ? 'Never' : 'Always',\n      sortOrder: 'Ascending'\n    }, params));\n\n    if (this.parent.enableVirtualization) {\n      this.obj.dataSource = [args.rowData];\n    }\n\n    this.addEventListener();\n    this.obj.query.params = this.parent.query.params;\n    this.obj.appendTo(args.element);\n    /* tslint:disable-next-line:no-any */\n\n    args.element.setAttribute('name', getComplexFieldID(args.column.field));\n  }\n\n  addEventListener() {\n    this.ddCreated = this.dropdownCreated.bind(this);\n    this.ddOpen = this.dropDownOpen.bind(this);\n    this.ddBeforeOpen = this.dropdownBeforeOpen.bind(this);\n    this.ddComplete = this.ddActionComplete.bind(this);\n    this.obj.addEventListener(create, this.ddCreated);\n    this.obj.addEventListener(open, this.ddOpen);\n    this.obj.addEventListener(beforeOpen, this.ddBeforeOpen);\n    this.obj.addEventListener(actionComplete, this.ddComplete);\n  }\n\n  removeEventListener() {\n    if (this.obj.isDestroyed) {\n      return;\n    }\n\n    this.obj.removeEventListener(create, this.ddCreated);\n    this.obj.removeEventListener(open, this.ddOpen);\n    this.obj.removeEventListener(beforeOpen, this.ddBeforeOpen);\n    this.obj.removeEventListener(actionComplete, this.ddComplete);\n  } // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  dropdownCreated(e) {\n    this.flag = true;\n  }\n\n  dropdownBeforeOpen() {\n    if (this.parent.enableVirtualization) {\n      this.obj.dataSource = this.parent.dataSource instanceof DataManager ? this.parent.dataSource : new DataManager(this.parent.dataSource);\n    }\n  }\n\n  ddActionComplete(e) {\n    e.result = DataUtil.distinct(e.result, this.obj.fields.value, true);\n\n    if (this.flag && this.column.dataSource) {\n      if ('result' in this.column.dataSource) {\n        this.column.dataSource.result = e.result;\n      } else if (this.column.dataSource instanceof DataManager) {\n        this.column.dataSource.dataSource.json = e.result;\n      }\n    }\n\n    this.flag = false;\n  }\n\n  dropDownOpen(args) {\n    const dlgElement = parentsUntil(this.obj.element, 'e-dialog');\n\n    if (this.parent.editSettings.mode === 'Dialog' && !isNullOrUndefined(dlgElement)) {\n      const dlgObj = select('#' + dlgElement.id, document).ej2_instances[0];\n      args.popup.element.style.zIndex = (dlgObj.zIndex + 1).toString();\n    }\n  }\n\n}\n/**\n * `NumericEditCell` is used to handle numeric cell type editing.\n *\n * @hidden\n */\n\n\nclass NumericEditCell {\n  constructor(parent) {\n    this.parent = parent;\n  }\n\n  keyEventHandler(args) {\n    if (args.keyCode === 13 || args.keyCode === 9) {\n      const evt = document.createEvent('HTMLEvents');\n      evt.initEvent('change', false, true); // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n      this.dispatchEvent(evt);\n    }\n  }\n\n  create(args) {\n    this.instances = new Internationalization(this.parent.locale);\n    return createEditElement(this.parent, args.column, 'e-field', {});\n  } // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  read(element) {\n    return this.obj.value;\n  }\n\n  write(args) {\n    const col = args.column;\n    const isInline = this.parent.editSettings.mode !== 'Dialog';\n    this.obj = new NumericTextBox(extend({\n      value: parseFloat(getObject(args.column.field, args.rowData)),\n      enableRtl: this.parent.enableRtl,\n      placeholder: isInline ? '' : args.column.headerText,\n      enabled: isEditable(args.column, args.requestType, args.element),\n      floatLabelType: this.parent.editSettings.mode !== 'Dialog' ? 'Never' : 'Always',\n      locale: this.parent.locale\n    }, col.edit.params));\n    args.element.setAttribute('name', getComplexFieldID(args.column.field));\n    this.obj.appendTo(args.element);\n    this.obj.element.addEventListener('keydown', this.keyEventHandler);\n  }\n\n  destroy() {\n    if (this.obj && !this.obj.isDestroyed) {\n      this.obj.element.removeEventListener('keydown', this.keyEventHandler);\n      this.obj.destroy();\n    }\n  }\n\n}\n/**\n * `DefaultEditCell` is used to handle default cell type editing.\n *\n * @hidden\n */\n\n\nclass DefaultEditCell extends EditCellBase {\n  create(args) {\n    const attr = {\n      type: 'text',\n      value: !isNullOrUndefined(args.value) ? args.value : '',\n      style: 'text-align:' + args.column.textAlign\n    };\n    return createEditElement(this.parent, args.column, 'e-field e-input e-defaultcell', attr);\n  }\n\n  read(element) {\n    return element.value;\n  }\n\n  write(args) {\n    const col = args.column;\n    const isInline = this.parent.editSettings.mode !== 'Dialog';\n    this.obj = new TextBox(extend({\n      element: args.element,\n      floatLabelType: this.parent.editSettings.mode !== 'Dialog' ? 'Never' : 'Always',\n      enableRtl: this.parent.enableRtl,\n      enabled: isEditable(args.column, args.requestType, args.element),\n      placeholder: isInline ? '' : args.column.headerText\n    }, col.edit.params));\n    this.obj.appendTo(args.element);\n  }\n\n}\n/**\n * `NormalEdit` module is used to handle normal('inline, dialog, external') editing actions.\n *\n * @hidden\n */\n\n\nclass NormalEdit {\n  constructor(parent, serviceLocator, renderer) {\n    this.args = {};\n    this.currentVirtualData = {};\n    this.parent = parent;\n    this.renderer = renderer;\n    this.serviceLocator = serviceLocator;\n    this.addEventListener();\n  }\n\n  clickHandler(e) {\n    const target = e.target;\n    const gObj = this.parent;\n\n    if ((parentsUntil(target, gridContent) && parentsUntil(parentsUntil(target, gridContent), 'e-grid').id === gObj.element.id || gObj.frozenRows && parentsUntil(target, headerContent)) && !parentsUntil(target, 'e-unboundcelldiv')) {\n      this.rowIndex = parentsUntil(target, rowCell) ? parseInt(target.parentElement.getAttribute(ariaRowIndex), 10) : -1;\n\n      if (gObj.isEdit) {\n        gObj.editModule.endEdit();\n      }\n    }\n  }\n\n  dblClickHandler(e) {\n    if (parentsUntil(e.target, rowCell) && this.parent.editSettings.allowEditOnDblClick) {\n      this.parent.editModule.startEdit(parentsUntil(e.target, row));\n    }\n  }\n  /**\n   * The function used to trigger editComplete\n   *\n   * @param {NotifyArgs} e - specifies the NotifyArgs\n   * @returns {void}\n   * @hidden\n   */\n\n\n  editComplete(e) {\n    this.parent.isEdit = false;\n    const action = 'action';\n\n    switch (e.requestType) {\n      case 'save':\n        if (!(this.parent.isCheckBoxSelection || this.parent.selectionSettings.type === 'Multiple') || !this.parent.isPersistSelection) {\n          if (e[action] !== 'edit') {\n            this.parent.selectRow(0);\n          }\n        }\n\n        this.parent.trigger(actionComplete, extend(e, {\n          requestType: 'save',\n          type: actionComplete\n        }));\n        break;\n\n      case 'delete':\n        this.parent.trigger(actionComplete, extend(e, {\n          requestType: 'delete',\n          type: actionComplete\n        }));\n\n        if (!this.parent.isCheckBoxSelection) {\n          this.parent.selectRow(this.editRowIndex);\n        }\n\n        break;\n    }\n  }\n\n  getEditArgs(editedData, rowObj, isScroll) {\n    const primaryKeys = this.parent.getPrimaryKeyFieldNames();\n    const primaryKeyValues = [];\n\n    for (let i = 0; i < primaryKeys.length; i++) {\n      primaryKeyValues.push(getObject(primaryKeys[i], editedData));\n    }\n\n    const args = {\n      primaryKey: primaryKeys,\n      primaryKeyValue: primaryKeyValues,\n      requestType: 'beginEdit',\n      rowData: editedData,\n      rowIndex: this.rowIndex,\n      type: 'edit',\n      cancel: false,\n      foreignKeyData: rowObj && rowObj.foreignKeyData,\n      target: undefined,\n      isScroll: isScroll\n    };\n    return args;\n  }\n\n  startEdit(tr) {\n    const gObj = this.parent;\n    this.rowIndex = this.editRowIndex = parseInt(tr.getAttribute(ariaRowIndex), 10);\n\n    if (gObj.enableVirtualization || gObj.enableInfiniteScrolling) {\n      const selector = '.e-row[aria-rowindex=\"' + this.rowIndex + '\"]';\n      const virtualRow = this.parent.element.querySelector(selector);\n\n      if (!virtualRow) {\n        return;\n      }\n    }\n\n    const e = {\n      data: undefined,\n      index: this.rowIndex,\n      isScroll: false\n    };\n    this.parent.notify(virtualScrollEditActionBegin, e);\n\n    if (isGroupAdaptive(gObj)) {\n      const rObj = gObj.getRowObjectFromUID(tr.getAttribute('data-uid'));\n      this.previousData = rObj.data;\n    } else if (!this.previousData && (this.parent.enableVirtualization || this.parent.enableInfiniteScrolling)) {\n      this.previousData = e.data;\n    } else if (!this.parent.enableVirtualization) {\n      this.previousData = extend({}, {}, gObj.getCurrentViewRecords()[this.rowIndex], true);\n    }\n\n    const editedData = extend({}, {}, e.data || this.previousData, true);\n    this.uid = tr.getAttribute('data-uid');\n    const rowObj = gObj.getRowObjectFromUID(this.uid);\n    const args = this.getEditArgs(editedData, rowObj, e.isScroll);\n    args.row = tr;\n\n    if (!args.isScroll) {\n      this.parent.notify(createVirtualValidationForm, {\n        uid: this.uid,\n        prevData: this.previousData,\n        argsCreator: this.getEditArgs.bind(this),\n        renderer: this.renderer\n      });\n      gObj.trigger(beginEdit, args, begineditargs => {\n        begineditargs.type = 'actionBegin';\n        gObj.trigger(actionBegin, begineditargs, editargs => {\n          if (!editargs.cancel) {\n            this.inlineEditHandler(editargs, tr);\n          }\n        });\n      });\n    } else {\n      this.inlineEditHandler(args, tr);\n    }\n  }\n\n  inlineEditHandler(editargs, tr) {\n    const gObj = this.parent;\n    gObj.isEdit = true;\n    editargs.row = editargs.row ? editargs.row : tr;\n\n    if (gObj.editSettings.mode !== 'Dialog') {\n      gObj.clearSelection();\n    }\n\n    if (gObj.editSettings.mode === 'Dialog' && gObj.selectionModule) {\n      gObj.selectionModule.preventFocus = true;\n      editargs.row.classList.add('e-dlgeditrow');\n    }\n\n    this.renderer.update(editargs);\n    this.uid = tr.getAttribute('data-uid');\n    gObj.editModule.applyFormValidation();\n    editargs.type = 'actionComplete';\n    gObj.trigger(actionComplete, editargs);\n    this.args = editargs;\n\n    if (this.parent.allowTextWrap) {\n      this.parent.notify(freezeRender, {\n        case: 'textwrap'\n      });\n    }\n  }\n\n  updateRow(index, data) {\n    const gObj = this.parent;\n    this.editRowIndex = index;\n    const args = {\n      requestType: 'save',\n      action: 'edit',\n      type: actionBegin,\n      data: data,\n      cancel: false,\n      previousData: gObj.getCurrentViewRecords()[index],\n      row: gObj.getRowByIndex(index)\n    };\n    gObj.showSpinner();\n    gObj.notify(updateData, args);\n\n    if (args.promise) {\n      args.promise.then(() => gObj.refresh()).catch(e => this.edFail(e));\n    } else {\n      gObj.refresh();\n    }\n  }\n\n  editFormValidate() {\n    const gObj = this.parent;\n    const isValid = gObj.editModule.editFormValidate();\n    const validationArgs = {\n      prevData: this.previousData,\n      isValid: true,\n      editIdx: this.editRowIndex,\n      addIdx: this.addedRowIndex\n    };\n    gObj.notify(validateVirtualForm, validationArgs);\n    return isValid && validationArgs.isValid;\n  }\n\n  endEdit() {\n    const gObj = this.parent;\n\n    if (!this.parent.isEdit || !this.editFormValidate()) {\n      return;\n    }\n\n    let editedData = extend({}, {}, this.previousData, true);\n    const args = extend(this.args, {\n      requestType: 'save',\n      type: actionBegin,\n      data: editedData,\n      cancel: false,\n      previousData: this.previousData,\n      selectedRow: gObj.selectedRowIndex,\n      foreignKeyData: {}\n    });\n    const index = gObj.getFrozenMode() === 'Right' ? 1 : 0;\n    const isDlg = gObj.editSettings.mode === 'Dialog';\n    const dlgWrapper = select('#' + gObj.element.id + '_dialogEdit_wrapper', document);\n    const dlgForm = isDlg ? dlgWrapper.querySelector('.e-gridform') : gObj.element.getElementsByClassName('e-gridform')[index];\n    const data = {\n      virtualData: extend({}, {}, this.previousData, true),\n      isAdd: false,\n      isScroll: false,\n      endEdit: true\n    };\n    this.parent.notify(getVirtualData, data);\n\n    if ((this.parent.enableVirtualization || this.parent.enableInfiniteScrolling) && this.parent.editSettings.mode === 'Normal' && Object.keys(data.virtualData).length) {\n      if (this.parent.isEdit) {\n        this.currentVirtualData = editedData = args.data = data.virtualData;\n      }\n    } else {\n      editedData = gObj.editModule.getCurrentEditedData(dlgForm, editedData);\n    }\n\n    if (gObj.isFrozenGrid() && gObj.editSettings.mode === 'Normal') {\n      const mhdrFrm = gObj.getMovableVirtualHeader().querySelector('.e-gridform');\n      const mCntFrm = gObj.getMovableVirtualContent().querySelector('.e-gridform');\n      const mvblEle = [mhdrFrm || mCntFrm];\n      let frHdrFrm;\n      let frCntFrm;\n      let frEle = [];\n\n      if (gObj.getFrozenMode() === leftRight) {\n        frHdrFrm = gObj.getFrozenRightHeader().querySelector('.e-gridform');\n        frCntFrm = gObj.getFrozenRightContent().querySelector('.e-gridform');\n        frEle = [frHdrFrm || frCntFrm];\n      }\n\n      gridActionHandler(this.parent, (tableName, elements) => {\n        for (const ele of elements) {\n          if (ele) {\n            editedData = gObj.editModule.getCurrentEditedData(ele, editedData);\n          }\n        }\n      }, [[], mvblEle, frEle]);\n    }\n\n    let eleLength = [].slice.call(gObj.element.getElementsByClassName(editedRow)).length;\n\n    if (!data.isAdd && Object.keys(this.currentVirtualData).length && !eleLength) {\n      eleLength = 1;\n    }\n\n    if (isDlg ? dlgWrapper.getElementsByClassName(editedRow).length : eleLength) {\n      args.action = 'edit';\n      gObj.trigger(actionBegin, args, endEditArgs => {\n        if (endEditArgs.cancel) {\n          return;\n        }\n\n        gObj.showSpinner();\n        gObj.notify(updateData, endEditArgs);\n      });\n    } else {\n      args.action = 'add';\n      args.selectedRow = 0;\n      args.index = this.addedRowIndex;\n      gObj.notify(virtualScrollEditSuccess, {});\n      gObj.notify(modelChanged, args);\n      this.addedRowIndex = null;\n\n      if (args.cancel) {\n        return;\n      }\n    }\n  }\n\n  destroyElements() {\n    const gObj = this.parent;\n    gObj.editModule.destroyWidgets();\n    gObj.editModule.destroyForm();\n    this.parent.notify(dialogDestroy, {});\n  }\n\n  editHandler(args) {\n    if (args.promise) {\n      args.promise.then(e => this.edSucc(e, args)).catch(e => this.edFail(e));\n    } else {\n      this.editSuccess(args.data, args);\n    }\n  }\n\n  edSucc(e, args) {\n    this.editSuccess(e, args);\n  }\n\n  edFail(e) {\n    this.editFailure(e);\n  }\n\n  updateCurrentViewData(data) {\n    if (!this.parent.enableVirtualization && !this.parent.enableInfiniteScrolling) {\n      this.parent.getCurrentViewRecords()[this.editRowIndex] = data;\n    }\n  }\n\n  requestSuccess(args) {\n    if (this.parent.editModule.formObj && !this.parent.editModule.formObj.isDestroyed) {\n      this.destroyElements();\n      this.stopEditStatus();\n\n      if (this.parent.editSettings.mode === 'Dialog' && args.action !== 'add' && this.parent.selectionModule) {\n        this.parent.element.querySelector('.e-dlgeditrow').classList.remove('e-dlgeditrow');\n      }\n    }\n  }\n\n  editSuccess(e, args) {\n    if (!isNullOrUndefined(e) && !(e instanceof Array)) {\n      const rowData = 'rowData';\n      args.data = extend({}, extend({}, args[rowData], args.data), e);\n    }\n\n    this.requestSuccess(args);\n    this.parent.trigger(beforeDataBound, args);\n    args.type = actionComplete;\n    this.parent.isEdit = false;\n    this.refreshRow(args.data);\n    this.parent.notify(virtualScrollEditSuccess, args);\n    this.parent.editModule.checkLastRow(args.row);\n    this.parent.editModule.isLastRow = false;\n    this.updateCurrentViewData(args.data);\n    this.blazorTemplate();\n    this.editRowIndex = null;\n    this.parent.trigger(actionComplete, args);\n\n    if (!(this.parent.isCheckBoxSelection || this.parent.selectionSettings.type === 'Multiple') || !this.parent.isPersistSelection && !this.parent.selectionSettings.checkboxOnly) {\n      if (this.parent.editSettings.mode !== 'Dialog') {\n        this.parent.selectRow(this.rowIndex > -1 ? this.rowIndex : this.editRowIndex);\n      }\n    }\n\n    this.parent.hideSpinner();\n  }\n\n  closeForm() {\n    if (!this.cloneRow && this.parent.isEdit) {\n      this.stopEditStatus();\n    }\n\n    if (this.cloneRow) {\n      this.cloneRow.remove();\n      this.cloneRow = null;\n      this.originalRow.classList.remove('e-hiddenrow');\n    }\n\n    if (this.parent.isFrozenGrid() && this.cloneFrozen) {\n      this.cloneFrozen.remove();\n      this.frozen.classList.remove('e-hiddenrow');\n    }\n  }\n\n  blazorTemplate() {\n    const cols = this.parent.getColumns();\n\n    if (this.parent.editSettings.template && this.parent.editSettings.mode === 'Normal') {\n      updateBlazorTemplate(this.parent.element.id + 'editSettingsTemplate', 'Template', this.parent.editSettings);\n    }\n\n    for (let i = 0; i < cols.length; i++) {\n      const col = cols[i];\n\n      if (col.template) {\n        updateBlazorTemplate(this.parent.element.id + col.uid, 'Template', col, false);\n      }\n\n      if (col.editTemplate) {\n        updateBlazorTemplate(this.parent.element.id + col.uid + 'editTemplate', 'EditTemplate', col);\n      }\n    }\n  }\n\n  editFailure(e) {\n    this.parent.trigger(actionFailure, {\n      error: e\n    });\n    this.parent.hideSpinner();\n    this.parent.log('actionfailure', {\n      error: e\n    });\n  }\n\n  needRefresh() {\n    let refresh = true;\n    const editedRow$$1 = this.parent.element.querySelector('.e-gridform');\n\n    if ((this.parent.enableVirtualization || this.parent.infiniteScrollSettings.enableCache) && this.parent.editSettings.mode === 'Normal' && !editedRow$$1) {\n      refresh = false;\n    }\n\n    return refresh;\n  }\n\n  refreshRow(data) {\n    const frzCols = this.parent.isFrozenGrid();\n    const row$$1 = new RowRenderer(this.serviceLocator, null, this.parent);\n    let rowObj = this.parent.getRowObjectFromUID(this.uid);\n\n    if (rowObj) {\n      rowObj.changes = data;\n      this.parent.notify(refreshVirtualCache, {\n        data: data\n      });\n      refreshForeignData(rowObj, this.parent.getForeignKeyColumns(), rowObj.changes);\n\n      if (this.needRefresh()) {\n        row$$1.refresh(rowObj, this.parent.getColumns(), true);\n      }\n\n      const tr = [].slice.call(this.parent.element.querySelectorAll('[aria-rowindex=\"' + rowObj.index + '\"]'));\n\n      if (frzCols && tr.length) {\n        for (let i = 0; i < tr.length; i++) {\n          const rowUid = tr[i].getAttribute('data-uid');\n\n          if (rowUid !== this.uid) {\n            rowObj = this.parent.getRowObjectFromUID(rowUid);\n            rowObj.changes = data;\n            row$$1.refresh(rowObj, this.parent.getColumns(), true);\n            this.parent.editModule.checkLastRow(tr[i]);\n          }\n        }\n      }\n    }\n  }\n\n  closeEdit() {\n    if (!this.parent.isEdit) {\n      return;\n    }\n\n    const gObj = this.parent;\n    const args = extend(this.args, {\n      requestType: 'cancel',\n      type: actionBegin,\n      cancel: false,\n      data: this.previousData,\n      selectedRow: gObj.selectedRowIndex\n    });\n    gObj.notify(virtualScrollEditCancel, args);\n    this.blazorTemplate();\n    gObj.trigger(actionBegin, args, closeEditArgs => {\n      if (closeEditArgs.cancel) {\n        return;\n      }\n\n      if (this.parent.editSettings.mode === 'Dialog') {\n        this.parent.notify(dialogDestroy, {});\n      }\n\n      gObj.isEdit = false;\n      this.stopEditStatus();\n      closeEditArgs.type = actionComplete;\n\n      if (gObj.editSettings.mode !== 'Dialog') {\n        this.refreshRow(closeEditArgs.data);\n      }\n\n      const isLazyLoad = gObj.groupSettings.enableLazyLoading && gObj.groupSettings.columns.length && !gObj.getContentTable().querySelector('tr.e-emptyrow');\n\n      if (!gObj.getContentTable().querySelector('tr.e-emptyrow') && !gObj.getContentTable().querySelector('tr.e-row') && !isLazyLoad) {\n        gObj.renderModule.emptyRow();\n      }\n\n      if (gObj.editSettings.mode !== 'Dialog') {\n        gObj.selectRow(this.rowIndex);\n      }\n\n      gObj.trigger(actionComplete, closeEditArgs);\n    });\n  }\n\n  addRecord(data, index) {\n    const gObj = this.parent;\n    this.addedRowIndex = index = !isNullOrUndefined(index) ? index : 0;\n\n    if (data) {\n      gObj.notify(modelChanged, {\n        requestType: 'save',\n        type: actionBegin,\n        data: data,\n        selectedRow: 0,\n        action: 'add',\n        index: index\n      });\n      return;\n    }\n\n    if (gObj.isEdit) {\n      return;\n    }\n\n    this.previousData = {};\n    this.uid = '';\n    const cols = gObj.getColumns();\n    const rowData = {\n      virtualData: {},\n      isScroll: false\n    };\n    this.parent.notify(getVirtualData, rowData);\n\n    for (let i = 0; i < cols.length; i++) {\n      if (rowData.isScroll && cols[i].getFreezeTableName() !== 'movable') {\n        continue;\n      }\n\n      if (cols[i].field) {\n        DataUtil.setValue(cols[i].field, cols[i].defaultValue, this.previousData);\n      }\n    }\n\n    const args = {\n      cancel: false,\n      foreignKeyData: {},\n      requestType: 'add',\n      data: this.previousData,\n      type: actionBegin,\n      index: index,\n      rowData: this.previousData,\n      target: undefined,\n      isScroll: rowData.isScroll\n    };\n\n    if ((this.parent.enableVirtualization || this.parent.infiniteScrollSettings.enableCache) && Object.keys(rowData.virtualData).length) {\n      args.data = args.rowData = rowData.virtualData;\n    }\n\n    if (!args.isScroll) {\n      this.parent.notify(createVirtualValidationForm, {\n        uid: this.uid,\n        prevData: this.previousData,\n        argsCreator: this.getEditArgs.bind(this),\n        renderer: this.renderer\n      });\n      gObj.trigger(actionBegin, args, addArgs => {\n        if (addArgs.cancel) {\n          return;\n        }\n\n        this.inlineAddHandler(addArgs);\n      });\n    } else {\n      this.inlineAddHandler(args);\n    }\n  }\n\n  inlineAddHandler(addArgs) {\n    const gObj = this.parent;\n    gObj.isEdit = true;\n\n    if (gObj.editSettings.mode !== 'Dialog') {\n      gObj.clearSelection();\n    }\n\n    this.renderer.addNew(addArgs);\n    gObj.editModule.applyFormValidation();\n    addArgs.type = actionComplete;\n    addArgs.row = gObj.element.querySelector('.' + addedRow);\n    gObj.trigger(actionComplete, addArgs);\n    this.args = addArgs;\n  }\n\n  deleteRecord(fieldname, data) {\n    this.editRowIndex = this.parent.selectedRowIndex;\n\n    if (data) {\n      data = data instanceof Array ? data : [data];\n      const gObj = this.parent;\n      const dataLen = Object.keys(data).length;\n      fieldname = fieldname || this.parent.getPrimaryKeyFieldNames()[0];\n\n      for (let i = 0; i < dataLen; i++) {\n        let tmpRecord;\n        const contained = gObj.currentViewData.some(record => {\n          tmpRecord = record;\n          return data[i] === getObject(fieldname, record) || data[i] === record;\n        });\n        data[i] = contained ? tmpRecord : data[i][fieldname] ? data[i] : {\n          [fieldname]: data[i]\n        };\n      }\n    }\n\n    const args = {\n      requestType: 'delete',\n      type: actionBegin,\n      foreignKeyData: {},\n      data: data ? data : this.parent.getSelectedRecords(),\n      tr: this.parent.getSelectedRows(),\n      cancel: false\n    };\n\n    if (!isNullOrUndefined(this.parent.commandDelIndex)) {\n      args.data[0] = this.parent.getRowObjectFromUID(this.parent.getRowByIndex(this.parent.commandDelIndex).getAttribute('data-uid')).data;\n    }\n\n    if (this.parent.enableVirtualization && args.data.length > 1) {\n      const uid = this.parent.getSelectedRows()[0].getAttribute('data-uid');\n      args.data = [this.parent.getRowObjectFromUID(uid).data];\n    }\n\n    this.parent.notify(modelChanged, args);\n  }\n\n  stopEditStatus() {\n    const gObj = this.parent;\n    const addElements = [].slice.call(gObj.element.getElementsByClassName(addedRow));\n    const editElements = [].slice.call(gObj.element.getElementsByClassName(editedRow));\n\n    for (let i = 0; i < addElements.length; i++) {\n      remove(addElements[i]);\n    }\n\n    for (let i = 0; i < editElements.length; i++) {\n      editElements[i].classList.remove(editedRow);\n    }\n  }\n  /**\n   * @returns {void}\n   * @hidden\n   */\n\n\n  addEventListener() {\n    if (this.parent.isDestroyed) {\n      return;\n    }\n\n    this.evtHandlers = [{\n      event: crudAction,\n      handler: this.editHandler\n    }, {\n      event: doubleTap,\n      handler: this.dblClickHandler\n    }, {\n      event: click,\n      handler: this.clickHandler\n    }, {\n      event: recordAdded,\n      handler: this.requestSuccess\n    }, {\n      event: dblclick,\n      handler: this.dblClickHandler\n    }, {\n      event: deleteComplete,\n      handler: this.editComplete\n    }, {\n      event: saveComplete,\n      handler: this.editComplete\n    }, {\n      event: rowModeChange,\n      handler: this.closeEdit\n    }, {\n      event: closeInline,\n      handler: this.closeForm\n    }];\n    addRemoveEventListener(this.parent, this.evtHandlers, true, this);\n  }\n  /**\n   * @returns {void}\n   * @hidden\n   */\n\n\n  removeEventListener() {\n    if (this.parent.isDestroyed) {\n      return;\n    }\n\n    addRemoveEventListener(this.parent, this.evtHandlers, false);\n  }\n  /**\n   * @returns {void}\n   * @hidden\n   */\n\n\n  destroy() {\n    this.removeEventListener();\n    this.renderer.destroy();\n  }\n\n}\n/**\n * `InlineEdit` module is used to handle inline editing actions.\n *\n * @hidden\n */\n\n\nclass InlineEdit extends NormalEdit {\n  constructor(parent, serviceLocator, renderer) {\n    super(parent, serviceLocator);\n    this.parent = parent;\n    this.serviceLocator = serviceLocator;\n    this.renderer = renderer;\n  }\n\n  closeEdit() {\n    super.closeEdit();\n  }\n\n  addRecord(data, index) {\n    super.addRecord(data, index);\n  }\n\n  endEdit() {\n    super.endEdit();\n  }\n\n  updateRow(index, data) {\n    super.updateRow(index, data);\n  }\n\n  deleteRecord(fieldname, data) {\n    super.deleteRecord(fieldname, data);\n  }\n\n  startEdit(tr) {\n    super.startEdit(tr);\n  }\n\n}\n/**\n * `BatchEdit` module is used to handle batch editing actions.\n *\n * @hidden\n */\n\n\nclass BatchEdit {\n  constructor(parent, serviceLocator, renderer) {\n    this.cellDetails = {};\n    this.originalCell = {};\n    this.cloneCell = {};\n    this.editNext = false;\n    this.preventSaveCell = false;\n    this.parent = parent;\n    this.serviceLocator = serviceLocator;\n    this.renderer = renderer;\n    this.focus = serviceLocator.getService('focus');\n    this.addEventListener();\n  }\n  /**\n   * @returns {void}\n   * @hidden\n   */\n\n\n  addEventListener() {\n    if (this.parent.isDestroyed) {\n      return;\n    }\n\n    this.evtHandlers = [{\n      event: click,\n      handler: this.clickHandler\n    }, {\n      event: dblclick,\n      handler: this.dblClickHandler\n    }, {\n      event: beforeCellFocused,\n      handler: this.onBeforeCellFocused\n    }, {\n      event: cellFocused,\n      handler: this.onCellFocused\n    }, {\n      event: doubleTap,\n      handler: this.dblClickHandler\n    }, {\n      event: keyPressed,\n      handler: this.keyDownHandler\n    }, {\n      event: editNextValCell,\n      handler: this.editNextValCell\n    }, {\n      event: closeBatch,\n      handler: this.closeForm\n    }, {\n      event: destroy,\n      handler: this.destroy\n    }];\n    addRemoveEventListener(this.parent, this.evtHandlers, true, this);\n    this.dataBoundFunction = this.dataBound.bind(this);\n    this.batchCancelFunction = this.batchCancel.bind(this);\n    this.parent.addEventListener(dataBound, this.dataBoundFunction);\n    this.parent.addEventListener(batchCancel, this.batchCancelFunction);\n  }\n  /**\n   * @returns {void}\n   * @hidden\n   */\n\n\n  removeEventListener() {\n    if (this.parent.isDestroyed) {\n      return;\n    }\n\n    addRemoveEventListener(this.parent, this.evtHandlers, false);\n    this.parent.removeEventListener(dataBound, this.dataBoundFunction);\n    this.parent.removeEventListener(batchCancel, this.batchCancelFunction);\n  }\n\n  batchCancel() {\n    this.parent.focusModule.restoreFocus();\n  }\n\n  dataBound() {\n    this.parent.notify(toolbarRefresh, {});\n  }\n  /**\n   * @returns {void}\n   * @hidden\n   */\n\n\n  destroy() {\n    this.removeEventListener();\n  }\n\n  clickHandler(e) {\n    if (!parentsUntil(e.target, this.parent.element.id + '_add', true)) {\n      if (this.parent.isEdit && closest(this.form, 'td') !== closest(e.target, 'td')) {\n        this.saveCell();\n        this.editNextValCell();\n      }\n\n      if (parentsUntil(e.target, rowCell) && !this.parent.isEdit) {\n        this.setCellIdx(e.target);\n      }\n    }\n  }\n\n  dblClickHandler(e) {\n    const target = parentsUntil(e.target, rowCell);\n    const tr = parentsUntil(e.target, row);\n    const rowIndex = tr && parseInt(tr.getAttribute(ariaRowIndex), 10);\n    const colIndex = target && parseInt(target.getAttribute(ariaColIndex), 10);\n\n    if (!isNullOrUndefined(target) && !isNullOrUndefined(rowIndex) && !isNaN(colIndex) && !target.parentElement.classList.contains(editedRow)) {\n      this.editCell(rowIndex, this.parent.getColumns()[colIndex].field, this.isAddRow(rowIndex));\n    }\n  }\n\n  onBeforeCellFocused(e) {\n    if (this.parent.isEdit && this.validateFormObj() && (e.byClick || ['tab', 'shiftTab', 'enter', 'shiftEnter'].indexOf(e.keyArgs.action) > -1)) {\n      e.cancel = true;\n\n      if (e.byClick) {\n        e.clickArgs.preventDefault();\n      } else {\n        e.keyArgs.preventDefault();\n      }\n    }\n  }\n\n  onCellFocused(e) {\n    const frzCols = this.parent.getFrozenLeftCount();\n    const frzRightCols = this.parent.getFrozenRightColumnsCount();\n    const mCont = this.parent.getContent().querySelector('.' + movableContent);\n    const mHdr = this.parent.getHeaderContent().querySelector('.' + movableHeader);\n    const clear = (!e.container.isContent || !e.container.isDataCell) && !(this.parent.frozenRows && e.container.isHeader);\n\n    if (!e.byKey || clear) {\n      if (this.parent.isEdit && clear) {\n        this.saveCell();\n      }\n\n      return;\n    }\n\n    let [rowIndex, cellIndex] = e.container.indexes;\n\n    if (frzCols && (mCont.contains(e.element) || this.parent.frozenRows && mHdr.contains(e.element))) {\n      cellIndex += frzCols;\n    }\n\n    if (frzRightCols) {\n      const frHdr = this.parent.getHeaderContent().querySelector('.e-frozen-right-header');\n      const frCont = this.parent.getContent().querySelector('.e-frozen-right-content');\n\n      if (frCont.contains(e.element) || this.parent.frozenRows && frHdr.contains(e.element)) {\n        cellIndex += frzCols + this.parent.getMovableColumnsCount();\n      }\n    }\n\n    if (this.parent.frozenRows && e.container.isContent) {\n      rowIndex += this.parent.frozenRows;\n    }\n\n    let isEdit = this.parent.isEdit;\n\n    if (!this.parent.element.getElementsByClassName('e-popup-open').length) {\n      isEdit = isEdit && !this.validateFormObj();\n\n      switch (e.keyArgs.action) {\n        case 'tab':\n        case 'shiftTab':\n          // eslint-disable-next-line no-case-declarations\n          const col = this.parent.getColumns()[e.indexes[1]];\n\n          if (col && !this.parent.isEdit) {\n            this.editCell(e.indexes[0], col.field);\n          }\n\n          if (isEdit || this.parent.isLastCellPrimaryKey) {\n            this.editCellFromIndex(rowIndex, cellIndex);\n          }\n\n          break;\n\n        case 'enter':\n        case 'shiftEnter':\n          e.keyArgs.preventDefault(); // eslint-disable-next-line no-case-declarations\n\n          const args = {\n            cancel: false,\n            keyArgs: e.keyArgs\n          };\n          this.parent.notify('beforeFocusCellEdit', args);\n\n          if (!args.cancel && isEdit) {\n            this.editCell(rowIndex, this.cellDetails.column.field);\n          }\n\n          break;\n\n        case 'f2':\n          this.editCellFromIndex(rowIndex, cellIndex);\n          this.focus.focus();\n          break;\n      }\n    }\n  }\n\n  isAddRow(index) {\n    return this.parent.getDataRows()[index].classList.contains('e-insertedrow');\n  }\n\n  editCellFromIndex(rowIdx, cellIdx) {\n    this.cellDetails.rowIndex = rowIdx;\n    this.cellDetails.cellIndex = cellIdx;\n    this.editCell(rowIdx, this.parent.getColumns()[cellIdx].field, this.isAddRow(rowIdx));\n  }\n\n  closeEdit() {\n    const gObj = this.parent;\n    const rows = this.parent.getRowsObject();\n    const argument = {\n      cancel: false,\n      batchChanges: this.getBatchChanges()\n    };\n    gObj.notify(beforeBatchCancel, argument);\n\n    if (argument.cancel) {\n      return;\n    }\n\n    if (gObj.isEdit) {\n      this.saveCell(true);\n    }\n\n    this.isAdded = false;\n    gObj.clearSelection();\n    const allRows = getGridRowObjects(this.parent);\n\n    for (let i = 0; i < rows.length; i++) {\n      let isInsert = false;\n      const isDirty = rows[i].isDirty;\n      gridActionHandler(this.parent, (tableName, rows) => {\n        isInsert = this.removeBatchElementChanges(rows[i], isDirty);\n\n        if (isInsert) {\n          rows.splice(i, 1);\n        }\n      }, allRows);\n\n      if (isInsert) {\n        i--;\n      }\n    }\n\n    if (!gObj.getContentTable().querySelector('tr.e-row')) {\n      gObj.renderModule.renderEmptyRow();\n    }\n\n    let args = {\n      requestType: 'batchCancel',\n      rows: this.parent.getRowsObject()\n    };\n    gObj.notify(batchCancel, {\n      rows: this.parent.getRowsObject().length ? this.parent.getRowsObject() : [new Row({\n        isDataRow: true,\n        cells: [new Cell({\n          isDataCell: true,\n          visible: true\n        })]\n      })]\n    });\n    gObj.selectRow(this.cellDetails.rowIndex);\n    this.refreshRowIdx();\n    gObj.notify(toolbarRefresh, {});\n    this.parent.notify(tooltipDestroy, {});\n    args = {\n      requestType: 'batchCancel',\n      rows: this.parent.getRowsObject()\n    };\n    gObj.trigger(batchCancel, args);\n  }\n\n  removeBatchElementChanges(row$$1, isDirty) {\n    const gObj = this.parent;\n    const rowRenderer = new RowRenderer(this.serviceLocator, null, this.parent);\n    let isInstertedRemoved = false;\n\n    if (isDirty) {\n      row$$1.isDirty = isDirty;\n      const tr = gObj.getRowElementByUID(row$$1.uid);\n\n      if (tr) {\n        if (tr.classList.contains('e-insertedrow')) {\n          remove(tr);\n          isInstertedRemoved = true;\n        } else {\n          refreshForeignData(row$$1, this.parent.getForeignKeyColumns(), row$$1.data);\n          delete row$$1.changes;\n          delete row$$1.edit;\n          row$$1.isDirty = false;\n          classList(tr, [], ['e-hiddenrow', 'e-updatedtd']);\n          rowRenderer.refresh(row$$1, gObj.getColumns(), false);\n        }\n\n        if (this.parent.aggregates.length > 0) {\n          const type = 'type';\n          const editType = [];\n          editType[type] = 'cancel';\n          this.parent.notify(refreshFooterRenderer, editType);\n\n          if (this.parent.groupSettings.columns.length > 0) {\n            this.parent.notify(groupAggregates, editType);\n          }\n        }\n      }\n    }\n\n    return isInstertedRemoved;\n  }\n\n  removeHideAndSelection(tr) {\n    if (tr.classList.contains('e-hiddenrow')) {\n      tr.removeAttribute('aria-selected');\n      const tdElements = [].slice.call(tr.getElementsByClassName('e-selectionbackground'));\n\n      for (let i = 0; i < tdElements.length; i++) {\n        removeClass([tdElements[i]], ['e-selectionbackground', 'e-active']);\n      }\n    }\n\n    classList(tr, [], ['e-hiddenrow', 'e-updatedtd']);\n  }\n\n  deleteRecord(fieldname, data) {\n    this.saveCell();\n\n    if (this.validateFormObj()) {\n      this.saveCell(true);\n    }\n\n    this.isAdded = false;\n    this.bulkDelete(fieldname, data);\n\n    if (this.parent.aggregates.length > 0) {\n      this.parent.notify(refreshFooterRenderer, {});\n\n      if (this.parent.groupSettings.columns.length > 0) {\n        this.parent.notify(groupAggregates, {});\n      }\n    }\n  }\n\n  addRecord(data) {\n    this.bulkAddRow(data);\n  }\n\n  endEdit() {\n    if (this.parent.isEdit && this.validateFormObj()) {\n      return;\n    }\n\n    this.batchSave();\n  }\n\n  closeForm() {\n    for (let i = 0; i < Object.keys(this.originalCell).length; i++) {\n      for (let j = 0; j < Object.keys(this.cloneCell).length; j++) {\n        if (Object.keys(this.originalCell)[i] === Object.keys(this.cloneCell)[j]) {\n          this.cloneCell[Object.keys(this.cloneCell)[j]].replaceWith(this.originalCell[Object.keys(this.originalCell)[i]]);\n\n          if (this.originalCell[Object.keys(this.originalCell)[i]].classList.contains('e-selectionbackground')) {\n            this.originalCell[Object.keys(this.originalCell)[i]].classList.remove('e-selectionbackground', 'e-cellselectionbackground', 'e-active');\n          }\n        }\n      }\n    }\n\n    this.cloneCell = {};\n    this.originalCell = {};\n  }\n\n  validateFormObj() {\n    return this.parent.editModule.formObj && !this.parent.editModule.formObj.validate();\n  }\n\n  batchSave() {\n    const gObj = this.parent;\n    const deletedRecords$$1 = 'deletedRecords';\n\n    if (gObj.isCheckBoxSelection) {\n      const checkAllBox = gObj.element.querySelector('.e-checkselectall').parentElement;\n\n      if (checkAllBox.classList.contains('e-checkbox-disabled') && gObj.pageSettings.totalRecordsCount > gObj.currentViewData.length) {\n        removeClass([checkAllBox], ['e-checkbox-disabled']);\n      }\n    }\n\n    this.saveCell();\n\n    if (gObj.isEdit || this.editNextValCell() || gObj.isEdit) {\n      return;\n    }\n\n    const changes = this.getBatchChanges();\n\n    if (this.parent.selectionSettings.type === 'Multiple' && changes[deletedRecords$$1].length && this.parent.selectionSettings.persistSelection) {\n      changes[deletedRecords$$1] = this.removeSelectedData;\n      this.removeSelectedData = [];\n    }\n\n    const original = {\n      changedRecords: this.parent.getRowsObject().filter(row$$1 => row$$1.isDirty && ['add', 'delete'].indexOf(row$$1.edit) === -1).map(row$$1 => row$$1.data)\n    };\n    const args = {\n      batchChanges: changes,\n      cancel: false\n    };\n    gObj.trigger(beforeBatchSave, args, beforeBatchSaveArgs => {\n      if (beforeBatchSaveArgs.cancel) {\n        return;\n      }\n\n      gObj.showSpinner();\n      gObj.notify(bulkSave, {\n        changes: changes,\n        original: original\n      });\n    });\n  }\n\n  getBatchChanges() {\n    const changes = {\n      addedRecords: [],\n      deletedRecords: [],\n      changedRecords: []\n    };\n    const rows = this.parent.getRowsObject();\n\n    for (const row$$1 of rows) {\n      if (row$$1.isDirty) {\n        switch (row$$1.edit) {\n          case 'add':\n            changes.addedRecords.push(row$$1.changes);\n            break;\n\n          case 'delete':\n            changes.deletedRecords.push(row$$1.data);\n            break;\n\n          default:\n            changes.changedRecords.push(row$$1.changes);\n        }\n      }\n    }\n\n    return changes;\n  }\n  /**\n   * @param {string} uid - specifes the uid\n   * @returns {void}\n   * @hidden\n   */\n\n\n  removeRowObjectFromUID(uid) {\n    const rows = this.parent.getRowsObject();\n    let i = 0;\n\n    for (let len = rows.length; i < len; i++) {\n      if (rows[i].uid === uid) {\n        break;\n      }\n    }\n\n    gridActionHandler(this.parent, (tableName, rows) => {\n      rows.splice(i, 1);\n    }, getGridRowObjects(this.parent));\n  }\n  /**\n   * @param {Row<Column>} row - specifies the row object\n   * @returns {void}\n   * @hidden\n   */\n\n\n  addRowObject(row$$1) {\n    const gObj = this.parent;\n    const isTop = gObj.editSettings.newRowPosition === 'Top';\n    gridActionHandler(this.parent, (tableName, rows) => {\n      const rowClone = row$$1.clone();\n      rowClone.cells = splitFrozenRowObjectCells(gObj, rowClone.cells, tableName);\n\n      if (isTop) {\n        rows.unshift(rowClone);\n      } else {\n        rows.push(rowClone);\n      }\n    }, getGridRowObjects(this.parent), true);\n  } // tslint:disable-next-line:max-func-body-length\n\n\n  bulkDelete(fieldname, data) {\n    this.removeSelectedData = [];\n    const gObj = this.parent;\n    let index = gObj.selectedRowIndex;\n    let selectedRows = gObj.getSelectedRows();\n    const args = {\n      primaryKey: this.parent.getPrimaryKeyFieldNames(),\n      rowIndex: index,\n      rowData: data ? data : gObj.getSelectedRecords()[0],\n      cancel: false\n    };\n\n    if (data) {\n      args.row = gObj.editModule.deleteRowUid ? gObj.getRowElementByUID(gObj.editModule.deleteRowUid) : gObj.getRows()[gObj.getCurrentViewRecords().indexOf(data)];\n    } else {\n      args.row = data ? gObj.getRows()[index] : selectedRows[0];\n    }\n\n    if (!args.row) {\n      return;\n    } // tslint:disable-next-line:max-func-body-length\n\n\n    gObj.trigger(beforeBatchDelete, args, beforeBatchDeleteArgs => {\n      if (beforeBatchDeleteArgs.cancel) {\n        return;\n      }\n\n      this.removeSelectedData = gObj.getSelectedRecords();\n      gObj.clearSelection();\n      beforeBatchDeleteArgs.row = beforeBatchDeleteArgs.row ? beforeBatchDeleteArgs.row : data ? gObj.getRows()[index] : selectedRows[0];\n\n      if (this.parent.isFrozenGrid()) {\n        if (data) {\n          index = parseInt(beforeBatchDeleteArgs.row.getAttribute(ariaRowIndex), 10);\n          selectedRows = [];\n          selectedRows.push(gObj.getRowByIndex(index));\n          selectedRows.push(gObj.getMovableRowByIndex(index));\n\n          if (gObj.getFrozenMode() === leftRight) {\n            selectedRows.push(gObj.getFrozenRightRowByIndex(index));\n          }\n        }\n\n        for (let i = 0; i < selectedRows.length; i++) {\n          const uid = selectedRows[i].getAttribute('data-uid');\n\n          if (selectedRows[i].classList.contains('e-insertedrow')) {\n            this.removeRowObjectFromUID(uid);\n            remove(selectedRows[i]);\n          } else {\n            const rowObj = gObj.getRowObjectFromUID(uid);\n            rowObj.isDirty = true;\n            rowObj.edit = 'delete';\n            classList(selectedRows[i], ['e-hiddenrow', 'e-updatedtd'], []);\n\n            if (gObj.frozenRows && index < gObj.frozenRows && gObj.getMovableDataRows().length >= gObj.frozenRows) {\n              gObj.getMovableHeaderTbody().appendChild(gObj.getMovableRowByIndex(gObj.frozenRows - 1));\n              gObj.getFrozenHeaderTbody().appendChild(gObj.getRowByIndex(gObj.frozenRows - 1));\n\n              if (gObj.getFrozenMode() === leftRight) {\n                gObj.getFrozenRightHeaderTbody().appendChild(gObj.getFrozenRightRowByIndex(gObj.frozenRows - 1));\n              }\n            }\n\n            if (gObj.frozenRows && index < gObj.frozenRows && gObj.getDataRows().length >= gObj.frozenRows) {\n              gObj.getHeaderTable().querySelector(tbody).appendChild(gObj.getRowByIndex(gObj.frozenRows - 1));\n            }\n          }\n\n          delete selectedRows[i];\n        }\n      } else if (!this.parent.isFrozenGrid() && (selectedRows.length === 1 || data)) {\n        let uid = beforeBatchDeleteArgs.row.getAttribute('data-uid');\n        uid = data && this.parent.editModule.deleteRowUid ? uid = this.parent.editModule.deleteRowUid : uid;\n\n        if (beforeBatchDeleteArgs.row.classList.contains('e-insertedrow')) {\n          this.removeRowObjectFromUID(uid);\n          remove(beforeBatchDeleteArgs.row);\n        } else {\n          const rowObj = gObj.getRowObjectFromUID(uid);\n          rowObj.isDirty = true;\n          rowObj.edit = 'delete';\n          classList(beforeBatchDeleteArgs.row, ['e-hiddenrow', 'e-updatedtd'], []);\n        }\n\n        delete beforeBatchDeleteArgs.row;\n      } else {\n        for (let i = 0; i < selectedRows.length; i++) {\n          const uniqueid = selectedRows[i].getAttribute('data-uid');\n\n          if (selectedRows[i].classList.contains('e-insertedrow')) {\n            this.removeRowObjectFromUID(uniqueid);\n            remove(selectedRows[i]);\n          } else {\n            classList(selectedRows[i], ['e-hiddenrow', 'e-updatedtd'], []);\n            const selectedRow = gObj.getRowObjectFromUID(uniqueid);\n            selectedRow.isDirty = true;\n            selectedRow.edit = 'delete';\n            delete selectedRows[i];\n          }\n        }\n      }\n\n      this.refreshRowIdx();\n\n      if (data) {\n        gObj.editModule.deleteRowUid = undefined;\n\n        if (gObj.getSelectedRows().length) {\n          index = parseInt(gObj.getSelectedRows()[0].getAttribute(ariaRowIndex), 10);\n        }\n      }\n\n      if (!gObj.isCheckBoxSelection) {\n        gObj.selectRow(index);\n      }\n\n      gObj.trigger(batchDelete, beforeBatchDeleteArgs);\n      gObj.notify(batchDelete, {\n        rows: this.parent.getRowsObject()\n      });\n      gObj.notify(toolbarRefresh, {});\n    });\n  }\n\n  refreshRowIdx() {\n    const gObj = this.parent;\n    const rows = gObj.getAllDataRows(true);\n    const dataRows = getGridRowElements(this.parent);\n    const dataObjects = getGridRowObjects(this.parent);\n\n    for (let i = 0, j = 0, len = rows.length; i < len; i++) {\n      if (rows[i].classList.contains(row) && !rows[i].classList.contains('e-hiddenrow')) {\n        gridActionHandler(this.parent, (tableName, rowElements, rowObjects) => {\n          rowElements[i].setAttribute(ariaRowIndex, j.toString());\n          rowObjects[i].index = j;\n        }, dataRows, null, dataObjects);\n        j++;\n      } else {\n        gridActionHandler(this.parent, (tableName, rowElements, rowObjects) => {\n          rowElements[i].removeAttribute(ariaRowIndex);\n          rowObjects[i].index = -1;\n        }, dataRows, null, dataObjects);\n      }\n    }\n  }\n\n  getIndexFromData(data) {\n    return inArray(data, this.parent.getCurrentViewRecords());\n  }\n\n  bulkAddRow(data) {\n    const gObj = this.parent;\n\n    if (!gObj.editSettings.allowAdding) {\n      return;\n    }\n\n    if (gObj.isEdit) {\n      this.saveCell();\n      this.parent.notify(editNextValCell, {});\n    }\n\n    if (gObj.isEdit) {\n      return;\n    }\n\n    this.parent.element.classList.add('e-editing');\n    const defaultData = data ? data : this.getDefaultData();\n    const args = {\n      defaultData: defaultData,\n      primaryKey: gObj.getPrimaryKeyFieldNames(),\n      cancel: false\n    };\n    gObj.trigger(beforeBatchAdd, args, beforeBatchAddArgs => {\n      if (beforeBatchAddArgs.cancel) {\n        return;\n      }\n\n      this.isAdded = true;\n      gObj.clearSelection();\n      let mTr;\n      let frTr;\n      const row$$1 = new RowRenderer(this.serviceLocator, null, this.parent);\n      const model = new RowModelGenerator(this.parent);\n      const modelData = model.generateRows([beforeBatchAddArgs.defaultData]);\n      let tr = row$$1.render(modelData[0], gObj.getColumns());\n      let col;\n      let index;\n\n      for (let i = 0; i < this.parent.groupSettings.columns.length; i++) {\n        tr.insertBefore(this.parent.createElement('td', {\n          className: 'e-indentcell'\n        }), tr.firstChild);\n        modelData[0].cells.unshift(new Cell({\n          cellType: CellType.Indent\n        }));\n      }\n\n      let tbody$$1 = gObj.getContentTable().querySelector(tbody);\n      tr.classList.add('e-insertedrow');\n\n      if (tbody$$1.querySelector('.e-emptyrow')) {\n        const emptyRow = tbody$$1.querySelector('.e-emptyrow');\n        emptyRow.parentNode.removeChild(emptyRow);\n        this.removeFrozenTbody();\n      }\n\n      if (gObj.isFrozenGrid()) {\n        frTr = tr.cloneNode(true);\n        mTr = this.renderMovable(tr, frTr);\n        tr = gObj.getFrozenMode() === 'Right' ? frTr : tr;\n        this.renderFrozenAddRow(tr, mTr, frTr);\n      }\n\n      if (gObj.frozenRows && gObj.editSettings.newRowPosition === 'Top') {\n        tbody$$1 = gObj.getHeaderTable().querySelector(tbody);\n      } else {\n        tbody$$1 = gObj.getContentTable().querySelector(tbody);\n      }\n\n      if (this.parent.editSettings.newRowPosition === 'Top') {\n        tbody$$1.insertBefore(tr, tbody$$1.firstChild);\n      } else {\n        tbody$$1.appendChild(tr);\n      }\n\n      addClass([].slice.call(tr.getElementsByClassName(rowCell)), ['e-updatedtd']);\n      modelData[0].isDirty = true;\n      modelData[0].changes = extend({}, {}, modelData[0].data, true);\n      modelData[0].edit = 'add';\n      this.addRowObject(modelData[0]);\n      this.refreshRowIdx();\n      this.focus.forgetPrevious();\n      gObj.notify(batchAdd, {\n        rows: this.parent.getRowsObject(),\n        args: {\n          isFrozen: this.parent.isFrozenGrid()\n        }\n      });\n      const changes = this.getBatchChanges();\n      const btmIdx = this.getBottomIndex();\n\n      if (this.parent.editSettings.newRowPosition === 'Top') {\n        gObj.selectRow(0);\n      } else {\n        gObj.selectRow(btmIdx);\n      }\n\n      if (!data) {\n        index = this.findNextEditableCell(0, true);\n        col = gObj.getColumns()[index];\n\n        if (this.parent.editSettings.newRowPosition === 'Top') {\n          this.editCell(0, col.field, true);\n        } else {\n          this.editCell(btmIdx, col.field, true);\n        }\n      }\n\n      if (this.parent.aggregates.length > 0 && (data || changes[addedRecords].length)) {\n        this.parent.notify(refreshFooterRenderer, {});\n      }\n\n      const args1 = {\n        defaultData: beforeBatchAddArgs.defaultData,\n        row: tr,\n        columnObject: col,\n        columnIndex: index,\n        primaryKey: beforeBatchAddArgs.primaryKey,\n        cell: tr.cells[index]\n      };\n      gObj.trigger(batchAdd, args1);\n\n      if (gObj.isFrozenGrid()) {\n        alignFrozenEditForm(mTr.querySelector('td:not(.e-hide)'), tr.querySelector('td:not(.e-hide)'));\n      }\n    });\n  }\n\n  renderFrozenAddRow(tr, mTr, frTr) {\n    const gObj = this.parent;\n    const mTbody = getMovableTbody(this.parent);\n    const frTbody = getFrozenRightTbody(this.parent);\n\n    if (gObj.editSettings.newRowPosition === 'Top') {\n      mTbody.insertBefore(mTr, mTbody.firstChild);\n    } else {\n      mTbody.appendChild(mTr);\n    }\n\n    addClass([].slice.call(mTr.getElementsByClassName(rowCell)), ['e-updatedtd']);\n\n    if (frTbody && frTr) {\n      if (gObj.editSettings.newRowPosition === 'Top') {\n        frTbody.insertBefore(frTr, frTbody.firstChild);\n      } else {\n        frTbody.appendChild(frTr);\n      }\n\n      addClass([].slice.call(frTr.getElementsByClassName(rowCell)), ['e-updatedtd']);\n      alignFrozenEditForm(frTr.querySelector('td:not(.e-hide)'), tr.querySelector('td:not(.e-hide)'));\n    }\n\n    if (gObj.height === 'auto') {\n      gObj.notify(frozenHeight, {});\n    }\n  }\n\n  removeFrozenTbody() {\n    const gObj = this.parent;\n\n    if (gObj.isFrozenGrid()) {\n      const moveTbody = gObj.getContent().querySelector('.' + movableContent).querySelector(tbody);\n      moveTbody.firstElementChild.parentNode.removeChild(moveTbody.firstElementChild);\n\n      if (gObj.getFrozenMode() === leftRight) {\n        const frTbody = gObj.getContent().querySelector('.e-frozen-right-content').querySelector(tbody);\n        frTbody.firstElementChild.parentNode.removeChild(frTbody.firstElementChild);\n      }\n    }\n  }\n\n  renderMovable(ele, rightEle) {\n    const mEle = ele.cloneNode(true);\n    const movable = this.parent.getMovableColumnsCount();\n    const left = this.parent.getFrozenLeftCount();\n    const right = this.parent.getFrozenRightColumnsCount();\n    sliceElements(ele, 0, left);\n    sliceElements(mEle, left, right ? mEle.children.length - right : mEle.children.length);\n    sliceElements(rightEle, left + movable, rightEle.children.length);\n    return mEle;\n  }\n\n  findNextEditableCell(columnIndex, isAdd, isValOnly) {\n    const cols = this.parent.getColumns();\n    const endIndex = cols.length;\n    let validation;\n\n    for (let i = columnIndex; i < endIndex; i++) {\n      validation = isValOnly ? isNullOrUndefined(cols[i].validationRules) : false;\n\n      if (!isAdd && this.checkNPCell(cols[i])) {\n        return i;\n      } else if (isAdd && !cols[i].template && cols[i].visible && cols[i].allowEditing && !(cols[i].isIdentity && cols[i].isPrimaryKey) && !validation) {\n        return i;\n      }\n    }\n\n    return -1;\n  }\n\n  checkNPCell(col) {\n    return !col.template && col.visible && !col.isPrimaryKey && !col.isIdentity && col.allowEditing;\n  }\n\n  getDefaultData() {\n    const gObj = this.parent;\n    const data = {};\n    const dValues = {\n      'number': 0,\n      'string': null,\n      'boolean': false,\n      'date': null,\n      'datetime': null\n    };\n\n    for (const col of gObj.columnModel) {\n      if (col.field) {\n        setValue(col.field, Object.keys(col).indexOf('defaultValue') >= 0 ? col.defaultValue : dValues[col.type], data);\n      }\n    }\n\n    return data;\n  }\n\n  setCellIdx(target) {\n    let gLen = 0;\n\n    if (this.parent.allowGrouping) {\n      gLen = this.parent.groupSettings.columns.length;\n    }\n\n    this.cellDetails.cellIndex = target.cellIndex - gLen;\n    this.cellDetails.rowIndex = parseInt(target.getAttribute('index'), 10);\n  }\n\n  editCell(index, field, isAdd) {\n    const gObj = this.parent;\n    const col = gObj.getColumnByField(field);\n    this.index = index;\n    this.field = field;\n    this.isAdd = isAdd;\n    const checkEdit = gObj.isEdit && !(this.cellDetails.column.field === field && this.cellDetails.rowIndex === index && this.parent.getDataRows().length - 1 !== index);\n\n    if (gObj.editSettings.allowEditing) {\n      if (!checkEdit && col.allowEditing) {\n        this.editCellExtend(index, field, isAdd);\n      } else if (checkEdit) {\n        this.editNext = true;\n        this.saveCell();\n      }\n    }\n  }\n\n  editCellExtend(index, field, isAdd) {\n    const gObj = this.parent;\n    const col = gObj.getColumnByField(field);\n    const keys = gObj.getPrimaryKeyFieldNames();\n\n    if (gObj.isEdit) {\n      return;\n    }\n\n    let row$$1;\n    let mRowData;\n    let rowData = extend({}, {}, this.getDataByIndex(index), true);\n\n    if (col.getFreezeTableName() === 'movable' || col.getFreezeTableName() === frozenRight) {\n      row$$1 = col.getFreezeTableName() === 'movable' ? gObj.getMovableDataRows()[index] : gObj.getFrozenRightDataRows()[index];\n      mRowData = this.parent.getRowObjectFromUID(row$$1.getAttribute('data-uid'));\n      rowData = mRowData.changes ? extend({}, {}, mRowData.changes, true) : rowData;\n    } else {\n      row$$1 = gObj.getDataRows()[index];\n      rowData = extend({}, {}, this.getDataByIndex(index), true);\n    }\n\n    if (keys[0] === col.field && !row$$1.classList.contains('e-insertedrow') || col.columns || col.isPrimaryKey && col.isIdentity) {\n      this.parent.isLastCellPrimaryKey = true;\n      return;\n    }\n\n    this.parent.isLastCellPrimaryKey = false;\n    this.parent.element.classList.add('e-editing');\n    const rowObj = gObj.getRowObjectFromUID(row$$1.getAttribute('data-uid'));\n    const cells = [].slice.apply(row$$1.cells);\n    const args = {\n      columnName: col.field,\n      isForeignKey: !isNullOrUndefined(col.foreignKeyValue),\n      primaryKey: keys,\n      rowData: rowData,\n      validationRules: extend({}, col.validationRules ? col.validationRules : {}),\n      value: getObject(col.field, rowData),\n      type: !isAdd ? 'edit' : 'add',\n      cancel: false,\n      foreignKeyData: rowObj && rowObj.foreignKeyData\n    };\n    args.cell = cells[this.getColIndex(cells, this.getCellIdx(col.uid))];\n    args.row = row$$1;\n    args.columnObject = col;\n\n    if (!args.cell) {\n      return;\n    }\n\n    gObj.trigger(cellEdit, args, cellEditArgs => {\n      if (cellEditArgs.cancel) {\n        return;\n      }\n\n      cellEditArgs.cell = cellEditArgs.cell ? cellEditArgs.cell : cells[this.getColIndex(cells, this.getCellIdx(col.uid))];\n      cellEditArgs.row = cellEditArgs.row ? cellEditArgs.row : row$$1;\n      cellEditArgs.columnObject = cellEditArgs.columnObject ? cellEditArgs.columnObject : col;\n      cellEditArgs.columnObject.index = isNullOrUndefined(cellEditArgs.columnObject.index) ? 0 : cellEditArgs.columnObject.index;\n      this.cellDetails = {\n        rowData: rowData,\n        column: col,\n        value: cellEditArgs.value,\n        isForeignKey: cellEditArgs.isForeignKey,\n        rowIndex: index,\n        cellIndex: parseInt(cellEditArgs.cell.getAttribute(ariaColIndex), 10),\n        foreignKeyData: cellEditArgs.foreignKeyData\n      };\n\n      if (cellEditArgs.cell.classList.contains('e-updatedtd')) {\n        this.isColored = true;\n        cellEditArgs.cell.classList.remove('e-updatedtd');\n      }\n\n      gObj.isEdit = true;\n      gObj.clearSelection();\n\n      if (!gObj.isCheckBoxSelection || !gObj.isPersistSelection) {\n        gObj.selectRow(this.cellDetails.rowIndex, true);\n      }\n\n      this.renderer.update(cellEditArgs);\n      this.parent.notify(batchEditFormRendered, cellEditArgs);\n      this.form = select('#' + gObj.element.id + 'EditForm', gObj.element);\n      gObj.editModule.applyFormValidation([col]);\n      this.parent.element.querySelector('.e-gridpopup').style.display = 'none';\n    });\n  }\n\n  updateCell(rowIndex, field, value) {\n    const gObj = this.parent;\n    const col = gObj.getColumnByField(field);\n    const index = gObj.getColumnIndexByField(field);\n\n    if (col && !col.isPrimaryKey && col.allowEditing) {\n      const td = getCellByColAndRowIndex(this.parent, col, rowIndex, index);\n      const rowObj = col.getFreezeTableName() === 'movable' ? this.parent.getMovableRowsObject()[rowIndex] : col.getFreezeTableName() === frozenRight ? gObj.getFrozenRightRowsObject()[rowIndex] : gObj.getRowObjectFromUID(td.parentElement.getAttribute('data-uid'));\n      this.refreshTD(td, col, rowObj, value);\n      this.parent.trigger(queryCellInfo, {\n        cell: this.newReactTd || td,\n        column: col,\n        data: rowObj.changes\n      });\n    }\n  }\n\n  setChanges(rowObj, field, value) {\n    let currentRowObj;\n\n    if (!this.parent.isFrozenGrid()) {\n      if (!rowObj.changes) {\n        rowObj.changes = extend({}, {}, rowObj.data, true);\n      }\n\n      if (!isNullOrUndefined(field)) {\n        DataUtil.setValue(field, value, rowObj.changes);\n      }\n\n      if (rowObj.data[field] !== value) {\n        const type = this.parent.getColumnByField(field).type;\n\n        if (type === 'date' || type === 'datetime') {\n          if (new Date(rowObj.data[field]).toString() !== new Date(value).toString()) {\n            rowObj.isDirty = true;\n          }\n        } else {\n          rowObj.isDirty = true;\n        }\n      }\n    } else {\n      const rowEle = this.parent.getRowElementByUID(rowObj.uid);\n      const rowIndex = parseInt(rowEle.getAttribute(ariaRowIndex), 10);\n      currentRowObj = this.parent.getRowsObject()[rowIndex];\n\n      if (!currentRowObj.changes) {\n        currentRowObj.changes = extend({}, {}, rowObj.data, true);\n      }\n\n      if (!isNullOrUndefined(field)) {\n        setValue(field, value, currentRowObj.changes);\n      }\n\n      const movableRowObject = this.parent.getMovableRowsObject()[rowIndex];\n      movableRowObject.changes = extend({}, {}, currentRowObj.changes, true);\n\n      if (rowObj.data[field] !== value) {\n        movableRowObject.isDirty = true;\n        currentRowObj.isDirty = true;\n      }\n\n      if (this.parent.getFrozenMode() === leftRight) {\n        const frRowObject = this.parent.getFrozenRightRowsObject()[rowIndex];\n        frRowObject.changes = extend({}, {}, currentRowObj.changes, true);\n\n        if (rowObj.data[field] !== value) {\n          frRowObject.isDirty = true;\n        }\n      }\n    }\n  }\n\n  updateRow(index, data) {\n    const keys = Object.keys(data);\n\n    for (const col of keys) {\n      this.updateCell(index, col, data[col]);\n    }\n  }\n\n  getCellIdx(uid) {\n    let cIdx = this.parent.getColumnIndexByUid(uid) + this.parent.groupSettings.columns.length;\n\n    if (!isNullOrUndefined(this.parent.detailTemplate) || !isNullOrUndefined(this.parent.childGrid)) {\n      cIdx++;\n    }\n\n    if (this.parent.isRowDragable()) {\n      cIdx++;\n    }\n\n    return cIdx;\n  }\n\n  refreshTD(td, column, rowObj, value) {\n    const cell = new CellRenderer(this.parent, this.serviceLocator);\n    let rowcell;\n    value = column.type === 'number' && !isNullOrUndefined(value) ? parseFloat(value) : value;\n    this.setChanges(rowObj, column.field, value);\n    let frzCols = this.parent.getFrozenColumns() || this.parent.getFrozenLeftColumnsCount() || this.parent.getFrozenRightColumnsCount();\n    frzCols = frzCols && this.parent.isRowDragable() ? frzCols + 1 : frzCols;\n    refreshForeignData(rowObj, this.parent.getForeignKeyColumns(), rowObj.changes);\n\n    if (frzCols && column.getFreezeTableName() === 'movable' && this.parent.getColumns().length === rowObj.cells.length) {\n      rowcell = rowObj.cells.slice(frzCols, rowObj.cells.length);\n    } else {\n      rowcell = rowObj.cells;\n    }\n\n    let parentElement;\n    let cellIndex;\n\n    if (this.parent.isReact) {\n      parentElement = td.parentElement;\n      cellIndex = td.cellIndex;\n    }\n\n    let index = 0;\n\n    if (frzCols) {\n      index = column.getFreezeTableName() === 'movable' && this.parent.getFrozenMode() !== 'Right' ? frzCols : column.getFreezeTableName() === frozenRight ? this.parent.getFrozenLeftColumnsCount() + this.parent.getMovableColumnsCount() : index;\n    }\n\n    cell.refreshTD(td, rowcell[this.getCellIdx(column.uid) - index], rowObj.changes, {\n      'index': this.getCellIdx(column.uid)\n    });\n\n    if (this.parent.isReact) {\n      this.newReactTd = parentElement.cells[cellIndex];\n      parentElement.cells[cellIndex].classList.add('e-updatedtd');\n    } else {\n      td.classList.add('e-updatedtd');\n    }\n\n    td.classList.add('e-updatedtd');\n    this.parent.notify(toolbarRefresh, {});\n  }\n\n  getColIndex(cells, index) {\n    let cIdx = 0;\n\n    if (this.parent.allowGrouping && this.parent.groupSettings.columns) {\n      cIdx = this.parent.groupSettings.columns.length;\n    }\n\n    if (!isNullOrUndefined(this.parent.detailTemplate) || !isNullOrUndefined(this.parent.childGrid)) {\n      cIdx++;\n    }\n\n    if (this.parent.isRowDragable()) {\n      cIdx++;\n    }\n\n    for (let m = 0; m < cells.length; m++) {\n      const colIndex = parseInt(cells[m].getAttribute(ariaColIndex), 10);\n\n      if (colIndex === index - cIdx) {\n        return m;\n      }\n    }\n\n    return -1;\n  }\n\n  editNextValCell() {\n    const gObj = this.parent;\n    const btmIdx = this.getBottomIndex();\n\n    if (this.isAdded && !gObj.isEdit) {\n      for (let i = this.cellDetails.cellIndex; i < gObj.getColumns().length; i++) {\n        if (gObj.isEdit) {\n          return;\n        }\n\n        const index = this.findNextEditableCell(this.cellDetails.cellIndex + 1, true, true);\n        const col = gObj.getColumns()[index];\n\n        if (col) {\n          if (this.parent.editSettings.newRowPosition === 'Bottom') {\n            this.editCell(btmIdx, col.field, true);\n          } else {\n            const args = {\n              index: 0,\n              column: col\n            };\n            this.parent.notify(nextCellIndex, args);\n            this.editCell(args.index, col.field, true);\n          }\n\n          this.saveCell();\n        }\n      }\n\n      if (!gObj.isEdit) {\n        this.isAdded = false;\n      }\n    }\n  }\n\n  escapeCellEdit() {\n    const args = this.generateCellArgs();\n    args.value = args.previousValue;\n    this.successCallBack(args, args.cell.parentElement, args.column, true)(args);\n  }\n\n  generateCellArgs() {\n    const gObj = this.parent;\n    this.parent.element.classList.remove('e-editing');\n    const column = this.cellDetails.column;\n    const obj = {};\n    obj[column.field] = getObject(column.field, this.cellDetails.rowData);\n    let editedData = gObj.editModule.getCurrentEditedData(this.form, obj);\n    const cloneEditedData = extend({}, editedData);\n    editedData = extend({}, editedData, this.cellDetails.rowData);\n    const value = getObject(column.field, cloneEditedData);\n\n    if (!isNullOrUndefined(column.field) && !isUndefined(value)) {\n      setValue(column.field, value, editedData);\n    }\n\n    const args = {\n      columnName: column.field,\n      value: getObject(column.field, editedData),\n      rowData: this.cellDetails.rowData,\n      column: column,\n      previousValue: this.cellDetails.value,\n      isForeignKey: this.cellDetails.isForeignKey,\n      cancel: false\n    };\n    args.cell = this.form.parentElement;\n    args.columnObject = column;\n    return args;\n  }\n\n  saveCell(isForceSave) {\n    if (this.preventSaveCell || !this.form) {\n      return;\n    }\n\n    const gObj = this.parent;\n\n    if (!isForceSave && (!gObj.isEdit || this.validateFormObj())) {\n      return;\n    }\n\n    this.preventSaveCell = true;\n    const args = this.generateCellArgs();\n    const tr = args.cell.parentElement;\n    const col = args.column;\n\n    if (!isForceSave) {\n      gObj.trigger(cellSave, args, this.successCallBack(args, tr, col));\n      gObj.notify(batchForm, {\n        formObj: this.form\n      });\n    } else {\n      this.successCallBack(args, tr, col)(args);\n    }\n  }\n\n  successCallBack(cellSaveArgs, tr, column, isEscapeCellEdit) {\n    return cellSaveArgs => {\n      const gObj = this.parent;\n      cellSaveArgs.cell = cellSaveArgs.cell ? cellSaveArgs.cell : this.form.parentElement;\n      cellSaveArgs.columnObject = cellSaveArgs.columnObject ? cellSaveArgs.columnObject : column;\n      cellSaveArgs.columnObject.index = isNullOrUndefined(cellSaveArgs.columnObject.index) ? 0 : cellSaveArgs.columnObject.index;\n\n      if (cellSaveArgs.cancel) {\n        this.preventSaveCell = false;\n\n        if (this.editNext) {\n          this.editNext = false;\n\n          if (this.cellDetails.rowIndex === this.index && this.cellDetails.column.field === this.field) {\n            return;\n          }\n\n          this.editCellExtend(this.index, this.field, this.isAdd);\n        }\n\n        return;\n      }\n\n      gObj.editModule.destroyWidgets([column]);\n      gObj.isEdit = false;\n      gObj.editModule.destroyForm();\n      this.parent.notify(tooltipDestroy, {});\n      let rowObj = parentsUntil(cellSaveArgs.cell, movableContent) || parentsUntil(cellSaveArgs.cell, movableHeader) ? gObj.getRowObjectFromUID(tr.getAttribute('data-uid'), true) : gObj.getRowObjectFromUID(tr.getAttribute('data-uid'));\n\n      if (gObj.getFrozenMode() === leftRight && (parentsUntil(cellSaveArgs.cell, 'e-frozen-right-header') || parentsUntil(cellSaveArgs.cell, 'e-frozen-right-content'))) {\n        rowObj = gObj.getRowObjectFromUID(tr.getAttribute('data-uid'), false, true);\n      }\n\n      this.refreshTD(cellSaveArgs.cell, column, rowObj, cellSaveArgs.value);\n\n      if (this.parent.isReact) {\n        cellSaveArgs.cell = this.newReactTd;\n      }\n\n      removeClass([tr], [editedRow, 'e-batchrow']);\n      removeClass([cellSaveArgs.cell], ['e-editedbatchcell', 'e-boolcell']);\n\n      if (!isNullOrUndefined(cellSaveArgs.value) && cellSaveArgs.value.toString() === (!isNullOrUndefined(this.cellDetails.value) ? this.cellDetails.value : '').toString() && !this.isColored || isNullOrUndefined(cellSaveArgs.value) && isNullOrUndefined(rowObj.data[column.field]) && isNullOrUndefined(this.cellDetails.value) && !cellSaveArgs.cell.parentElement.classList.contains('e-insertedrow')) {\n        cellSaveArgs.cell.classList.remove('e-updatedtd');\n      }\n\n      if (isNullOrUndefined(isEscapeCellEdit)) {\n        gObj.trigger(cellSaved, cellSaveArgs);\n      }\n\n      gObj.notify(toolbarRefresh, {});\n      this.isColored = false;\n\n      if (this.parent.aggregates.length > 0) {\n        this.parent.notify(refreshFooterRenderer, {});\n\n        if (this.parent.groupSettings.columns.length > 0 && !this.isAddRow(this.cellDetails.rowIndex)) {\n          this.parent.notify(groupAggregates, {});\n        }\n      }\n\n      this.preventSaveCell = false;\n\n      if (this.editNext) {\n        this.editNext = false;\n\n        if (this.cellDetails.rowIndex === this.index && this.cellDetails.column.field === this.field) {\n          return;\n        }\n\n        const col = gObj.getColumnByField(this.field);\n\n        if (col && col.allowEditing) {\n          this.editCellExtend(this.index, this.field, this.isAdd);\n        }\n      }\n\n      if (isEscapeCellEdit) {\n        gObj.notify(restoreFocus, {});\n      }\n    };\n  }\n\n  getDataByIndex(index) {\n    const row$$1 = this.parent.getRowObjectFromUID(this.parent.getDataRows()[index].getAttribute('data-uid'));\n    return row$$1.changes ? row$$1.changes : row$$1.data;\n  }\n\n  keyDownHandler(e) {\n    if ((e.action === 'tab' || e.action === 'shiftTab') && this.parent.isEdit) {\n      const gObj = this.parent;\n      const btmIdx = this.getBottomIndex();\n      const rowcell = parentsUntil(e.target, rowCell);\n\n      if (rowcell) {\n        const cell = rowcell.querySelector('.e-field');\n\n        if (cell) {\n          const visibleColumns = this.parent.getVisibleColumns();\n          const columnIndex = e.action === 'tab' ? visibleColumns.length - 1 : 0;\n\n          if (visibleColumns[columnIndex].field === cell.getAttribute('id').slice(this.parent.element.id.length)) {\n            if (this.cellDetails.rowIndex === btmIdx && e.action === 'tab') {\n              if (gObj.editSettings.newRowPosition === 'Top') {\n                gObj.editSettings.newRowPosition = 'Bottom';\n                this.addRecord();\n                gObj.editSettings.newRowPosition = 'Top';\n              } else {\n                this.addRecord();\n              }\n            } else {\n              this.saveCell();\n            }\n          }\n        }\n      }\n    }\n  }\n  /**\n   * @returns {void}\n   * @hidden\n   */\n\n\n  addCancelWhilePaging() {\n    if (this.validateFormObj()) {\n      this.parent.notify(destroyForm, {});\n      this.parent.isEdit = false;\n      this.isColored = false;\n    }\n  }\n\n  getBottomIndex() {\n    const changes = this.getBatchChanges();\n    return this.parent.getCurrentViewRecords().length + changes[addedRecords].length - changes[deletedRecords].length - 1;\n  }\n\n}\n/**\n * `DialogEdit` module is used to handle dialog editing actions.\n *\n * @hidden\n */\n\n\nclass DialogEdit extends NormalEdit {\n  constructor(parent, serviceLocator, renderer) {\n    //constructor\n    super(parent, serviceLocator);\n    this.parent = parent;\n    this.serviceLocator = serviceLocator;\n    this.renderer = renderer;\n  }\n\n  closeEdit() {\n    //closeEdit\n    super.closeEdit();\n  }\n\n  addRecord(data, index) {\n    //addRecord\n    super.addRecord(data, index);\n  }\n\n  endEdit() {\n    //endEdit\n    super.endEdit();\n  }\n\n  updateRow(index, data) {\n    super.updateRow(index, data);\n  }\n\n  deleteRecord(fieldname, data) {\n    //deleteRecord\n    super.deleteRecord(fieldname, data);\n  }\n\n  startEdit(tr) {\n    super.startEdit(tr);\n  }\n\n}\n/**\n * `DatePickerEditCell` is used to handle datepicker cell type editing.\n *\n * @hidden\n */\n\n\nclass DatePickerEditCell extends EditCellBase {\n  write(args) {\n    if (args.column.editType === 'datepickeredit') {\n      this.obj = new DatePicker(extend(dateanddatetimerender(args, this.parent.editSettings.mode, this.parent.enableRtl), args.column.edit.params));\n    } else if (args.column.editType === 'datetimepickeredit') {\n      this.obj = new DateTimePicker(extend(dateanddatetimerender(args, this.parent.editSettings.mode, this.parent.enableRtl), args.column.edit.params));\n    }\n\n    this.obj.appendTo(args.element);\n  }\n\n} // eslint-disable-next-line\n\n\nfunction dateanddatetimerender(args, mode, rtl) {\n  const isInline = mode !== 'Dialog';\n  const format = getCustomDateFormat(args.column.format, args.column.type);\n  let value = getObject(args.column.field, args.rowData);\n  value = value ? new Date(value) : null;\n  return {\n    floatLabelType: isInline ? 'Never' : 'Always',\n    value: value,\n    format: format,\n    placeholder: isInline ? '' : args.column.headerText,\n    enableRtl: rtl,\n    enabled: isEditable(args.column, args.requestType, args.element)\n  };\n}\n/**\n * `TemplateEditCell` is used to handle template cell.\n *\n * @hidden\n */\n\n\nclass TemplateEditCell {\n  constructor(parent) {\n    this.parent = parent;\n  }\n\n  read(element, value) {\n    return value;\n  }\n\n  write() {//\n  }\n\n  destroy() {//\n  }\n\n}\n/**\n * The `Edit` module is used to handle editing actions.\n */\n\n\nlet Edit = /*#__PURE__*/(() => {\n  class Edit {\n    /**\n     * Constructor for the Grid editing module\n     *\n     * @param {IGrid} parent - specifies the IGrid\n     * @param {ServiceLocator} serviceLocator - specifies the servicelocator\n     * @hidden\n     */\n    constructor(parent, serviceLocator) {\n      this.editType = {\n        'Inline': InlineEdit,\n        'Normal': InlineEdit,\n        'Batch': BatchEdit,\n        'Dialog': DialogEdit\n      };\n      this.parent = parent;\n      this.serviceLocator = serviceLocator;\n      this.l10n = this.serviceLocator.getService('localization');\n      this.addEventListener();\n      this.updateEditObj();\n      this.createAlertDlg();\n      this.createConfirmDlg();\n    }\n\n    updateColTypeObj() {\n      const cols = this.parent.columnModel;\n\n      for (let i = 0; i < cols.length; i++) {\n        if (this.parent.editSettings.template || cols[i].editTemplate) {\n          const templteCell = 'templateedit';\n          cols[i].edit = extend(new Edit.editCellType[templteCell](this.parent), cols[i].edit || {});\n        } else {\n          cols[i].edit = extend(new Edit.editCellType[cols[i].editType && Edit.editCellType[cols[i].editType] ? cols[i].editType : 'defaultedit'](this.parent, this.serviceLocator), cols[i].edit || {});\n        }\n      }\n\n      this.parent.log('primary_column_missing');\n    }\n    /**\n     * For internal use only - Get the module name.\n     *\n     * @returns {string} returns the module name\n     * @private\n     */\n\n\n    getModuleName() {\n      return 'edit';\n    }\n    /**\n     * @param {NotifyArgs} e - specifies the notifyargs\n     * @returns {void}\n     * @hidden\n     */\n\n\n    onPropertyChanged(e) {\n      if (e.module !== this.getModuleName()) {\n        return;\n      }\n\n      const gObj = this.parent;\n\n      for (const prop of Object.keys(e.properties)) {\n        switch (prop) {\n          case 'allowAdding':\n          case 'allowDeleting':\n          case 'allowEditing':\n            if (gObj.editSettings.allowAdding || gObj.editSettings.allowEditing || gObj.editSettings.allowDeleting) {\n              this.initialEnd();\n            }\n\n            break;\n\n          case 'mode':\n            this.updateEditObj();\n            gObj.isEdit = false;\n            gObj.refresh();\n            break;\n        }\n      }\n    }\n\n    updateEditObj() {\n      if (this.editModule) {\n        this.editModule.destroy();\n      }\n\n      this.renderer = new EditRender(this.parent, this.serviceLocator);\n      this.editModule = new this.editType[this.parent.editSettings.mode](this.parent, this.serviceLocator, this.renderer);\n    }\n\n    initialEnd() {\n      this.updateColTypeObj();\n    }\n    /**\n     * Edits any bound record in the Grid by TR element.\n     *\n     * @param {HTMLTableRowElement} tr - Defines the table row to be edited.\n     * @returns {void}\n     */\n\n\n    startEdit(tr) {\n      const gObj = this.parent;\n\n      if (!gObj.editSettings.allowEditing || gObj.isEdit || gObj.editSettings.mode === 'Batch') {\n        return;\n      }\n\n      this.parent.element.classList.add('e-editing');\n\n      if (!gObj.getSelectedRows().length) {\n        if (!tr) {\n          this.showDialog('EditOperationAlert', this.alertDObj);\n          return;\n        }\n      } else if (!tr) {\n        tr = gObj.getSelectedRows()[0];\n      }\n\n      this.isLastRow = tr.rowIndex === this.parent.getContent().querySelector('tr:last-child').rowIndex;\n\n      if (tr.style.display === 'none') {\n        return;\n      }\n\n      this.editModule.startEdit(tr);\n      this.refreshToolbar();\n      gObj.element.querySelector('.e-gridpopup').style.display = 'none';\n      this.parent.notify('start-edit', {});\n    }\n    /**\n     * @param {Element} tr - specifies the tr element\n     * @param {object} args - specifies the object\n     * @param {Element} args.row -specfifes the row\n     * @param {string} args.requestType - specifies the request type\n     * @returns {void}\n     * @hidden\n     */\n\n\n    checkLastRow(tr, args) {\n      const checkLastRow = this.isLastRow;\n\n      if (this.parent.height !== 'auto' && this.parent.editSettings.newRowPosition === 'Bottom' && args && args.requestType === 'add' && this.parent.getContent().firstElementChild.offsetHeight > this.parent.getContentTable().scrollHeight) {\n        addClass([].slice.call(tr.getElementsByClassName(rowCell)), 'e-lastrowadded');\n      } else if (checkLastRow && tr && tr.classList) {\n        addClass([].slice.call(tr.getElementsByClassName(rowCell)), 'e-lastrowcell');\n      }\n    }\n    /**\n     * Cancels edited state.\n     *\n     * @returns {void}\n     */\n\n\n    closeEdit() {\n      if (this.parent.editSettings.mode === 'Batch' && this.parent.editSettings.showConfirmDialog && this.parent.element.getElementsByClassName('e-updatedtd').length) {\n        this.showDialog('CancelEdit', this.dialogObj);\n        return;\n      }\n\n      this.parent.element.classList.remove('e-editing');\n      this.editModule.closeEdit();\n      this.refreshToolbar();\n      this.parent.notify(closeEdit, {});\n    }\n\n    refreshToolbar() {\n      this.parent.notify(toolbarRefresh, {});\n    }\n    /**\n     * To adds a new row at the top with the given data. When data is not passed, it will add empty rows.\n     * > `editSettings.allowEditing` should be true.\n     *\n     * @param {Object} data - Defines the new add record data.\n     * @param {number} index - Defines the row index to be added\n     * @returns {void}\n     */\n\n\n    addRecord(data, index) {\n      if (!this.parent.editSettings.allowAdding) {\n        return;\n      }\n\n      const args = {\n        startEdit: true\n      };\n\n      if (!data) {\n        this.parent.notify(virtualScrollAddActionBegin, args);\n      }\n\n      if (args.startEdit) {\n        this.parent.element.classList.add('e-editing');\n        this.editModule.addRecord(data, index);\n        this.refreshToolbar();\n        this.parent.notify('start-add', {});\n      }\n    }\n    /**\n     * Deletes a record with the given options. If fieldname and data are not given, the Grid will delete the selected record.\n     * > `editSettings.allowDeleting` should be true.\n     *\n     * @param {string} fieldname - Defines the primary key field name of the column.\n     * @param {Object} data - Defines the JSON data record to be deleted.\n     * @returns {void}\n     */\n\n\n    deleteRecord(fieldname, data) {\n      const gObj = this.parent;\n\n      if (!gObj.editSettings.allowDeleting) {\n        return;\n      }\n\n      if (!data) {\n        if (!gObj.getSelectedRecords().length && isNullOrUndefined(gObj.commandDelIndex)) {\n          this.showDialog('DeleteOperationAlert', this.alertDObj);\n          return;\n        }\n      }\n\n      if (gObj.editSettings.showDeleteConfirmDialog) {\n        this.showDialog('ConfirmDelete', this.dialogObj);\n        return;\n      }\n\n      this.editModule.deleteRecord(fieldname, data);\n    }\n    /**\n     * Deletes a visible row by TR element.\n     *\n     * @param {HTMLTableRowElement} tr - Defines the table row element.\n     * @returns {void}\n     */\n\n\n    deleteRow(tr) {\n      this.deleteRowUid = tr.getAttribute('data-uid');\n      const rowObj = this.parent.getRowObjectFromUID(this.deleteRowUid);\n\n      if (!isNullOrUndefined(rowObj)) {\n        this.deleteRecord(null, rowObj.data);\n      }\n    }\n    /**\n     * If Grid is in editable state, you can save a record by invoking endEdit.\n     *\n     * @returns {void}\n     */\n\n\n    endEdit() {\n      if (this.parent.editSettings.mode === 'Batch' && this.parent.editSettings.showConfirmDialog && (isNullOrUndefined(this.formObj) || this.formObj.validate())) {\n        this.parent.editModule.saveCell();\n        this.parent.notify(editNextValCell, {});\n\n        if (isNullOrUndefined(this.formObj) || this.formObj.validate()) {\n          this.showDialog('BatchSaveConfirm', this.dialogObj);\n          return;\n        }\n      }\n\n      this.endEditing();\n    }\n    /**\n     * To update the specified cell by given value without changing into edited state.\n     *\n     * @param {number} rowIndex Defines the row index.\n     * @param {string} field Defines the column field.\n     * @param {string | number | boolean | Date} value - Defines the value to be changed.\n     * @returns {void}\n     */\n\n\n    updateCell(rowIndex, field, value) {\n      this.editModule.updateCell(rowIndex, field, value);\n    }\n    /**\n     * To update the specified row by given values without changing into edited state.\n     *\n     * @param {number} index Defines the row index.\n     * @param {Object} data Defines the data object to be updated.\n     * @returns {void}\n     */\n\n\n    updateRow(index, data) {\n      this.editModule.updateRow(index, data);\n    }\n    /**\n     * Resets added, edited, and deleted records in the batch mode.\n     *\n     * @returns {void}\n     */\n\n\n    batchCancel() {\n      this.closeEdit();\n    }\n    /**\n     * Bulk saves added, edited, and deleted records in the batch mode.\n     *\n     * @returns {void}\n     */\n\n\n    batchSave() {\n      this.endEdit();\n    }\n    /**\n     * Changes a particular cell into edited state based on the row index and field name provided in the `batch` mode.\n     *\n     * @param {number} index - Defines row index to edit a particular cell.\n     * @param {string} field - Defines the field name of the column to perform batch edit.\n     * @returns {void}\n     */\n\n\n    editCell(index, field) {\n      this.editModule.editCell(index, field);\n    }\n    /**\n     * Checks the status of validation at the time of editing. If validation is passed, it returns true.\n     *\n     * @returns {boolean} returns whether the form is validated\n     */\n\n\n    editFormValidate() {\n      const form1 = this.formObj ? this.formObj.validate() : true;\n      const form2 = this.mFormObj ? this.mFormObj.validate() : true;\n      const form3 = this.frFormObj ? this.frFormObj.validate() : true;\n      return form1 && form2 && form3;\n    }\n    /**\n     * Gets the added, edited,and deleted data before bulk save to the DataSource in batch mode.\n     *\n     * @returns {Object} returns the Object\n     */\n\n\n    getBatchChanges() {\n      return this.editModule.getBatchChanges ? this.editModule.getBatchChanges() : {};\n    }\n    /**\n     * Gets the current value of the edited component.\n     *\n     * @returns {Object} returns the Object\n     */\n\n\n    getCurrentEditCellData() {\n      const obj = this.getCurrentEditedData(this.formObj.element, {});\n      return obj[Object.keys(obj)[0]];\n    }\n    /**\n     * Saves the cell that is currently edited. It does not save the value to the DataSource.\n     *\n     * @returns {void}\n     */\n\n\n    saveCell() {\n      this.editModule.saveCell();\n    }\n\n    endEditing() {\n      this.parent.element.classList.remove('e-editing');\n      this.editModule.endEdit();\n      this.refreshToolbar();\n    }\n\n    showDialog(content$$1, obj) {\n      obj.content = '<div>' + this.l10n.getConstant(content$$1) + '</div>';\n      obj.dataBind();\n      obj.show();\n    }\n\n    getValueFromType(col, value) {\n      let val = value;\n\n      switch (col.type) {\n        case 'number':\n          val = !isNaN(parseFloat(value)) ? parseFloat(value) : null;\n          break;\n\n        case 'boolean':\n          if (col.editType !== 'booleanedit') {\n            val = value === this.l10n.getConstant('True') || value === true ? true : false;\n          }\n\n          break;\n\n        case 'date':\n        case 'datetime':\n          if (col.editType !== 'datepickeredit' && col.editType !== 'datetimepickeredit' && value && value.length) {\n            val = new Date(value);\n          } else if (value === '') {\n            val = null;\n          }\n\n          break;\n      }\n\n      return val;\n    }\n\n    destroyToolTip() {\n      const elements = [].slice.call(this.parent.element.getElementsByClassName('e-griderror'));\n\n      for (const elem of elements) {\n        remove(elem);\n      }\n\n      this.parent.getContent().firstElementChild.style.position = 'relative';\n    }\n\n    createConfirmDlg() {\n      this.dialogObj = this.dlgWidget([{\n        click: this.dlgOk.bind(this),\n        buttonModel: {\n          content: this.l10n.getConstant('OKButton'),\n          cssClass: 'e-primary',\n          isPrimary: true\n        }\n      }, {\n        click: this.dlgCancel.bind(this),\n        buttonModel: {\n          cssClass: 'e-flat',\n          content: this.l10n.getConstant('CancelButton')\n        }\n      }], 'EditConfirm');\n    }\n\n    createAlertDlg() {\n      this.alertDObj = this.dlgWidget([{\n        click: this.alertClick.bind(this),\n        buttonModel: {\n          content: this.l10n.getConstant('OKButton'),\n          cssClass: 'e-flat',\n          isPrimary: true\n        }\n      }], 'EditAlert');\n    }\n\n    alertClick() {\n      this.alertDObj.hide();\n    }\n\n    dlgWidget(btnOptions, name) {\n      const div = this.parent.createElement('div', {\n        id: this.parent.element.id + name\n      });\n      this.parent.element.appendChild(div);\n      const options = {\n        showCloseIcon: false,\n        isModal: true,\n        visible: false,\n        closeOnEscape: true,\n        target: this.parent.element,\n        width: '320px',\n        animationSettings: {\n          effect: 'None'\n        }\n      };\n      options.buttons = btnOptions;\n      const obj = new Dialog(options);\n      const isStringTemplate = 'isStringTemplate';\n      obj[isStringTemplate] = true;\n      obj.appendTo(div);\n      return obj;\n    }\n\n    dlgCancel() {\n      this.parent.focusModule.clearIndicator();\n      this.parent.focusModule.restoreFocus();\n      this.dialogObj.hide();\n    }\n\n    dlgOk() {\n      switch (this.dialogObj.element.querySelector('.e-dlg-content').firstElementChild.innerText) {\n        case this.l10n.getConstant('ConfirmDelete'):\n          this.editModule.deleteRecord();\n          break;\n\n        case this.l10n.getConstant('CancelEdit'):\n          this.editModule.closeEdit();\n          break;\n\n        case this.l10n.getConstant('BatchSaveConfirm'):\n          this.endEditing();\n          break;\n\n        case this.l10n.getConstant('BatchSaveLostChanges'):\n          if (this.parent.editSettings.mode === 'Batch') {\n            this.editModule.addCancelWhilePaging();\n          }\n\n          this.executeAction();\n          break;\n      }\n\n      this.dlgCancel();\n    }\n\n    destroyEditComponents() {\n      if (this.parent.isEdit) {\n        this.destroyWidgets();\n        this.destroyForm();\n      }\n\n      this.destroy();\n    }\n    /**\n     * @returns {void}\n     * @hidden\n     */\n\n\n    addEventListener() {\n      if (this.parent.isDestroyed) {\n        return;\n      }\n\n      this.eventDetails = [{\n        event: inBoundModelChanged,\n        handler: this.onPropertyChanged\n      }, {\n        event: initialEnd,\n        handler: this.initialEnd\n      }, {\n        event: keyPressed,\n        handler: this.keyPressHandler\n      }, {\n        event: autoCol,\n        handler: this.updateColTypeObj\n      }, {\n        event: tooltipDestroy,\n        handler: this.destroyToolTip\n      }, {\n        event: preventBatch,\n        handler: this.preventBatch\n      }, {\n        event: destroyForm,\n        handler: this.destroyForm\n      }, {\n        event: destroy,\n        handler: this.destroyEditComponents\n      }];\n      addRemoveEventListener(this.parent, this.eventDetails, true, this);\n      this.actionBeginFunction = this.onActionBegin.bind(this);\n      this.actionCompleteFunction = this.actionComplete.bind(this);\n      this.parent.addEventListener(actionBegin, this.actionBeginFunction);\n      this.parent.addEventListener(actionComplete, this.actionCompleteFunction);\n    }\n    /**\n     * @returns {void}\n     * @hidden\n     */\n\n\n    removeEventListener() {\n      if (this.parent.isDestroyed) {\n        return;\n      }\n\n      addRemoveEventListener(this.parent, this.eventDetails, false);\n      this.parent.removeEventListener(actionComplete, this.actionCompleteFunction);\n      this.parent.removeEventListener(actionBegin, this.actionBeginFunction);\n    }\n\n    actionComplete(e) {\n      const actions = ['add', 'beginEdit', 'save', 'delete', 'cancel'];\n\n      if (actions.indexOf(e.requestType) < 0) {\n        this.parent.isEdit = false;\n      }\n\n      if (e.requestType === 'batchsave') {\n        this.parent.focusModule.restoreFocus();\n      }\n\n      this.refreshToolbar();\n    }\n    /**\n     * @param {Element} form - specifies the element\n     * @param {Object} editedData - specifies the edited data\n     * @returns {Object} returns the object\n     * @hidden\n     */\n\n\n    getCurrentEditedData(form, editedData) {\n      const gObj = this.parent;\n\n      if (gObj.editSettings.template) {\n        const elements = [].slice.call(form.elements);\n\n        for (let k = 0; k < elements.length; k++) {\n          if ((elements[k].hasAttribute('name') && elements[k].className !== 'e-multi-hidden' || elements[k].classList.contains('e-multiselect')) && !(elements[k].type === 'hidden' && (parentsUntil(elements[k], 'e-switch-wrapper') || parentsUntil(elements[k], 'e-checkbox-wrapper')))) {\n            const field = elements[k].hasAttribute('name') ? setComplexFieldID(elements[k].getAttribute('name')) : setComplexFieldID(elements[k].getAttribute('id'));\n            const column = gObj.getColumnByField(field) || {\n              field: field,\n              type: elements[k].getAttribute('type')\n            };\n            let value;\n\n            if (column.type === 'checkbox' || column.type === 'boolean') {\n              value = elements[k].checked;\n            } else if (elements[k].value) {\n              value = elements[k].value;\n\n              if (elements[k].ej2_instances && elements[k].ej2_instances.length && !isNullOrUndefined(elements[k].ej2_instances[0].value)) {\n                elements[k].blur();\n                value = elements[k].ej2_instances[0].value;\n              }\n            } else if (elements[k].ej2_instances) {\n              value = elements[k].ej2_instances[0].value;\n            }\n\n            if (column.edit && typeof column.edit.read === 'string') {\n              value = getValue(column.edit.read, window)(elements[k], value);\n            } else if (column.edit && column.edit.read) {\n              value = column.edit.read(elements[k], value);\n            }\n\n            value = gObj.editModule.getValueFromType(column, value);\n\n            if (elements[k].type === 'radio') {\n              if (elements[k].checked) {\n                DataUtil.setValue(column.field, value, editedData);\n              }\n            } else {\n              DataUtil.setValue(column.field, value, editedData);\n            }\n          }\n        }\n\n        return editedData;\n      }\n\n      const col = gObj.columnModel.filter(col => col.editTemplate);\n\n      for (let j = 0; j < col.length; j++) {\n        if (form[getComplexFieldID(col[j].field)]) {\n          let inputElements = [].slice.call(form[getComplexFieldID(col[j].field)]);\n          inputElements = inputElements.length ? inputElements : [form[getComplexFieldID(col[j].field)]];\n          let temp = inputElements.filter(e => !isNullOrUndefined(e.ej2_instances));\n\n          if (temp.length === 0) {\n            temp = inputElements.filter(e => e.hasAttribute('name'));\n          }\n\n          for (let k = 0; k < temp.length; k++) {\n            const value = this.getValue(col[j], temp[k], editedData);\n            DataUtil.setValue(col[j].field, value, editedData);\n          }\n        }\n      }\n\n      const inputs = [].slice.call(form.getElementsByClassName('e-field'));\n\n      for (let i = 0, len = inputs.length; i < len; i++) {\n        const col = gObj.getColumnByUid(inputs[i].getAttribute('e-mappinguid'));\n\n        if (col && col.field) {\n          const value = this.getValue(col, inputs[i], editedData);\n          DataUtil.setValue(col.field, value, editedData);\n        }\n      }\n\n      return editedData;\n    }\n\n    getValue(col, input, editedData) {\n      let value = input.ej2_instances ? input.ej2_instances[0].value : input.value;\n      const gObj = this.parent;\n      let temp = col.edit.read;\n\n      if (col.type === 'checkbox' || col.type === 'boolean') {\n        value = input.checked;\n      }\n\n      if (typeof temp === 'string') {\n        temp = getValue(temp, window);\n        value = gObj.editModule.getValueFromType(col, temp(input, value));\n      } else {\n        value = gObj.editModule.getValueFromType(col, col.edit.read(input, value));\n      }\n\n      if (isNullOrUndefined(editedData[col.field]) && value === '') {\n        value = editedData[col.field];\n      }\n\n      return value;\n    }\n    /**\n     * @param {NotifyArgs} e - specifies the NotifyArgs\n     * @returns {void}\n     * @hidden\n     */\n\n\n    onActionBegin(e) {\n      if (e.requestType === 'columnstate' && this.parent.isEdit && this.parent.editSettings.mode !== 'Batch') {\n        this.closeEdit();\n      } else {\n        const editRow = this.parent.element.querySelector('.' + editedRow);\n        const addRow = this.parent.element.querySelector('.' + addedRow);\n\n        if (editRow && this.parent.frozenRows && e.requestType === 'virtualscroll' && parseInt(parentsUntil(editRow, row).getAttribute(ariaRowIndex), 10) < this.parent.frozenRows) {\n          return;\n        }\n\n        const restrictedRequestTypes = ['filterafteropen', 'filterbeforeopen', 'filterchoicerequest', 'save', 'infiniteScroll', 'virtualscroll'];\n        const isRestrict = restrictedRequestTypes.indexOf(e.requestType) === -1;\n        const isDestroyVirtualForm = this.parent.enableVirtualization && this.formObj && !this.formObj.isDestroyed && (editRow || addRow || e.requestType === 'cancel') && isRestrict;\n\n        if (!this.parent.enableVirtualization && this.parent.editSettings.mode !== 'Batch' && this.formObj && !this.formObj.isDestroyed && isRestrict && !e.cancel || isDestroyVirtualForm) {\n          this.destroyWidgets();\n          this.destroyForm();\n        }\n      }\n    }\n    /**\n     * @param {Column[]} cols - specfies the column\n     * @returns {void}\n     * @hidden\n     */\n\n\n    destroyWidgets(cols) {\n      const gObj = this.parent;\n\n      if (gObj.editSettings.template) {\n        this.parent.destroyTemplate(['editSettingsTemplate']);\n\n        if (this.parent.isReact) {\n          this.parent.renderTemplates();\n        }\n      }\n\n      cols = cols ? cols : this.parent.getCurrentVisibleColumns(this.parent.enableColumnVirtualization);\n\n      if (cols.some(column => !isNullOrUndefined(column.editTemplate))) {\n        this.parent.destroyTemplate(['editTemplate']);\n\n        if (this.parent.isReact) {\n          this.parent.renderTemplates();\n        }\n      }\n\n      for (const col of cols) {\n        let temp = col.edit.destroy;\n\n        if (col.edit.destroy) {\n          if (typeof temp === 'string') {\n            temp = getValue(temp, window);\n            temp();\n          } else {\n            col.edit.destroy();\n          }\n        }\n      }\n\n      const elements = [].slice.call(this.formObj.element.elements);\n\n      for (let i = 0; i < elements.length; i++) {\n        if (elements[i].hasAttribute('name')) {\n          if (elements[i].ej2_instances && elements[i].ej2_instances.length && !elements[i].ej2_instances[0].isDestroyed) {\n            elements[i].ej2_instances[0].destroy();\n          }\n        }\n      }\n    }\n    /**\n     * @returns {void}\n     * @hidden\n     */\n\n\n    destroyForm() {\n      this.destroyToolTip();\n      const formObjects = [this.formObj, this.mFormObj, this.frFormObj, this.virtualFormObj];\n\n      for (let i = 0; i < formObjects.length; i++) {\n        if (formObjects[i] && formObjects[i].element && !formObjects[i].isDestroyed) {\n          formObjects[i].destroy();\n        }\n      }\n\n      this.destroyToolTip();\n    }\n    /**\n     * To destroy the editing.\n     *\n     * @returns {void}\n     * @hidden\n     */\n\n\n    destroy() {\n      const gridElement = this.parent.element;\n\n      if (!gridElement) {\n        return;\n      }\n\n      const hasGridChild = gridElement.querySelector('.' + gridHeader) && gridElement.querySelector('.' + gridContent) ? true : false;\n\n      if (hasGridChild) {\n        this.destroyForm();\n      }\n\n      this.removeEventListener();\n      let elem = this.dialogObj.element;\n\n      if (elem.childElementCount > 0) {\n        this.dialogObj.destroy();\n        remove(elem);\n      }\n\n      elem = this.alertDObj.element;\n\n      if (elem.childElementCount > 0) {\n        this.alertDObj.destroy();\n        remove(elem);\n      }\n\n      if (!hasGridChild) {\n        return;\n      }\n\n      if (this.editModule) {\n        this.editModule.destroy();\n      }\n    }\n\n    keyPressHandler(e) {\n      switch (e.action) {\n        case 'insert':\n          this.addRecord();\n          break;\n\n        case 'delete':\n          if ((e.target.tagName !== 'INPUT' || e.target.classList.contains('e-checkselect')) && !document.querySelector('.e-popup-open')) {\n            this.deleteRecord();\n          }\n\n          break;\n\n        case 'f2':\n          this.startEdit();\n          break;\n\n        case 'enter':\n          if (!parentsUntil(e.target, 'e-unboundcelldiv') && this.parent.editSettings.mode !== 'Batch' && (parentsUntil(e.target, gridContent) || this.parent.frozenRows && parentsUntil(e.target, headerContent)) && !document.getElementsByClassName('e-popup-open').length) {\n            e.preventDefault();\n            this.endEdit();\n          }\n\n          break;\n\n        case 'escape':\n          if (this.parent.isEdit) {\n            if (this.parent.editSettings.mode === 'Batch') {\n              this.editModule.escapeCellEdit();\n            } else {\n              this.closeEdit();\n            }\n          }\n\n          break;\n      }\n    }\n\n    preventBatch(args) {\n      this.preventObj = args;\n      this.showDialog('BatchSaveLostChanges', this.dialogObj);\n    }\n\n    executeAction() {\n      this.preventObj.handler.call(this.preventObj.instance, this.preventObj.arg1, this.preventObj.arg2, this.preventObj.arg3, this.preventObj.arg4, this.preventObj.arg5, this.preventObj.arg6, this.preventObj.arg7, this.preventObj.arg8);\n    }\n    /**\n     * @param {Column[]} cols - specifies the column\n     * @returns {void}\n     * @hidden\n     */\n\n\n    applyFormValidation(cols) {\n      const gObj = this.parent;\n      const frzCols = gObj.isFrozenGrid();\n      const isInline = this.parent.editSettings.mode === 'Normal';\n      const idx = this.parent.getFrozenMode() === 'Right' && isInline ? 1 : 0;\n      const form = this.parent.editSettings.mode !== 'Dialog' ? gObj.element.getElementsByClassName('e-gridform')[idx] : select('#' + gObj.element.id + '_dialogEdit_wrapper .e-gridform', document);\n      const index = this.parent.getFrozenMode() === 'Right' && isInline ? 0 : 1;\n      const mForm = gObj.element.getElementsByClassName('e-gridform')[index];\n      let rules = {};\n      const mRules = {};\n      const frRules = {};\n      cols = cols ? cols : gObj.getColumns();\n\n      for (let i = 0; i < cols.length; i++) {\n        if (!cols[i].visible && (gObj.editSettings.mode !== 'Dialog' || gObj.groupSettings.columns.indexOf(cols[i].field) === -1 && gObj.editSettings.mode === 'Dialog')) {\n          continue;\n        }\n\n        if (cols[i].validationRules) {\n          setValidationRuels(cols[i], index, rules, mRules, frRules, cols.length);\n        }\n      }\n\n      if (frzCols && this.parent.editSettings.mode !== 'Dialog') {\n        this.parent.editModule.mFormObj = this.createFormObj(mForm, mRules);\n\n        if (this.parent.getFrozenMode() === leftRight) {\n          const frForm = gObj.element.getElementsByClassName('e-gridform')[2];\n          this.parent.editModule.frFormObj = this.createFormObj(frForm, frRules);\n        }\n      } else {\n        rules = extend(rules, mRules, frRules);\n      }\n\n      this.parent.editModule.formObj = this.createFormObj(form, rules);\n    }\n    /**\n     * @param {HTMLFormElement} form - Defined Form element\n     * @param {Object} rules - Defines form rules\n     * @returns {FormValidator} Returns formvalidator instance\n     * @hidden\n     */\n\n\n    createFormObj(form, rules) {\n      return new FormValidator(form, {\n        rules: rules,\n        locale: this.parent.locale,\n        validationComplete: args => {\n          this.validationComplete(args);\n        },\n        customPlacement: (inputElement, error) => {\n          const uid = inputElement.getAttribute('e-mappinguid');\n          const args = {\n            column: this.parent.getColumnByUid(uid),\n            error: error,\n            inputElement: inputElement,\n            value: inputElement.value\n          };\n          this.valErrorPlacement(inputElement, error);\n          this.parent.notify(valCustomPlacement, args);\n        }\n      });\n    }\n\n    valErrorPlacement(inputElement, error) {\n      if (this.parent.isEdit) {\n        const id = error.getAttribute('for');\n        const elem = this.getElemTable(inputElement).querySelector('#' + id + '_Error');\n\n        if (!elem) {\n          this.createTooltip(inputElement, error, id, '');\n        } else {\n          elem.querySelector('.e-tip-content').innerHTML = error.outerHTML;\n        }\n      }\n    }\n\n    getElemTable(inputElement) {\n      let isFHdr;\n      const gObj = this.parent;\n      let table$$1;\n\n      if (gObj.editSettings.mode !== 'Dialog') {\n        isFHdr = gObj.frozenRows && gObj.frozenRows > (parseInt(closest(inputElement, '.' + row).getAttribute(ariaRowIndex), 10) || 0);\n        const field = inputElement.name;\n        let col;\n\n        if (field) {\n          col = getColumnModelByFieldName(this.parent, setComplexFieldID(field));\n        }\n\n        if (col && gObj.isFrozenGrid()) {\n          if (col.getFreezeTableName() === 'frozen-left') {\n            table$$1 = isFHdr ? gObj.getFrozenVirtualHeader().querySelector('table') : gObj.getFrozenVirtualContent().querySelector('table');\n          } else if (col.getFreezeTableName() === 'frozen-right') {\n            table$$1 = isFHdr ? gObj.getFrozenRightHeader().querySelector('table') : gObj.getFrozenRightContent().querySelector('table');\n          } else if (col.getFreezeTableName() === 'movable') {\n            table$$1 = isFHdr ? gObj.getMovableVirtualHeader().querySelector('table') : gObj.getMovableVirtualContent().querySelector('table');\n          }\n        } else {\n          table$$1 = isFHdr ? gObj.getHeaderTable() : gObj.getContentTable();\n        }\n      } else {\n        table$$1 = select('#' + gObj.element.id + '_dialogEdit_wrapper', document);\n      }\n\n      return table$$1;\n    }\n\n    resetElemPosition(elem, args) {\n      const td = parentsUntil(args.element, rowCell);\n\n      if (td) {\n        const tdRight = td.getBoundingClientRect().right;\n        const elemRight = elem.getBoundingClientRect().right;\n\n        if (elemRight > tdRight) {\n          const offSet = elemRight - tdRight;\n          elem.style.left = elem.offsetLeft - offSet + 'px';\n        }\n      }\n    }\n\n    validationComplete(args) {\n      if (this.parent.isEdit) {\n        const elem = this.getElemTable(args.element).querySelector('#' + args.inputName + '_Error');\n\n        if (elem) {\n          if (args.status === 'failure') {\n            elem.style.display = '';\n            this.resetElemPosition(elem, args);\n          } else {\n            elem.style.display = 'none';\n          }\n        }\n      }\n    }\n\n    createTooltip(element, error, name, display) {\n      const column = this.parent.getColumnByField(name);\n      let formObj = this.parent.getFrozenMode() === leftRight && this.parent.editSettings.mode === 'Normal' && column.getFreezeTableName() === frozenRight ? this.frFormObj.element : this.formObj.element;\n      const customForm = parentsUntil(element, 'e-virtual-validation');\n\n      if (customForm) {\n        formObj = this.virtualFormObj.element;\n      }\n\n      let gcontent = this.parent.getContent().firstElementChild;\n      const frzCols = this.parent.getFrozenColumns() || this.parent.getFrozenLeftColumnsCount() || this.parent.getFrozenRightColumnsCount();\n\n      if (frzCols) {\n        gcontent = this.parent.getMovableVirtualContent();\n      }\n\n      const isScroll = gcontent.scrollHeight > gcontent.clientHeight || gcontent.scrollWidth > gcontent.clientWidth;\n      const isInline = this.parent.editSettings.mode !== 'Dialog';\n      const td = closest(element, '.' + rowCell);\n      const row$$1 = closest(element, '.' + row);\n      const fCont = this.parent.getContent().querySelector('.' + frozenContent);\n      let isFHdr;\n      let isFHdrLastRow = false;\n      let validationForBottomRowPos;\n      let isBatchModeLastRow = false;\n      const viewPortRowCount = Math.round(this.parent.getContent().clientHeight / this.parent.getRowHeight()) - 1;\n      const rows = !fCont ? [].slice.call(this.parent.getContent().getElementsByClassName(row)) : [].slice.call(this.parent.getFrozenVirtualContent().getElementsByClassName(row));\n\n      if (this.parent.editSettings.mode === 'Batch') {\n        if (viewPortRowCount > 1 && rows.length >= viewPortRowCount && rows[rows.length - 1].getAttribute(ariaRowIndex) === row$$1.getAttribute(ariaRowIndex)) {\n          isBatchModeLastRow = true;\n        }\n      }\n\n      if (isInline) {\n        if (this.parent.frozenRows) {\n          const fHeraderRows = frzCols ? this.parent.getFrozenVirtualHeader().querySelector(tbody).children : this.parent.getHeaderTable().querySelector(tbody).children;\n          isFHdr = fHeraderRows.length > (parseInt(row$$1.getAttribute(ariaRowIndex), 10) || 0);\n          isFHdrLastRow = isFHdr && parseInt(row$$1.getAttribute(ariaRowIndex), 10) === fHeraderRows.length - 1;\n        }\n\n        if (isFHdrLastRow || viewPortRowCount > 1 && rows.length >= viewPortRowCount && (this.parent.editSettings.newRowPosition === 'Bottom' && this.editModule.args && this.editModule.args.requestType === 'add' || td.classList.contains('e-lastrowcell') && !row$$1.classList.contains(addedRow)) || isBatchModeLastRow) {\n          validationForBottomRowPos = true;\n        }\n      }\n\n      const table$$1 = isInline ? isFHdr ? this.parent.getHeaderTable() : this.parent.getContentTable() : select('#' + this.parent.element.id + '_dialogEdit_wrapper .e-dlg-content', document);\n      const client = table$$1.getBoundingClientRect();\n      const left = isInline ? this.parent.element.getBoundingClientRect().left : client.left;\n      const input = closest(element, 'td');\n      const inputClient = input ? input.getBoundingClientRect() : element.parentElement.getBoundingClientRect();\n      const div = this.parent.createElement('div', {\n        className: 'e-tooltip-wrap e-lib e-control e-popup e-griderror',\n        id: name + '_Error',\n        styles: 'display:' + display + ';top:' + ((isFHdr ? inputClient.top + inputClient.height : inputClient.bottom - client.top - (frzCols ? fCont.scrollTop : 0)) + table$$1.scrollTop + 9) + 'px;left:' + (inputClient.left - left + table$$1.scrollLeft + inputClient.width / 2) + 'px;' + 'max-width:' + inputClient.width + 'px;text-align:center;'\n      });\n\n      if (isInline && client.left < left) {\n        div.style.left = parseInt(div.style.left, 10) - client.left + left + 'px';\n      }\n\n      const content$$1 = this.parent.createElement('div', {\n        className: 'e-tip-content'\n      });\n      content$$1.appendChild(error);\n      let arrow;\n\n      if (validationForBottomRowPos) {\n        arrow = this.parent.createElement('div', {\n          className: 'e-arrow-tip e-tip-bottom'\n        });\n        arrow.appendChild(this.parent.createElement('div', {\n          className: 'e-arrow-tip-outer e-tip-bottom'\n        }));\n        arrow.appendChild(this.parent.createElement('div', {\n          className: 'e-arrow-tip-inner e-tip-bottom'\n        }));\n      } else {\n        arrow = this.parent.createElement('div', {\n          className: 'e-arrow-tip e-tip-top'\n        });\n        arrow.appendChild(this.parent.createElement('div', {\n          className: 'e-arrow-tip-outer e-tip-top'\n        }));\n        arrow.appendChild(this.parent.createElement('div', {\n          className: 'e-arrow-tip-inner e-tip-top'\n        }));\n      }\n\n      div.appendChild(content$$1);\n      div.appendChild(arrow);\n\n      if (!customForm && (frzCols || this.parent.frozenRows) && this.parent.editSettings.mode !== 'Dialog') {\n        const getEditCell = this.parent.editSettings.mode === 'Normal' ? closest(element, '.e-editcell') : closest(element, '.' + table);\n        getEditCell.style.position = 'relative';\n        div.style.position = 'absolute';\n\n        if (this.parent.editSettings.mode === 'Batch' || closest(element, '.' + frozenContent) || closest(element, '.' + frozenHeader) || this.parent.frozenRows && !frzCols) {\n          formObj.appendChild(div);\n        } else {\n          this.mFormObj.element.appendChild(div);\n        }\n      } else {\n        if (customForm) {\n          this.virtualFormObj.element.appendChild(div);\n        } else {\n          this.formObj.element.appendChild(div);\n        }\n      }\n\n      if (!validationForBottomRowPos && isInline && gcontent.getBoundingClientRect().bottom < inputClient.bottom + inputClient.height) {\n        gcontent.scrollTop = gcontent.scrollTop + div.offsetHeight + arrow.scrollHeight;\n      }\n\n      const lineHeight = parseInt(document.defaultView.getComputedStyle(div, null).getPropertyValue('font-size'), 10);\n\n      if (div.getBoundingClientRect().width < inputClient.width && div.querySelector('label').getBoundingClientRect().height / (lineHeight * 1.2) >= 2) {\n        div.style.width = div.style.maxWidth;\n      }\n\n      if ((frzCols || this.parent.frozenRows) && this.parent.editSettings.mode !== 'Dialog') {\n        div.style.left = input.offsetLeft + (input.offsetWidth / 2 - div.offsetWidth / 2) + 'px';\n      } else {\n        div.style.left = parseInt(div.style.left, 10) - div.offsetWidth / 2 + 'px';\n      }\n\n      if (isInline && !isScroll && !this.parent.allowPaging || frzCols || this.parent.frozenRows) {\n        gcontent.style.position = 'static';\n        const pos = calculateRelativeBasedPosition(input, div);\n        div.style.top = pos.top + inputClient.height + 9 + 'px';\n      }\n\n      if (validationForBottomRowPos) {\n        if (isScroll && !frzCols && this.parent.height !== 'auto' && !this.parent.frozenRows && !this.parent.enableVirtualization) {\n          const scrollWidth = gcontent.scrollWidth > gcontent.offsetWidth ? getScrollBarWidth() : 0;\n          div.style.bottom = this.parent.height - gcontent.querySelector('table').offsetHeight - scrollWidth + inputClient.height + 9 + 'px';\n        } else {\n          div.style.bottom = inputClient.height + 9 + 'px';\n        }\n\n        if (rows.length < viewPortRowCount && this.parent.editSettings.newRowPosition === 'Bottom' && this.editModule.args && this.editModule.args.requestType === 'add') {\n          const rowsCount = this.parent.frozenRows ? this.parent.frozenRows + (rows.length - 1) : rows.length - 1;\n          const rowsHeight = rowsCount * this.parent.getRowHeight();\n          const position = this.parent.getContent().clientHeight - rowsHeight;\n          div.style.bottom = position + 9 + 'px';\n        }\n\n        div.style.top = null;\n      }\n    }\n    /**\n     * @param {Column} col - specfies the column\n     * @returns {boolean} returns the whether column is grouped\n     * @hidden\n     */\n\n\n    checkColumnIsGrouped(col) {\n      return !col.visible && !(this.parent.groupSettings.columns.indexOf(col.field) > -1);\n    }\n    /**\n     * @param {object} editors -specfies the editors\n     * @returns {void}\n     * @hidden\n     */\n\n\n    static AddEditors(editors) {\n      Edit.editCellType = extend(Edit.editCellType, editors);\n    }\n\n  }\n\n  Edit.editCellType = {\n    'dropdownedit': DropDownEditCell,\n    'numericedit': NumericEditCell,\n    'datepickeredit': DatePickerEditCell,\n    'datetimepickeredit': DatePickerEditCell,\n    'booleanedit': BooleanEditCell,\n    'defaultedit': DefaultEditCell,\n    'templateedit': TemplateEditCell\n  };\n  /**\n   * The `ColumnChooser` module is used to show or hide columns dynamically.\n   */\n\n  return Edit;\n})();\n\nclass ColumnChooser {\n  /**\n   * Constructor for the Grid ColumnChooser module\n   *\n   * @param {IGrid} parent - specifies the IGrid\n   * @param {ServiceLocator} serviceLocator - specifies the serviceLocator\n   * @hidden\n   */\n  constructor(parent, serviceLocator) {\n    this.showColumn = [];\n    this.hideColumn = [];\n    this.changedColumns = [];\n    this.unchangedColumns = [];\n    this.isDlgOpen = false;\n    this.initialOpenDlg = true;\n    this.stateChangeColumns = [];\n    this.changedStateColumns = [];\n    this.isInitialOpen = false;\n    this.isCustomizeOpenCC = false;\n    this.searchOperator = 'startswith';\n    this.prevShowedCols = [];\n    this.hideDialogFunction = this.hideDialog.bind(this);\n    this.parent = parent;\n    this.serviceLocator = serviceLocator;\n    this.addEventListener();\n    this.cBoxTrue = createCheckBox(this.parent.createElement, true, {\n      checked: true,\n      label: ' '\n    });\n    this.cBoxFalse = createCheckBox(this.parent.createElement, true, {\n      checked: false,\n      label: ' '\n    });\n    this.cBoxTrue.insertBefore(this.parent.createElement('input', {\n      className: 'e-chk-hidden e-cc e-cc-chbox',\n      attrs: {\n        type: 'checkbox'\n      }\n    }), this.cBoxTrue.firstChild);\n    this.cBoxFalse.insertBefore(this.parent.createElement('input', {\n      className: 'e-chk-hidden e-cc e-cc-chbox',\n      attrs: {\n        'type': 'checkbox'\n      }\n    }), this.cBoxFalse.firstChild);\n    this.cBoxFalse.querySelector('.e-frame').classList.add('e-uncheck');\n\n    if (this.parent.enableRtl) {\n      addClass([this.cBoxTrue, this.cBoxFalse], ['e-rtl']);\n    }\n  }\n\n  destroy() {\n    const gridElement = this.parent.element;\n\n    if (!gridElement || !gridElement.querySelector('.' + gridHeader) && !gridElement.querySelector('.' + gridContent)) {\n      return;\n    }\n\n    this.removeEventListener();\n    this.unWireEvents();\n\n    if (!isNullOrUndefined(this.dlgObj) && this.dlgObj.element && !this.dlgObj.isDestroyed) {\n      this.dlgObj.destroy();\n    }\n  }\n\n  rtlUpdate() {\n    if (this.parent.enableRtl) {\n      addClass([].slice.call(this.innerDiv.getElementsByClassName('e-checkbox-wrapper')), ['e-rtl']);\n    } else {\n      removeClass([].slice.call(this.innerDiv.getElementsByClassName('e-checkbox-wrapper')), ['e-rtl']);\n    }\n  }\n  /**\n   * @returns {void}\n   * @hidden\n   */\n\n\n  addEventListener() {\n    if (this.parent.isDestroyed) {\n      return;\n    }\n\n    EventHandler.add(document, 'click', this.clickHandler, this);\n    this.parent.on(uiUpdate, this.enableAfterRenderEle, this);\n    this.parent.on(initialEnd, this.render, this);\n    this.parent.addEventListener(dataBound, this.hideDialogFunction);\n    this.parent.on(destroy, this.destroy, this);\n    this.parent.on(rtlUpdated, this.rtlUpdate, this);\n    this.parent.on(keyPressed, this.keyUpHandler, this);\n    this.parent.on(resetColumns, this.onResetColumns, this);\n  }\n  /**\n   * @returns {void}\n   * @hidden\n   */\n\n\n  removeEventListener() {\n    if (this.parent.isDestroyed) {\n      return;\n    }\n\n    EventHandler.remove(document, 'click', this.clickHandler);\n    this.parent.off(initialEnd, this.render);\n    this.parent.off(destroy, this.destroy);\n    this.parent.off(uiUpdate, this.enableAfterRenderEle);\n    this.parent.off(rtlUpdated, this.rtlUpdate);\n    this.parent.on(keyPressed, this.keyUpHandler, this);\n    this.parent.off(resetColumns, this.onResetColumns);\n    this.parent.removeEventListener(dataBound, this.hideDialogFunction);\n  }\n\n  render() {\n    this.l10n = this.serviceLocator.getService('localization');\n    this.renderDlgContent();\n    this.getShowHideService = this.serviceLocator.getService('showHideService');\n  }\n\n  clickHandler(e) {\n    const targetElement = e.target;\n\n    if (!this.isCustomizeOpenCC) {\n      if (!isNullOrUndefined(closest(targetElement, '.e-cc')) || !isNullOrUndefined(closest(targetElement, '.e-cc-toolbar'))) {\n        if (targetElement.classList.contains('e-columnchooser-btn') || targetElement.classList.contains('e-cc-toolbar')) {\n          if (this.initialOpenDlg && this.dlgObj.visible || !this.isDlgOpen) {\n            this.isDlgOpen = true;\n            return;\n          }\n        } else if (targetElement.classList.contains('e-cc-cancel')) {\n          targetElement.parentElement.querySelector('.e-ccsearch').value = '';\n          this.columnChooserSearch('');\n          this.removeCancelIcon();\n          this.refreshCheckboxButton();\n        }\n      } else {\n        if (!isNullOrUndefined(this.dlgObj) && this.dlgObj.visible && !targetElement.classList.contains('e-toolbar-items')) {\n          this.dlgObj.hide();\n          this.clearActions();\n          this.refreshCheckboxState(); // this.unWireEvents();\n\n          this.isDlgOpen = false;\n        }\n      }\n\n      if (this.parent.detailTemplate || this.parent.childGrid) {\n        this.targetdlg = e.target;\n      }\n    }\n\n    if (this.isCustomizeOpenCC && e.target.classList.contains('e-cc-cancel')) {\n      this.refreshCheckboxState();\n    }\n\n    this.rtlUpdate();\n  }\n\n  hideDialog() {\n    if (!isNullOrUndefined(this.dlgObj) && this.dlgObj.visible) {\n      this.dlgObj.hide(); // this.unWireEvents();\n\n      this.isDlgOpen = false;\n    }\n  }\n  /**\n   * To render columnChooser when showColumnChooser enabled.\n   *\n   * @param {number} x - specifies the position x\n   * @param {number} y - specifies the position y\n   * @param {Element} target - specifies the target\n   * @returns {void}\n   * @hidden\n   */\n\n\n  renderColumnChooser(x, y, target) {\n    if (!this.dlgObj.visible && (this.parent.detailTemplate || this.parent.childGrid)) {\n      this.hideOpenedDialog();\n    }\n\n    if (!this.dlgObj.visible) {\n      const args = this.beforeOpenColumnChooserEvent();\n\n      if (args.cancel) {\n        return;\n      }\n\n      if (target) {\n        this.targetdlg = target;\n      }\n\n      this.refreshCheckboxState();\n      this.dlgObj.dataBind();\n      this.dlgObj.element.style.maxHeight = '430px';\n      const elementVisible = this.dlgObj.element.style.display;\n      this.dlgObj.element.style.display = 'block';\n      let isSticky = this.parent.getHeaderContent().classList.contains('e-sticky');\n      const toolbarItem = closest(target, '.e-toolbar-item');\n      let newpos;\n\n      if (isSticky) {\n        newpos = toolbarItem.getBoundingClientRect();\n        this.dlgObj.element.classList.add('e-sticky');\n      } else {\n        this.dlgObj.element.classList.remove('e-sticky');\n        newpos = calculateRelativeBasedPosition(toolbarItem, this.dlgObj.element);\n      }\n\n      this.dlgObj.element.style.display = elementVisible;\n      this.dlgObj.element.style.top = newpos.top + closest(target, '.e-cc-toolbar').getBoundingClientRect().height + 'px';\n      const dlgWidth = 250;\n\n      if (!isNullOrUndefined(closest(target, '.e-bigger'))) {\n        this.dlgObj.width = 258;\n      }\n\n      if (Browser.isDevice) {\n        this.dlgObj.target = document.body;\n        this.dlgObj.position = {\n          X: 'center',\n          Y: 'center'\n        };\n        this.dlgObj.refreshPosition();\n        this.dlgObj.open = this.mOpenDlg.bind(this);\n      } else {\n        if (this.parent.enableRtl) {\n          this.dlgObj.element.style.left = target.offsetLeft + 'px';\n        } else {\n          this.dlgObj.element.style.left = newpos.left - dlgWidth + closest(target, '.e-cc-toolbar').clientWidth + 2 + 'px';\n        }\n      }\n\n      this.removeCancelIcon();\n      this.dlgObj.show();\n      this.parent.notify(columnChooserOpened, {\n        dialog: this.dlgObj\n      });\n    } else {\n      // this.unWireEvents();\n      this.hideDialog();\n      this.addcancelIcon();\n      this.clearActions();\n      this.refreshCheckboxState();\n    }\n\n    this.rtlUpdate();\n  }\n  /**\n   * Column chooser can be displayed on screen by given position(X and Y axis).\n   *\n   * @param  {number} X - Defines the X axis.\n   * @param  {number} Y - Defines the Y axis.\n   * @return {void}\n   */\n\n\n  openColumnChooser(X, Y) {\n    this.isCustomizeOpenCC = true;\n\n    if (this.dlgObj.visible) {\n      this.hideDialog();\n      return;\n    }\n\n    const args = this.beforeOpenColumnChooserEvent();\n\n    if (args.cancel) {\n      return;\n    }\n\n    if (!this.isInitialOpen) {\n      this.dlgObj.content = this.renderChooserList();\n      this.updateIntermediateBtn();\n    } else {\n      this.refreshCheckboxState();\n    }\n\n    this.dlgObj.dataBind();\n    this.dlgObj.position = {\n      X: 'center',\n      Y: 'center'\n    };\n\n    if (isNullOrUndefined(X)) {\n      this.dlgObj.position = {\n        X: 'center',\n        Y: 'center'\n      };\n      this.dlgObj.refreshPosition();\n    } else {\n      this.dlgObj.element.style.top = '';\n      this.dlgObj.element.style.left = '';\n      this.dlgObj.element.style.top = Y + 'px';\n      this.dlgObj.element.style.left = X + 'px';\n    }\n\n    this.dlgObj.beforeOpen = this.customDialogOpen.bind(this);\n    this.dlgObj.show();\n    this.isInitialOpen = true;\n    this.dlgObj.beforeClose = this.customDialogClose.bind(this);\n  }\n\n  enableAfterRenderEle(e) {\n    if (e.module === this.getModuleName() && e.enable) {\n      this.render();\n    }\n  }\n\n  keyUpHandler(e) {\n    if (e.action === 'escape') {\n      this.hideDialog();\n    }\n  }\n\n  customDialogOpen() {\n    const searchElement = this.dlgObj.content.querySelector('input.e-ccsearch');\n    EventHandler.add(searchElement, 'keyup', this.columnChooserManualSearch, this);\n  }\n\n  customDialogClose() {\n    const searchElement = this.dlgObj.content.querySelector('input.e-ccsearch');\n    EventHandler.remove(searchElement, 'keyup', this.columnChooserManualSearch);\n  }\n\n  getColumns() {\n    const columns = this.parent.getColumns().filter(column => column.type !== 'checkbox' && column.showInColumnChooser === true || column.type === 'checkbox' && column.field !== undefined);\n    return columns;\n  }\n\n  renderDlgContent() {\n    this.dlgDiv = this.parent.createElement('div', {\n      className: 'e-ccdlg e-cc',\n      id: this.parent.element.id + '_ccdlg'\n    });\n    this.dlgDiv.setAttribute('aria-label', this.l10n.getConstant('ColumnChooserDialogARIA'));\n    this.parent.element.appendChild(this.dlgDiv);\n    this.dlgObj = new Dialog({\n      header: this.l10n.getConstant('ChooseColumns'),\n      showCloseIcon: false,\n      closeOnEscape: false,\n      locale: this.parent.locale,\n      visible: false,\n      enableRtl: this.parent.enableRtl,\n      target: document.getElementById(this.parent.element.id),\n      buttons: [{\n        click: this.confirmDlgBtnClick.bind(this),\n        buttonModel: {\n          content: this.l10n.getConstant('OKButton'),\n          isPrimary: true,\n          cssClass: 'e-cc e-cc_okbtn'\n        }\n      }, {\n        click: this.clearBtnClick.bind(this),\n        buttonModel: {\n          cssClass: 'e-flat e-cc e-cc-cnbtn',\n          content: this.l10n.getConstant('CancelButton')\n        }\n      }],\n      content: this.renderChooserList(),\n      width: 250,\n      cssClass: 'e-cc',\n      animationSettings: {\n        effect: 'None'\n      }\n    });\n    const isStringTemplate = 'isStringTemplate';\n    this.dlgObj[isStringTemplate] = true;\n    this.dlgObj.appendTo(this.dlgDiv);\n    this.wireEvents();\n  }\n\n  renderChooserList() {\n    this.mainDiv = this.parent.createElement('div', {\n      className: 'e-main-div e-cc'\n    });\n    const searchDiv = this.parent.createElement('div', {\n      className: 'e-cc-searchdiv e-cc e-input-group'\n    });\n    const ccsearchele = this.parent.createElement('input', {\n      className: 'e-ccsearch e-cc e-input',\n      attrs: {\n        placeholder: this.l10n.getConstant('Search')\n      }\n    });\n    const ccsearchicon = this.parent.createElement('span', {\n      className: 'e-ccsearch-icon e-icons e-cc e-input-group-icon',\n      attrs: {\n        title: this.l10n.getConstant('Search')\n      }\n    });\n    const conDiv = this.parent.createElement('div', {\n      className: 'e-cc-contentdiv'\n    });\n    this.innerDiv = this.parent.createElement('div', {\n      className: 'e-innerdiv e-cc'\n    });\n    searchDiv.appendChild(ccsearchele);\n    searchDiv.appendChild(ccsearchicon);\n    this.searchBoxObj = new SearchBox(ccsearchele);\n    const innerDivContent = this.refreshCheckboxList(this.parent.getColumns());\n    this.innerDiv.appendChild(innerDivContent);\n    conDiv.appendChild(this.innerDiv);\n    this.mainDiv.appendChild(searchDiv);\n    this.mainDiv.appendChild(conDiv);\n    return this.mainDiv;\n  }\n\n  confirmDlgBtnClick(args) {\n    this.stateChangeColumns = [];\n    this.changedStateColumns = [];\n    this.changedColumns = this.changedColumns.length > 0 ? this.changedColumns : this.unchangedColumns;\n    this.changedColumnState(this.changedColumns);\n    const uncheckedLength = this.ulElement.querySelector('.e-uncheck') && this.ulElement.querySelectorAll('.e-uncheck:not(.e-selectall)').length;\n\n    if (!isNullOrUndefined(args)) {\n      if (uncheckedLength < this.parent.getColumns().length) {\n        if (this.hideColumn.length) {\n          this.columnStateChange(this.hideColumn, false);\n        }\n\n        if (this.showColumn.length) {\n          this.columnStateChange(this.showColumn, true);\n        }\n\n        this.getShowHideService.setVisible(this.stateChangeColumns, this.changedStateColumns);\n        this.clearActions();\n        this.parent.notify(tooltipDestroy, {\n          module: 'edit'\n        });\n\n        if (this.parent.getCurrentViewRecords().length === 0) {\n          const emptyRowCell = this.parent.element.querySelector('.e-emptyrow').querySelector('td');\n          emptyRowCell.setAttribute('colSpan', this.parent.getVisibleColumns().length.toString());\n        }\n      }\n    }\n  }\n\n  onResetColumns(e) {\n    if (e.requestType === 'columnstate') {\n      this.resetColumnState();\n      return;\n    }\n  }\n\n  resetColumnState() {\n    this.showColumn = [];\n    this.hideColumn = [];\n    this.hideDialog();\n  }\n\n  changedColumnState(changedColumns) {\n    for (let index = 0; index < changedColumns.length; index++) {\n      const colUid = changedColumns[index];\n      const currentCol = this.parent.getColumnByUid(colUid);\n      this.changedStateColumns.push(currentCol);\n    }\n  }\n\n  columnStateChange(stateColumns, state) {\n    for (let index = 0; index < stateColumns.length; index++) {\n      const colUid = stateColumns[index];\n      const currentCol = this.parent.getColumnByUid(colUid);\n\n      if (currentCol.type !== 'checkbox') {\n        currentCol.visible = state;\n      }\n\n      this.stateChangeColumns.push(currentCol);\n    }\n  }\n\n  clearActions() {\n    this.resetColumnState();\n    this.addcancelIcon();\n  }\n\n  clearBtnClick() {\n    this.clearActions();\n    this.parent.notify(columnChooserCancelBtnClick, {\n      dialog: this.dlgObj\n    });\n  }\n\n  checkstatecolumn(isChecked, coluid, selectAll$$1 = false) {\n    if (isChecked) {\n      if (this.hideColumn.indexOf(coluid) !== -1) {\n        this.hideColumn.splice(this.hideColumn.indexOf(coluid), 1);\n      }\n\n      if (this.showColumn.indexOf(coluid) === -1) {\n        this.showColumn.push(coluid);\n      }\n    } else {\n      if (this.showColumn.indexOf(coluid) !== -1) {\n        this.showColumn.splice(this.showColumn.indexOf(coluid), 1);\n      }\n\n      if (this.hideColumn.indexOf(coluid) === -1) {\n        this.hideColumn.push(coluid);\n      }\n    }\n\n    if (selectAll$$1) {\n      if (!isChecked) {\n        this.changedColumns.push(coluid);\n      } else {\n        this.unchangedColumns.push(coluid);\n      }\n    } else if (this.changedColumns.indexOf(coluid) !== -1) {\n      this.changedColumns.splice(this.changedColumns.indexOf(coluid), 1);\n    } else {\n      this.changedColumns.push(coluid);\n    }\n  }\n\n  columnChooserSearch(searchVal) {\n    let clearSearch = false;\n    let fltrCol;\n    let okButton;\n    const buttonEle = this.dlgDiv.querySelector('.e-footer-content');\n    const selectedCbox = this.ulElement.querySelector('.e-check') && this.ulElement.querySelectorAll('.e-check:not(.e-selectall)').length;\n    this.isInitialOpen = true;\n\n    if (buttonEle) {\n      okButton = buttonEle.querySelector('.e-btn').ej2_instances[0];\n    }\n\n    if (searchVal === '') {\n      this.removeCancelIcon();\n      fltrCol = this.getColumns();\n      clearSearch = true;\n    } else {\n      fltrCol = new DataManager(this.getColumns()).executeLocal(new Query().where('headerText', this.searchOperator, searchVal, true, this.parent.columnChooserSettings.ignoreAccent));\n    }\n\n    if (fltrCol.length) {\n      this.innerDiv.innerHTML = ' ';\n      this.innerDiv.classList.remove('e-ccnmdiv');\n      this.innerDiv.appendChild(this.refreshCheckboxList(fltrCol));\n\n      if (!clearSearch) {\n        this.addcancelIcon();\n        this.refreshCheckboxButton();\n      } else {\n        if (okButton && selectedCbox) {\n          okButton.disabled = false;\n        }\n      }\n    } else {\n      const nMatchele = this.parent.createElement('span', {\n        className: 'e-cc e-nmatch'\n      });\n      nMatchele.innerHTML = this.l10n.getConstant('Matchs');\n      this.innerDiv.innerHTML = ' ';\n      this.innerDiv.appendChild(nMatchele);\n      this.innerDiv.classList.add('e-ccnmdiv');\n\n      if (okButton) {\n        okButton.disabled = true;\n      }\n    }\n\n    this.flag = true;\n    this.stopTimer();\n  }\n\n  wireEvents() {\n    EventHandler.add(this.dlgObj.element, 'click', this.checkBoxClickHandler, this);\n    EventHandler.add(this.searchBoxObj.searchBox, 'keyup', this.columnChooserManualSearch, this);\n    this.searchBoxObj.wireEvent();\n  }\n\n  unWireEvents() {\n    if (this.parent.isDestroyed) {\n      return;\n    }\n\n    if (this.dlgObj.element) {\n      EventHandler.remove(this.dlgObj.element, 'click', this.checkBoxClickHandler);\n    }\n\n    EventHandler.remove(this.searchBoxObj.searchBox, 'keyup', this.columnChooserManualSearch);\n    this.searchBoxObj.unWireEvent();\n  }\n\n  checkBoxClickHandler(e) {\n    let checkstate;\n    const elem = parentsUntil(e.target, 'e-checkbox-wrapper');\n\n    if (elem) {\n      const selectAll$$1 = elem.querySelector('.e-selectall');\n\n      if (selectAll$$1) {\n        this.updateSelectAll(!elem.querySelector('.e-check'));\n      } else {\n        toogleCheckbox(elem.parentElement);\n      }\n\n      elem.querySelector('.e-chk-hidden').focus();\n\n      if (elem.querySelector('.e-check')) {\n        checkstate = true;\n      } else if (elem.querySelector('.e-uncheck')) {\n        checkstate = false;\n      } else {\n        return;\n      }\n\n      this.updateIntermediateBtn();\n      const columnUid = parentsUntil(elem, 'e-ccheck').getAttribute('uid');\n      const column = this.parent.getColumns();\n\n      if (columnUid === 'grid-selectAll') {\n        this.changedColumns = [];\n        this.unchangedColumns = [];\n\n        for (let i = 0; i < column.length; i++) {\n          if (column[i].showInColumnChooser) {\n            this.checkstatecolumn(checkstate, column[i].uid, true);\n          }\n        }\n      } else {\n        this.checkstatecolumn(checkstate, columnUid);\n      }\n\n      this.refreshCheckboxButton();\n    }\n  }\n\n  updateIntermediateBtn() {\n    const cnt = this.ulElement.children.length - 1;\n    let className = [];\n    const elem = this.ulElement.children[0].querySelector('.e-frame');\n    const selected = this.ulElement.querySelectorAll('.e-check:not(.e-selectall)').length;\n    const btn = this.dlgObj.btnObj[0];\n    btn.disabled = false;\n\n    if (cnt === selected) {\n      className = ['e-check'];\n    } else if (selected) {\n      className = ['e-stop'];\n    } else {\n      className = ['e-uncheck'];\n      btn.disabled = true;\n    }\n\n    btn.dataBind();\n    removeClass([elem], ['e-check', 'e-stop', 'e-uncheck']);\n    addClass([elem], className);\n  }\n\n  updateSelectAll(checked) {\n    const cBoxes = [].slice.call(this.ulElement.getElementsByClassName('e-frame'));\n\n    for (const cBox of cBoxes) {\n      removeAddCboxClasses(cBox, checked);\n    }\n  }\n\n  refreshCheckboxButton() {\n    const visibleCols = this.parent.getVisibleColumns();\n\n    for (let i = 0; i < visibleCols.length; i++) {\n      const columnUID = visibleCols[i].uid;\n\n      if (this.prevShowedCols.indexOf(columnUID) === -1) {\n        this.prevShowedCols.push(columnUID);\n      }\n    }\n\n    for (let i = 0; i < this.hideColumn.length; i++) {\n      const index = this.prevShowedCols.indexOf(this.hideColumn[i]);\n\n      if (index !== -1) {\n        this.prevShowedCols.splice(index, 1);\n      }\n    }\n\n    const selected = this.showColumn.length !== 0 ? 1 : this.prevShowedCols.length;\n    const btn = this.dlgDiv.querySelector('.e-footer-content').querySelector('.e-btn').ej2_instances[0];\n    btn.disabled = false;\n    const srchShowCols = [];\n    const searchData = [].slice.call(this.parent.element.getElementsByClassName('e-cc-chbox'));\n\n    for (let i = 0, itemsLen = searchData.length; i < itemsLen; i++) {\n      const element = searchData[i];\n      const columnUID = parentsUntil(element, 'e-ccheck').getAttribute('uid');\n      srchShowCols.push(columnUID);\n    }\n\n    const hideCols = this.showColumn.filter(column => srchShowCols.indexOf(column) !== -1);\n\n    if (selected === 0 && hideCols.length === 0) {\n      btn.disabled = true;\n    }\n\n    btn.dataBind();\n  }\n\n  refreshCheckboxList(gdCol) {\n    this.ulElement = this.parent.createElement('ul', {\n      className: 'e-ccul-ele e-cc'\n    });\n    const selectAllValue = this.l10n.getConstant('SelectAll');\n    const cclist = this.parent.createElement('li', {\n      className: 'e-cclist e-cc e-cc-selectall'\n    });\n    const selectAll$$1 = this.createCheckBox(selectAllValue, false, 'grid-selectAll');\n\n    if (gdCol.length) {\n      selectAll$$1.querySelector('.e-checkbox-wrapper').firstElementChild.classList.add('e-selectall');\n      selectAll$$1.querySelector('.e-frame').classList.add('e-selectall');\n      this.checkState(selectAll$$1.querySelector('.e-icons'), true);\n      cclist.appendChild(selectAll$$1);\n      this.ulElement.appendChild(cclist);\n    }\n\n    for (let i = 0; i < gdCol.length; i++) {\n      const columns = gdCol[i];\n      this.renderCheckbox(columns);\n    }\n\n    return this.ulElement;\n  }\n\n  refreshCheckboxState() {\n    this.dlgObj.element.querySelector('.e-cc.e-input').value = '';\n    this.columnChooserSearch('');\n    const gridObject = this.parent;\n    const currentCheckBoxColls = this.dlgObj.element.querySelectorAll('.e-cc-chbox:not(.e-selectall)');\n\n    for (let i = 0, itemLen = currentCheckBoxColls.length; i < itemLen; i++) {\n      const element = currentCheckBoxColls[i];\n      let columnUID;\n\n      if (this.parent.childGrid || this.parent.detailTemplate) {\n        columnUID = parentsUntil(this.dlgObj.element.querySelectorAll('.e-cc-chbox:not(.e-selectall)')[i], 'e-ccheck').getAttribute('uid');\n      } else {\n        columnUID = parentsUntil(element, 'e-ccheck').getAttribute('uid');\n      }\n\n      const column = gridObject.getColumnByUid(columnUID);\n      const uncheck = [].slice.call(element.parentElement.getElementsByClassName('e-uncheck'));\n\n      if (column.visible && !uncheck.length) {\n        element.checked = true;\n        this.checkState(element.parentElement.querySelector('.e-icons'), true);\n      } else {\n        element.checked = false;\n        this.checkState(element.parentElement.querySelector('.e-icons'), false);\n      }\n    }\n  }\n\n  checkState(element, state) {\n    if (state) {\n      classList(element, ['e-check'], ['e-uncheck']);\n    } else {\n      classList(element, ['e-uncheck'], ['e-check']);\n    }\n  }\n\n  createCheckBox(label, checked, uid) {\n    const cbox = checked ? this.cBoxTrue.cloneNode(true) : this.cBoxFalse.cloneNode(true);\n    cbox.querySelector('.e-label').innerHTML = label;\n    return createCboxWithWrap(uid, cbox, 'e-ccheck');\n  }\n\n  renderCheckbox(column) {\n    let cclist;\n    let hideColState;\n    let showColState;\n\n    if (column.showInColumnChooser) {\n      cclist = this.parent.createElement('li', {\n        className: 'e-cclist e-cc',\n        styles: 'list-style:None',\n        id: 'e-ccli_' + column.uid\n      });\n      hideColState = this.hideColumn.indexOf(column.uid) === -1 ? false : true;\n      showColState = this.showColumn.indexOf(column.uid) === -1 ? false : true;\n      const cccheckboxlist = this.createCheckBox(column.headerText, column.visible && !hideColState || showColState, column.uid);\n      cclist.appendChild(cccheckboxlist);\n      this.ulElement.appendChild(cclist);\n    }\n\n    if (this.isInitialOpen) {\n      this.updateIntermediateBtn();\n    }\n  }\n\n  columnChooserManualSearch(e) {\n    this.addcancelIcon();\n    this.searchValue = e.target.value;\n    this.stopTimer();\n    this.startTimer(e);\n  }\n\n  startTimer(e) {\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    const proxy = this;\n    const interval = !proxy.flag && e.keyCode !== 13 ? 500 : 0;\n    this.timer = window.setInterval(() => {\n      proxy.columnChooserSearch(proxy.searchValue);\n    }, interval);\n  }\n\n  stopTimer() {\n    window.clearInterval(this.timer);\n  }\n\n  addcancelIcon() {\n    this.dlgDiv.querySelector('.e-cc.e-ccsearch-icon').classList.add('e-cc-cancel');\n  }\n\n  removeCancelIcon() {\n    this.dlgDiv.querySelector('.e-cc.e-ccsearch-icon').classList.remove('e-cc-cancel');\n  }\n\n  mOpenDlg() {\n    if (Browser.isDevice) {\n      this.dlgObj.element.querySelector('.e-cc-searchdiv').classList.remove('e-input-focus');\n      this.dlgObj.element.querySelectorAll('.e-cc-chbox')[0].focus();\n    }\n  } // internally use\n\n\n  getModuleName() {\n    return 'columnChooser';\n  }\n\n  hideOpenedDialog() {\n    const openCC = [].slice.call(document.getElementsByClassName('e-ccdlg')).filter(dlgEle => dlgEle.classList.contains('e-popup-open'));\n\n    for (let i = 0, dlgLen = openCC.length; i < dlgLen; i++) {\n      if (openCC[i].classList.contains('e-dialog') || this.parent.element.id + '_ccdlg' !== openCC[i].id) {\n        openCC[i].ej2_instances[0].hide();\n      }\n    }\n  }\n\n  beforeOpenColumnChooserEvent() {\n    const args1 = {\n      requestType: 'beforeOpenColumnChooser',\n      element: this.parent.element,\n      columns: this.getColumns(),\n      cancel: false,\n      searchOperator: this.parent.columnChooserSettings.operator\n    };\n    this.parent.trigger(beforeOpenColumnChooser, args1);\n    this.searchOperator = args1.searchOperator;\n    return args1;\n  }\n\n}\n/**\n * @hidden\n * `ExportHelper` for `PdfExport` & `ExcelExport`\n */\n\n\nclass ExportHelper {\n  constructor(parent, foreignKeyData) {\n    this.hideColumnInclude = false;\n    this.foreignKeyData = {};\n    this.parent = parent;\n\n    if (!parent.parentDetails && foreignKeyData) {\n      this.foreignKeyData = foreignKeyData;\n    }\n  }\n\n  static getQuery(parent, data) {\n    const query = data.generateQuery(true).requiresCount();\n\n    if (data.isRemote()) {\n      if (parent.groupSettings.enableLazyLoading && parent.groupSettings.columns.length) {\n        query.lazyLoad = [];\n      } else {\n        query.take(parent.pageSettings.totalRecordsCount);\n      }\n    }\n\n    return query;\n  }\n\n  getFData(value, column) {\n    const foreignKeyData = getForeignData(column, {}, value, this.foreignKeyData[column.field])[0];\n    return foreignKeyData;\n  }\n\n  getGridRowModel(columns, dataSource, gObj, startIndex = 0) {\n    const rows = [];\n    const length = dataSource.length;\n\n    if (length) {\n      for (let i = 0; i < length; i++, startIndex++) {\n        const options = {\n          isExpand: false\n        };\n        options.data = dataSource[i];\n        options.index = startIndex;\n\n        if (gObj.childGrid) {\n          if (gObj.hierarchyPrintMode === 'All') {\n            options.isExpand = true;\n          } else if (gObj.hierarchyPrintMode === 'Expanded' && this.parent.expandedRows && this.parent.expandedRows[startIndex]) {\n            options.isExpand = gObj.expandedRows[startIndex].isExpand;\n          }\n        }\n\n        const row = new Row(options);\n        row.cells = this.generateCells(columns, gObj);\n        rows.push(row);\n      }\n\n      this.processColumns(rows);\n    }\n\n    return rows;\n  }\n\n  generateCells(columns, gObj) {\n    const cells = [];\n\n    if (gObj.childGridLevel) {\n      const len = gObj.childGridLevel;\n\n      for (let i = 0; len > i; i++) {\n        cells.push(this.generateCell({}, CellType.Indent));\n      }\n    }\n\n    for (const col of columns) {\n      cells.push(this.generateCell(col, CellType.Data));\n    }\n\n    return cells;\n  }\n\n  getColumnData(gridObj) {\n    const columnPromise = [];\n    let promise;\n    const fColumns = gridObj.getForeignKeyColumns();\n\n    if (fColumns.length) {\n      for (let i = 0; i < fColumns.length; i++) {\n        const colData = 'result' in fColumns[i].dataSource ? new DataManager(fColumns[i].dataSource.result) : fColumns[i].dataSource;\n        columnPromise.push(colData.executeQuery(new Query()));\n      }\n\n      promise = Promise.all(columnPromise).then(e => {\n        for (let j = 0; j < fColumns.length; j++) {\n          this.foreignKeyData[fColumns[j].field] = e[j].result;\n        } // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n      });\n    }\n\n    return promise;\n  }\n\n  getHeaders(columns, isHideColumnInclude) {\n    if (isHideColumnInclude) {\n      this.hideColumnInclude = true;\n    } else {\n      this.hideColumnInclude = false;\n    }\n\n    this.colDepth = measureColumnDepth(columns);\n    let rows = [];\n\n    for (let i = 0; i < this.colDepth; i++) {\n      rows[i] = new Row({});\n      rows[i].cells = [];\n    }\n\n    rows = this.processColumns(rows);\n    rows = this.processHeaderCells(rows, columns);\n    return {\n      rows,\n      columns: this.generateActualColumns(columns)\n    };\n  }\n\n  getConvertedWidth(input) {\n    const value = parseFloat(input);\n    return input.indexOf('%') !== -1 ? this.parent.element.getBoundingClientRect().width * value / 100 : value;\n  }\n\n  generateActualColumns(columns, actualColumns = []) {\n    for (const column of columns) {\n      if (column.commands) {\n        continue;\n      }\n\n      if (!column.columns) {\n        if (column.visible || this.hideColumnInclude) {\n          actualColumns.push(column);\n        }\n      } else {\n        if (column.visible || this.hideColumnInclude) {\n          const colSpan = this.getCellCount(column, 0);\n\n          if (colSpan !== 0) {\n            this.generateActualColumns(column.columns, actualColumns);\n          }\n        }\n      }\n    }\n\n    return actualColumns;\n  }\n\n  processHeaderCells(rows, cols) {\n    const columns = cols;\n\n    for (let i = 0; i < columns.length; i++) {\n      if (!columns[i].commands) {\n        rows = this.appendGridCells(columns[i], rows, 0);\n      }\n    }\n\n    return rows;\n  }\n\n  appendGridCells(cols, gridRows, index) {\n    if (!cols.columns && (cols.visible !== false || this.hideColumnInclude) && !cols.commands) {\n      gridRows[index].cells.push(this.generateCell(cols, CellType.Header, this.colDepth - index, index));\n    } else if (cols.columns) {\n      const colSpan = this.getCellCount(cols, 0);\n\n      if (colSpan) {\n        gridRows[index].cells.push(new Cell({\n          cellType: CellType.StackedHeader,\n          column: cols,\n          colSpan: colSpan\n        }));\n      }\n\n      let isIgnoreFirstCell;\n\n      for (let i = 0, len = cols.columns.length; i < len; i++) {\n        if (cols.columns[i].visible && !isIgnoreFirstCell) {\n          isIgnoreFirstCell = true;\n        }\n\n        gridRows = this.appendGridCells(cols.columns[i], gridRows, index + 1);\n      }\n    }\n\n    return gridRows;\n  }\n\n  generateCell(gridColumn, cellType, rowSpan, rowIndex) {\n    const option = {\n      'visible': gridColumn.visible,\n      'isDataCell': cellType === CellType.Data,\n      'column': gridColumn,\n      'cellType': cellType,\n      'rowSpan': rowSpan,\n      'index': rowIndex\n    };\n\n    if (!option.rowSpan || option.rowSpan < 2) {\n      delete option.rowSpan;\n    }\n\n    return new Cell(option);\n  }\n\n  processColumns(rows) {\n    //TODO: generate dummy column for group, detail, stacked row here; ensureColumns here\n    const gridObj = this.parent;\n    let columnIndexes = [];\n\n    if (gridObj.enableColumnVirtualization) {\n      columnIndexes = gridObj.getColumnIndexesInView();\n    }\n\n    for (let i = 0, len = rows.length; i < len; i++) {\n      if (gridObj.allowGrouping) {\n        for (let j = 0, len = gridObj.groupSettings.columns.length - 1; j < len; j++) {\n          if (gridObj.enableColumnVirtualization && columnIndexes.indexOf(j) === -1) {\n            continue;\n          }\n\n          rows[i].cells.splice(0, 0, this.generateCell({}, CellType.HeaderIndent));\n        }\n      }\n    }\n\n    return rows;\n  }\n\n  getCellCount(column, count) {\n    if (column.columns) {\n      for (let i = 0; i < column.columns.length; i++) {\n        count = this.getCellCount(column.columns[i], count);\n      }\n    } else {\n      if (column.visible || this.hideColumnInclude) {\n        count++;\n      }\n    }\n\n    return count;\n  }\n\n  checkAndExport(gridPool, globalResolve) {\n    const bool = Object.keys(gridPool).some(key => {\n      return !gridPool[key];\n    });\n\n    if (!bool) {\n      globalResolve();\n    }\n  }\n\n  failureHandler(gridPool, childGridObj, resolve) {\n    return () => {\n      gridPool[childGridObj.id] = true;\n      this.checkAndExport(gridPool, resolve);\n    };\n  }\n\n  createChildGrid(gObj, row, exportType, gridPool) {\n    const childGridObj = new Grid(this.parent.detailRowModule.getGridModel(gObj, row, exportType));\n    gObj.isPrinting = false;\n    const parent = 'parentDetails';\n    childGridObj[parent] = {\n      parentID: gObj.element.id,\n      parentPrimaryKeys: gObj.getPrimaryKeyFieldNames(),\n      parentKeyField: gObj.childGrid.queryString,\n      parentKeyFieldValue: getValue(childGridObj.queryString, row.data),\n      parentRowData: row.data\n    };\n    const exportId = getUid('child-grid');\n    const element = createElement('div', {\n      id: exportId,\n      styles: 'display: none'\n    });\n    document.body.appendChild(element);\n    childGridObj.id = exportId;\n    gridPool[exportId] = false;\n    childGridObj.isExportGrid = true;\n    return {\n      childGrid: childGridObj,\n      element\n    };\n  }\n\n  getGridExportColumns(columns) {\n    const actualGridColumns = [];\n\n    for (let i = 0, gridColumns = columns; i < gridColumns.length; i++) {\n      if (gridColumns[i].type !== 'checkbox') {\n        actualGridColumns.push(gridColumns[i]);\n      }\n    }\n\n    return actualGridColumns;\n  }\n  /**\n   * Gets the foreignkey data.\n   *\n   * @returns {ForeignKeyFormat} returns the foreignkey data\n   * @hidden\n   */\n\n\n  getForeignKeyData() {\n    return this.foreignKeyData;\n  }\n\n}\n/**\n * @hidden\n * `ExportValueFormatter` for `PdfExport` & `ExcelExport`\n */\n\n\nclass ExportValueFormatter {\n  constructor(culture) {\n    this.valueFormatter = new ValueFormatter(culture);\n    this.internationalization = new Internationalization(culture);\n  }\n\n  returnFormattedValue(args, customFormat) {\n    if (!isNullOrUndefined(args.value) && args.value) {\n      return this.valueFormatter.getFormatFunction(customFormat)(args.value);\n    } else {\n      return '';\n    }\n  }\n  /**\n   * Used to format the exporting cell value\n   *\n   * @param  {ExportHelperArgs} args - Specifies cell details.\n   * @returns {string} returns formated value\n   * @hidden\n   */\n\n\n  formatCellValue(args) {\n    if (args.isForeignKey) {\n      args.value = getValue(args.column.foreignKeyValue, getForeignData(args.column, {}, args.value)[0]);\n    }\n\n    if (args.column.type === 'number' && args.column.format !== undefined && args.column.format !== '') {\n      return args.value || args.value === 0 ? this.internationalization.getNumberFormat({\n        format: args.column.format\n      })(args.value) : '';\n    } else if (args.column.type === 'boolean' && args.value !== '') {\n      return args.value ? 'true' : 'false';\n      /* tslint:disable-next-line:max-line-length */\n    } else if ((args.column.type === 'date' || args.column.type === 'datetime' || args.column.type === 'time') && args.column.format !== undefined) {\n      if (typeof args.value === 'string') {\n        args.value = new Date(args.value);\n      }\n\n      if (typeof args.column.format === 'string') {\n        let format;\n        const cFormat = args.column.format;\n\n        if (args.column.type === 'date') {\n          format = {\n            type: 'date',\n            skeleton: cFormat\n          };\n        } else if (args.column.type === 'time') {\n          format = {\n            type: 'time',\n            skeleton: cFormat\n          };\n        } else {\n          format = {\n            type: 'dateTime',\n            skeleton: cFormat\n          };\n        }\n\n        return this.returnFormattedValue(args, format);\n      } else {\n        if (args.column.format instanceof Object && args.column.format.type === undefined) {\n          return args.value.toString();\n        } else {\n          let customFormat;\n\n          if (args.column.type === 'date') {\n            customFormat = {\n              type: args.column.format.type,\n              format: args.column.format.format,\n              skeleton: args.column.format.skeleton\n            };\n          } else if (args.column.type === 'time') {\n            customFormat = {\n              type: 'time',\n              format: args.column.format.format,\n              skeleton: args.column.format.skeleton\n            };\n          } else {\n            customFormat = {\n              type: 'dateTime',\n              format: args.column.format.format,\n              skeleton: args.column.format.skeleton\n            };\n          }\n\n          return this.returnFormattedValue(args, customFormat);\n        }\n      }\n    } else {\n      if (!isNullOrUndefined(args.column.type) && !isNullOrUndefined(args.value) || !isNullOrUndefined(args.value)) {\n        return args.value.toString();\n      } else {\n        return '';\n      }\n    }\n  }\n\n}\n/**\n * @hidden\n * `ExcelExport` module is used to handle the Excel export action.\n */\n\n\nclass ExcelExport {\n  /**\n   * Constructor for the Grid Excel Export module.\n   *\n   * @param {IGrid} parent - specifies the IGrid\n   * @param {ServiceLocator} locator - specifies the ServiceLocator\n   * @hidden\n   */\n  constructor(parent, locator) {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    this.book = {};\n    this.workSheet = [];\n    this.rows = [];\n    this.columns = [];\n    this.styles = [];\n    this.rowLength = 1;\n    this.expType = 'AppendToSheet';\n    this.includeHiddenColumn = false;\n    this.isCsvExport = false;\n    this.isElementIdChanged = false;\n    this.gridPool = {};\n    this.sheet = {};\n    this.parent = parent;\n    this.helper = new ExportHelper(parent);\n    this.locator = locator;\n    this.l10n = this.locator.getService('localization');\n  }\n  /**\n   * For internal use only - Get the module name.\n   *\n   * @returns {string} returns the module name\n   */\n\n\n  getModuleName() {\n    return 'ExcelExport';\n  }\n\n  init(gObj) {\n    if (gObj.element !== null && gObj.element.id === '') {\n      gObj.element.id = new Date().toISOString();\n      this.isElementIdChanged = true;\n    }\n\n    this.parent = gObj;\n\n    if (this.parent.isDestroyed) {\n      return;\n    }\n\n    this.isExporting = undefined;\n    this.book = {};\n    this.workSheet = [];\n    this.rows = [];\n    this.columns = [];\n    this.styles = [];\n    this.rowLength = 1;\n    this.footer = undefined;\n    this.expType = 'AppendToSheet';\n    this.includeHiddenColumn = false;\n    this.exportValueFormatter = new ExportValueFormatter(gObj.locale);\n    gObj.id = getUid('main-grid');\n    this.gridPool[gObj.id] = false;\n  }\n  /**\n   * Export Grid to Excel file.\n   *\n   * @param {IGrid} grid - Defines the grid.\n   * @param  {exportProperties} exportProperties - Defines the export properties of the Grid.\n   * @param  {isMultipleExport} isMultipleExport - Defines is multiple Grid's are exported.\n   * @param  {Workbook} workbook - Defined the Workbook if multiple Grid is exported.\n   * @param  {boolean} isCsv - true if export to CSV.\n   * @param {boolean} isBlob - true if isBlob is enabled.\n   * @returns {Promise<any>} - Returns the map for export.\n   */\n  // eslint-disable-next-line\n\n\n  Map(grid, exportProperties, isMultipleExport, workbook, isCsv, isBlob) {\n    const gObj = grid;\n    const cancel = 'cancel';\n    const isBlb = 'isBlob';\n    const csv = 'isCsv';\n    const workbk = 'workbook';\n    const isMultiEx = 'isMultipleExport';\n    this.gridPool = {};\n\n    if (grid.childGrid && !(!isNullOrUndefined(exportProperties) && exportProperties.hierarchyExportMode === 'None')) {\n      grid.expandedRows = getPrintGridModel(grid).expandedRows;\n    }\n\n    const args = {\n      requestType: 'beforeExcelExport',\n      gridObject: gObj,\n      cancel: false,\n      isMultipleExport: isMultipleExport,\n      workbook: workbook,\n      isCsv: isCsv,\n      isBlob: isBlob\n    };\n    gObj.trigger(beforeExcelExport, args);\n\n    if (args[cancel]) {\n      return new Promise(resolve => {\n        return resolve();\n      });\n    }\n\n    this.parent.log('exporting_begin', this.getModuleName());\n    this.data = new Data(gObj);\n    this.isExporting = true;\n    this.isBlob = args[isBlb];\n\n    if (args[csv]) {\n      this.isCsvExport = args[csv];\n    } else {\n      this.isCsvExport = false;\n    }\n\n    if (isExportColumns(exportProperties)) {\n      updateColumnTypeForExportColumns(exportProperties, gObj);\n    }\n\n    return this.processRecords(gObj, exportProperties, args[isMultiEx], args[workbk]);\n  }\n\n  exportingSuccess(resolve) {\n    this.isExporting = false;\n    this.parent.trigger(excelExportComplete, this.isBlob ? {\n      promise: this.blobPromise\n    } : {});\n    this.parent.log('exporting_complete', this.getModuleName());\n    resolve(this.book);\n    this.sheet.images = [];\n  } // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n\n  processRecords(gObj, exportProperties, isMultipleExport, workbook) {\n    if (!isNullOrUndefined(exportProperties) && !isNullOrUndefined(exportProperties.dataSource) && exportProperties.dataSource instanceof DataManager) {\n      const query = exportProperties.query ? exportProperties.query : new Query();\n\n      if (isNullOrUndefined(query.isCountRequired) || gObj.aggregates) {\n        query.isCountRequired = true;\n      }\n\n      return new Promise(resolve => {\n        const dataManager = exportProperties.dataSource.executeQuery(query);\n        dataManager.then(r => {\n          this.init(gObj);\n          this.processInnerRecords(gObj, exportProperties, isMultipleExport, workbook, r).then(() => {\n            this.exportingSuccess(resolve);\n          });\n        });\n      });\n    } else if (!isNullOrUndefined(exportProperties) && exportProperties.exportType === 'CurrentPage') {\n      return new Promise(resolve => {\n        this.init(gObj);\n        this.processInnerRecords(gObj, exportProperties, isMultipleExport, workbook, this.parent.getCurrentViewRecords());\n        this.exportingSuccess(resolve);\n      });\n    } else {\n      const allPromise = [];\n      allPromise.push(this.data.getData({}, ExportHelper.getQuery(gObj, this.data)));\n      allPromise.push(this.helper.getColumnData(gObj));\n      return new Promise((resolve, reject) => {\n        Promise.all(allPromise).then(e => {\n          this.init(gObj);\n          this.processInnerRecords(gObj, exportProperties, isMultipleExport, workbook, e[0]).then(() => {\n            this.exportingSuccess(resolve);\n          });\n        }).catch(e => {\n          reject(this.book);\n          this.parent.trigger(actionFailure, e);\n        });\n      });\n    }\n  }\n\n  processInnerRecords(gObj, exportProperties, // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  isMultipleExport, workbook, r) {\n    this.groupedColLength = gObj.groupSettings.columns.length;\n    let blankRows = 5;\n    let separator;\n    let rows = [];\n    const colDepth = measureColumnDepth(gObj.columns);\n    const isExportPropertiesPresent = !isNullOrUndefined(exportProperties);\n\n    if (isExportPropertiesPresent && !isNullOrUndefined(exportProperties.multipleExport)) {\n      this.expType = !isNullOrUndefined(exportProperties.multipleExport.type) ? exportProperties.multipleExport.type : 'AppendToSheet';\n\n      if (!isNullOrUndefined(exportProperties.multipleExport.blankRows)) {\n        blankRows = exportProperties.multipleExport.blankRows;\n      }\n    }\n\n    if (isNullOrUndefined(workbook)) {\n      this.workSheet = [];\n      this.rows = [];\n      this.columns = [];\n      this.styles = [];\n    } else if (this.expType === 'NewSheet') {\n      this.workSheet = workbook.worksheets;\n      this.rows = [];\n      this.columns = [];\n      this.styles = workbook.styles;\n    } else {\n      this.workSheet = [];\n      this.rows = workbook.worksheets[0].rows;\n      this.columns = workbook.worksheets[0].columns;\n      this.styles = workbook.styles;\n      this.rowLength = this.rows[this.rows.length - 1].index + blankRows;\n      this.rowLength++;\n    }\n\n    if (isExportPropertiesPresent) {\n      if (!isNullOrUndefined(isMultipleExport)) {\n        if (!isNullOrUndefined(exportProperties.header) && (isMultipleExport || this.expType === 'NewSheet')) {\n          this.processExcelHeader(JSON.parse(JSON.stringify(exportProperties.header)));\n        }\n\n        if (!isNullOrUndefined(exportProperties.footer)) {\n          if (this.expType === 'AppendToSheet') {\n            if (!isMultipleExport) {\n              this.footer = JSON.parse(JSON.stringify(exportProperties.footer));\n            }\n          } else {\n            this.footer = JSON.parse(JSON.stringify(exportProperties.footer));\n          }\n        }\n      } else {\n        if (!isNullOrUndefined(exportProperties.header)) {\n          this.processExcelHeader(JSON.parse(JSON.stringify(exportProperties.header)));\n        }\n\n        if (!isNullOrUndefined(exportProperties.footer)) {\n          this.footer = JSON.parse(JSON.stringify(exportProperties.footer));\n        }\n      }\n    }\n\n    this.includeHiddenColumn = isExportPropertiesPresent ? exportProperties.includeHiddenColumn : false; // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n    return new Promise((resolve, reject) => {\n      gObj.childGridLevel = 0;\n      rows = this.processGridExport(gObj, exportProperties, r);\n      this.globalResolve = resolve;\n      this.gridPool[gObj.id] = true;\n      this.helper.checkAndExport(this.gridPool, this.globalResolve);\n    }).then(() => {\n      const organisedRows = [];\n      this.organiseRows(rows, rows[0].index, organisedRows);\n      this.rows = this.rows.concat(organisedRows); //footer template add\n\n      if (!isNullOrUndefined(this.footer)) {\n        if (this.expType === 'AppendToSheet' && !isMultipleExport || this.expType === 'NewSheet') {\n          this.processExcelFooter(this.footer);\n        }\n      }\n\n      if (this.columns.length > 0) {\n        this.sheet.columns = this.columns;\n      } // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n\n      this.sheet.rows = this.rows;\n      this.sheet.enableRtl = this.parent.enableRtl;\n\n      if (this.parent.allowFiltering && gObj.getVisibleColumns().length && isExportPropertiesPresent && exportProperties.enableFilter) {\n        const headerRowLen = exportProperties.header ? exportProperties.header.headerRows || exportProperties.header.rows.length : 0;\n        const autoFilters = {\n          row: colDepth + headerRowLen,\n          column: this.groupedColLength ? this.groupedColLength + 1 : this.sheet.columns[0].index,\n          lastRow: this.sheet.rows.length,\n          lastColumn: this.sheet.columns.length\n        };\n        this.sheet.autoFilters = autoFilters;\n      }\n\n      this.workSheet.push(this.sheet);\n      this.book.worksheets = this.workSheet;\n      this.book.styles = this.styles;\n      gObj.notify('finalPageSetup', this.book);\n\n      if (!isMultipleExport) {\n        if (this.isCsvExport) {\n          if (isExportPropertiesPresent && !isNullOrUndefined(exportProperties.separator) && exportProperties.separator !== ',') {\n            separator = exportProperties.separator;\n          }\n\n          const book = new Workbook(this.book, 'csv', gObj.locale, gObj.currencyCode, separator);\n\n          if (!this.isBlob) {\n            if (isExportPropertiesPresent && exportProperties.fileName) {\n              book.save(exportProperties.fileName);\n            } else {\n              book.save('Export.csv');\n            }\n          } else {\n            this.blobPromise = book.saveAsBlob('text/csv');\n          }\n        } else {\n          const book = new Workbook(this.book, 'xlsx', gObj.locale, gObj.currencyCode);\n\n          if (!this.isBlob) {\n            if (isExportPropertiesPresent && exportProperties.fileName) {\n              book.save(exportProperties.fileName);\n            } else {\n              book.save('Export.xlsx');\n            }\n          } else {\n            this.blobPromise = book.saveAsBlob('application/vnd.openxmlformats-officedocument.spreadsheetml.sheet');\n          }\n        }\n\n        if (this.isElementIdChanged) {\n          gObj.element.id = '';\n        }\n\n        delete gObj.expandedRows;\n      }\n\n      return workbook;\n    });\n  }\n\n  organiseRows(rows, initialIndex, organisedRows) {\n    if (!rows.length) {\n      return initialIndex;\n    }\n\n    for (let i = 0; i < rows.length; i++) {\n      const row = rows[i];\n      const childRows = row.childRows;\n\n      if (childRows) {\n        row.index = initialIndex++;\n        delete row.childRows;\n        organisedRows.push(row);\n        initialIndex = this.organiseRows(childRows, initialIndex, organisedRows);\n      } else {\n        row.index = initialIndex++;\n        organisedRows.push(row);\n      }\n    }\n\n    return initialIndex;\n  }\n\n  processGridExport(gObj, exportProperties, r) {\n    let excelRows = [];\n    const isFrozen = this.parent.isFrozenGrid() && !this.parent.getFrozenColumns();\n\n    if (!isNullOrUndefined(exportProperties) && !isNullOrUndefined(exportProperties.theme)) {\n      this.theme = exportProperties.theme;\n    }\n\n    if (gObj.childGrid && !isNullOrUndefined(exportProperties)) {\n      gObj.hierarchyPrintMode = exportProperties.hierarchyExportMode || 'Expanded';\n    }\n\n    const helper = new ExportHelper(gObj, this.helper.getForeignKeyData());\n    const gColumns = isExportColumns(exportProperties) ? prepareColumns(exportProperties.columns, gObj.enableColumnVirtualization) : helper.getGridExportColumns(isFrozen ? gObj.getColumns() : gObj.columns);\n    const headerRow = helper.getHeaders(gColumns, this.includeHiddenColumn);\n    const groupIndent = gObj.groupSettings.columns.length ? gObj.groupSettings.columns.length - 1 : 0;\n    excelRows = this.processHeaderContent(gObj, headerRow, groupIndent, excelRows); // eslint-disable-next-line max-len\n\n    if (!isNullOrUndefined(exportProperties) && !isNullOrUndefined(exportProperties.dataSource) && !(exportProperties.dataSource instanceof DataManager)) {\n      // eslint-disable-next-line max-len\n      excelRows = this.processRecordContent(gObj, r, headerRow, exportProperties, exportProperties.dataSource, excelRows, helper);\n    } else if (!isNullOrUndefined(exportProperties) && exportProperties.exportType === 'CurrentPage') {\n      excelRows = this.processRecordContent(gObj, r, headerRow, exportProperties, gObj.currentViewData, excelRows, helper);\n    } else {\n      excelRows = this.processRecordContent(gObj, r, headerRow, exportProperties, undefined, excelRows, helper);\n    }\n\n    gObj.notify(exportDataBound, {\n      excelRows: excelRows,\n      type: 'excel'\n    });\n    return excelRows;\n  }\n\n  processRecordContent(gObj, returnType, headerRow, exportProperties, currentViewRecords, excelRow, helper) {\n    let record;\n\n    if (!isNullOrUndefined(currentViewRecords) && currentViewRecords.length) {\n      record = currentViewRecords;\n    } else {\n      record = returnType.result;\n    }\n\n    if (!isNullOrUndefined(record.level)) {\n      this.processGroupedRows(gObj, record, headerRow, record.level, 0, exportProperties, excelRow, helper);\n    } else {\n      this.processRecordRows(gObj, record, headerRow, 0, 0, exportProperties, excelRow, helper);\n    }\n\n    if (!isNullOrUndefined(returnType.aggregates)) {\n      if (!isNullOrUndefined(currentViewRecords)) {\n        this.processAggregates(gObj, returnType.result, excelRow, currentViewRecords);\n      } else {\n        const result = returnType.result.GroupGuid ? returnType.result.records : returnType.result;\n        this.processAggregates(gObj, result, excelRow);\n      }\n    }\n\n    return excelRow;\n  }\n\n  processGroupedRows( // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  gObj, dataSource, headerRow, level, startIndex, excelExportProperties, excelRows, helper) {\n    for (const item of dataSource) {\n      const cells = [];\n      const index = 1; // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n      const cell = {};\n      cell.index = index + level - 1;\n      const col = gObj.getColumnByField(item.field); // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n      const args = {\n        value: item.key,\n        column: col,\n        style: undefined,\n        isForeignKey: col.isForeignColumn()\n      };\n      let value = gObj.getColumnByField(item.field).headerText + ': ' + (!col.enableGroupByFormat ? this.exportValueFormatter.formatCellValue(args) : item.key) + ' - ';\n\n      if (item.count > 1) {\n        value += item.count + ' items';\n      } else {\n        value += item.count + ' item';\n      }\n\n      const cArgs = {\n        captionText: value,\n        type: this.isCsvExport ? 'CSV' : 'Excel',\n        data: item\n      };\n      this.parent.trigger(exportGroupCaption, cArgs);\n      cell.value = cArgs.captionText;\n      cell.style = this.getCaptionThemeStyle(this.theme);\n      const captionModelGen = new CaptionSummaryModelGenerator(gObj);\n      const groupCaptionSummaryRows = captionModelGen.generateRows(item);\n      this.fillAggregates(gObj, groupCaptionSummaryRows, dataSource.level + dataSource.childLevels - 1, excelRows, this.rowLength);\n      cells.push(cell);\n\n      if (excelRows[excelRows.length - 1].cells.length > 0) {\n        let lIndex = dataSource.level + dataSource.childLevels + groupCaptionSummaryRows[0].cells.length;\n        let hIndex = 0;\n\n        for (const tCell of excelRows[excelRows.length - 1].cells) {\n          if (tCell.index < lIndex) {\n            lIndex = tCell.index;\n          }\n\n          if (tCell.index > hIndex) {\n            hIndex = tCell.index;\n          }\n\n          if (cells[cells.length - 1].index !== tCell.index) {\n            cells.push(tCell);\n          }\n        }\n\n        if (lIndex - cell.index > 1) {\n          cell.colSpan = lIndex - cell.index;\n        }\n\n        while (hIndex < headerRow.columns.length + level + dataSource.childLevels) {\n          // eslint-disable-next-line @typescript-eslint/no-explicit-any\n          const sCell = {};\n          sCell.index = hIndex + 1;\n          sCell.style = this.getCaptionThemeStyle(this.theme);\n          cells.push(sCell);\n          hIndex++;\n        }\n      } else {\n        let span = 0; //Calculation for column span when group caption dont have aggregates\n\n        for (const col of headerRow.columns) {\n          if (col.visible) {\n            span++;\n          }\n        }\n\n        cell.colSpan = dataSource.childLevels + span;\n      }\n\n      excelRows[excelRows.length - 1].cells = cells;\n      this.rowLength++;\n\n      if (this.groupedColLength < 8 && level > 1) {\n        const grouping = {\n          outlineLevel: level - 1,\n          isCollapsed: true\n        };\n        excelRows[excelRows.length - 1].grouping = grouping;\n      }\n\n      if (!isNullOrUndefined(dataSource.childLevels) && dataSource.childLevels > 0) {\n        this.processGroupedRows(gObj, item.items, headerRow, item.items.level, startIndex, excelExportProperties, excelRows, helper);\n        this.processAggregates(gObj, item, excelRows, undefined, level - 1 + dataSource.childLevels, true);\n      } else {\n        startIndex = this.processRecordRows(gObj, item.items, headerRow, level - 1, startIndex, excelExportProperties, excelRows, helper);\n        this.processAggregates(gObj, item, excelRows, undefined, level - 1, true);\n      }\n    }\n  }\n\n  processRecordRows(gObj, record, headerRow, level, startIndex, excelExportProperties, excelRows, helper) {\n    let index = 1;\n    let cells = [];\n    const columns = headerRow.columns;\n    const rows = helper.getGridRowModel(columns, record, gObj, startIndex);\n\n    for (const row of rows) {\n      cells = [];\n      startIndex++;\n      index = 1;\n      let templateRowHeight;\n\n      for (let c = 0, len = row.cells.length; c < len; c++) {\n        const gCell = row.cells[c];\n\n        if (gCell.cellType !== CellType.Data) {\n          continue;\n        }\n\n        const column = gCell.column;\n        const field = column.field;\n        const cellValue = !isNullOrUndefined(field) ? column.valueAccessor(field, row.data, column) : '';\n        let value = !isNullOrUndefined(cellValue) ? cellValue : '';\n        let fkData;\n\n        if (column.isForeignColumn && column.isForeignColumn()) {\n          fkData = helper.getFData(value, column);\n          value = getValue(column.foreignKeyValue, fkData);\n        }\n\n        if (!isNullOrUndefined(value)) {\n          let cell = {};\n          const idx = index + level + gObj.childGridLevel; // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n          let excelCellArgs = {\n            data: row.data,\n            column: column,\n            foreignKeyData: fkData,\n            value: value,\n            style: undefined,\n            colSpan: 1,\n            cell: cell\n          };\n          gObj.trigger(excelQueryCellInfo, excelCellArgs);\n\n          if (!isNullOrUndefined(excelCellArgs.image) && !isNullOrUndefined(excelCellArgs.image.base64)) {\n            templateRowHeight = this.setImage(excelCellArgs, idx);\n          }\n\n          if (!isNullOrUndefined(excelCellArgs.hyperLink)) {\n            excelCellArgs.cell.hyperlink = {\n              target: excelCellArgs.hyperLink.target\n            };\n            excelCellArgs.value = excelCellArgs.hyperLink.displayText || excelCellArgs.value;\n          }\n\n          cell = excelCellArgs.cell;\n          cell.index = idx;\n          cell.value = excelCellArgs.value;\n\n          if (excelCellArgs.data === '' && gObj.childGridLevel && index === 1) {\n            const style = {};\n            style.hAlign = 'left';\n            excelCellArgs = {\n              style: style\n            };\n            cell.colSpan = gObj.getVisibleColumns().length;\n            cell.value = this.l10n.getConstant('EmptyRecord');\n          }\n\n          if (excelCellArgs.colSpan > 1) {\n            cell.colSpan = excelCellArgs.colSpan;\n          }\n\n          if (!isNullOrUndefined(excelCellArgs.style)) {\n            const styleIndex = this.getColumnStyle(gObj, index + level);\n            cell.style = this.mergeOptions(this.styles[styleIndex], excelCellArgs.style);\n          } else {\n            cell.style = {\n              name: gObj.element.id + 'column' + (index + level)\n            };\n          }\n\n          cells.push(cell);\n        }\n\n        index++;\n      }\n\n      const excelRow = {\n        index: this.rowLength++,\n        cells: cells\n      };\n\n      if (!isNullOrUndefined(templateRowHeight)) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        excelRow.height = templateRowHeight;\n      }\n\n      if (this.groupedColLength < 8 && level + 1 > 0) {\n        excelRow.grouping = {\n          outlineLevel: level + 1,\n          isCollapsed: true\n        };\n        excelRows.push(excelRow);\n      } else {\n        excelRows.push(excelRow);\n      }\n\n      if (row.isExpand && !isNullOrUndefined(gObj.childGrid)) {\n        gObj.isPrinting = true;\n        const exportType = !isNullOrUndefined(excelExportProperties) && excelExportProperties.exportType ? excelExportProperties.exportType : 'AllPages';\n        const returnVal = this.helper.createChildGrid(gObj, row, exportType, this.gridPool);\n        const childGridObj = returnVal.childGrid;\n        const element = returnVal.element;\n        childGridObj.actionFailure = helper.failureHandler(this.gridPool, childGridObj, this.globalResolve);\n        childGridObj.childGridLevel = gObj.childGridLevel + 1;\n        const args = {\n          childGrid: childGridObj,\n          row,\n          exportProperties: excelExportProperties\n        };\n        this.parent.trigger(exportDetailDataBound, args);\n        childGridObj.beforeDataBound = this.childGridCell(excelRow, childGridObj, excelExportProperties, row);\n        childGridObj.appendTo(element);\n      }\n\n      gObj.notify(exportRowDataBound, {\n        rowObj: row,\n        type: 'excel',\n        excelRows: excelRows\n      });\n    }\n\n    return startIndex;\n  }\n\n  setImage(args, idx) {\n    if (isNullOrUndefined(this.sheet.images)) {\n      this.sheet.images = [];\n    } // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n\n    const excelImage = {\n      image: args.image.base64,\n      row: this.rowLength,\n      column: idx,\n      lastRow: this.rowLength,\n      lastColumn: idx\n    };\n    this.sheet.images.push(excelImage);\n    this.columns[idx - 1].width = args.image.width || this.columns[idx - 1].width;\n    return args.image.height || 50;\n  }\n\n  childGridCell(excelRow, childGridObj, excelExportProps, gRow) {\n    return result => {\n      childGridObj.beforeDataBound = null;\n      result.cancel = true;\n\n      if (result.result.length === 0) {\n        result.result = [''];\n      }\n\n      excelRow.childRows = this.processGridExport(childGridObj, excelExportProps, result);\n      const intent = this.parent.groupSettings.columns.length;\n      const rows = excelRow.childRows;\n\n      for (let i = 0; i < rows.length; i++) {\n        rows[i].grouping = {\n          outlineLevel: intent + childGridObj.childGridLevel,\n          isCollapsed: !gRow.isExpand,\n          isHidden: !gRow.isExpand\n        };\n      }\n\n      childGridObj.destroy();\n      detach(childGridObj.element);\n      this.gridPool[childGridObj.id] = true;\n      this.helper.checkAndExport(this.gridPool, this.globalResolve);\n      return excelRow;\n    };\n  }\n\n  processAggregates(gObj, rec, excelRows, currentViewRecords, indent, byGroup) {\n    const summaryModel = new SummaryModelGenerator(gObj);\n    let columns = summaryModel.getColumns();\n    columns = columns.filter(col => {\n      return isNullOrUndefined(col.commands) && col.type !== 'checkbox';\n    });\n\n    if (gObj.aggregates.length && this.parent !== gObj) {\n      gObj.aggregateModule.prepareSummaryInfo();\n    }\n\n    let data = undefined;\n\n    if (!isNullOrUndefined(currentViewRecords)) {\n      data = currentViewRecords;\n    } else {\n      data = rec;\n    }\n\n    if (indent === undefined) {\n      indent = 0;\n    }\n\n    if (gObj.groupSettings.columns.length > 0 && byGroup) {\n      const groupSummaryModel = new GroupSummaryModelGenerator(gObj);\n      const groupSummaryRows = groupSummaryModel.generateRows(data, {\n        level: data.level\n      });\n\n      if (groupSummaryRows.length > 0) {\n        excelRows = this.fillAggregates(gObj, groupSummaryRows, indent, excelRows);\n      }\n    } else {\n      indent = gObj.groupSettings.columns.length > 0 && !byGroup ? gObj.groupSettings.columns.length : indent;\n      const sRows = summaryModel.generateRows(data, rec.aggregates, null, null, columns);\n\n      if (sRows.length > 0 && !byGroup) {\n        indent = gObj.groupSettings.columns.length ? indent - 1 : indent;\n        excelRows = this.fillAggregates(gObj, sRows, indent, excelRows);\n      }\n    }\n\n    return excelRows;\n  }\n\n  fillAggregates(gObj, rows, indent, excelRows, customIndex) {\n    for (const row of rows) {\n      const cells = [];\n      let isEmpty = true;\n      let index = 0;\n\n      for (const cell of row.cells) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const eCell = {};\n\n        if (cell.cellType === CellType.DetailFooterIntent) {\n          continue;\n        }\n\n        if (cell.visible || this.includeHiddenColumn) {\n          index++;\n\n          if (cell.isDataCell) {\n            isEmpty = false;\n            const footerTemplate = !isNullOrUndefined(cell.column.footerTemplate);\n            const groupFooterTemplate = !isNullOrUndefined(cell.column.groupFooterTemplate);\n            const groupCaptionTemplate = !isNullOrUndefined(cell.column.groupCaptionTemplate);\n            eCell.index = index + indent + gObj.childGridLevel;\n\n            if (footerTemplate) {\n              eCell.value = this.getAggreateValue(CellType.Summary, cell.column.footerTemplate, cell, row);\n            } else if (groupFooterTemplate) {\n              eCell.value = this.getAggreateValue(CellType.GroupSummary, cell.column.groupFooterTemplate, cell, row);\n            } else if (groupCaptionTemplate) {\n              eCell.value = this.getAggreateValue(CellType.CaptionSummary, cell.column.groupCaptionTemplate, cell, row);\n            } else {\n              for (const key of Object.keys(row.data[cell.column.field])) {\n                if (key === cell.column.type) {\n                  if (!isNullOrUndefined(row.data[cell.column.field].Sum)) {\n                    eCell.value = row.data[cell.column.field][`${cell.column.field} - sum`];\n                  } else if (!isNullOrUndefined(row.data[cell.column.field].Average)) {\n                    eCell.value = row.data[cell.column.field][`${cell.column.field} - average`];\n                  } else if (!isNullOrUndefined(row.data[cell.column.field].Max)) {\n                    eCell.value = row.data[cell.column.field][`${cell.column.field} - max`];\n                  } else if (!isNullOrUndefined(row.data[cell.column.field].Min)) {\n                    eCell.value = row.data[cell.column.field][`${cell.column.field} - min`];\n                  } else if (!isNullOrUndefined(row.data[cell.column.field].Count)) {\n                    eCell.value = row.data[cell.column.field][`${cell.column.field} - count`];\n                  } else if (!isNullOrUndefined(row.data[cell.column.field].TrueCount)) {\n                    eCell.value = row.data[cell.column.field][`${cell.column.field} - truecount`];\n                  } else if (!isNullOrUndefined(row.data[cell.column.field].FalseCount)) {\n                    eCell.value = row.data[cell.column.field][`${cell.column.field} - falsecount`];\n                  } else if (!isNullOrUndefined(row.data[cell.column.field].Custom)) {\n                    eCell.value = row.data[cell.column.field].Custom;\n                  }\n                }\n              }\n            }\n\n            eCell.style = this.getCaptionThemeStyle(this.theme); //{ name: gObj.element.id + 'column' + index };\n\n            this.aggregateStyle(cell.column, eCell.style, cell.column.field);\n            const gridCellStyle = cell.attributes.style;\n\n            if (gridCellStyle.textAlign) {\n              eCell.style.hAlign = gridCellStyle.textAlign.toLowerCase();\n            }\n\n            const args = {\n              row: row,\n              type: footerTemplate ? 'Footer' : groupFooterTemplate ? 'GroupFooter' : 'GroupCaption',\n              style: eCell\n            };\n            this.parent.trigger(excelAggregateQueryCellInfo, args);\n            cells.push(eCell);\n          } else {\n            if (customIndex === undefined) {\n              eCell.index = index + indent + gObj.childGridLevel;\n              eCell.style = this.getCaptionThemeStyle(this.theme); //{ name: gObj.element.id + 'column' + index };\n\n              cells.push(eCell);\n            }\n          }\n        }\n      }\n\n      if (!isNullOrUndefined(customIndex)) {\n        excelRows.push({\n          index: customIndex,\n          cells: cells\n        });\n      } else {\n        let row = {};\n\n        if (this.groupedColLength < 8 && this.groupedColLength > 0) {\n          const dummyOutlineLevel = 'outlineLevel';\n          const dummyGrouping = 'grouping';\n          const level = excelRows[excelRows.length - 1][dummyGrouping][dummyOutlineLevel];\n          const grouping = {\n            outlineLevel: level,\n            isCollapsed: true\n          };\n          row = {\n            index: this.rowLength++,\n            cells: cells,\n            grouping\n          };\n        } else {\n          row = {\n            index: this.rowLength++,\n            cells: cells\n          };\n        }\n\n        if (!isEmpty) {\n          excelRows.push(row);\n        }\n      }\n    }\n\n    return excelRows;\n  }\n\n  aggregateStyle(col, style, field) {\n    const column = this.parent.getColumnByField(field);\n\n    if (typeof col.format === 'object') {\n      const format = col.format;\n      style.numberFormat = !isNullOrUndefined(format.format) ? format.format : format.skeleton;\n\n      if (!isNullOrUndefined(format.type)) {\n        style.type = format.type.toLowerCase();\n      }\n    } else {\n      style.numberFormat = col.format;\n    }\n\n    if (!isNullOrUndefined(column) && isNullOrUndefined(style.type)) {\n      style.type = column.type.toLowerCase();\n    }\n  }\n\n  getAggreateValue(cellType, template, cell, row) {\n    const templateFn = {};\n    templateFn[getEnumValue(CellType, cell.cellType)] = compile(template);\n    let txt;\n    const data = row.data[cell.column.field ? cell.column.field : cell.column.columnName];\n\n    if (this.parent.isReact || this.parent.isVue) {\n      txt = templateFn[getEnumValue(CellType, cell.cellType)](data, this.parent);\n\n      if (this.parent.isReact) {\n        this.parent.renderTemplates();\n      }\n    } else {\n      txt = templateFn[getEnumValue(CellType, cell.cellType)](data);\n    }\n\n    return txt[0].textContent;\n  }\n\n  mergeOptions(JSON1, JSON2) {\n    const result = {};\n    let attrname = Object.keys(JSON1);\n\n    for (let index = 0; index < attrname.length; index++) {\n      if (attrname[index] !== 'name') {\n        result[attrname[index]] = JSON1[attrname[index]];\n      }\n    }\n\n    attrname = Object.keys(JSON2);\n\n    for (let index = 0; index < attrname.length; index++) {\n      if (attrname[index] !== 'name') {\n        result[attrname[index]] = JSON2[attrname[index]];\n      }\n    }\n\n    return result;\n  }\n\n  getColumnStyle(gObj, columnIndex) {\n    let index = 0;\n\n    for (const style of this.styles) {\n      if (style.name === gObj.element.id + 'column' + columnIndex) {\n        return index;\n      }\n\n      index++;\n    }\n\n    return undefined;\n  }\n\n  processHeaderContent(gObj, headerRow, indent, excelRows) {\n    const rowIndex = 1;\n    const gridRows = headerRow.rows; // Column collection with respect to the records in the grid\n\n    const gridColumns = headerRow.columns;\n    const spannedCells = [];\n\n    if (indent > 0) {\n      let index = 0;\n\n      while (index !== indent) {\n        this.columns.push({\n          index: index + 1,\n          width: 30\n        });\n        index++;\n      }\n    }\n\n    for (let col = 0; col < gridColumns.length; col++) {\n      this.parseStyles(gObj, gridColumns[col], this.getRecordThemeStyle(this.theme), indent + col + 1);\n    }\n\n    let templateRowHeight;\n\n    for (let row = 0; row < gridRows.length; row++) {\n      let currentCellIndex = 1 + indent;\n      const cells = [];\n\n      for (let column = 0; column < gridRows[row].cells.length; column++) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        let style = {};\n        const cell = {};\n        const gridCell = gridRows[row].cells[column];\n\n        if (gridCell.cellType === CellType.HeaderIndent || gridCell.cellType === CellType.DetailHeader) {\n          continue;\n        }\n\n        let result = {\n          contains: true,\n          index: 1\n        };\n\n        while (result.contains) {\n          result = this.getIndex(spannedCells, rowIndex, currentCellIndex);\n          currentCellIndex = result.index;\n\n          if (!result.contains) {\n            cell.index = result.index + gObj.childGridLevel;\n            break;\n          }\n        }\n\n        if (!isNullOrUndefined(gridCell.rowSpan) && gridCell.rowSpan !== 1) {\n          cell.rowSpan = gridCell.rowSpan;\n\n          for (let i = rowIndex; i < gridCell.rowSpan + rowIndex; i++) {\n            const spannedCell = {\n              rowIndex: 0,\n              columnIndex: 0\n            };\n            spannedCell.rowIndex = i;\n            spannedCell.columnIndex = currentCellIndex;\n            spannedCells.push(spannedCell);\n          }\n        }\n\n        if (!isNullOrUndefined(gridCell.colSpan) && gridCell.colSpan !== 1) {\n          cell.colSpan = gridCell.colSpan;\n          currentCellIndex = currentCellIndex + cell.colSpan - 1;\n        }\n\n        cell.value = gridCell.column.headerText;\n        style = this.getHeaderThemeStyle(this.theme);\n\n        if (!isNullOrUndefined(gridCell.column.textAlign)) {\n          style.hAlign = gridCell.column.textAlign.toLowerCase();\n        }\n\n        if (!isNullOrUndefined(gridCell.column.headerTextAlign)) {\n          style.hAlign = gridCell.column.headerTextAlign.toLowerCase();\n        }\n\n        const excelHeaderCellArgs = {\n          cell: cell,\n          gridCell: gridCell,\n          style: style\n        };\n        gObj.trigger(excelHeaderQueryCellInfo, excelHeaderCellArgs);\n\n        if (!isNullOrUndefined(excelHeaderCellArgs.image) && !isNullOrUndefined(excelHeaderCellArgs.image.base64)) {\n          templateRowHeight = this.setImage(excelHeaderCellArgs, currentCellIndex);\n        }\n\n        if (!isNullOrUndefined(excelHeaderCellArgs.hyperLink)) {\n          excelHeaderCellArgs.cell.hyperlink = {\n            target: excelHeaderCellArgs.hyperLink.target\n          };\n          cell.value = excelHeaderCellArgs.hyperLink.displayText || cell.value;\n        }\n\n        cell.style = excelHeaderCellArgs.style;\n        cells.push(cell);\n        currentCellIndex++;\n      }\n\n      const excelRow = {\n        index: this.rowLength++,\n        cells: cells\n      };\n\n      if (!isNullOrUndefined(templateRowHeight)) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        excelRow.height = templateRowHeight;\n      }\n\n      excelRows.push(excelRow);\n    }\n\n    return excelRows;\n  }\n\n  getHeaderThemeStyle(theme) {\n    let style = {};\n    style.fontSize = 12;\n    style.borders = {\n      color: '#E0E0E0'\n    };\n    style.bold = true;\n\n    if (!isNullOrUndefined(theme) && !isNullOrUndefined(theme.header)) {\n      style = this.updateThemeStyle(theme.header, style);\n    }\n\n    return style;\n  }\n\n  updateThemeStyle(themestyle, style) {\n    return extend(style, themestyle);\n  }\n\n  getCaptionThemeStyle(theme) {\n    let style = {};\n    style.fontSize = 13;\n    style.backColor = '#F6F6F6';\n\n    if (!isNullOrUndefined(theme) && !isNullOrUndefined(theme.caption)) {\n      style = this.updateThemeStyle(theme.caption, style);\n    }\n\n    return style;\n  }\n\n  getRecordThemeStyle(theme) {\n    let style = {};\n    style.fontSize = 13;\n    style.borders = {\n      color: '#E0E0E0'\n    };\n\n    if (!isNullOrUndefined(theme) && !isNullOrUndefined(theme.record)) {\n      style = this.updateThemeStyle(theme.record, style);\n    }\n\n    return style;\n  }\n\n  processExcelHeader(header) {\n    if (!isNullOrUndefined(header.rows) && (this.expType === 'NewSheet' || this.rowLength === 1)) {\n      let noRows;\n\n      if (header.headerRows === undefined) {\n        this.rowLength = header.rows.length;\n      } else {\n        this.rowLength = header.headerRows;\n      }\n\n      if (this.rowLength < header.rows.length) {\n        noRows = this.rowLength;\n      } else {\n        noRows = header.rows.length;\n      }\n\n      this.rowLength++;\n\n      for (let row = 0; row < noRows; row++) {\n        const json = header.rows[row]; //Row index\n\n        if (!(json.index !== null && !isNullOrUndefined(json.index))) {\n          json.index = row + 1;\n        }\n\n        this.updatedCellIndex(json);\n      }\n    }\n  }\n\n  updatedCellIndex(json) {\n    const cellsLength = json.cells.length;\n\n    for (let cellId = 0; cellId < cellsLength; cellId++) {\n      const jsonCell = json.cells[cellId]; //cell index\n\n      if (!(jsonCell.index !== null && !isNullOrUndefined(jsonCell.index))) {\n        jsonCell.index = cellId + 1;\n      }\n    }\n\n    this.rows.push(json);\n  }\n\n  processExcelFooter(footer) {\n    if (!isNullOrUndefined(footer.rows)) {\n      let noRows;\n\n      if (footer.footerRows === undefined) {\n        this.rowLength += footer.rows.length;\n      } else {\n        if (footer.footerRows > footer.rows.length) {\n          this.rowLength += footer.footerRows - footer.rows.length;\n          noRows = footer.rows.length;\n        } else {\n          noRows = footer.footerRows;\n        }\n      }\n\n      for (let row = 0; row < noRows; row++) {\n        const json = footer.rows[row]; //Row index\n\n        if (json.index === null || json.index === undefined) {\n          json.index = this.rowLength++;\n        } else {\n          json.index += this.rowLength;\n        }\n\n        this.updatedCellIndex(json);\n      }\n    }\n  }\n\n  getIndex(spannedCells, rowIndex, columnIndex) {\n    for (const spannedCell of spannedCells) {\n      if (spannedCell.rowIndex === rowIndex && spannedCell.columnIndex === columnIndex) {\n        columnIndex = columnIndex + 1;\n        return {\n          contains: true,\n          index: columnIndex\n        };\n      }\n    }\n\n    return {\n      contains: false,\n      index: columnIndex\n    };\n  }\n\n  parseStyles(gObj, col, style, index) {\n    if (!isNullOrUndefined(col.format)) {\n      if (typeof col.format === 'object') {\n        const format = col.format;\n        style.numberFormat = !isNullOrUndefined(format.format) ? format.format : format.skeleton;\n\n        if (!isNullOrUndefined(format.type)) {\n          style.type = format.type.toLowerCase();\n        }\n      } else {\n        style.numberFormat = col.format;\n        style.type = col.type;\n      }\n    }\n\n    if (!isNullOrUndefined(col.textAlign)) {\n      style.hAlign = col.textAlign.toLowerCase();\n    }\n\n    if (Object.keys(style).length > 0) {\n      style.name = gObj.element.id + 'column' + index;\n      this.styles.push(style);\n    }\n\n    if (!isNullOrUndefined(col.width) && col.width !== 'auto') {\n      this.columns.push({\n        index: index + gObj.childGridLevel,\n        width: typeof col.width === 'number' ? col.width : this.helper.getConvertedWidth(col.width)\n      });\n    }\n  }\n\n  destroy() {//destroy for exporting\n  }\n\n}\n/**\n * `PDF Export` module is used to handle the exportToPDF action.\n *\n * @hidden\n */\n\n\nclass PdfExport {\n  /**\n   * Constructor for the Grid PDF Export module\n   *\n   * @param {IGrid} parent - specifies the IGrid\n   * @hidden\n   */\n  constructor(parent) {\n    this.hideColumnInclude = false;\n    this.currentViewData = false;\n    this.customDataSource = false;\n    this.isGrouping = false;\n    this.headerOnPages = [];\n    this.drawPosition = {\n      xPosition: 0,\n      yPosition: 0\n    };\n    this.parent = parent;\n    this.helper = new ExportHelper(parent);\n    this.gridPool = {};\n  }\n  /**\n   * For internal use only - Get the module name.\n   *\n   * @returns {string} returns the module name\n   */\n\n\n  getModuleName() {\n    return 'PdfExport';\n  }\n\n  init(parent) {\n    this.exportValueFormatter = new ExportValueFormatter(parent.locale);\n    this.pdfDocument = undefined;\n    this.hideColumnInclude = false;\n    this.currentViewData = false;\n    this.parent = parent;\n    this.isGrouping = false;\n    this.isExporting = true;\n    parent.id = getUid('main-grid');\n    this.gridPool[parent.id] = false;\n    this.pdfPageSettings = new PdfPageSettings();\n  }\n\n  exportWithData(parent, pdfDoc, resolve, returnType, pdfExportProperties, isMultipleExport, reject) {\n    this.init(parent);\n\n    if (!isNullOrUndefined(pdfDoc)) {\n      this.pdfDocument = pdfDoc;\n    } else {\n      this.pdfDocument = new PdfDocument();\n    }\n\n    this.processExport(parent, returnType, pdfExportProperties, isMultipleExport).then(() => {\n      this.isExporting = false;\n      parent.trigger(pdfExportComplete, this.isBlob ? {\n        promise: this.blobPromise\n      } : {});\n      this.parent.log('exporting_complete', this.getModuleName());\n      resolve(this.pdfDocument);\n    }).catch(e => {\n      reject(this.pdfDocument);\n      this.parent.trigger(actionFailure, e);\n    });\n  }\n  /**\n   * Used to map the input data\n   *\n   * @param {IGrid} parent - specifies the IGrid\n   * @param {PdfExportProperties} pdfExportProperties - specifies the PdfExportProperties\n   * @param {boolean} isMultipleExport - specifies the isMultipleExport\n   * @param {Object} pdfDoc - specifies the pdfDoc\n   * @param {boolean} isBlob - speciies whether it is Blob or not\n   * @returns {void}\n   */\n\n\n  Map(parent, pdfExportProperties, isMultipleExport, pdfDoc, isBlob) {\n    this.data = new Data(this.parent);\n    this.isBlob = isBlob;\n    this.gridPool = {};\n    let query = new Query();\n\n    if (parent.childGrid && !(!isNullOrUndefined(pdfExportProperties) && pdfExportProperties.hierarchyExportMode === 'None')) {\n      parent.expandedRows = getPrintGridModel(parent).expandedRows;\n    }\n\n    const args = {\n      requestType: 'beforePdfExport',\n      cancel: false,\n      headerPageNumbers: [],\n      gridDrawPosition: {\n        xPosition: 0,\n        yPosition: 0\n      },\n      generateQuery: false\n    };\n    const gridObject = 'gridObject';\n    args[gridObject] = parent;\n    const can = 'cancel';\n    const generateQuery$$1 = 'generateQuery';\n    const header = 'headerPageNumbers';\n    const drawPos = 'gridDrawPosition';\n    parent.trigger(beforePdfExport, args);\n\n    if (args[can] === true) {\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      return new Promise((resolve, reject) => {\n        return resolve();\n      });\n    }\n\n    if (isExportColumns(pdfExportProperties)) {\n      updateColumnTypeForExportColumns(pdfExportProperties, parent);\n    }\n\n    if (args[generateQuery$$1]) {\n      query = ExportHelper.getQuery(parent, this.data);\n    }\n\n    this.headerOnPages = args[header];\n    this.drawPosition = args[drawPos];\n    this.parent.log('exporting_begin', this.getModuleName());\n\n    if (!isNullOrUndefined(pdfExportProperties) && !isNullOrUndefined(pdfExportProperties.dataSource) && pdfExportProperties.dataSource instanceof DataManager) {\n      return new Promise((resolve, reject) => {\n        pdfExportProperties.dataSource.executeQuery(query).then(returnType => {\n          this.exportWithData(parent, pdfDoc, resolve, returnType, pdfExportProperties, isMultipleExport, reject);\n        });\n      });\n    } else if (!isNullOrUndefined(pdfExportProperties) && pdfExportProperties.exportType === 'CurrentPage') {\n      return new Promise((resolve, reject) => {\n        this.exportWithData(parent, pdfDoc, resolve, this.parent.getCurrentViewRecords(), pdfExportProperties, isMultipleExport, reject);\n      });\n    } else {\n      const allPromise = [];\n      allPromise.push(this.data.getData({}, ExportHelper.getQuery(parent, this.data)));\n      allPromise.push(this.helper.getColumnData(parent));\n      return new Promise((resolve, reject) => {\n        Promise.all(allPromise).then(e => {\n          this.init(parent);\n\n          if (!isNullOrUndefined(pdfDoc)) {\n            this.pdfDocument = pdfDoc;\n          } else {\n            this.pdfDocument = new PdfDocument();\n          }\n\n          this.processExport(parent, e[0], pdfExportProperties, isMultipleExport).then(() => {\n            this.isExporting = false;\n            parent.trigger(pdfExportComplete, this.isBlob ? {\n              promise: this.blobPromise\n            } : {});\n            this.parent.log('exporting_complete', this.getModuleName());\n            resolve(this.pdfDocument);\n          }).catch(e => {\n            reject(this.pdfDocument);\n            this.parent.trigger(actionFailure, e);\n          });\n        });\n      });\n    }\n  }\n\n  processExport(gObj, returnType, pdfExportProperties, isMultipleExport) {\n    const section = this.pdfDocument.sections.add();\n    let pdfGrid;\n    this.processSectionExportProperties(section, pdfExportProperties);\n    const pdfPage = section.pages.add(); // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n    return new Promise((resolve, reject) => {\n      pdfGrid = this.processGridExport(gObj, returnType, pdfExportProperties);\n      this.globalResolve = resolve;\n      this.gridPool[gObj.id] = true;\n      this.helper.checkAndExport(this.gridPool, this.globalResolve);\n    }).then(() => {\n      // draw the grid\n      const xPosition = 'xPosition';\n      const yPosition = 'yPosition';\n      pdfGrid.draw(pdfPage, this.drawPosition[xPosition], this.drawPosition[yPosition]);\n      this.drawHeader(pdfExportProperties);\n\n      if (!isMultipleExport) {\n        // save the PDF\n        if (!this.isBlob) {\n          if (!isNullOrUndefined(pdfExportProperties) && pdfExportProperties.fileName) {\n            this.pdfDocument.save(pdfExportProperties.fileName);\n          } else {\n            this.pdfDocument.save('Export.pdf');\n          }\n        } else {\n          this.blobPromise = this.pdfDocument.save();\n        }\n\n        this.pdfDocument.destroy();\n        delete gObj.expandedRows;\n      }\n\n      return this.pdfDocument;\n    });\n  }\n\n  processSectionExportProperties(section, pdfExportProperties) {\n    if (!isNullOrUndefined(pdfExportProperties) && (!isNullOrUndefined(pdfExportProperties.pageOrientation) || !isNullOrUndefined(pdfExportProperties.pageSize))) {\n      this.pdfPageSettings.orientation = pdfExportProperties.pageOrientation === 'Landscape' ? PdfPageOrientation.Landscape : PdfPageOrientation.Portrait;\n      this.pdfPageSettings.size = this.getPageSize(pdfExportProperties.pageSize);\n      section.setPageSettings(this.pdfPageSettings);\n    }\n\n    return section;\n  }\n\n  processGridExport(gObj, returnType, pdfExportProperties) {\n    let allowHorizontalOverflow = true;\n    const isFrozen = this.parent.isFrozenGrid() && !this.parent.getFrozenColumns();\n\n    if (!isNullOrUndefined(pdfExportProperties)) {\n      this.gridTheme = pdfExportProperties.theme;\n      allowHorizontalOverflow = isNullOrUndefined(pdfExportProperties.allowHorizontalOverflow) ? true : pdfExportProperties.allowHorizontalOverflow;\n    }\n\n    const helper = new ExportHelper(gObj, this.helper.getForeignKeyData());\n    const dataSource = this.processExportProperties(pdfExportProperties, returnType.result);\n    let columns = isExportColumns(pdfExportProperties) ? prepareColumns(pdfExportProperties.columns, gObj.enableColumnVirtualization) : helper.getGridExportColumns(isFrozen ? gObj.getColumns() : gObj.columns);\n    columns = columns.filter(columns => {\n      return isNullOrUndefined(columns.commands);\n    });\n    let isGrouping = false;\n\n    if (gObj.groupSettings.columns.length) {\n      isGrouping = true;\n    }\n\n    if (gObj.childGrid && !isNullOrUndefined(pdfExportProperties)) {\n      gObj.hierarchyPrintMode = pdfExportProperties.hierarchyExportMode || 'Expanded';\n    } // create a grid\n\n\n    let pdfGrid = new PdfGrid(); // get header theme style\n\n    const headerThemeStyle = this.getHeaderThemeStyle();\n    let border = headerThemeStyle.border;\n    const headerFont = headerThemeStyle.font;\n    const headerBrush = headerThemeStyle.brush;\n    const returnValue = helper.getHeaders(columns, this.hideColumnInclude); // Column collection with respect to the records in the grid\n\n    const gridColumns = returnValue.columns; // process grid header content\n\n    pdfGrid = this.processGridHeaders(gObj.groupSettings.columns.length, pdfGrid, returnValue.rows, gridColumns, border, headerFont, headerBrush, gObj, allowHorizontalOverflow, columns); // set alignment, width and type of the values of the column\n\n    this.setColumnProperties(gridColumns, pdfGrid, helper, gObj, allowHorizontalOverflow);\n    const captionThemeStyle = this.getSummaryCaptionThemeStyle();\n\n    if (!isNullOrUndefined(dataSource) && dataSource.length) {\n      if (isGrouping) {\n        if (!isNullOrUndefined(captionThemeStyle.border)) {\n          border = captionThemeStyle.border;\n        }\n\n        this.processGroupedRecords(pdfGrid, dataSource, gridColumns, gObj, border, 0, captionThemeStyle.font, captionThemeStyle.brush, captionThemeStyle.backgroundBrush, returnType, pdfExportProperties, helper, 0);\n      } else {\n        this.processRecord(border, gridColumns, gObj, dataSource, pdfGrid, 0, pdfExportProperties, helper, 0);\n      }\n\n      if (!isNullOrUndefined(returnType.aggregates)) {\n        const summaryModel = new SummaryModelGenerator(gObj);\n        let sRows;\n        let column = summaryModel.getColumns();\n        column = column.filter(col => {\n          return isNullOrUndefined(col.commands) && col.type !== 'checkbox';\n        });\n\n        if (gObj.aggregates.length && this.parent !== gObj) {\n          gObj.aggregateModule.prepareSummaryInfo();\n        }\n\n        if (this.customDataSource) {\n          sRows = summaryModel.generateRows(dataSource, returnType.aggregates);\n        } else if (this.currentViewData) {\n          sRows = summaryModel.generateRows(this.parent.getCurrentViewRecords(), returnType.aggregates);\n        } else if (isGrouping) {\n          sRows = summaryModel.generateRows(dataSource.records, returnType.aggregates);\n        } else {\n          sRows = summaryModel.generateRows(returnType.result, returnType.aggregates, null, null, column);\n        }\n\n        this.processAggregates(sRows, pdfGrid, border, captionThemeStyle.font, captionThemeStyle.brush, captionThemeStyle.backgroundBrush, false, null, null, null, isGrouping ? false : true);\n      }\n    } else {\n      const row = pdfGrid.rows.addRow();\n      row.style.setBorder(border);\n    }\n\n    return pdfGrid;\n  }\n\n  getSummaryCaptionThemeStyle() {\n    if (!isNullOrUndefined(this.gridTheme) && !isNullOrUndefined(this.gridTheme.caption)) {\n      const fontSize = !isNullOrUndefined(this.gridTheme.caption.fontSize) ? this.gridTheme.caption.fontSize : 9.75;\n      const fontFamily = !isNullOrUndefined(this.gridTheme.caption.fontName) ? this.getFontFamily(this.gridTheme.caption.fontName) : PdfFontFamily.Helvetica;\n      const fontStyle = this.getFontStyle(this.gridTheme.caption);\n      let pdfColor = new PdfColor(0, 0, 0);\n\n      if (!isNullOrUndefined(this.gridTheme.caption.fontColor)) {\n        const penBrushColor = this.hexToRgb(this.gridTheme.caption.fontColor);\n        pdfColor = new PdfColor(penBrushColor.r, penBrushColor.g, penBrushColor.b);\n      }\n\n      const borderCaption = this.gridTheme.caption.border ? this.getBorderStyle(this.gridTheme.caption.border) : null;\n      let font = new PdfStandardFont(fontFamily, fontSize, fontStyle);\n\n      if (!isNullOrUndefined(this.gridTheme.caption.font)) {\n        font = this.gridTheme.caption.font;\n      }\n\n      return {\n        font: font,\n        brush: new PdfSolidBrush(pdfColor),\n        backgroundBrush: new PdfSolidBrush(new PdfColor(246, 246, 246)),\n        border: borderCaption\n      };\n    } else {\n      //Material theme\n      return {\n        font: new PdfStandardFont(PdfFontFamily.Helvetica, 9.75),\n        brush: new PdfSolidBrush(new PdfColor(0, 0, 0)),\n        backgroundBrush: new PdfSolidBrush(new PdfColor(246, 246, 246))\n      };\n    }\n  }\n\n  getGridPdfFont(args) {\n    const fontFamily = 'fontFamily';\n    const fontSize = 'fontSize';\n    const fontStyle = 'fontStyle';\n    const isTrueType = 'isTrueType';\n    let style = 0;\n\n    if (args.header && args.header.font) {\n      const headerFont = args.header.font[fontFamily];\n      const headerSize = args.header.font[fontSize];\n      const headerStyle = args.header.font[fontStyle];\n      style = isNullOrUndefined(PdfFontStyle[headerStyle]) ? 0 : PdfFontStyle[headerStyle];\n\n      if (args.header.font[isTrueType]) {\n        args.header.font = new PdfTrueTypeFont(headerFont, headerSize, style);\n      } else {\n        const fontFamily = !isNullOrUndefined(headerFont) ? this.getFontFamily(headerFont) : PdfFontFamily.Helvetica;\n        args.header.font = new PdfStandardFont(fontFamily, headerSize, style);\n      }\n    }\n\n    if (args.caption && args.caption.font) {\n      const captionFont = args.caption.font[fontFamily];\n      const captionSize = args.caption.font[fontSize];\n      const captionStyle = args.caption.font[fontStyle];\n      style = isNullOrUndefined(PdfFontStyle[captionStyle]) ? 0 : PdfFontStyle[captionStyle];\n\n      if (args.caption.font[isTrueType]) {\n        args.caption.font = new PdfTrueTypeFont(captionFont, captionSize, style);\n      } else {\n        const fontFamily = !isNullOrUndefined(captionFont) ? this.getFontFamily(captionFont) : PdfFontFamily.Helvetica;\n        args.caption.font = new PdfStandardFont(fontFamily, captionSize, style);\n      }\n    }\n\n    if (args.record && args.record.font) {\n      const recordFont = args.record.font[fontFamily];\n      const recordSize = args.record.font[fontSize];\n      const recordStyle = args.record.font[fontStyle];\n      style = isNullOrUndefined(PdfFontStyle[recordStyle]) ? 0 : PdfFontStyle[recordStyle];\n\n      if (args.record.font[isTrueType]) {\n        args.record.font = new PdfTrueTypeFont(recordFont, recordSize, style);\n      } else {\n        const fontFamily = !isNullOrUndefined(recordFont) ? this.getFontFamily(recordFont) : PdfFontFamily.Helvetica;\n        args.record.font = new PdfStandardFont(fontFamily, recordSize, style);\n      }\n    }\n  }\n\n  getHeaderThemeStyle() {\n    const border = new PdfBorders();\n\n    if (!isNullOrUndefined(this.gridTheme) && !isNullOrUndefined(this.gridTheme.header)) {\n      const fontFamily = !isNullOrUndefined(this.gridTheme.header.fontName) ? this.getFontFamily(this.gridTheme.header.fontName) : PdfFontFamily.Helvetica;\n      const fontStyle = this.getFontStyle(this.gridTheme.header);\n      const fontSize = !isNullOrUndefined(this.gridTheme.header.fontSize) ? this.gridTheme.header.fontSize : 10.5;\n      let pdfColor = new PdfColor();\n\n      if (!isNullOrUndefined(this.gridTheme.header.fontColor)) {\n        const penBrushColor = this.hexToRgb(this.gridTheme.header.fontColor);\n        pdfColor = new PdfColor(penBrushColor.r, penBrushColor.g, penBrushColor.b);\n      }\n\n      let font = new PdfStandardFont(fontFamily, fontSize, fontStyle);\n\n      if (!isNullOrUndefined(this.gridTheme.header.font)) {\n        font = this.gridTheme.header.font;\n      }\n\n      return {\n        border: this.getBorderStyle(this.gridTheme.header.border),\n        font: font,\n        brush: new PdfSolidBrush(pdfColor)\n      };\n    } else {\n      //Material theme\n      border.all = new PdfPen(new PdfColor(234, 234, 234));\n      return {\n        border: border,\n        font: new PdfStandardFont(PdfFontFamily.Helvetica, 10.5),\n        brush: new PdfSolidBrush(new PdfColor(102, 102, 102))\n      };\n    }\n  } // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n\n  processGroupedRecords(pdfGrid, dataSource, gridColumns, gObj, border, level, font, brush, backgroundBrush, returnType, pdfExportProperties, helper, index) {\n    const groupIndex = level;\n\n    for (const dataSourceItems of dataSource) {\n      const row = pdfGrid.rows.addRow();\n      const col = gObj.getColumnByField(dataSourceItems.field); // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n      const args = {\n        value: dataSourceItems.key,\n        column: col,\n        style: undefined,\n        isForeignKey: col.isForeignColumn()\n      };\n      const value = this.parent.getColumnByField(dataSourceItems.field).headerText + ': ' + (!col.enableGroupByFormat ? this.exportValueFormatter.formatCellValue(args) : dataSourceItems.key) + ' - ' + dataSourceItems.count + (dataSource.count > 1 ? ' items' : ' item');\n      const cArgs = {\n        captionText: value,\n        type: 'PDF',\n        data: dataSourceItems\n      };\n      this.parent.trigger(exportGroupCaption, cArgs, cArgs => {\n        row.cells.getCell(groupIndex).value = cArgs.captionText;\n        row.cells.getCell(groupIndex).style.stringFormat = new PdfStringFormat(PdfTextAlignment.Left);\n        row.style.setBorder(border);\n        row.style.setFont(font);\n        row.style.setTextBrush(brush);\n        row.style.setBackgroundBrush(backgroundBrush);\n        let sRows;\n        const captionSummaryModel = new CaptionSummaryModelGenerator(gObj);\n\n        if (!isNullOrUndefined(dataSourceItems.items.records)) {\n          sRows = captionSummaryModel.generateRows(dataSourceItems.items.records, dataSourceItems);\n        } else {\n          sRows = captionSummaryModel.generateRows(dataSourceItems.items, dataSourceItems);\n        }\n\n        if (!isNullOrUndefined(sRows) && sRows.length === 0) {\n          row.cells.getCell(groupIndex + 1).columnSpan = pdfGrid.columns.count - (groupIndex + 1);\n        }\n\n        if (!isNullOrUndefined(dataSource.childLevels) && dataSource.childLevels > 0) {\n          this.processAggregates(sRows, pdfGrid, border, font, brush, backgroundBrush, true, row, groupIndex);\n          this.processGroupedRecords(pdfGrid, dataSourceItems.items, gridColumns, gObj, border, groupIndex + 1, font, brush, backgroundBrush, returnType, pdfExportProperties, helper, index);\n          const groupSummaryModel = new GroupSummaryModelGenerator(gObj);\n          sRows = groupSummaryModel.generateRows(dataSourceItems.items.records, dataSourceItems);\n          this.processAggregates(sRows, pdfGrid, border, font, brush, backgroundBrush, false);\n        } else {\n          this.processAggregates(sRows, pdfGrid, border, font, brush, backgroundBrush, true, row, groupIndex);\n          index = this.processRecord(border, gridColumns, gObj, dataSourceItems.items, pdfGrid, groupIndex + 1, pdfExportProperties, helper, index);\n          const groupSummaryModel = new GroupSummaryModelGenerator(gObj);\n          sRows = groupSummaryModel.generateRows(dataSourceItems.items, dataSourceItems);\n          const isGroupedFooter = true;\n          this.processAggregates(sRows, pdfGrid, border, font, brush, backgroundBrush, false, null, null, isGroupedFooter);\n        }\n      });\n    }\n  }\n\n  processGridHeaders(childLevels, pdfGrid, rows, gridColumn, border, headerFont, headerBrush, grid, allowHorizontalOverflow, eCols) {\n    let columnCount = gridColumn.length + childLevels;\n    const depth = measureColumnDepth(eCols);\n    const cols = eCols;\n    let index = 0;\n\n    if (this.parent.groupSettings.columns.length) {\n      index = this.parent.groupSettings.columns.length - 1;\n      columnCount = columnCount - 1;\n    }\n\n    pdfGrid.columns.add(columnCount);\n    pdfGrid.headers.add(rows.length);\n\n    const applyTextAndSpan = (rowIdx, colIdx, col, rowSpan, colSpan) => {\n      const gridHeader = pdfGrid.headers.getHeader(rowIdx);\n      const pdfCell = gridHeader.cells.getCell(colIdx);\n      const cell = rows[rowIdx].cells[colIdx];\n\n      if (!isNullOrUndefined(col.headerTextAlign)) {\n        pdfCell.style.stringFormat = this.getHorizontalAlignment(col.headerTextAlign);\n      }\n\n      if (rowSpan > 0) {\n        pdfCell.rowSpan = rowSpan;\n        pdfCell.style.stringFormat = this.getVerticalAlignment('Bottom', pdfCell.style.stringFormat, col.textAlign);\n      }\n\n      if (colSpan > 0) {\n        pdfCell.columnSpan = colSpan;\n      }\n\n      gridHeader.style.setBorder(border);\n      gridHeader.style.setFont(headerFont);\n      gridHeader.style.setTextBrush(headerBrush);\n      pdfCell.value = col.headerText;\n\n      if (!isNullOrUndefined(cell) && (cell.cellType === CellType.HeaderIndent || cell.cellType === CellType.DetailHeader)) {\n        pdfCell.value = '';\n        pdfCell.width = 20;\n      }\n\n      const args = {\n        cell: pdfCell,\n        gridCell: cell,\n        style: pdfCell.style\n      };\n      this.parent.trigger(pdfHeaderQueryCellInfo, args);\n      const evtArgs = args;\n\n      if (!isNullOrUndefined(evtArgs.image)) {\n        pdfCell.value = new PdfBitmap(evtArgs.image.base64);\n      }\n\n      if (!isNullOrUndefined(evtArgs.hyperLink)) {\n        pdfCell.value = this.setHyperLink(evtArgs);\n      }\n    };\n\n    const recuHeader = (cols, depth, spanCnt, colIndex, rowIndex, isRoot) => {\n      let cidx = 0;\n\n      for (let i = 0; i < cols.length; i++) {\n        if (isRoot) {\n          cidx = cidx + spanCnt + (i === 0 ? 0 : -1);\n          colIndex = cidx;\n          spanCnt = 0;\n        }\n\n        if (!isRoot && !cols[i].visible) {\n          colIndex = colIndex - 1;\n        }\n\n        if (cols[i].columns && cols[i].columns.length) {\n          const newSpanCnt = recuHeader(cols[i].columns, depth - 1, 0, i + colIndex, rowIndex + 1, false);\n          applyTextAndSpan(rowIndex, i + colIndex + index, cols[i], 0, newSpanCnt);\n          spanCnt = spanCnt + newSpanCnt;\n          colIndex = colIndex + newSpanCnt - 1;\n        } else if (cols[i].visible || this.hideColumnInclude) {\n          spanCnt++;\n          applyTextAndSpan(rowIndex, i + colIndex + index, cols[i], depth, 0);\n        }\n      }\n\n      return spanCnt;\n    };\n\n    recuHeader(cols, depth, 0, 0, 0, true);\n\n    if (pdfGrid.columns.count >= 6 && allowHorizontalOverflow) {\n      pdfGrid.style.allowHorizontalOverflow = true;\n    }\n\n    return pdfGrid;\n  }\n\n  processExportProperties(pdfExportProperties, dataSource) {\n    if (!isNullOrUndefined(pdfExportProperties)) {\n      if (!isNullOrUndefined(pdfExportProperties.theme)) {\n        this.gridTheme = pdfExportProperties.theme;\n      }\n\n      const clientSize = this.pdfPageSettings.size;\n      this.drawHeader(pdfExportProperties);\n\n      if (!isNullOrUndefined(pdfExportProperties.footer)) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const footer = pdfExportProperties.footer;\n        const position = new PointF(0, clientSize.width - 80 - footer.fromBottom * 0.75);\n        const size = new SizeF(clientSize.width - 80, footer.height * 0.75);\n        const bounds = new RectangleF(position, size);\n        this.pdfDocument.template.bottom = this.drawPageTemplate(new PdfPageTemplateElement(bounds), footer);\n      }\n\n      if (!isNullOrUndefined(pdfExportProperties.includeHiddenColumn) && !this.isGrouping) {\n        this.hideColumnInclude = pdfExportProperties.includeHiddenColumn;\n      }\n\n      if (!isNullOrUndefined(pdfExportProperties.dataSource)) {\n        if (!(pdfExportProperties.dataSource instanceof DataManager)) {\n          dataSource = pdfExportProperties.dataSource;\n        }\n\n        this.customDataSource = true;\n        this.currentViewData = false;\n      } else if (!isNullOrUndefined(pdfExportProperties.exportType)) {\n        if (pdfExportProperties.exportType === 'CurrentPage') {\n          dataSource = this.parent.currentViewData;\n          this.currentViewData = true;\n          this.customDataSource = false;\n        } else {\n          this.currentViewData = false;\n          this.customDataSource = false;\n        }\n      } else {\n        this.currentViewData = false;\n        this.customDataSource = false;\n      }\n    } else {\n      this.currentViewData = false;\n      this.customDataSource = false;\n    }\n\n    return dataSource;\n  }\n\n  drawHeader(pdfExportProperties) {\n    const clientSize = this.pdfPageSettings.size;\n\n    if (!isNullOrUndefined(pdfExportProperties) && !isNullOrUndefined(pdfExportProperties.header)) {\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      const header = pdfExportProperties.header;\n      const position = new PointF(0, header.fromTop);\n      const size = new SizeF(clientSize.width - 80, header.height * 0.75);\n      const bounds = new RectangleF(position, size);\n\n      if (!this.headerOnPages.length) {\n        this.pdfDocument.template.top = this.drawPageTemplate(new PdfPageTemplateElement(bounds), header);\n      } else {\n        const headerTemplate = this.drawPageTemplate(new PdfPageTemplateElement(bounds), header);\n        this.headerOnPages.filter(index => {\n          if (index - 1 >= 0 && index - 1 < this.pdfDocument.pages.count - 1) {\n            this.pdfDocument.pages.getPageByIndex(index - 1).graphics.drawPdfTemplate(headerTemplate.template, new PointF(0, 0));\n          }\n        });\n      }\n    }\n  }\n\n  drawPageTemplate(template, element) {\n    for (const content of element.contents) {\n      this.processContentValidation(content);\n\n      switch (content.type) {\n        case 'Text':\n          if (content.value === '' || content.value === undefined || content.value === null || typeof content.value !== 'string') {\n            throw new Error('please enter the valid input value in text content...');\n          }\n\n          this.drawText(template, content);\n          break;\n\n        case 'PageNumber':\n          this.drawPageNumber(template, content);\n          break;\n\n        case 'Image':\n          if (content.src === undefined || content.src === null || content.src === '') {\n            throw new Error('please enter the valid base64 string in image content...');\n          }\n\n          this.drawImage(template, content);\n          break;\n\n        case 'Line':\n          this.drawLine(template, content);\n          break;\n\n        default:\n          throw new Error('Please set valid content type...');\n      }\n    }\n\n    return template;\n  }\n\n  processContentValidation(content) {\n    if (content.type === undefined || content.type === null) {\n      throw new Error('please set valid content type...');\n    } else {\n      if (content.type === 'Line') {\n        if (content.points === undefined || content.points === null) {\n          throw new Error('please enter valid points in ' + content.type + ' content...');\n        } else {\n          if (content.points.x1 === undefined || content.points.x1 === null || typeof content.points.x1 !== 'number') {\n            throw new Error('please enter valid x1 co-ordinate in ' + content.type + ' points...');\n          }\n\n          if (content.points.y1 === undefined || content.points.y1 === null || typeof content.points.y1 !== 'number') {\n            throw new Error('please enter valid y1 co-ordinate in ' + content.type + ' points...');\n          }\n\n          if (content.points.x2 === undefined || content.points.x2 === null || typeof content.points.x2 !== 'number') {\n            throw new Error('please enter valid x2 co-ordinate in ' + content.type + ' points...');\n          }\n\n          if (content.points.y2 === undefined || content.points.y2 === null || typeof content.points.y2 !== 'number') {\n            throw new Error('please enter valid y2 co-ordinate in ' + content.type + ' points...');\n          }\n        }\n      } else {\n        if (content.position === undefined || content.position === null) {\n          throw new Error('please enter valid position in ' + content.type + ' content...');\n        } else {\n          if (content.position.x === undefined || content.position.x === null || typeof content.position.x !== 'number') {\n            throw new Error('please enter valid x co-ordinate in ' + content.type + ' position...');\n          }\n\n          if (content.position.y === undefined || content.position.y === null || typeof content.position.y !== 'number') {\n            throw new Error('please enter valid y co-ordinate in ' + content.type + ' position...');\n          }\n        }\n      }\n    }\n  } // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n\n  drawText(pageTemplate, content) {\n    const font = this.getFont(content);\n    let brush = this.getBrushFromContent(content);\n    let pen = null;\n\n    if (!isNullOrUndefined(content.style.textPenColor)) {\n      const penColor = this.hexToRgb(content.style.textPenColor);\n      pen = new PdfPen(new PdfColor(penColor.r, penColor.g, penColor.b));\n    }\n\n    if (brush == null && pen == null) {\n      brush = new PdfSolidBrush(new PdfColor(0, 0, 0));\n    }\n\n    const value = content.value.toString();\n    const x = content.position.x * 0.75;\n    const y = content.position.y * 0.75;\n    const format = new PdfStringFormat();\n    const result = this.setContentFormat(content, format);\n\n    if (result !== null && !isNullOrUndefined(result.format) && !isNullOrUndefined(result.size)) {\n      pageTemplate.graphics.drawString(value, font, pen, brush, x, y, result.size.width, result.size.height, result.format);\n    } else {\n      pageTemplate.graphics.drawString(value, font, pen, brush, x, y, format);\n    }\n  } // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n\n  drawPageNumber(documentHeader, content) {\n    const font = this.getFont(content);\n    let brush = null;\n\n    if (!isNullOrUndefined(content.style.textBrushColor)) {\n      const brushColor = this.hexToRgb(content.style.textBrushColor);\n      brush = new PdfSolidBrush(new PdfColor(brushColor.r, brushColor.g, brushColor.b));\n    } else {\n      brush = new PdfSolidBrush(new PdfColor(0, 0, 0));\n    }\n\n    const pageNumber = new PdfPageNumberField(font, brush);\n    pageNumber.numberStyle = this.getPageNumberStyle(content.pageNumberType);\n    let compositeField;\n    let format;\n\n    if (!isNullOrUndefined(content.format)) {\n      const total = '$total';\n      const current = '$current';\n\n      if (content.format.indexOf(total) !== -1 && content.format.indexOf(current) !== -1) {\n        const pageCount = new PdfPageCountField(font);\n        pageCount.numberStyle = this.getPageNumberStyle(content.pageNumberType);\n\n        if (content.format.indexOf(total) > content.format.indexOf(current)) {\n          format = content.format.replace(current, '0');\n          format = format.replace(total, '1');\n        } else {\n          format = content.format.replace(current, '1');\n          format = format.replace(total, '0');\n        }\n\n        compositeField = new PdfCompositeField(font, brush, format, pageNumber, pageCount);\n      } else if (content.format.indexOf(current) !== -1 && content.format.indexOf(total) === -1) {\n        format = content.format.replace(current, '0');\n        compositeField = new PdfCompositeField(font, brush, format, pageNumber);\n      } else {\n        const pageCount = new PdfPageCountField(font);\n        format = content.format.replace(total, '0');\n        compositeField = new PdfCompositeField(font, brush, format, pageCount);\n      }\n    } else {\n      format = '{0}';\n      compositeField = new PdfCompositeField(font, brush, format, pageNumber);\n    }\n\n    const x = content.position.x * 0.75;\n    const y = content.position.y * 0.75;\n    const result = this.setContentFormat(content, compositeField.stringFormat);\n\n    if (result !== null && !isNullOrUndefined(result.format) && !isNullOrUndefined(result.size)) {\n      compositeField.stringFormat = result.format;\n      compositeField.bounds = new RectangleF(x, y, result.size.width, result.size.height);\n    }\n\n    compositeField.draw(documentHeader.graphics, x, y);\n  } // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n\n  drawImage(documentHeader, content) {\n    const x = content.position.x * 0.75;\n    const y = content.position.y * 0.75;\n    const width = !isNullOrUndefined(content.size) ? content.size.width * 0.75 : undefined;\n    const height = !isNullOrUndefined(content.size) ? content.size.height * 0.75 : undefined;\n    const image = new PdfBitmap(content.src);\n\n    if (!isNullOrUndefined(width)) {\n      documentHeader.graphics.drawImage(image, x, y, width, height);\n    } else {\n      documentHeader.graphics.drawImage(image, x, y);\n    }\n  } // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n\n  drawLine(documentHeader, content) {\n    const x1 = content.points.x1 * 0.75;\n    const y1 = content.points.y1 * 0.75;\n    const x2 = content.points.x2 * 0.75;\n    const y2 = content.points.y2 * 0.75;\n    const pen = this.getPenFromContent(content);\n\n    if (!isNullOrUndefined(content.style) && content.style !== null) {\n      if (!isNullOrUndefined(content.style.penSize) && content.style.penSize !== null && typeof content.style.penSize === 'number') {\n        pen.width = content.style.penSize * 0.75;\n      }\n\n      pen.dashStyle = this.getDashStyle(content.style.dashStyle);\n    }\n\n    documentHeader.graphics.drawLine(pen, x1, y1, x2, y2);\n  }\n\n  processAggregates(sRows, pdfGrid, border, font, brush, backgroundBrush, isCaption, captionRow, groupIndex, isGroupedFooter, isAggregate) {\n    for (const row of sRows) {\n      let leastCaptionSummaryIndex = -1;\n      let index = 0;\n      let isEmpty = true; // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n      const value = [];\n      const aggIdx = isAggregate ? 0 : 1;\n\n      for (let i = 0; i < pdfGrid.columns.count + aggIdx; i++) {\n        let cell = row.cells[index];\n\n        if (cell.cellType === CellType.DetailFooterIntent) {\n          i--;\n          index++;\n          continue;\n        }\n\n        if (!this.hideColumnInclude) {\n          while (cell.visible === undefined) {\n            if (cell.cellType === CellType.DetailFooterIntent) {\n              continue;\n            }\n\n            if (!isNullOrUndefined(captionRow)) {\n              if (!isNullOrUndefined(captionRow.cells.getCell(i).value)) {\n                const args = {\n                  row: row,\n                  type: 'GroupCaption',\n                  style: captionRow.cells\n                };\n                this.parent.trigger(pdfAggregateQueryCellInfo, args);\n                value.push(captionRow.cells.getCell(i).value);\n                isEmpty = false;\n\n                if (!isCaption) {\n                  i += 1;\n                }\n              } else {\n                value.push('');\n              }\n            } else {\n              value.push('');\n            }\n\n            i += 1;\n            index = index + 1;\n            cell = row.cells[index];\n          }\n\n          while (!isNullOrUndefined(cell.visible) && !cell.visible) {\n            index = index + 1;\n            cell = row.cells[index];\n          }\n        }\n\n        if (cell.isDataCell) {\n          let templateFn = {};\n\n          if (!isNullOrUndefined(cell.column.footerTemplate) || !isNullOrUndefined(cell.column.groupCaptionTemplate) || !isNullOrUndefined(cell.column.groupFooterTemplate)) {\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            const result = this.getTemplateFunction(templateFn, i, leastCaptionSummaryIndex, cell);\n            templateFn = result.templateFunction;\n            leastCaptionSummaryIndex = result.leastCaptionSummaryIndex;\n            let txt;\n            const data = row.data[cell.column.field ? cell.column.field : cell.column.columnName];\n\n            if (this.parent.isReact || this.parent.isVue) {\n              txt = templateFn[getEnumValue(CellType, cell.cellType)](data, this.parent);\n\n              if (this.parent.isReact) {\n                this.parent.renderTemplates();\n              }\n            } else {\n              txt = templateFn[getEnumValue(CellType, cell.cellType)](data);\n            }\n\n            value.push(txt[0].textContent);\n            isEmpty = false;\n          } else {\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            const result = this.getSummaryWithoutTemplate(row.data[cell.column.field]);\n\n            if (!isNullOrUndefined(result)) {\n              value.push(result);\n            }\n          }\n        } else {\n          value.push('');\n        }\n\n        if (isEmpty && value[i] !== '' && !isNullOrUndefined(value[i]) && value[i] !== null) {\n          isEmpty = false;\n        }\n\n        index += 1;\n      }\n\n      if (!isAggregate) {\n        if (!isCaption) {\n          value.splice(0, 1);\n        } else {\n          for (let i = this.parent.groupSettings.columns.length; i < value.length - 1; i++) {\n            value[i] = value[i + 1];\n            value[i + 1] = value[i + 2] ? value[i + 2] : '';\n          }\n        }\n      }\n\n      if (!isEmpty) {\n        if (!isCaption) {\n          const gridRow = pdfGrid.rows.addRow();\n          gridRow.style.setBorder(border);\n          gridRow.style.setFont(font);\n          gridRow.style.setTextBrush(brush);\n          gridRow.style.setBackgroundBrush(backgroundBrush);\n          const args = {\n            row: row,\n            type: isGroupedFooter ? 'GroupFooter' : 'Footer',\n            style: gridRow.cells\n          };\n          this.parent.trigger(pdfAggregateQueryCellInfo, args);\n\n          for (let i = 0; i < pdfGrid.columns.count; i++) {\n            gridRow.cells.getCell(i).value = value[i].toString();\n          }\n        } else {\n          for (let i = 0; i < pdfGrid.columns.count; i++) {\n            captionRow.cells.getCell(i).value = value[i].toString();\n\n            if (i === groupIndex && leastCaptionSummaryIndex !== -1 && leastCaptionSummaryIndex !== 1) {\n              captionRow.cells.getCell(i).columnSpan = leastCaptionSummaryIndex - 1 - groupIndex;\n            } else if (i === groupIndex && leastCaptionSummaryIndex === -1) {\n              captionRow.cells.getCell(i).columnSpan = pdfGrid.columns.count - groupIndex;\n            }\n          }\n        }\n      }\n    }\n  } // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n\n  getTemplateFunction(templateFn, index, leastCaptionSummaryIndex, cell) {\n    if (!isNullOrUndefined(cell.column.footerTemplate) && cell.cellType === CellType.Summary) {\n      templateFn[getEnumValue(CellType, CellType.Summary)] = compile(cell.column.footerTemplate);\n    } else if (!isNullOrUndefined(cell.column.groupCaptionTemplate)) {\n      if (leastCaptionSummaryIndex === -1) {\n        leastCaptionSummaryIndex = index;\n      }\n\n      templateFn[getEnumValue(CellType, CellType.CaptionSummary)] = compile(cell.column.groupCaptionTemplate);\n    } else {\n      templateFn[getEnumValue(CellType, CellType.GroupSummary)] = compile(cell.column.groupFooterTemplate);\n    }\n\n    return {\n      templateFunction: templateFn,\n      leastCaptionSummaryIndex: leastCaptionSummaryIndex\n    };\n  } // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n\n  getSummaryWithoutTemplate(data) {\n    if (!isNullOrUndefined(data.Sum)) {\n      return data.Sum;\n    } else if (!isNullOrUndefined(data.Average)) {\n      return data.Average;\n    } else if (!isNullOrUndefined(data.Max)) {\n      return data.Max;\n    } else if (!isNullOrUndefined(data.Min)) {\n      return data.Min;\n    } else if (!isNullOrUndefined(data.Count)) {\n      return data.Count;\n    } else if (!isNullOrUndefined(data.TrueCount)) {\n      return data.TrueCount;\n    } else if (!isNullOrUndefined(data.FalseCount)) {\n      return data.FalseCount;\n    } else if (!isNullOrUndefined(data.Custom)) {\n      return data.Custom;\n    }\n  }\n  /**\n   * Set alignment, width and type of the values of the column\n   *\n   * @param {Column[]} gridColumns - specifies the grid column\n   * @param {PdfGrid} pdfGrid - specifies the pdfGrid\n   * @param {ExportHelper} helper - specifies the helper\n   * @param {IGrid} gObj - specifies the IGrid\n   * @param {boolean} allowHorizontalOverflow - specifies the allowHorizontalOverflow\n   * @returns {void}\n   */\n\n\n  setColumnProperties(gridColumns, pdfGrid, helper, gObj, allowHorizontalOverflow) {\n    const startIndex = gObj.groupSettings.columns.length ? gObj.groupSettings.columns.length - 1 : 0;\n\n    for (let i = 0; i < startIndex; i++) {\n      pdfGrid.columns.getColumn(i).width = 20;\n    }\n\n    for (let i = 0; i < gridColumns.length; i++) {\n      if (!isNullOrUndefined(gridColumns[i].textAlign)) {\n        pdfGrid.columns.getColumn(i + startIndex).format = this.getHorizontalAlignment(gridColumns[i].textAlign);\n      } // Need to add width consideration with % value\n\n\n      if (pdfGrid.style.allowHorizontalOverflow && !isNullOrUndefined(gridColumns[i].width) && allowHorizontalOverflow) {\n        pdfGrid.columns.getColumn(i + startIndex).width = typeof gridColumns[i].width === 'number' ? gridColumns[i].width * 0.75 : helper.getConvertedWidth(gridColumns[i].width) * 0.75;\n      }\n    }\n  }\n  /**\n   * set default style properties of each rows in exporting grid\n   *\n   * @param {PdfGridRow} row - specifies the PdfGridRow\n   * @param {PdfBorders} border - specifies the PdfBorders\n   * @returns {PdfGrid} returns the pdfgrid\n   * @private\n   */\n\n\n  setRecordThemeStyle(row, border) {\n    if (!isNullOrUndefined(this.gridTheme) && !isNullOrUndefined(this.gridTheme.record)) {\n      const fontFamily = !isNullOrUndefined(this.gridTheme.record.fontName) ? this.getFontFamily(this.gridTheme.record.fontName) : PdfFontFamily.Helvetica;\n      const fontSize = !isNullOrUndefined(this.gridTheme.record.fontSize) ? this.gridTheme.record.fontSize : 9.75;\n      const fontStyle = this.getFontStyle(this.gridTheme.record);\n      let font = new PdfStandardFont(fontFamily, fontSize, fontStyle);\n\n      if (!isNullOrUndefined(this.gridTheme.record.font)) {\n        font = this.gridTheme.record.font;\n      }\n\n      row.style.setFont(font);\n      let pdfColor = new PdfColor();\n\n      if (!isNullOrUndefined(this.gridTheme.record.fontColor)) {\n        const penBrushColor = this.hexToRgb(this.gridTheme.record.fontColor);\n        pdfColor = new PdfColor(penBrushColor.r, penBrushColor.g, penBrushColor.b);\n      }\n\n      row.style.setTextBrush(new PdfSolidBrush(pdfColor));\n    } else {\n      row.style.setTextBrush(new PdfSolidBrush(new PdfColor(0, 0, 0)));\n    }\n\n    const borderRecord = this.gridTheme && this.gridTheme.record && this.gridTheme.record.border ? this.getBorderStyle(this.gridTheme.record.border) : border;\n    row.style.setBorder(borderRecord);\n    return row;\n  }\n  /**\n   * generate the formatted cell values\n   *\n   * @param {PdfBorders} border - specifies the border\n   * @param {Column[]} columns - specifies the columns\n   * @param {IGrid} gObj - specifies the IGrid\n   * @param {Object[]} dataSource - specifies the datasource\n   * @param {PdfGrid} pdfGrid - specifies the pdfGrid\n   * @param {number} startIndex - specifies the startindex\n   * @param {PdfExportProperties} pdfExportProperties - specifies the pdfExportProperties\n   * @param {ExportHelper} helper - specifies the helper\n   * @param {number} rowIndex - specifies the rowIndex\n   * @returns {number} returns the number of records\n   * @private\n   */\n\n\n  processRecord(border, columns, gObj, dataSource, pdfGrid, startIndex, pdfExportProperties, helper, rowIndex) {\n    const rows = helper.getGridRowModel(columns, dataSource, gObj, rowIndex);\n\n    for (const row of rows) {\n      rowIndex++; // create a new row and set default style properties\n\n      const gridRow = this.setRecordThemeStyle(pdfGrid.rows.addRow(), border);\n      const cellLength = row.cells.length;\n\n      for (let j = 0; j < cellLength; j++) {\n        const gridCell = row.cells[j];\n\n        if (gridCell.cellType !== CellType.Data) {\n          continue;\n        }\n\n        const column = gridCell.column;\n        const field = column.field;\n        const cellValue = !isNullOrUndefined(field) ? column.valueAccessor(field, row.data, column) : '';\n        let value = !isNullOrUndefined(cellValue) ? cellValue : '';\n        let foreignKeyData$$1;\n\n        if (column.isForeignColumn && column.isForeignColumn()) {\n          foreignKeyData$$1 = helper.getFData(value, column);\n          value = getValue(column.foreignKeyValue, foreignKeyData$$1);\n        }\n\n        const data = row.data;\n        const cell = gridRow.cells.getCell(j);\n        const args = {\n          data: data,\n          value: value,\n          column: column,\n          style: undefined,\n          colSpan: 1,\n          cell: cell\n        };\n        args.value = args.column.type === 'boolean' && typeof args.value === 'string' ? args.value : this.exportValueFormatter.formatCellValue(args);\n        this.parent.trigger(pdfQueryCellInfo, args);\n\n        if (!isNullOrUndefined(args.image)) {\n          args.value = new PdfBitmap(args.image.base64);\n          args.value.height = args.image.height || args.value.height;\n          args.value.width = args.image.width || args.value.width;\n        }\n\n        cell.value = args.value;\n\n        if (!isNullOrUndefined(args.hyperLink)) {\n          cell.value = this.setHyperLink(args);\n        }\n\n        if (!isNullOrUndefined(args.style)) {\n          this.processCellStyle(cell, args);\n        }\n\n        if (args.colSpan > 1) {\n          if (j + 1 + args.colSpan > gridRow.cells.count) {\n            args.colSpan = gridRow.cells.count - (j + 1);\n          }\n\n          cell.columnSpan = args.colSpan;\n\n          for (let i = 1; i < cell.columnSpan; i++) {\n            const spanCell = gridRow.cells.getCell(j + i);\n            spanCell.value = '';\n          }\n\n          j += args.colSpan - 1;\n        }\n      }\n\n      if (row.isExpand) {\n        const gridRow = this.setRecordThemeStyle(pdfGrid.rows.addRow(), border);\n        const cell = gridRow.cells.getCell(startIndex);\n        cell.columnSpan = gridRow.cells.count - startIndex;\n        cell.style.cellPadding = new PdfPaddings(10, 10, 10, 10);\n        gObj.isPrinting = true;\n        const exportType = !isNullOrUndefined(pdfExportProperties) && pdfExportProperties.exportType ? pdfExportProperties.exportType : 'AllPages';\n        const returnValue = this.helper.createChildGrid(gObj, row, exportType, this.gridPool);\n        const childGridObj = returnValue.childGrid;\n        const element = returnValue.element;\n        childGridObj.actionFailure = helper.failureHandler(this.gridPool, childGridObj, this.globalResolve);\n        const args = {\n          childGrid: childGridObj,\n          row,\n          cell,\n          exportProperties: pdfExportProperties\n        };\n        this.parent.trigger(exportDetailDataBound, args);\n        childGridObj.beforeDataBound = this.childGridCell(cell, childGridObj, pdfExportProperties);\n        childGridObj.appendTo(element);\n      }\n\n      this.parent.notify(exportRowDataBound, {\n        type: 'pdf',\n        rowObj: row\n      });\n    }\n\n    return rowIndex;\n  }\n\n  setHyperLink(args) {\n    // create the Text Web Link\n    const textLink = new PdfTextWebLink(); // set the hyperlink\n\n    textLink.url = args.hyperLink.target; // set the link text\n\n    textLink.text = args.hyperLink.displayText || args.hyperLink.target; // set the font\n\n    textLink.font = new PdfStandardFont(PdfFontFamily.Helvetica, 9.75); // set the brush and pen for the text color\n\n    textLink.brush = new PdfSolidBrush(new PdfColor(51, 102, 187));\n    return textLink;\n  }\n\n  childGridCell(cell, childGridObj, pdfExportProperties) {\n    return result => {\n      childGridObj.beforeDataBound = null;\n      result.cancel = true;\n      cell.value = this.processGridExport(childGridObj, result, pdfExportProperties);\n      childGridObj.destroy();\n      detach(childGridObj.element);\n      this.gridPool[childGridObj.id] = true;\n      this.helper.checkAndExport(this.gridPool, this.globalResolve);\n      return cell;\n    };\n  }\n\n  processCellStyle(cell, args) {\n    if (!isNullOrUndefined(args.style.backgroundColor)) {\n      const backColor = this.hexToRgb(args.style.backgroundColor);\n      cell.style.backgroundBrush = new PdfSolidBrush(new PdfColor(backColor.r, backColor.g, backColor.b));\n    }\n\n    if (!isNullOrUndefined(args.style.textAlignment)) {\n      cell.style.stringFormat = this.getHorizontalAlignment(args.style.textAlignment);\n    }\n\n    if (!isNullOrUndefined(args.style.cellPadding)) {\n      cell.style.cellPadding = args.style.cellPadding;\n    }\n\n    if (!isNullOrUndefined(args.style.verticalAlignment)) {\n      cell.style.stringFormat = this.getVerticalAlignment(args.style.verticalAlignment, cell.style.stringFormat);\n    }\n\n    if (!isNullOrUndefined(args.style.textBrushColor)) {\n      const textBrushColor = this.hexToRgb(args.style.textBrushColor);\n      cell.style.textBrush = new PdfSolidBrush(new PdfColor(textBrushColor.r, textBrushColor.g, textBrushColor.b));\n    }\n\n    if (!isNullOrUndefined(args.style.textPenColor)) {\n      const textPenColor = this.hexToRgb(args.style.textPenColor);\n      cell.style.textPen = new PdfPen(new PdfColor(textPenColor.r, textPenColor.g, textPenColor.b));\n    }\n\n    if (!isNullOrUndefined(args.style.fontFamily) || !isNullOrUndefined(args.style.fontSize) || !isNullOrUndefined(args.style.bold) || !isNullOrUndefined(args.style.italic) || !isNullOrUndefined(args.style.underline) || !isNullOrUndefined(args.style.strikeout)) {\n      cell.style.font = this.getFont(args);\n    }\n\n    if (!isNullOrUndefined(args.style.border)) {\n      const border = new PdfBorders();\n      const borderWidth = args.style.border.width; // set border width\n\n      const width = !isNullOrUndefined(borderWidth) && typeof borderWidth === 'number' ? borderWidth * 0.75 : undefined; // set border color\n\n      let color = new PdfColor(196, 196, 196);\n\n      if (!isNullOrUndefined(args.style.border.color)) {\n        const borderColor = this.hexToRgb(args.style.border.color);\n        color = new PdfColor(borderColor.r, borderColor.g, borderColor.b);\n      }\n\n      const pen = new PdfPen(color, width); // set border dashStyle 'Solid <default>, Dash, Dot, DashDot, DashDotDot'\n\n      if (!isNullOrUndefined(args.style.border.dashStyle)) {\n        pen.dashStyle = this.getDashStyle(args.style.border.dashStyle);\n      }\n\n      border.all = pen;\n      cell.style.borders = border;\n    }\n\n    if (!isNullOrUndefined(args.style.paragraphIndent)) {\n      cell.style.stringFormat = new PdfStringFormat();\n      cell.style.stringFormat.paragraphIndent = args.style.paragraphIndent;\n    }\n  }\n  /**\n   * set text alignment of each columns in exporting grid\n   *\n   * @param {string} textAlign - specifies the textAlign\n   * @param {PdfStringFormat} format - specifies the PdfStringFormat\n   * @returns {PdfStringFormat} returns the PdfStringFormat\n   * @private\n   */\n\n\n  getHorizontalAlignment(textAlign, format) {\n    if (format === undefined) {\n      format = new PdfStringFormat();\n    }\n\n    switch (textAlign) {\n      case 'Right':\n        format.alignment = PdfTextAlignment.Right;\n        break;\n\n      case 'Center':\n        format.alignment = PdfTextAlignment.Center;\n        break;\n\n      case 'Justify':\n        format.alignment = PdfTextAlignment.Justify;\n        break;\n\n      case 'Left':\n        format.alignment = PdfTextAlignment.Left;\n        break;\n    }\n\n    return format;\n  }\n  /**\n   * set vertical alignment of each columns in exporting grid\n   *\n   * @param {string} verticalAlign - specifies the verticalAlign\n   * @param {PdfStringFormat} format - specifies the PdfStringFormat\n   * @param {string} textAlign - specifies the text align\n   * @returns {PdfStringFormat} returns the PdfStringFormat\n   * @private\n   */\n\n\n  getVerticalAlignment(verticalAlign, format, textAlign) {\n    if (format === undefined) {\n      format = new PdfStringFormat();\n      format = this.getHorizontalAlignment(textAlign, format);\n    }\n\n    switch (verticalAlign) {\n      case 'Bottom':\n        format.lineAlignment = PdfVerticalAlignment.Bottom;\n        break;\n\n      case 'Middle':\n        format.lineAlignment = PdfVerticalAlignment.Middle;\n        break;\n\n      case 'Top':\n        format.lineAlignment = PdfVerticalAlignment.Top;\n        break;\n    }\n\n    return format;\n  }\n\n  getFontFamily(fontFamily) {\n    switch (fontFamily) {\n      case 'TimesRoman':\n        return 2;\n\n      case 'Courier':\n        return 1;\n\n      case 'Symbol':\n        return 3;\n\n      case 'ZapfDingbats':\n        return 4;\n\n      default:\n        return 0;\n    }\n  } // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n\n  getFont(content) {\n    if (content.font) {\n      return content.font;\n    }\n\n    const fontSize = !isNullOrUndefined(content.style.fontSize) ? content.style.fontSize * 0.75 : 9.75;\n    const fontFamily = !isNullOrUndefined(content.style.fontFamily) ? this.getFontFamily(content.style.fontFamily) : PdfFontFamily.TimesRoman;\n    let fontStyle = PdfFontStyle.Regular;\n\n    if (!isNullOrUndefined(content.style.bold) && content.style.bold) {\n      fontStyle |= PdfFontStyle.Bold;\n    }\n\n    if (!isNullOrUndefined(content.style.italic) && content.style.italic) {\n      fontStyle |= PdfFontStyle.Italic;\n    }\n\n    if (!isNullOrUndefined(content.style.underline) && content.style.underline) {\n      fontStyle |= PdfFontStyle.Underline;\n    }\n\n    if (!isNullOrUndefined(content.style.strikeout) && content.style.strikeout) {\n      fontStyle |= PdfFontStyle.Strikeout;\n    }\n\n    return new PdfStandardFont(fontFamily, fontSize, fontStyle);\n  }\n\n  getPageNumberStyle(pageNumberType) {\n    switch (pageNumberType) {\n      case 'LowerLatin':\n        return 2;\n\n      case 'LowerRoman':\n        return 3;\n\n      case 'UpperLatin':\n        return 4;\n\n      case 'UpperRoman':\n        return 5;\n\n      default:\n        return 1;\n    }\n  }\n\n  setContentFormat(content, format) {\n    if (!isNullOrUndefined(content.size)) {\n      const width = content.size.width * 0.75;\n      const height = content.size.height * 0.75;\n      format = new PdfStringFormat(PdfTextAlignment.Left, PdfVerticalAlignment.Middle);\n\n      if (!isNullOrUndefined(content.style.hAlign)) {\n        switch (content.style.hAlign) {\n          case 'Right':\n            format.alignment = PdfTextAlignment.Right;\n            break;\n\n          case 'Center':\n            format.alignment = PdfTextAlignment.Center;\n            break;\n\n          case 'Justify':\n            format.alignment = PdfTextAlignment.Justify;\n            break;\n\n          default:\n            format.alignment = PdfTextAlignment.Left;\n        }\n      }\n\n      if (!isNullOrUndefined(content.style.vAlign)) {\n        format = this.getVerticalAlignment(content.style.vAlign, format);\n      }\n\n      return {\n        format: format,\n        size: new SizeF(width, height)\n      };\n    }\n\n    return null;\n  }\n\n  getPageSize(pageSize) {\n    switch (pageSize) {\n      case 'Letter':\n        return new SizeF(612, 792);\n\n      case 'Note':\n        return new SizeF(540, 720);\n\n      case 'Legal':\n        return new SizeF(612, 1008);\n\n      case 'A0':\n        return new SizeF(2380, 3368);\n\n      case 'A1':\n        return new SizeF(1684, 2380);\n\n      case 'A2':\n        return new SizeF(1190, 1684);\n\n      case 'A3':\n        return new SizeF(842, 1190);\n\n      case 'A5':\n        return new SizeF(421, 595);\n\n      case 'A6':\n        return new SizeF(297, 421);\n\n      case 'A7':\n        return new SizeF(210, 297);\n\n      case 'A8':\n        return new SizeF(148, 210);\n\n      case 'A9':\n        return new SizeF(105, 148);\n      // case 'A10':\n      // return new SizeF(74, 105);\n\n      case 'B0':\n        return new SizeF(2836, 4008);\n\n      case 'B1':\n        return new SizeF(2004, 2836);\n\n      case 'B2':\n        return new SizeF(1418, 2004);\n\n      case 'B3':\n        return new SizeF(1002, 1418);\n\n      case 'B4':\n        return new SizeF(709, 1002);\n\n      case 'B5':\n        return new SizeF(501, 709);\n\n      case 'Archa':\n        return new SizeF(648, 864);\n\n      case 'Archb':\n        return new SizeF(864, 1296);\n\n      case 'Archc':\n        return new SizeF(1296, 1728);\n\n      case 'Archd':\n        return new SizeF(1728, 2592);\n\n      case 'Arche':\n        return new SizeF(2592, 3456);\n\n      case 'Flsa':\n        return new SizeF(612, 936);\n\n      case 'HalfLetter':\n        return new SizeF(396, 612);\n\n      case 'Letter11x17':\n        return new SizeF(792, 1224);\n\n      case 'Ledger':\n        return new SizeF(1224, 792);\n\n      default:\n        return new SizeF(595, 842);\n    }\n  }\n\n  getDashStyle(dashStyle) {\n    switch (dashStyle) {\n      case 'Dash':\n        return 1;\n\n      case 'Dot':\n        return 2;\n\n      case 'DashDot':\n        return 3;\n\n      case 'DashDotDot':\n        return 4;\n\n      default:\n        return 0;\n    }\n  }\n\n  getPenFromContent(content) {\n    let pen = new PdfPen(new PdfColor(0, 0, 0));\n\n    if (!isNullOrUndefined(content.style) && content.style !== null && !isNullOrUndefined(content.style.penColor)) {\n      const penColor = this.hexToRgb(content.style.penColor);\n      pen = new PdfPen(new PdfColor(penColor.r, penColor.g, penColor.b));\n    }\n\n    return pen;\n  }\n\n  getBrushFromContent(content) {\n    let brush = null;\n\n    if (!isNullOrUndefined(content.style.textBrushColor)) {\n      /* tslint:disable-next-line:max-line-length */\n      const brushColor = this.hexToRgb(content.style.textBrushColor);\n      brush = new PdfSolidBrush(new PdfColor(brushColor.r, brushColor.g, brushColor.b));\n    }\n\n    return brush;\n  }\n\n  hexToRgb(hex) {\n    if (hex === null || hex === '' || hex.length !== 7) {\n      throw new Error('please set valid hex value for color...');\n    }\n\n    hex = hex.substring(1);\n    const bigint = parseInt(hex, 16);\n    const r = bigint >> 16 & 255;\n    const g = bigint >> 8 & 255;\n    const b = bigint & 255;\n    return {\n      r: r,\n      g: g,\n      b: b\n    };\n  }\n\n  getFontStyle(theme) {\n    let fontStyle = PdfFontStyle.Regular;\n\n    if (!isNullOrUndefined(theme) && theme.bold) {\n      fontStyle |= PdfFontStyle.Bold;\n    }\n\n    if (!isNullOrUndefined(theme) && theme.italic) {\n      fontStyle |= PdfFontStyle.Italic;\n    }\n\n    if (!isNullOrUndefined(theme) && theme.underline) {\n      fontStyle |= PdfFontStyle.Underline;\n    }\n\n    if (!isNullOrUndefined(theme) && theme.strikeout) {\n      fontStyle |= PdfFontStyle.Strikeout;\n    }\n\n    return fontStyle;\n  }\n\n  getBorderStyle(border) {\n    const borders = new PdfBorders();\n\n    if (!isNullOrUndefined(border)) {\n      const borderWidth = border.width; // set border width\n\n      const width = !isNullOrUndefined(borderWidth) && typeof borderWidth === 'number' ? borderWidth * 0.75 : undefined; // set border color\n\n      let color = new PdfColor(196, 196, 196);\n\n      if (!isNullOrUndefined(border.color)) {\n        const borderColor = this.hexToRgb(border.color);\n        color = new PdfColor(borderColor.r, borderColor.g, borderColor.b);\n      }\n\n      const pen = new PdfPen(color, width); // set border dashStyle 'Solid <default>, Dash, Dot, DashDot, DashDotDot'\n\n      if (!isNullOrUndefined(border.dashStyle)) {\n        pen.dashStyle = this.getDashStyle(border.dashStyle);\n      }\n\n      borders.all = pen;\n    } else {\n      borders.all = new PdfPen(new PdfColor(234, 234, 234));\n    }\n\n    return borders;\n  }\n\n  destroy() {//destroy for exporting\n  }\n\n}\n/**\n * `CommandColumn` used to render command column in grid\n *\n * @hidden\n */\n\n\nclass CommandColumnRenderer extends CellRenderer {\n  constructor(parent, locator) {\n    super(parent, locator);\n    this.buttonElement = this.parent.createElement('button', {});\n    this.unbounDiv = this.parent.createElement('div', {\n      className: 'e-unboundcelldiv',\n      styles: 'display: inline-block'\n    });\n    this.childRefs = [];\n    this.element = this.parent.createElement('TD', {\n      className: 'e-rowcell e-unboundcell',\n      attrs: {\n        role: 'gridcell',\n        tabindex: '-1'\n      }\n    });\n    this.parent.on(destroy, this.destroyButtons, this);\n  }\n\n  destroyButtons() {\n    for (let i = 0; i < this.childRefs.length; i++) {\n      if (this.childRefs[i] && !this.childRefs[i].isDestroyed) {\n        this.childRefs[i].destroy();\n      }\n    }\n\n    this.parent.off(destroy, this.destroyButtons);\n  }\n  /**\n   * Function to render the cell content based on Column object.\n   *\n   * @param {cell<Column>} cell - specifies the cell\n   * @param {Object} data - specifies the data\n   * @param {Object} attributes - specifies the attributes\n   * @param {boolean} isVirtualEdit - specifies virtual scroll editing\n   * @returns {Element} returns the element\n   */\n\n\n  render(cell, data, attributes$$1, isVirtualEdit) {\n    let node = this.element.cloneNode();\n    const uid = 'uid';\n    node.appendChild(this.unbounDiv.cloneNode());\n    node.setAttribute('aria-label', 'is Command column column header ' + cell.column.headerText);\n\n    if (cell.column.commandsTemplate) {\n      if (this.parent.isReact && typeof cell.column.commandsTemplate !== 'string') {\n        const tempID = this.parent + 'commandsTemplate';\n        cell.column.getColumnTemplate()(data, this.parent, 'commandsTemplate', tempID, null, null, node.firstElementChild);\n        this.parent.renderTemplates();\n      } else {\n        appendChildren(node.firstElementChild, cell.column.getColumnTemplate()(data));\n      }\n    } else {\n      for (const command of cell.commands) {\n        node = this.renderButton(node, command, attributes$$1.index, command[uid]);\n      }\n    }\n\n    this.setAttributes(node, cell, attributes$$1);\n\n    if (!this.parent.enableVirtualization && this.parent.isEdit || isVirtualEdit) {\n      addClass([].slice.call(node.getElementsByClassName('e-edit-delete')), 'e-hide');\n      removeClass([].slice.call(node.getElementsByClassName('e-save-cancel')), 'e-hide');\n    } else {\n      addClass([].slice.call(node.getElementsByClassName('e-save-cancel')), 'e-hide');\n      removeClass([].slice.call(node.getElementsByClassName('e-edit-delete')), 'e-hide');\n    }\n\n    return node;\n  }\n\n  renderButton(node, buttonOption, index, uid) {\n    const button = this.buttonElement.cloneNode();\n    attributes(button, {\n      'id': this.parent.element.id + (buttonOption.type || '') + '_' + index + '_' + uid,\n      'type': 'button',\n      title: !isNullOrUndefined(buttonOption.title) ? buttonOption.title : buttonOption.buttonOption.content || this.localizer.getConstant(buttonOption.type) || buttonOption.type,\n      'data-uid': uid\n    });\n    button.onclick = buttonOption.buttonOption.click;\n    const buttonObj = new Button(buttonOption.buttonOption, button);\n    this.childRefs.push(buttonObj);\n    buttonObj.commandType = buttonOption.type;\n    node.firstElementChild.appendChild(buttonObj.element);\n\n    switch (buttonOption.type) {\n      case 'Edit':\n      case 'Delete':\n        addClass([button], ['e-edit-delete', 'e-' + buttonOption.type.toLowerCase() + 'button']);\n        break;\n\n      case 'Cancel':\n      case 'Save':\n        addClass([button], ['e-save-cancel', 'e-' + buttonOption.type.toLowerCase() + 'button']);\n        break;\n    }\n\n    return node;\n  }\n\n}\n/**\n * `CommandColumn` used to handle the command column actions.\n *\n * @hidden\n */\n\n\nclass CommandColumn {\n  constructor(parent, locator) {\n    this.parent = parent;\n    this.locator = locator;\n    this.initiateRender();\n    this.addEventListener();\n  }\n\n  initiateRender() {\n    const cellFac = this.locator.getService('cellRendererFactory');\n    cellFac.addCellRenderer(CellType.CommandColumn, new CommandColumnRenderer(this.parent, this.locator));\n  }\n\n  commandClickHandler(e) {\n    const gObj = this.parent;\n    const target = closest(e.target, 'button');\n\n    if (!target || !closest(e.target, '.e-unboundcell')) {\n      return;\n    }\n\n    const buttonObj = target.ej2_instances[0];\n    const type = buttonObj.commandType;\n    const uid = target.getAttribute('data-uid');\n    let commandColumn;\n    const row$$1 = gObj.getRowObjectFromUID(closest(target, '.' + row).getAttribute('data-uid'));\n    const cols = this.parent.columnModel;\n\n    for (let i = 0; i < cols.length; i++) {\n      if (cols[i].commands) {\n        const commandCols = cols[i].commands;\n\n        for (let j = 0; j < commandCols.length; j++) {\n          const idInString = 'uid';\n          const typeInString = 'type';\n\n          if (commandCols[j][idInString] === uid && commandCols[j][typeInString] === type) {\n            commandColumn = commandCols[j];\n          } else {\n            const buttons = [].slice.call(closest(target, '.e-unboundcell').querySelectorAll('button'));\n            const index = buttons.findIndex(ele => ele === target);\n\n            if (index >= 0 && commandCols[index][typeInString] === type) {\n              commandColumn = commandCols[index];\n            }\n          }\n        }\n      }\n    }\n\n    const args = {\n      cancel: false,\n      target: target,\n      commandColumn: commandColumn,\n      rowData: isNullOrUndefined(row$$1) ? undefined : row$$1.data\n    };\n    this.parent.trigger(commandClick, args, commandclickargs => {\n      if (buttonObj.disabled || !gObj.editModule || commandclickargs.cancel) {\n        return;\n      }\n\n      switch (type) {\n        case 'Edit':\n          gObj.editModule.endEdit();\n          gObj.editModule.startEdit(closest(target, 'tr'));\n          break;\n\n        case 'Cancel':\n          gObj.editModule.closeEdit();\n          break;\n\n        case 'Save':\n          gObj.editModule.endEdit();\n          break;\n\n        case 'Delete':\n          if (gObj.editSettings.mode !== 'Batch') {\n            gObj.editModule.endEdit();\n          }\n\n          gObj.commandDelIndex = parseInt(closest(target, 'tr').getAttribute(ariaRowIndex), 10);\n          gObj.clearSelection(); //for toogle issue when dbl click\n\n          gObj.selectRow(gObj.commandDelIndex, false);\n          gObj.editModule.deleteRecord();\n          gObj.commandDelIndex = undefined;\n          break;\n      }\n    });\n  }\n  /**\n   * For internal use only - Get the module name.\n   *\n   * @returns {string} returns the module name\n   */\n\n\n  getModuleName() {\n    return 'commandColumn';\n  }\n  /**\n   * To destroy CommandColumn.\n   *\n   * @function destroy\n   * @returns {void}\n   */\n\n\n  destroy() {\n    if (this.parent.isDestroyed) {\n      return;\n    }\n\n    this.removeEventListener();\n  }\n\n  removeEventListener() {\n    if (this.parent.isDestroyed) {\n      return;\n    }\n\n    this.parent.off(click, this.commandClickHandler);\n    this.parent.off(keyPressed, this.keyPressHandler);\n    this.parent.off(initialEnd, this.load);\n    this.parent.off(destroy, this.destroy);\n  }\n\n  addEventListener() {\n    if (this.parent.isDestroyed) {\n      return;\n    }\n\n    this.parent.on(click, this.commandClickHandler, this);\n    this.parent.on(keyPressed, this.keyPressHandler, this);\n    this.parent.on(initialEnd, this.load, this);\n    this.parent.on(destroy, this.destroy, this);\n  }\n\n  keyPressHandler(e) {\n    if (e.action === 'enter' && closest(e.target, '.e-unboundcelldiv')) {\n      this.commandClickHandler(e);\n      e.preventDefault();\n    }\n  }\n\n  load() {\n    const uid = 'uid';\n    const col = this.parent.columnModel;\n\n    for (let i = 0; i < col.length; i++) {\n      if (col[i].commands) {\n        const commandCol = col[i].commands;\n\n        for (let j = 0; j < commandCol.length; j++) {\n          commandCol[j][uid] = getUid('gridcommand');\n        }\n      }\n    }\n  }\n\n}\n\nconst menuClass = {\n  header: '.' + gridHeader,\n  content: '.' + gridContent,\n  edit: '.e-inline-edit',\n  batchEdit: '.e-editedbatchcell',\n  editIcon: 'e-edit',\n  pager: '.e-gridpager',\n  delete: 'e-delete',\n  save: 'e-save',\n  cancel: 'e-cancel',\n  copy: 'e-copy',\n  pdf: 'e-pdfexport',\n  group: 'e-icon-group',\n  ungroup: 'e-icon-ungroup',\n  csv: 'e-csvexport',\n  excel: 'e-excelexport',\n  fPage: 'e-icon-first',\n  nPage: 'e-icon-next',\n  lPage: 'e-icon-last',\n  pPage: 'e-icon-prev',\n  ascending: 'e-icon-ascending',\n  descending: 'e-icon-descending',\n  groupHeader: 'e-groupdroparea',\n  touchPop: 'e-gridpopup'\n};\n/**\n * The `ContextMenu` module is used to handle context menu actions.\n */\n\nclass ContextMenu$1 {\n  constructor(parent, serviceLocator) {\n    this.defaultItems = {};\n    this.disableItems = [];\n    this.hiddenItems = [];\n    this.localeText = this.setLocaleKey();\n    this.parent = parent;\n    this.gridID = parent.element.id;\n    this.serviceLocator = serviceLocator;\n    this.addEventListener();\n  }\n  /**\n   * @returns {void}\n   * @hidden\n   */\n\n\n  addEventListener() {\n    if (this.parent.isDestroyed) {\n      return;\n    }\n\n    this.parent.on(uiUpdate, this.enableAfterRenderMenu, this);\n    this.parent.on(initialLoad, this.render, this);\n    this.parent.on(destroy, this.destroy, this);\n  }\n  /**\n   * @returns {void}\n   * @hidden\n   */\n\n\n  removeEventListener() {\n    if (this.parent.isDestroyed) {\n      return;\n    }\n\n    this.parent.off(initialLoad, this.render);\n    this.parent.off(uiUpdate, this.enableAfterRenderMenu);\n    this.parent.off(destroy, this.destroy);\n    EventHandler.remove(this.element, 'keydown', this.keyDownHandler.bind(this));\n  }\n\n  keyDownHandler(e) {\n    if (e.code === 'Tab' || e.which === 9) {\n      this.contextMenu.close();\n    }\n\n    if (e.code === 'Escape') {\n      this.contextMenu.close();\n      this.parent.notify(restoreFocus, {});\n    }\n  }\n\n  render() {\n    this.parent.element.classList.add('e-noselect');\n    this.l10n = this.serviceLocator.getService('localization');\n    this.element = this.parent.createElement('ul', {\n      id: this.gridID + '_cmenu'\n    });\n    EventHandler.add(this.element, 'keydown', this.keyDownHandler.bind(this));\n    this.parent.element.appendChild(this.element);\n    const target = '#' + this.gridID;\n    this.contextMenu = new ContextMenu({\n      items: this.getMenuItems(),\n      enableRtl: this.parent.enableRtl,\n      enablePersistence: this.parent.enablePersistence,\n      locale: this.parent.locale,\n      target: target,\n      select: this.contextMenuItemClick.bind(this),\n      beforeOpen: this.contextMenuBeforeOpen.bind(this),\n      onOpen: this.contextMenuOpen.bind(this),\n      onClose: this.contextMenuOnClose.bind(this),\n      cssClass: 'e-grid-menu'\n    });\n    this.contextMenu.appendTo(this.element);\n  }\n\n  enableAfterRenderMenu(e) {\n    if (e.module === this.getModuleName() && e.enable) {\n      if (this.contextMenu) {\n        this.contextMenu.destroy();\n        remove(this.element);\n        this.parent.element.classList.remove('e-noselect');\n      }\n\n      this.render();\n    }\n  }\n\n  getMenuItems() {\n    const menuItems = [];\n    const exportItems = [];\n\n    for (const item of this.parent.contextMenuItems) {\n      if (typeof item === 'string' && this.getDefaultItems().indexOf(item) !== -1) {\n        if (item.toLocaleLowerCase().indexOf('export') !== -1) {\n          exportItems.push(this.buildDefaultItems(item));\n        } else {\n          menuItems.push(this.buildDefaultItems(item));\n        }\n      } else if (typeof item !== 'string') {\n        menuItems.push(item);\n      }\n    }\n\n    if (exportItems.length > 0) {\n      const exportGroup = this.buildDefaultItems('export');\n      exportGroup.items = exportItems;\n      menuItems.push(exportGroup);\n    }\n\n    return menuItems;\n  }\n\n  getLastPage() {\n    let totalpage = Math.floor(this.parent.pageSettings.totalRecordsCount / this.parent.pageSettings.pageSize);\n\n    if (this.parent.pageSettings.totalRecordsCount % this.parent.pageSettings.pageSize) {\n      totalpage += 1;\n    }\n\n    return totalpage;\n  }\n\n  contextMenuOpen() {\n    this.isOpen = true;\n  }\n  /**\n   * @param {ContextMenuClickEventArgs} args - specifies the ContextMenuClickEventArgs argument type\n   * @returns {void}\n   * @hidden\n   */\n\n\n  contextMenuItemClick(args) {\n    const item = this.getKeyFromId(args.item.id);\n\n    switch (item) {\n      case 'AutoFitAll':\n        this.parent.autoFitColumns([]);\n        break;\n\n      case 'AutoFit':\n        this.parent.autoFitColumns(this.targetColumn.field);\n        break;\n\n      case 'Group':\n        this.parent.groupColumn(this.targetColumn.field);\n        break;\n\n      case 'Ungroup':\n        this.parent.ungroupColumn(this.targetColumn.field);\n        break;\n\n      case 'Edit':\n        if (this.parent.editModule) {\n          if (this.parent.editSettings.mode === 'Batch') {\n            if (this.row && this.cell && !isNaN(parseInt(this.cell.getAttribute(ariaColIndex), 10))) {\n              this.parent.editModule.editCell(parseInt(this.row.getAttribute(ariaRowIndex), 10), // eslint-disable-next-line\n              this.parent.getColumns()[parseInt(this.cell.getAttribute(ariaColIndex), 10)].field);\n            }\n          } else {\n            this.parent.editModule.endEdit();\n            this.parent.editModule.startEdit(this.row);\n          }\n        }\n\n        break;\n\n      case 'Delete':\n        if (this.parent.editModule) {\n          if (this.parent.editSettings.mode !== 'Batch') {\n            this.parent.editModule.endEdit();\n          }\n\n          if (this.parent.getSelectedRecords().length === 1) {\n            this.parent.editModule.deleteRow(this.row);\n          } else {\n            this.parent.deleteRecord();\n          }\n        }\n\n        break;\n\n      case 'Save':\n        if (this.parent.editModule) {\n          this.parent.editModule.endEdit();\n        }\n\n        break;\n\n      case 'Cancel':\n        if (this.parent.editModule) {\n          this.parent.editModule.closeEdit();\n        }\n\n        break;\n\n      case 'Copy':\n        this.parent.copy();\n        break;\n\n      case 'PdfExport':\n        this.parent.pdfExport();\n        break;\n\n      case 'ExcelExport':\n        this.parent.excelExport();\n        break;\n\n      case 'CsvExport':\n        this.parent.csvExport();\n        break;\n\n      case 'SortAscending':\n        this.isOpen = false;\n        this.parent.sortColumn(this.targetColumn.field, 'Ascending');\n        break;\n\n      case 'SortDescending':\n        this.isOpen = false;\n        this.parent.sortColumn(this.targetColumn.field, 'Descending');\n        break;\n\n      case 'FirstPage':\n        this.parent.goToPage(1);\n        break;\n\n      case 'PrevPage':\n        this.parent.goToPage(this.parent.pageSettings.currentPage - 1);\n        break;\n\n      case 'LastPage':\n        this.parent.goToPage(this.getLastPage());\n        break;\n\n      case 'NextPage':\n        this.parent.goToPage(this.parent.pageSettings.currentPage + 1);\n        break;\n    }\n\n    args.column = this.targetColumn;\n    args.rowInfo = this.targetRowdata;\n    this.parent.trigger(contextMenuClick, args);\n  }\n\n  contextMenuOnClose(args) {\n    const parent = 'parentObj';\n\n    if (args.items.length > 0 && args.items[0][parent] instanceof ContextMenu) {\n      this.updateItemStatus();\n    }\n\n    this.parent.notify(selectRowOnContextOpen, {\n      isOpen: false\n    });\n  }\n\n  getLocaleText(item) {\n    return this.l10n.getConstant(this.localeText[item]);\n  }\n\n  updateItemStatus() {\n    this.contextMenu.showItems(this.hiddenItems);\n    this.contextMenu.enableItems(this.disableItems);\n    this.hiddenItems = [];\n    this.disableItems = [];\n    this.isOpen = false;\n  }\n\n  contextMenuBeforeOpen(args) {\n    const closestGrid = closest(args.event.target, '.e-grid');\n\n    if (args.event && closestGrid && closestGrid !== this.parent.element) {\n      args.cancel = true;\n    } else if (args.event && (closest(args.event.target, '.' + menuClass.groupHeader) || closest(args.event.target, '.' + menuClass.touchPop) || closest(args.event.target, '.e-summarycell') || closest(args.event.target, '.e-groupcaption') || closest(args.event.target, '.e-filterbarcell'))) {\n      args.cancel = true;\n    } else {\n      this.targetColumn = this.getColumn(args.event);\n\n      if (parentsUntil(args.event.target, 'e-grid')) {\n        this.targetRowdata = this.parent.getRowInfo(args.event.target);\n      }\n\n      if (isNullOrUndefined(args.parentItem) && this.targetColumn) {\n        if (this.targetRowdata.cell) {\n          this.parent.notify(selectRowOnContextOpen, {\n            isOpen: true\n          });\n          this.selectRow(args.event, this.targetRowdata.cell.classList.contains('e-selectionbackground') && this.parent.selectionSettings.type === 'Multiple' ? false : true);\n        }\n      }\n\n      const hideSepItems = [];\n      const showSepItems = [];\n\n      for (const item of args.items) {\n        const key = this.getKeyFromId(item.id);\n        const dItem = this.defaultItems[key];\n\n        if (this.getDefaultItems().indexOf(key) !== -1) {\n          if (this.ensureDisabledStatus(key)) {\n            this.disableItems.push(item.text);\n          }\n\n          if (args.event && (this.ensureTarget(args.event.target, menuClass.edit) || this.ensureTarget(args.event.target, menuClass.batchEdit))) {\n            if (key !== 'Save' && key !== 'Cancel') {\n              this.hiddenItems.push(item.text);\n            }\n          } else if (this.parent.editModule && this.parent.editSettings.mode === 'Batch' && (closest(args.event.target, '.e-gridform') || this.parent.editModule.getBatchChanges()[changedRecords].length || this.parent.editModule.getBatchChanges()[addedRecords].length || this.parent.editModule.getBatchChanges()[deletedRecords].length) && (key === 'Save' || key === 'Cancel')) {\n            continue;\n          } else if (isNullOrUndefined(args.parentItem) && args.event && !this.ensureTarget(args.event.target, dItem.target)) {\n            this.hiddenItems.push(item.text);\n          }\n        } else if (item.target && args.event && !this.ensureTarget(args.event.target, item.target)) {\n          if (item.separator) {\n            hideSepItems.push(item.id);\n          } else {\n            this.hiddenItems.push(item.text);\n          }\n        } else if (this.ensureTarget(args.event.target, item.target) && item.separator) {\n          showSepItems.push(item.id);\n        }\n      }\n\n      if (showSepItems.length > 0) {\n        this.contextMenu.showItems(showSepItems, true);\n      }\n\n      this.contextMenu.enableItems(this.disableItems, false);\n      this.contextMenu.hideItems(this.hiddenItems);\n\n      if (hideSepItems.length > 0) {\n        this.contextMenu.hideItems(hideSepItems, true);\n      }\n\n      this.eventArgs = args.event;\n      args.column = this.targetColumn;\n      args.rowInfo = this.targetRowdata;\n      this.parent.trigger(contextMenuOpen, args);\n\n      if (args.cancel || this.hiddenItems.length === args.items.length && !args.parentItem) {\n        this.updateItemStatus();\n        args.cancel = true;\n      }\n    }\n\n    applyBiggerTheme(this.parent.element, this.contextMenu.element.parentElement);\n  }\n\n  ensureTarget(targetElement, selector) {\n    let target = targetElement;\n\n    if (this.ensureFrozenHeader(targetElement) && (selector === menuClass.header || selector === menuClass.content)) {\n      target = closest(targetElement, selector === menuClass.header ? 'thead' : tbody);\n    } else if (selector === menuClass.content || selector === menuClass.header) {\n      target = parentsUntil(closest(targetElement, '.' + table), selector.substr(1, selector.length));\n    } else {\n      target = closest(targetElement, selector);\n    }\n\n    return target && parentsUntil(target, 'e-grid') === this.parent.element;\n  }\n\n  ensureFrozenHeader(targetElement) {\n    return (this.parent.isFrozenGrid() || this.parent.frozenRows) && closest(targetElement, menuClass.header) ? true : false;\n  }\n\n  ensureDisabledStatus(item) {\n    let status = false;\n\n    switch (item) {\n      case 'AutoFitAll':\n      case 'AutoFit':\n        status = !(this.parent.ensureModuleInjected(Resize) && !this.parent.isEdit) || this.targetColumn && !this.targetColumn.field && item === 'AutoFit';\n        break;\n\n      case 'Group':\n        if (!this.parent.allowGrouping || this.parent.ensureModuleInjected(Group) && this.targetColumn && this.parent.groupSettings.columns.indexOf(this.targetColumn.field) >= 0 || this.targetColumn && !this.targetColumn.field) {\n          status = true;\n        }\n\n        break;\n\n      case 'Ungroup':\n        if (!this.parent.allowGrouping || !this.parent.ensureModuleInjected(Group) || this.parent.ensureModuleInjected(Group) && this.targetColumn && this.parent.groupSettings.columns.indexOf(this.targetColumn.field) < 0) {\n          status = true;\n        }\n\n        break;\n\n      case 'Edit':\n      case 'Delete':\n      case 'Save':\n      case 'Cancel':\n        if (!this.parent.editModule || this.parent.getDataRows().length === 0) {\n          status = true;\n        }\n\n        break;\n\n      case 'Copy':\n        if (this.parent.getSelectedRowIndexes().length === 0 && this.parent.getSelectedRowCellIndexes().length === 0 || this.parent.getCurrentViewRecords().length === 0) {\n          status = true;\n        }\n\n        break;\n\n      case 'export':\n        if (!this.parent.allowExcelExport || !this.parent.excelExport || !this.parent.ensureModuleInjected(PdfExport) && !this.parent.ensureModuleInjected(ExcelExport)) {\n          status = true;\n        }\n\n        break;\n\n      case 'PdfExport':\n        if (!this.parent.allowPdfExport || !this.parent.ensureModuleInjected(PdfExport)) {\n          status = true;\n        }\n\n        break;\n\n      case 'ExcelExport':\n      case 'CsvExport':\n        if (!this.parent.allowExcelExport || !this.parent.ensureModuleInjected(ExcelExport)) {\n          status = true;\n        }\n\n        break;\n\n      case 'SortAscending':\n      case 'SortDescending':\n        if (!this.parent.allowSorting || !this.parent.ensureModuleInjected(Sort) || this.targetColumn && !this.targetColumn.field) {\n          status = true;\n        } else if (this.parent.ensureModuleInjected(Sort) && this.parent.sortSettings.columns.length > 0 && this.targetColumn) {\n          const sortColumns = this.parent.sortSettings.columns;\n\n          for (let i = 0; i < sortColumns.length; i++) {\n            if (sortColumns[i].field === this.targetColumn.field && sortColumns[i].direction.toLowerCase() === item.toLowerCase().replace('sort', '').toLocaleLowerCase()) {\n              status = true;\n            }\n          }\n        }\n\n        break;\n\n      case 'FirstPage':\n      case 'PrevPage':\n        if (!this.parent.allowPaging || !this.parent.ensureModuleInjected(Page) || this.parent.getCurrentViewRecords().length === 0 || this.parent.ensureModuleInjected(Page) && this.parent.pageSettings.currentPage === 1) {\n          status = true;\n        }\n\n        break;\n\n      case 'LastPage':\n      case 'NextPage':\n        if (!this.parent.allowPaging || !this.parent.ensureModuleInjected(Page) || this.parent.getCurrentViewRecords().length === 0 || this.parent.ensureModuleInjected(Page) && this.parent.pageSettings.currentPage === this.getLastPage()) {\n          status = true;\n        }\n\n        break;\n    }\n\n    return status;\n  }\n  /**\n   * Gets the context menu element from the Grid.\n   *\n   * @returns {Element} returns the element\n   */\n\n\n  getContextMenu() {\n    return this.element;\n  }\n  /**\n   * Destroys the context menu component in the Grid.\n   *\n   * @function destroy\n   * @returns {void}\n   * @hidden\n   */\n\n\n  destroy() {\n    const gridElement = this.parent.element;\n\n    if (!gridElement || !gridElement.querySelector('.' + gridHeader) && !gridElement.querySelector('.' + gridContent)) {\n      return;\n    }\n\n    this.contextMenu.destroy();\n\n    if (this.element.parentNode) {\n      remove(this.element);\n    }\n\n    this.removeEventListener();\n    this.parent.element.classList.remove('e-noselect');\n  }\n\n  getModuleName() {\n    return 'contextMenu';\n  }\n\n  generateID(item) {\n    return this.gridID + '_cmenu_' + item;\n  }\n\n  getKeyFromId(id) {\n    return id.replace(this.gridID + '_cmenu_', '');\n  }\n\n  buildDefaultItems(item) {\n    let menuItem;\n\n    switch (item) {\n      case 'AutoFitAll':\n      case 'AutoFit':\n        menuItem = {\n          target: menuClass.header\n        };\n        break;\n\n      case 'Group':\n        menuItem = {\n          target: menuClass.header,\n          iconCss: menuClass.group\n        };\n        break;\n\n      case 'Ungroup':\n        menuItem = {\n          target: menuClass.header,\n          iconCss: menuClass.ungroup\n        };\n        break;\n\n      case 'Edit':\n        menuItem = {\n          target: menuClass.content,\n          iconCss: menuClass.editIcon\n        };\n        break;\n\n      case 'Delete':\n        menuItem = {\n          target: menuClass.content,\n          iconCss: menuClass.delete\n        };\n        break;\n\n      case 'Save':\n        menuItem = {\n          target: menuClass.edit,\n          iconCss: menuClass.save\n        };\n        break;\n\n      case 'Cancel':\n        menuItem = {\n          target: menuClass.edit,\n          iconCss: menuClass.cancel\n        };\n        break;\n\n      case 'Copy':\n        menuItem = {\n          target: menuClass.content,\n          iconCss: menuClass.copy\n        };\n        break;\n\n      case 'export':\n        menuItem = {\n          target: menuClass.content\n        };\n        break;\n\n      case 'PdfExport':\n        menuItem = {\n          target: menuClass.content,\n          iconCss: menuClass.pdf\n        };\n        break;\n\n      case 'ExcelExport':\n        menuItem = {\n          target: menuClass.content,\n          iconCss: menuClass.excel\n        };\n        break;\n\n      case 'CsvExport':\n        menuItem = {\n          target: menuClass.content,\n          iconCss: menuClass.csv\n        };\n        break;\n\n      case 'SortAscending':\n        menuItem = {\n          target: menuClass.header,\n          iconCss: menuClass.ascending\n        };\n        break;\n\n      case 'SortDescending':\n        menuItem = {\n          target: menuClass.header,\n          iconCss: menuClass.descending\n        };\n        break;\n\n      case 'FirstPage':\n        menuItem = {\n          target: menuClass.pager,\n          iconCss: menuClass.fPage\n        };\n        break;\n\n      case 'PrevPage':\n        menuItem = {\n          target: menuClass.pager,\n          iconCss: menuClass.pPage\n        };\n        break;\n\n      case 'LastPage':\n        menuItem = {\n          target: menuClass.pager,\n          iconCss: menuClass.lPage\n        };\n        break;\n\n      case 'NextPage':\n        menuItem = {\n          target: menuClass.pager,\n          iconCss: menuClass.nPage\n        };\n        break;\n    }\n\n    this.defaultItems[item] = {\n      text: this.getLocaleText(item),\n      id: this.generateID(item),\n      target: menuItem.target,\n      iconCss: menuItem.iconCss ? 'e-icons ' + menuItem.iconCss : ''\n    };\n    return this.defaultItems[item];\n  }\n\n  getDefaultItems() {\n    return ['AutoFitAll', 'AutoFit', 'Group', 'Ungroup', 'Edit', 'Delete', 'Save', 'Cancel', 'Copy', 'export', 'PdfExport', 'ExcelExport', 'CsvExport', 'SortAscending', 'SortDescending', 'FirstPage', 'PrevPage', 'LastPage', 'NextPage'];\n  }\n\n  setLocaleKey() {\n    const localeKeys = {\n      'AutoFitAll': 'autoFitAll',\n      'AutoFit': 'autoFit',\n      'Copy': 'Copy',\n      'Group': 'Group',\n      'Ungroup': 'Ungroup',\n      'Edit': 'EditRecord',\n      'Delete': 'DeleteRecord',\n      'Save': 'Save',\n      'Cancel': 'CancelButton',\n      'PdfExport': 'Pdfexport',\n      'ExcelExport': 'Excelexport',\n      'CsvExport': 'Csvexport',\n      'export': 'Export',\n      'SortAscending': 'SortAscending',\n      'SortDescending': 'SortDescending',\n      'FirstPage': 'FirstPage',\n      'LastPage': 'LastPage',\n      'PrevPage': 'PreviousPage',\n      'NextPage': 'NextPage'\n    };\n    return localeKeys;\n  }\n\n  getColumn(e) {\n    const cell = closest(e.target, 'th.e-headercell');\n\n    if (cell) {\n      const uid = cell.querySelector('.e-headercelldiv, .e-stackedheadercelldiv').getAttribute('e-mappinguid');\n      return this.parent.getColumnByUid(uid);\n    } else {\n      const ele = this.parent.getRowInfo(e.target).column;\n      return ele || null;\n    }\n  }\n\n  selectRow(e, isSelectable) {\n    this.cell = e.target;\n    this.row = closest(e.target, 'tr.e-row') || this.row;\n\n    if (this.row && isSelectable && !parentsUntil(e.target, 'e-gridpager')) {\n      this.parent.selectRow(parseInt(this.row.getAttribute(ariaRowIndex), 10));\n    }\n  }\n\n}\n/**\n * FreezeRowModelGenerator is used to generate grid data rows with freeze row and column.\n *\n * @hidden\n */\n\n\nclass FreezeRowModelGenerator {\n  constructor(parent) {\n    this.parent = parent;\n    this.rowModelGenerator = new RowModelGenerator(this.parent);\n  }\n\n  generateRows(data, notifyArgs, virtualRows) {\n    let tableName;\n\n    if (notifyArgs.renderFrozenRightContent || notifyArgs.renderMovableContent && !this.parent.enableVirtualization) {\n      tableName = 'frozen-right';\n    } else if (notifyArgs.renderMovableContent || notifyArgs.isFrozen) {\n      tableName = 'movable';\n    } else {\n      tableName = this.parent.getFrozenLeftCount() ? 'frozen-left' : 'frozen-right';\n    }\n\n    if (notifyArgs.requestType === 'virtualscroll' && notifyArgs.virtualInfo.sentinelInfo.axis === 'X') {\n      if (tableName !== 'movable') {\n        return null;\n      }\n    }\n\n    const row = this.parent.enableVirtualization && !notifyArgs.isFrozenRowsRender ? virtualRows : this.rowModelGenerator.generateRows(data, notifyArgs);\n\n    for (let i = 0, len = row.length; i < len; i++) {\n      row[i].cells = splitFrozenRowObjectCells(this.parent, row[i].cells, tableName);\n    }\n\n    return row;\n  }\n\n}\n/**\n * Freeze module is used to render grid content with frozen rows and columns\n *\n * @hidden\n */\n\n\nclass FreezeContentRender extends ContentRender {\n  constructor(parent, locator) {\n    super(parent, locator);\n    this.isInitialRender = true;\n    this.widthService = locator.getService('widthService');\n    this.addEventListener();\n  }\n\n  addEventListener() {\n    this.parent.addEventListener(actionComplete, this.actionComplete.bind(this));\n    this.parent.addEventListener(batchAdd, this.batchAdd.bind(this));\n    this.parent.on(batchCancel, this.batchAdd.bind(this));\n    this.parent.addEventListener(batchDelete, this.batchAdd.bind(this));\n    this.parent.on(setHeightToFrozenElement, this.refreshScrollOffset);\n    this.parent.on(columnVisibilityChanged, this.widthService.refreshFrozenScrollbar, this);\n  }\n\n  batchAdd(args) {\n    const isAdd = args.name !== 'batchCancel' && !(this.parent.frozenRows && this.parent.editSettings.newRowPosition === 'Top');\n\n    if (this.parent.height !== 'auto' && (isAdd || args.name === 'batchCancel' || args.name === 'batchDelete')) {\n      this.refreshScrollOffset();\n      const height = this.getTable().offsetHeight;\n\n      if (args.name === 'add' && this.parent.editSettings.newRowPosition === 'Bottom') {\n        this.parent.getContent().firstChild.scroll(0, height);\n      }\n    }\n  }\n\n  setHeightToContent(height) {\n    this.getFrozenContent().style.height = height.toString() + 'px';\n    this.getMovableContent().style.height = height.toString() + 'px';\n  }\n\n  actionComplete(args) {\n    if (this.parent.editSettings.mode !== 'Dialog' && (args.requestType === 'add' || args.requestType === 'cancel' && args.row.classList.contains(addedRow)) && (!this.parent.frozenRows || this.parent.editSettings.newRowPosition === 'Bottom') && this.parent.height !== 'auto') {\n      this.refreshScrollOffset();\n      const height = this.getTable().offsetHeight;\n\n      if (args.requestType === 'add' && this.parent.editSettings.newRowPosition === 'Bottom') {\n        this.parent.getContent().firstChild.scroll(0, height);\n      }\n    }\n  }\n\n  removeEventListener() {\n    if (this.parent.isDestroyed) {\n      return;\n    }\n\n    this.parent.removeEventListener(actionComplete, this.actionComplete);\n    this.parent.removeEventListener(batchAdd, this.batchAdd);\n    this.parent.off(columnVisibilityChanged, this.widthService.refreshFrozenScrollbar);\n  }\n\n  renderPanel() {\n    super.renderPanel();\n    let fDiv = this.parent.element.querySelector('.' + frozenContent);\n    let mDiv = this.parent.element.querySelector('.' + movableContent);\n\n    if (isNullOrUndefined(fDiv)) {\n      fDiv = this.parent.createElement('div', {\n        className: 'e-frozencontent e-frozen-left-content'\n      });\n      mDiv = this.parent.createElement('div', {\n        className: movableContent\n      });\n      this.getPanel().querySelector('.' + content).appendChild(fDiv);\n      this.getPanel().querySelector('.' + content).appendChild(mDiv);\n      mDiv.style.scrollbarWidth = 'none';\n    }\n\n    this.setFrozenContent(fDiv);\n    this.setMovableContent(mDiv);\n\n    if (Browser.userAgent.indexOf('Mac OS') > -1 && Browser.info.name === 'safari' && !this.parent.enableVirtualization) {\n      this.getPanel().firstElementChild.classList.add('e-mac-safari');\n    }\n  }\n\n  renderFrozenRigthPanel() {\n    super.renderPanel();\n  }\n\n  renderEmpty(tbody$$1) {\n    super.renderEmpty(tbody$$1);\n    this.getMovableContent().querySelector(tbody).innerHTML = '<tr><td></td></tr>';\n    addClass([this.getMovableContent().querySelector(tbody).querySelector('tr')], ['e-emptyrow']);\n    this.getFrozenContent().querySelector('.e-emptyrow').querySelector('td').colSpan = this.parent.getVisibleFrozenColumns();\n    this.getFrozenContent().style.borderRightWidth = '0px';\n\n    if (this.parent.frozenRows) {\n      this.parent.getHeaderContent().querySelector('.' + frozenHeader).querySelector(tbody).innerHTML = '';\n      this.parent.getHeaderContent().querySelector('.' + movableHeader).querySelector(tbody).innerHTML = '';\n    }\n  }\n\n  renderFrozenRightEmpty(tbody$$1) {\n    super.renderEmpty(tbody$$1);\n  }\n\n  setFrozenContent(ele) {\n    this.frozenContent = ele;\n  }\n  /**\n   * @param {Element} ele - specifies the element\n   * @returns {void}\n   * @hidden\n   */\n\n\n  setMovableContent(ele) {\n    this.movableContent = ele;\n  }\n\n  getFrozenContent() {\n    return this.frozenContent;\n  }\n\n  getMovableContent() {\n    return this.movableContent;\n  }\n\n  getModelGenerator() {\n    return new FreezeRowModelGenerator(this.parent);\n  }\n\n  renderFrozenRightTable() {\n    super.renderTable();\n  }\n\n  renderTable() {\n    let mTbl;\n\n    if (this.getFrozenContent().querySelector('.' + table) == null) {\n      super.renderTable();\n      this.getFrozenContent().appendChild(this.getTable());\n      mTbl = this.getTable().cloneNode(true);\n      this.getMovableContent().appendChild(mTbl);\n    } else {\n      this.setTable(this.getFrozenContent().querySelector('.' + table));\n      this.setColGroup(this.parent.element.querySelector('.' + gridHeader).querySelector(colGroup).cloneNode(true));\n      this.getFrozenContent().querySelector('.' + table).appendChild(this.getColGroup());\n      mTbl = this.getMovableContent().querySelector('.' + table);\n\n      if (this.parent.frozenRows) {\n        this.parent.getHeaderContent().classList.add('e-frozenhdrcont');\n      }\n    }\n\n    if (this.getMovableContent().querySelector(colGroup)) {\n      remove(this.getMovableContent().querySelector(colGroup));\n    }\n\n    const colGroup$$1 = this.parent.getHeaderContent().querySelector('.' + movableHeader).querySelector(colGroup).cloneNode(true);\n    mTbl.insertBefore(colGroup$$1, mTbl.querySelector(tbody));\n    const style = this.parent.enableVirtualization ? '' : 'flex';\n    this.getPanel().firstChild.style.display = style;\n    this.renderHorizontalScrollbar('e-frozenscrollbar e-frozen-left-scrollbar', this.getScrollbarDisplay());\n  }\n\n  getScrollbarDisplay() {\n    let frozenDisplay = '';\n\n    if (this.parent.getFrozenColumns() && !this.parent.getVisibleFrozenColumns() || this.parent.getFrozenLeftColumnsCount() && !this.parent.getVisibleFrozenLeftCount()) {\n      frozenDisplay = 'none';\n    }\n\n    return frozenDisplay;\n  }\n\n  renderHorizontalScrollbar(className, display, isRight) {\n    const left = this.parent.createElement('div', {\n      className: className,\n      styles: 'display:' + display\n    });\n    const movable = this.parent.createElement('div', {\n      className: 'e-movablescrollbar'\n    });\n    const child = this.parent.createElement('div', {\n      className: 'e-movablechild'\n    });\n    const scrollbarHeight = getScrollBarWidth().toString();\n    this.setScrollbarHeight(movable, scrollbarHeight);\n    this.setScrollbarHeight(child, scrollbarHeight);\n    movable.appendChild(child);\n    this.appendScrollbar(left, movable, isRight);\n  } // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  appendScrollbar(frozen, movable, isRight) {\n    const parent = this.parent.createElement('div', {\n      className: 'e-scrollbar',\n      styles: 'display: flex'\n    });\n    parent.appendChild(frozen);\n    parent.appendChild(movable);\n    this.parent.getContent().appendChild(parent);\n  }\n\n  setScrollbarHeight(ele, height) {\n    ele.style.minHeight = height + 'px';\n    ele.style.maxHeight = height + 'px';\n  }\n  /**\n   * @param {NotifyArgs} args - specifies the NotifyArgs\n   * @param {freezeTable} tableName - specifies the Freeze Table\n   * @returns {void}\n   * @hidden\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  setIsFrozen(args, tableName) {\n    args.isFrozen = !args.isFrozen;\n  }\n  /**\n   * @param {Row<Column>[]} modelData - specifies the modeldata\n   * @param {NotifyArgs} args - specifies the args\n   * @returns {freezeTable} returns the freeze table\n   * @hidden\n   */\n\n\n  setTbody(modelData, args) {\n    let tableName;\n\n    if (isNullOrUndefined(modelData[0].cells[0])) {\n      this.getMovableContent().querySelector(tbody).innerHTML = '';\n    }\n\n    let cell = modelData[0].cells[0];\n    let idx = cell.index;\n\n    if (isUndefined(idx) && this.parent.isRowDragable()) {\n      cell = modelData[0].cells[1];\n      idx = cell.index;\n    }\n\n    if (idx === 0) {\n      this.getPanel().firstChild.style.overflowX = 'hidden';\n\n      if (this.parent.enableColumnVirtualization) {\n        this.getMovableContent().style.overflowX = 'hidden';\n      }\n    }\n\n    if (this.parent.enableColumnVirtualization && args.renderMovableContent && args.requestType === 'virtualscroll' && this.getMovableContent().scrollLeft > 0 && args.virtualInfo.columnIndexes[0] !== 0) {\n      idx = this.parent.getFrozenColumns();\n    }\n\n    if (cell && cell.column) {\n      tableName = cell.column.getFreezeTableName();\n    }\n\n    this.setIdx(idx);\n    args.tableName = tableName;\n    return tableName;\n  }\n  /**\n   * @param {string} tableName - specifies the table name\n   * @returns {void}\n   * @hidden\n   */\n\n\n  splitRows(tableName) {\n    if (tableName === frozenLeft) {\n      this.freezeRows = this.rows;\n      this.freezeRowElements = this.rowElements;\n    } else {\n      this.movableRows = this.rows;\n    }\n  }\n  /**\n   * @param {NotifyArgs} args - specifies the notifyargs\n   * @param {string} tableName - specifies the tableName\n   * @returns {void}\n   * @hidden\n   */\n\n\n  renderNextFrozentPart(args, tableName) {\n    const isVFTable = this.parent.enableVirtualization;\n\n    if (tableName === frozenLeft) {\n      if (isVFTable) {\n        args.renderMovableContent = true;\n      }\n\n      this.refreshContentRows(extend({}, args));\n    }\n  }\n\n  appendContent(tbody$$1, frag, args, tableName) {\n    if (this.parent.isReact && !isNullOrUndefined(this.parent.rowTemplate)) {\n      tbody$$1 = frag;\n    } else {\n      tbody$$1.appendChild(frag);\n    }\n\n    if (tableName === frozenLeft) {\n      this.isLoaded = false;\n      this.getFrozenContent().querySelector('table').appendChild(tbody$$1);\n    } else {\n      this.refreshTbody(tbody$$1);\n      this.isLoaded = true;\n      this.getMovableContent().querySelector('table').appendChild(tbody$$1);\n      this.refreshHeight();\n      this.refreshScrollOffset();\n      this.widthService.refreshFrozenScrollbar();\n    }\n\n    if (this.isInitialRender) {\n      this.parent.scrollModule.setHeight();\n      this.isInitialRender = false;\n    }\n  }\n\n  refreshScrollOffset() {\n    if (this.parent.height !== 'auto') {\n      const height = this.getTable().offsetHeight + 1;\n      this.setHeightToContent(height);\n    }\n\n    this.parent.notify(refreshFrozenHeight, {});\n  }\n  /**\n   * @param {string} tableName - specifies the table name\n   * @returns {HTMLElement} returns the Html element\n   * @hidden\n   */\n\n\n  getFrozenHeader(tableName) {\n    if (tableName === frozenLeft) {\n      return this.parent.getHeaderContent().querySelector('.' + frozenHeader).querySelector(tbody);\n    } else {\n      return this.parent.getHeaderContent().querySelector('.' + movableHeader).querySelector(tbody);\n    }\n  }\n\n  refreshTbody(tbody$$1) {\n    if (tbody$$1.childElementCount < 1) {\n      tbody$$1.appendChild(this.parent.createElement('tr').appendChild(this.parent.createElement('td')));\n    }\n  }\n\n  refreshHeight() {\n    if (!this.parent.allowTextWrap) {\n      this.parent.notify(freezeRender, {\n        case: 'refreshHeight'\n      });\n    }\n\n    this.getFrozenContent().style.borderRightWidth = '1px';\n  }\n\n  setIdx(idx) {\n    this.idx = idx;\n  }\n\n  getIdx() {\n    return this.idx;\n  }\n  /**\n   * @param {freezeTable} tableName - specifies the table name\n   * @returns {Element} returns the element\n   * @hidden\n   */\n\n\n  getTbody(tableName) {\n    if (tableName === frozenLeft) {\n      return this.getTable().querySelector(tbody);\n    } else {\n      return this.getMovableContent().querySelector(tbody);\n    }\n  }\n\n}\n\nclass FreezeRender extends HeaderRender {\n  constructor(parent, locator) {\n    super(parent, locator);\n    this.addEventListener();\n  }\n\n  addEventListener() {\n    this.eventHandler = [{\n      event: freezeRender,\n      handler: this.refreshFreeze\n    }, {\n      event: frozenHeight,\n      handler: this.setFrozenHeight\n    }, {\n      event: uiUpdate,\n      handler: this.enableAfterRender\n    }];\n    addRemoveEventListener(this.parent, this.eventHandler, true, this);\n  }\n\n  removeEventListener() {\n    if (this.parent.isDestroyed) {\n      return;\n    }\n\n    addRemoveEventListener(this.parent, this.eventHandler, false);\n  }\n\n  renderTable() {\n    super.renderTable();\n    this.rfshMovable();\n    this.updateColgroup();\n    this.initializeHeaderDrag();\n    this.initializeHeaderDrop();\n    this.parent.notify(headerRefreshed, {\n      rows: this.rows,\n      args: {\n        isFrozen: false\n      }\n    });\n  }\n\n  renderPanel() {\n    let fDiv = this.parent.element.querySelector('.' + frozenHeader);\n    let mDiv = this.parent.element.querySelector('.' + movableHeader);\n    super.renderPanel();\n\n    if (isNullOrUndefined(fDiv)) {\n      fDiv = this.parent.createElement('div', {\n        className: 'e-frozenheader e-frozen-left-header'\n      });\n      mDiv = this.parent.createElement('div', {\n        className: movableHeader\n      });\n      this.getPanel().querySelector('.' + headerContent).appendChild(fDiv);\n      this.getPanel().querySelector('.' + headerContent).appendChild(mDiv);\n    }\n\n    this.setFrozenHeader(fDiv);\n    this.setMovableHeader(mDiv);\n  }\n\n  renderFrozenRightPanel() {\n    super.renderPanel();\n  }\n\n  renderFrozenRightTable() {\n    super.renderTable();\n  }\n\n  refreshUI() {\n    const tbody$$1 = this.getMovableHeader().querySelector(tbody);\n    remove(this.getMovableHeader().querySelector('table'));\n    super.refreshUI();\n    this.rfshMovable();\n    this.getMovableHeader().querySelector(tbody).innerHTML = tbody$$1.innerHTML;\n    this.updateColgroup();\n    this.widthService.setWidthToColumns();\n\n    if (!this.parent.enableVirtualization) {\n      this.widthService.setWidthToTable();\n    }\n\n    if (this.parent.allowTextWrap && this.parent.textWrapSettings.wrapMode === 'Header') {\n      wrap([].slice.call(this.movableHeader.querySelectorAll('tr.e-columnheader')), true);\n    }\n\n    this.parent.updateDefaultCursor();\n    renderMovable(this.parent.getContentTable().querySelector(colGroup), this.parent.getFrozenColumns(), this.parent);\n    this.widthService.refreshFrozenScrollbar();\n    this.initializeHeaderDrag();\n    this.parent.notify(headerRefreshed, {\n      rows: this.rows,\n      args: {\n        isFrozen: false\n      }\n    });\n  }\n\n  refreshFrozenLeftUI() {\n    super.refreshUI();\n  }\n\n  rfshMovable() {\n    this.getFrozenHeader().appendChild(this.getTable());\n    this.getMovableHeader().appendChild(this.createHeader(undefined, 'movable'));\n    this.refreshStackedHdrHgt();\n    this.addMovableFirstCls();\n  }\n\n  addMovableFirstCls() {\n    if (this.parent.getVisibleFrozenColumns()) {\n      const movablefirstcell = [].slice.call(this.parent.element.querySelector('.' + movableHeader).querySelector('thead').getElementsByClassName('e-columnheader'));\n      const len = movablefirstcell.length;\n\n      for (let i = 0; i < len; i++) {\n        const cells = 'cells';\n        const element = movablefirstcell[i][cells][0];\n\n        if (element) {\n          addClass([element], ['e-movablefirst']);\n\n          if (movablefirstcell[i][cells][0].rowSpan > 1) {\n            i = i + (movablefirstcell[i][cells][0].rowSpan - 1);\n          }\n        }\n      }\n    }\n  }\n\n  refreshFreeze(obj) {\n    if (obj.case === 'filter') {\n      const filterRow = this.getTable().querySelector('.e-filterbar');\n\n      if (this.parent.allowFiltering && filterRow && this.getMovableHeader().querySelector('thead')) {\n        this.getMovableHeader().querySelector('thead').appendChild(this.filterRenderer(filterRow, this.parent.getFrozenColumns()));\n        const elements = [].slice.call(this.getMovableHeader().querySelectorAll('thead .e-filterbarcell .e-input'));\n\n        for (const elem of elements) {\n          const args = {\n            element: elem,\n            floatLabelType: 'Never',\n            properties: {\n              enableRtl: this.parent.enableRtl,\n              showClearButton: true\n            }\n          };\n          Input.bindInitialEvent(args);\n        }\n      }\n    } else if (obj.case === 'textwrap' || obj.case === 'refreshHeight') {\n      this.refreshHeight(obj);\n      this.parent.contentModule.refreshScrollOffset();\n    }\n  }\n\n  refreshHeight(obj) {\n    let fRows;\n    let mRows;\n    const fHdr = this.getFrozenHeader();\n    const mHdr = this.getMovableHeader();\n    const cont = this.parent.getContent();\n    const wrapMode = this.parent.textWrapSettings.wrapMode;\n    const hdrClassList = this.parent.getHeaderContent().querySelector('.' + headerContent).classList;\n\n    if (obj.case === 'textwrap') {\n      if (wrapMode !== 'Header' || obj.isModeChg) {\n        fRows = cont.querySelector('.' + frozenContent).querySelectorAll('tr');\n        mRows = cont.querySelector('.' + movableContent).querySelectorAll('tr');\n        this.setWrapHeight(fRows, mRows, obj.isModeChg, true);\n      }\n\n      if (wrapMode === 'Content' && this.parent.allowTextWrap) {\n        hdrClassList.add('e-wrap');\n      } else {\n        hdrClassList.remove('e-wrap');\n      }\n\n      if (wrapMode === 'Both' || obj.isModeChg) {\n        fRows = fHdr.querySelectorAll('tr');\n        mRows = mHdr.querySelectorAll('tr');\n      } else {\n        mRows = mHdr.querySelector(wrapMode === 'Content' ? tbody : 'thead').querySelectorAll('tr');\n        fRows = fHdr.querySelector(wrapMode === 'Content' ? tbody : 'thead').querySelectorAll('tr');\n      }\n\n      if (!this.parent.getHeaderContent().getElementsByClassName('e-stackedheadercell').length) {\n        this.setWrapHeight(fRows, mRows, obj.isModeChg, false, this.colDepth > 1);\n      }\n\n      this.refreshStackedHdrHgt();\n    } else if (obj.case === 'refreshHeight') {\n      this.setWrapHeight(cont.querySelector('.' + frozenContent).querySelectorAll('tr'), cont.querySelector('.' + movableContent).querySelectorAll('tr'), obj.isModeChg);\n\n      if (!this.parent.getHeaderContent().getElementsByClassName('e-stackedheadercell').length) {\n        this.setWrapHeight(fHdr.querySelectorAll('tr'), mHdr.querySelectorAll('tr'), obj.isModeChg);\n      }\n    }\n  }\n\n  enableAfterRender(e) {\n    if (e.module === 'scroll') {\n      this.setFrozenHeight();\n    }\n  }\n\n  updateResizeHandler() {\n    const elements = [].slice.call(this.parent.getHeaderContent().getElementsByClassName('e-rhandler'));\n\n    for (let i = 0; i < elements.length; i++) {\n      elements[i].style.height = elements[i].parentElement.offsetHeight + 'px';\n    }\n  }\n\n  setWrapHeight(fRows, mRows, isModeChg, isContReset, isStackedHdr) {\n    let fRowHgt;\n    let mRowHgt;\n    const isWrap = this.parent.allowTextWrap;\n    const wrapMode = this.parent.textWrapSettings.wrapMode;\n    const tHead = this.parent.getHeaderContent().querySelector('thead');\n    const tBody = this.parent.getHeaderContent().querySelector(tbody);\n    const height = [];\n    const width = [];\n\n    for (let i = 0, len = fRows.length; i < len; i++) {\n      //separate loop for performance issue\n      if (!isNullOrUndefined(fRows[i]) && !isNullOrUndefined(mRows[i])) {\n        height[i] = fRows[i].getBoundingClientRect().height; //https://pagebuildersandwich.com/increased-plugins-performance-200/\n\n        width[i] = mRows[i].getBoundingClientRect().height;\n      }\n    }\n\n    for (let i = 0, len = fRows.length; i < len; i++) {\n      if (isModeChg && (wrapMode === 'Header' && isContReset || wrapMode === 'Content' && tHead.contains(fRows[i]) || wrapMode === 'Header' && tBody.contains(fRows[i])) || isStackedHdr) {\n        fRows[i].style.height = null;\n        mRows[i].style.height = null;\n      }\n\n      fRowHgt = height[i];\n      mRowHgt = width[i];\n\n      if (!isNullOrUndefined(fRows[i]) && fRows[i].childElementCount && (isWrap && fRowHgt < mRowHgt || !isWrap && fRowHgt < mRowHgt || this.parent.allowResizing && this.parent.resizeModule && this.parent.resizeModule.isFrozenColResized === false)) {\n        fRows[i].style.height = mRowHgt + 'px';\n      }\n\n      if (mRows && !isNullOrUndefined(mRows[i]) && mRows[i].childElementCount && (isWrap && fRowHgt > mRowHgt || !isWrap && fRowHgt > mRowHgt || this.parent.allowResizing && this.parent.resizeModule && this.parent.resizeModule.isFrozenColResized === true)) {\n        mRows[i].style.height = fRowHgt + 'px';\n      }\n    }\n\n    if (isWrap && this.parent.height !== 'auto') {\n      this.setFrozenHeight();\n    }\n  }\n\n  setFrozenHeight(height = getScrollBarWidth()) {\n    const movableContentHeight = this.parent.element.querySelector('.' + movableContent).getBoundingClientRect().height;\n    const movableContent$$1 = this.parent.element.querySelector('.' + movableContent);\n    const frozenContent$$1 = this.parent.element.querySelector('.' + frozenContent);\n    const contentScrollWidth = this.parent.getContent().scrollWidth;\n    const contentTableScrollWidth = this.parent.element.querySelector('.e-movablecontent table').scrollWidth + this.parent.getContentTable().scrollWidth;\n\n    if (movableContent$$1.scrollWidth - movableContent$$1.clientWidth) {\n      frozenContent$$1.style.height = movableContentHeight - height + 'px';\n      frozenContent$$1.style.borderBottom = '';\n    } else {\n      frozenContent$$1.style.height = movableContentHeight + 'px';\n\n      if ((frozenContent$$1.scrollHeight <= frozenContent$$1.clientHeight || movableContent$$1.scrollHeight <= movableContent$$1.clientHeight) && contentScrollWidth === contentTableScrollWidth) {\n        this.parent.scrollModule.removePadding();\n      }\n\n      frozenContent$$1.style.borderBottom = '0px';\n    }\n  }\n\n  refreshStackedHdrHgt() {\n    let fRowSpan;\n    let mRowSpan;\n    const fTr = [].slice.call(this.getFrozenHeader().getElementsByClassName('e-columnheader'));\n    const mTr = [].slice.call(this.getMovableHeader().getElementsByClassName('e-columnheader'));\n\n    for (let i = 0, len = fTr.length; i < len; i++) {\n      fRowSpan = this.getRowSpan(fTr[i]);\n      mRowSpan = this.getRowSpan(mTr[i]);\n\n      if (fRowSpan.min > 1) {\n        this.updateStackedHdrRowHgt(i, fRowSpan.max, fTr[i], mTr);\n      } else if (mRowSpan.min > 1) {\n        this.updateStackedHdrRowHgt(i, mRowSpan.max, mTr[i], fTr);\n      }\n    }\n\n    if (this.parent.allowResizing) {\n      this.updateResizeHandler();\n    }\n  }\n\n  getRowSpan(row$$1) {\n    let rSpan;\n    let minRowSpan;\n    let maxRowSpan;\n\n    for (let i = 0, len = row$$1.childElementCount; i < len; i++) {\n      if (i === 0) {\n        minRowSpan = row$$1.children[0].rowSpan;\n      }\n\n      rSpan = row$$1.children[i].rowSpan;\n      minRowSpan = Math.min(rSpan, minRowSpan);\n      maxRowSpan = Math.max(rSpan, minRowSpan);\n    }\n\n    return {\n      min: minRowSpan,\n      max: maxRowSpan\n    };\n  }\n\n  updateStackedHdrRowHgt(idx, maxRowSpan, row$$1, rows) {\n    let height = 0;\n\n    for (let i = 0; i < maxRowSpan; i++) {\n      height += rows[idx + i].style.height ? parseInt(rows[idx + i].style.height, 10) : rows[idx + i].offsetHeight;\n    }\n\n    row$$1.style.height = height + 'px';\n  }\n\n  setFrozenHeader(ele) {\n    this.frozenHeader = ele;\n  }\n  /**\n   * @param {Element} ele - specifies the element\n   * @returns {void}\n   * @hidden\n   */\n\n\n  setMovableHeader(ele) {\n    this.movableHeader = ele;\n  }\n\n  getFrozenHeader() {\n    return this.frozenHeader;\n  }\n\n  getMovableHeader() {\n    return this.movableHeader;\n  }\n  /**\n   * @returns {void}\n   * @hidden\n   */\n\n\n  updateColgroup() {\n    const mTable = this.getMovableHeader().querySelector('table');\n    remove(this.getMovableHeader().querySelector(colGroup));\n    mTable.insertBefore(renderMovable(this.getFrozenHeader().querySelector(colGroup), this.parent.getFrozenColumns(), this.parent), mTable.querySelector('thead'));\n  }\n\n  filterRenderer(ele, frozenColumn, total) {\n    const clone = ele.cloneNode(true);\n    clone.innerHTML = '';\n    const end = total ? total : this.parent.getColumns().length;\n\n    for (let i = frozenColumn; i < end; i++) {\n      clone.appendChild(ele.removeChild(ele.children[frozenColumn]));\n    }\n\n    return clone;\n  }\n\n}\n/**\n * ColumnFreezeHeaderRenderer is used to freeze the columns header at right and left\n *\n * @hidden\n */\n\n\nclass ColumnFreezeHeaderRenderer extends FreezeRender {\n  constructor(parent, locator) {\n    super(parent, locator);\n    this.addEventListener();\n  }\n\n  addEventListener() {\n    this.evtHandlers = [{\n      event: freezeRender,\n      handler: this.refreshFreeze\n    }, {\n      event: refreshFrozenColumns,\n      handler: this.refreshFrozenColumns\n    }, {\n      event: setReorderDestinationElement,\n      handler: this.setReorderElement\n    }, {\n      event: columnVisibilityChanged,\n      handler: this.setVisible\n    }];\n    addRemoveEventListener(this.parent, this.evtHandlers, true, this);\n  }\n\n  removeEventListener() {\n    if (this.parent.isDestroyed) {\n      return;\n    }\n\n    addRemoveEventListener(this.parent, this.evtHandlers, false);\n  }\n\n  setReorderElement(args) {\n    this.destEle = args.ele;\n  }\n\n  refreshFrozenColumns(args) {\n    if (!args.parent) {\n      this.parent.setProperties({\n        columns: args.columns\n      }, true);\n    }\n\n    const isFrozenLeft = parentsUntil(this.destEle, 'e-frozen-left-header');\n    const isFrozenRight = parentsUntil(this.destEle, 'e-frozen-right-header');\n    const left = this.parent.getFrozenLeftColumnsCount();\n    const right = this.parent.getFrozenRightColumnsCount();\n    args.column.freeze = null;\n\n    if (isFrozenLeft) {\n      args.column.freeze = 'Left';\n    } else if (isFrozenRight) {\n      args.column.freeze = 'Right';\n    }\n\n    this.parent.setFrozenCount();\n    args.cancel = left !== this.parent.getFrozenLeftColumnsCount() || right !== this.parent.getFrozenRightColumnsCount();\n\n    if (args.cancel) {\n      this.parent.refreshColumns();\n    }\n  }\n\n  setWrapHeight(fRows, mRows, isModeChg, isContReset, isStackedHdr, frRows) {\n    let fRowHgt;\n    let mRowHgt;\n    let frRowHgt;\n    const isWrap = this.parent.allowTextWrap;\n    const tBody = this.parent.getHeaderContent().querySelector(tbody);\n    const wrapMode = this.parent.textWrapSettings.wrapMode;\n    const tHead = this.parent.getHeaderContent().querySelector('thead');\n    const height = [];\n    const width = [];\n    const rightHeight = [];\n\n    for (let i = 0, len = fRows.length; i < len; i++) {\n      //separate loop for performance issue\n      if (!isNullOrUndefined(fRows[i]) && !isNullOrUndefined(mRows[i])) {\n        if (frRows) {\n          rightHeight[i] = frRows[i].getBoundingClientRect().height;\n        }\n\n        width[i] = mRows[i].getBoundingClientRect().height;\n        height[i] = fRows[i].getBoundingClientRect().height; //https://pagebuildersandwich.com/increased-plugins-performance-200/\n      }\n    }\n\n    for (let i = 0, len = fRows.length; i < len; i++) {\n      if (isModeChg && (wrapMode === 'Content' && tHead.contains(fRows[i]) || wrapMode === 'Header' && tBody.contains(fRows[i]) || wrapMode === 'Header' && isContReset) || isStackedHdr) {\n        if (frRows[i]) {\n          frRows[i].style.height = null;\n        }\n\n        fRows[i].style.height = null;\n        mRows[i].style.height = null;\n      }\n\n      fRowHgt = height[i];\n      mRowHgt = width[i];\n      frRowHgt = rightHeight[i] ? rightHeight[i] : 0;\n      const maxHeight = Math.max(fRowHgt, mRowHgt, frRowHgt);\n\n      if (!isNullOrUndefined(fRows[i]) && fRows[i].childElementCount && (isWrap && fRowHgt < maxHeight || !isWrap && fRowHgt < maxHeight || this.parent.allowResizing && this.parent.resizeModule && this.parent.resizeModule.isFrozenColResized === false)) {\n        fRows[i].style.height = maxHeight + 'px';\n      }\n\n      if (mRows && !isNullOrUndefined(mRows[i]) && mRows[i].childElementCount && (isWrap && maxHeight > mRowHgt || !isWrap && maxHeight > mRowHgt || this.parent.allowResizing && this.parent.resizeModule && this.parent.resizeModule.isFrozenColResized === true)) {\n        mRows[i].style.height = maxHeight + 'px';\n      }\n\n      if (frRows && !isNullOrUndefined(frRows[i]) && frRows[i].childElementCount && (isWrap && maxHeight > frRowHgt || !isWrap && maxHeight > frRowHgt || this.parent.allowResizing && this.parent.resizeModule && this.parent.resizeModule.isFrozenColResized === true)) {\n        frRows[i].style.height = maxHeight + 'px';\n      }\n    }\n\n    if (isWrap) {\n      this.setFrozenHeight();\n    }\n  }\n\n  refreshHeight(obj) {\n    const isLeftRight = this.parent.getFrozenMode() === leftRight;\n    let fRows;\n    let frRows;\n    let mRows;\n    const frHdr = this.getFrozenRightHeader();\n    const fHdr = this.parent.getHeaderContent().querySelector('.' + frozenHeader);\n    const cont = this.parent.getContent();\n    const mHdr = this.getMovableHeader();\n    const hdrClassList = this.parent.getHeaderContent().querySelector('.' + headerContent).classList;\n    const wrapMode = this.parent.textWrapSettings.wrapMode;\n\n    if (obj.case === 'textwrap') {\n      if (wrapMode !== 'Header' || obj.isModeChg) {\n        if (isLeftRight) {\n          frRows = cont.querySelector('.e-frozen-right-content').querySelectorAll('tr');\n        }\n\n        mRows = cont.querySelector('.' + movableContent).querySelectorAll('tr');\n        fRows = cont.querySelector('.' + frozenContent).querySelectorAll('tr');\n        this.setWrapHeight(fRows, mRows, obj.isModeChg, true, false, frRows);\n      }\n\n      if (wrapMode === 'Content' && this.parent.allowTextWrap) {\n        hdrClassList.add('e-wrap');\n      } else {\n        hdrClassList.remove('e-wrap');\n      }\n\n      if (wrapMode === 'Both' || obj.isModeChg) {\n        if (isLeftRight) {\n          frRows = frHdr.querySelectorAll('tr');\n        }\n\n        fRows = fHdr.querySelectorAll('tr');\n        mRows = mHdr.querySelectorAll('tr');\n      } else {\n        if (isLeftRight) {\n          frRows = frHdr.querySelector(wrapMode === 'Content' ? tbody : 'thead').querySelectorAll('tr');\n        }\n\n        fRows = fHdr.querySelector(wrapMode === 'Content' ? tbody : 'thead').querySelectorAll('tr');\n        mRows = mHdr.querySelector(wrapMode === 'Content' ? tbody : 'thead').querySelectorAll('tr');\n      }\n\n      if (!this.parent.getHeaderContent().getElementsByClassName('e-stackedheadercell').length) {\n        this.setWrapHeight(fRows, mRows, obj.isModeChg, false, this.colDepth > 1, frRows);\n      }\n\n      this.refreshStackedHdrHgt();\n    } else if (obj.case === 'refreshHeight') {\n      mRows = cont.querySelector('.' + movableContent).querySelectorAll('tr');\n      fRows = cont.querySelector('.' + frozenContent).querySelectorAll('tr');\n\n      if (isLeftRight) {\n        frRows = cont.querySelector('.e-frozen-right-content').querySelectorAll('tr');\n      }\n\n      this.setWrapHeight(fRows, mRows, obj.isModeChg, false, false, frRows);\n\n      if (!this.parent.getHeaderContent().getElementsByClassName('e-stackedheadercell').length) {\n        if (isLeftRight) {\n          frRows = frHdr.querySelectorAll('tr');\n        }\n\n        fRows = fHdr.querySelectorAll('tr');\n        mRows = mHdr.querySelectorAll('tr');\n        this.setWrapHeight(fRows, mRows, obj.isModeChg, false, false, frRows);\n      }\n    }\n  }\n  /**\n   * Function to hide header table column based on visible property\n   *\n   * @param {Column[]} columns - specifies the column[]\n   * @returns {void}\n   */\n\n\n  setVisible(columns) {\n    const gObj = this.parent;\n    let displayVal;\n    let idx;\n    const left = this.parent.getFrozenLeftColumnsCount();\n    const right = this.parent.getFrozenRightColumnsCount();\n    const movable = this.parent.getMovableColumnsCount();\n\n    for (let c = 0, clen = columns.length; c < clen; c++) {\n      const column = columns[c];\n      idx = gObj.getNormalizedColumnIndex(column.uid);\n      displayVal = column.visible ? '' : 'none';\n\n      if (column.freeze === 'Left' || column.freeze === 'Right') {\n        if (left && !right) {\n          const leftColGrp = gObj.getHeaderContent().querySelector('.e-frozen-left-header').querySelector(colGroup);\n          setStyleAttribute(leftColGrp.children[idx], {\n            'display': displayVal\n          });\n        } else if (!left && right) {\n          const rightColGrp = gObj.getHeaderContent().querySelector('.e-frozen-right-header').querySelector(colGroup);\n          setStyleAttribute(rightColGrp.children[idx - movable], {\n            'display': displayVal\n          });\n        }\n      } else {\n        const mTblColGrp = gObj.getHeaderContent().querySelector('.' + movableHeader).querySelector(colGroup);\n        setStyleAttribute(mTblColGrp.children[idx - left], {\n          'display': displayVal\n        });\n      }\n    }\n\n    this.refreshUI();\n  }\n\n  filterRenderer(ele, frozenColumn, total) {\n    return super.filterRenderer(ele, frozenColumn, total);\n  }\n\n  refreshUI() {\n    let frTbody;\n    const tbody$$1 = this.getMovableHeader().querySelector(tbody);\n    remove(this.getMovableHeader().querySelector('table'));\n\n    if (this.parent.getFrozenMode() === leftRight) {\n      frTbody = this.getFrozenRightHeader().querySelector(tbody);\n      remove(this.getFrozenRightHeader().querySelector('table'));\n    }\n\n    super.refreshFrozenLeftUI();\n    this.rfshMovable();\n    this.getMovableHeader().querySelector(tbody).innerHTML = tbody$$1.innerHTML;\n\n    if (frTbody) {\n      this.getFrozenRightHeader().querySelector(tbody).innerHTML = frTbody.innerHTML;\n    }\n\n    this.updateColgroup();\n    this.widthService.setWidthToColumns();\n    this.parent.notify(colGroupRefresh, {});\n\n    if (this.parent.allowTextWrap && this.parent.textWrapSettings.wrapMode === 'Header') {\n      wrap([].slice.call(this.getMovableHeader().querySelectorAll('tr.e-columnheader')), true);\n    }\n\n    this.parent.updateDefaultCursor();\n    const mTbl = this.parent.getContent().querySelector('.' + movableContent).querySelector('.' + table);\n    remove(mTbl.querySelector(colGroup));\n    const mColGroup = this.getMovableHeader().querySelector(colGroup).cloneNode(true);\n    mTbl.insertBefore(mColGroup, mTbl.querySelector(tbody));\n\n    if (frTbody) {\n      const frtbl = this.parent.getContent().querySelector('.e-frozen-right-content').querySelector('.' + table);\n      remove(frtbl.querySelector(colGroup));\n      const frtblColGroup = this.getFrozenRightHeader().querySelector(colGroup).cloneNode(true);\n      frtbl.insertBefore(frtblColGroup, frtbl.querySelector(tbody));\n    }\n\n    this.widthService.refreshFrozenScrollbar();\n    this.initializeHeaderDrag();\n    this.parent.notify(headerRefreshed, {\n      rows: this.rows,\n      args: {\n        isFrozen: false\n      }\n    });\n  }\n\n  refreshFreeze(obj) {\n    const left = this.parent.getFrozenLeftColumnsCount();\n    const right = this.parent.getFrozenRightColumnsCount();\n    const movable = this.parent.getMovableColumnsCount();\n\n    if (obj.case === 'filter') {\n      const filterRow = this.getTable().querySelector('.e-filterbar');\n\n      if (this.parent.allowFiltering && filterRow && this.getMovableHeader().querySelector('thead')) {\n        const isDraggable = this.parent.isRowDragable();\n        const index = left ? isDraggable ? left + 1 : left : 0;\n        const total = left + movable + (left && isDraggable ? 1 : 0);\n        this.getMovableHeader().querySelector('thead').appendChild(this.filterRenderer(filterRow, index, total));\n\n        if (this.parent.getFrozenMode() === leftRight) {\n          const ele = [].slice.call(this.getMovableHeader().querySelectorAll('thead .e-filterbarcell .e-input'));\n          this.getFrozenRightHeader().querySelector('thead').appendChild(this.filterRenderer(filterRow, index, index + right));\n          this.adjudtFilterBarCell(ele);\n        }\n\n        const elements = [].slice.call(this.getMovableHeader().querySelectorAll('thead .e-filterbarcell .e-input'));\n        this.adjudtFilterBarCell(elements);\n      }\n    } else if (obj.case === 'textwrap' || obj.case === 'refreshHeight') {\n      this.refreshHeight(obj);\n      this.parent.contentModule.refreshScrollOffset();\n    }\n  }\n\n  updateFrozenColGroup(cols, colGroup$$1) {\n    if (cols && cols.visible === false) {\n      setStyleAttribute(colGroup$$1, {\n        'display': 'none'\n      });\n    }\n  }\n\n  adjudtFilterBarCell(elements) {\n    for (const elem of elements) {\n      const args = {\n        element: elem,\n        floatLabelType: 'Never',\n        properties: {\n          enableRtl: this.parent.enableRtl,\n          showClearButton: true\n        }\n      };\n      Input.bindInitialEvent(args);\n    }\n  }\n\n  renderPanel() {\n    if (this.parent.getFrozenLeftColumnsCount()) {\n      super.renderPanel();\n\n      if (this.parent.getFrozenRightColumnsCount()) {\n        this.renderLeftWithRightFrozenPanel();\n      }\n    } else {\n      this.renderRightFrozenPanelAlone();\n    }\n\n    this.getPanel().firstChild.style.display = 'flex';\n    this.getMovableHeader().style.flex = '1';\n  }\n\n  renderTable() {\n    if (this.parent.getFrozenLeftColumnsCount()) {\n      super.renderTable();\n    } else {\n      this.renderFrozenRightTableAlone();\n    }\n  }\n\n  rfshMovable() {\n    if (this.parent.getFrozenLeftColumnsCount()) {\n      super.rfshMovable();\n\n      if (this.parent.getFrozenRightColumnsCount()) {\n        const rows = this.rows;\n        this.getFrozenRightHeader().appendChild(this.createHeader(undefined, 'frozen-right'));\n        this.refreshStackedHdrHgt();\n        this.parent.notify(headerRefreshed, {\n          rows: this.rows,\n          args: {\n            renderFrozenRightContent: true\n          }\n        });\n        this.rows = rows;\n      }\n    } else {\n      this.getFrozenRightHeader().appendChild(this.getTable());\n      this.getMovableHeader().appendChild(this.createHeader(undefined, 'movable'));\n      this.refreshStackedHdrHgt();\n      this.addMovableFirstCls();\n    }\n  }\n\n  refreshStackedHdrHgt() {\n    if (this.parent.getFrozenLeftColumnsCount()) {\n      super.refreshStackedHdrHgt();\n\n      if (this.parent.getFrozenRightColumnsCount()) {\n        this.refreshFrozenRightStackedHdrHgt();\n      }\n    } else {\n      this.refreshFrozenRightStackedHdrHgt();\n    }\n  }\n\n  refreshFrozenRightStackedHdrHgt() {\n    let fRowSpan;\n    const frTr = [].slice.call(this.getFrozenRightHeader().getElementsByClassName('e-columnheader'));\n    const mTr = [].slice.call(this.getMovableHeader().getElementsByClassName('e-columnheader'));\n\n    for (let i = 0, len = frTr.length; i < len; i++) {\n      fRowSpan = this.getRowSpan(frTr[i]);\n\n      if (fRowSpan.min > 1) {\n        this.updateStackedHdrRowHgt(i, fRowSpan.max, frTr[i], mTr);\n      }\n    }\n  }\n  /**\n   * @returns {void}\n   * @hidden\n   */\n\n\n  updateColgroup() {\n    this.updateMovableColGroup();\n\n    if (this.parent.getFrozenLeftColumnsCount()) {\n      this.updateFrozenLeftColGroup();\n    }\n\n    if (this.parent.getFrozenRightColumnsCount()) {\n      this.updateFrozenRightColGroup();\n    }\n  }\n\n  renderRightFrozenPanelAlone() {\n    let mDiv = this.parent.element.querySelector('.' + movableHeader);\n    let fRightDiv = this.parent.element.querySelector('.e-frozen-right-header');\n    super.renderFrozenRightPanel();\n\n    if (isNullOrUndefined(fRightDiv)) {\n      mDiv = this.parent.createElement('div', {\n        className: movableHeader\n      });\n      fRightDiv = this.parent.createElement('div', {\n        className: 'e-frozenheader e-frozen-right-header'\n      });\n      this.getPanel().querySelector('.' + headerContent).appendChild(mDiv);\n      this.getPanel().querySelector('.' + headerContent).appendChild(fRightDiv);\n    }\n\n    super.setMovableHeader(mDiv);\n    this.setFrozenRightHeader(fRightDiv);\n  }\n\n  renderLeftWithRightFrozenPanel() {\n    let fRightDiv = this.parent.element.querySelector('.e-frozen-right-header');\n    super.renderFrozenRightPanel();\n\n    if (isNullOrUndefined(fRightDiv)) {\n      fRightDiv = this.parent.createElement('div', {\n        className: 'e-frozenheader e-frozen-right-header'\n      });\n      this.getPanel().querySelector('.' + headerContent).appendChild(fRightDiv);\n    }\n\n    this.setFrozenRightHeader(fRightDiv);\n  }\n\n  renderFrozenRightTableAlone() {\n    super.renderFrozenRightTable();\n    this.rfshMovable();\n    this.updateColgroup();\n    this.initializeHeaderDrag();\n    this.initializeHeaderDrop();\n    this.parent.notify(headerRefreshed, {\n      rows: this.rows,\n      args: {\n        isFrozen: false\n      }\n    });\n  }\n\n  updateFrozenLeftColGroup() {\n    const leftColGroup = this.getFrozenHeader().querySelector(colGroup).children;\n    const start = this.parent.isRowDragable() ? 1 : 0;\n    const count = this.parent.isRowDragable() ? this.parent.getFrozenLeftColumnsCount() + 1 : this.parent.getFrozenLeftColumnsCount();\n\n    for (let i = start; i < leftColGroup.length; i++) {\n      if (i >= count) {\n        remove(leftColGroup[i]);\n        i--;\n      }\n    }\n  }\n\n  updateMovableColGroup() {\n    const movableColGroup = this.getMovableHeader().querySelector(colGroup).children;\n\n    if (this.parent.isRowDragable()) {\n      remove(movableColGroup[0]);\n    }\n\n    const length = movableColGroup.length;\n    const left = this.parent.getFrozenLeftColumnsCount();\n    const movable = this.parent.getMovableColumnsCount();\n    let k = 0;\n\n    for (let i = 0; i < length; i++, k++) {\n      if (i < left || i >= left + movable) {\n        remove(movableColGroup[k]);\n        k--;\n      }\n    }\n  }\n\n  updateFrozenRightColGroup() {\n    const isDraggable = this.parent.isRowDragable();\n    const rightColumns = this.parent.getFrozenRightColumns();\n    const rightColGroup = this.getFrozenRightHeader().querySelector(colGroup).children;\n\n    if (this.parent.getFrozenMode() === leftRight && isDraggable) {\n      remove(rightColGroup[0]);\n    }\n\n    const length = rightColGroup.length;\n    const left = this.parent.getFrozenLeftColumnsCount();\n    const movable = this.parent.getMovableColumnsCount();\n    let k = 0;\n\n    for (let i = 0; i < length; i++) {\n      if (i < left + movable) {\n        remove(rightColGroup[0]);\n      } else {\n        this.updateFrozenColGroup(rightColumns[k], rightColGroup[k]);\n        k++;\n      }\n    }\n  }\n\n  setFrozenRightHeader(ele) {\n    this.frozenRightHeader = ele;\n  }\n\n  getFrozenRightHeader() {\n    return this.frozenRightHeader;\n  }\n\n}\n/**\n * ColumnFreezeContentRenderer is used to freeze the columns content at right and left\n *\n * @hidden\n */\n\n\nclass ColumnFreezeContentRenderer extends FreezeContentRender {\n  constructor(parent, locator) {\n    super(parent, locator);\n    this.frzCount = 0;\n    this.isColGroupRefresh = false;\n    this.widthService = locator.getService('widthService');\n  }\n\n  renderPanel() {\n    if (this.parent.getFrozenLeftColumnsCount()) {\n      super.renderPanel();\n\n      if (this.parent.getFrozenRightColumnsCount()) {\n        this.renderFrozenLeftWithRightPanel();\n      }\n    } else {\n      this.renderFrozenRightPanelAlone();\n    }\n\n    const display = this.parent.enableVirtualization ? '' : 'flex';\n    this.getPanel().firstChild.style.display = display;\n  }\n\n  renderTable() {\n    if (this.parent.getFrozenLeftColumnsCount()) {\n      super.renderTable();\n\n      if (this.parent.getFrozenRightColumnsCount()) {\n        this.renderFrozenLeftWithRightTable();\n        const display = !this.parent.getVisibleFrozenRightCount() ? 'none' : '';\n        this.renderHorizontalScrollbar('e-frozenscrollbar e-frozen-right-scrollbar', display, true);\n      }\n    } else {\n      this.renderFrozenRightTableAlone();\n      const display = !this.parent.getVisibleFrozenRightCount() ? 'none' : '';\n      this.renderHorizontalScrollbar('e-frozenscrollbar e-frozen-right-scrollbar', display);\n    }\n\n    this.getMovableContent().style.flex = '1';\n  }\n\n  appendScrollbar(frozen, movable, isRight) {\n    const parent = this.parent.createElement('div', {\n      className: 'e-scrollbar',\n      styles: 'display: flex'\n    });\n\n    if (this.parent.getFrozenLeftColumnsCount()) {\n      if (!isRight) {\n        parent.appendChild(frozen);\n        parent.appendChild(movable);\n      } else {\n        this.parent.getContent().querySelector('.e-scrollbar').appendChild(frozen);\n        return;\n      }\n    } else {\n      parent.appendChild(movable);\n      parent.appendChild(frozen);\n    }\n\n    this.parent.getContent().appendChild(parent);\n  }\n\n  renderFrozenRightPanelAlone() {\n    this.renderFrozenRigthPanel();\n    let mDiv = this.parent.element.querySelector('.' + movableContent);\n    let fRightContent = this.parent.element.querySelector('.e-frozen-right-content');\n\n    if (isNullOrUndefined(fRightContent)) {\n      mDiv = this.parent.createElement('div', {\n        className: movableContent\n      });\n      fRightContent = this.parent.createElement('div', {\n        className: 'e-frozencontent e-frozen-right-content'\n      });\n      this.getPanel().querySelector('.' + content).appendChild(mDiv);\n      this.getPanel().querySelector('.' + content).appendChild(fRightContent);\n    }\n\n    super.setMovableContent(mDiv);\n    this.setFrozenRightContent(fRightContent);\n  }\n\n  renderFrozenLeftWithRightPanel() {\n    this.renderFrozenRigthPanel();\n    let fRightContent = this.parent.element.querySelector('.e-frozen-right-content');\n\n    if (isNullOrUndefined(fRightContent)) {\n      fRightContent = this.parent.createElement('div', {\n        className: 'e-frozencontent e-frozen-right-content'\n      });\n      this.getPanel().querySelector('.' + content).appendChild(fRightContent);\n    }\n\n    this.setFrozenRightContent(fRightContent);\n  }\n\n  renderFrozenRightTableAlone() {\n    let mTbl;\n\n    if (this.getFrozenRightContent().querySelector('.' + table) == null) {\n      super.renderFrozenRightTable();\n      this.getFrozenRightContent().appendChild(this.getTable());\n      mTbl = this.getTable().cloneNode(true);\n      this.getMovableContent().appendChild(mTbl);\n    } else {\n      if (this.parent.frozenRows) {\n        this.parent.getHeaderContent().classList.add('e-frozenhdrcont');\n      }\n\n      this.setTable(this.getFrozenRightContent().querySelector('.' + table));\n      this.setColGroup(this.getFrozenRightHeaderColGroup());\n      mTbl = this.getMovableContent().querySelector('.' + table);\n      this.getFrozenRightContent().querySelector('.' + table).appendChild(this.getColGroup());\n    }\n\n    if (this.getMovableContent().querySelector(colGroup)) {\n      remove(this.getMovableContent().querySelector(colGroup));\n    }\n\n    const colgroup = this.parent.getHeaderContent().querySelector('.' + movableHeader).querySelector(colGroup).cloneNode(true);\n    mTbl.insertBefore(colgroup, mTbl.querySelector(tbody));\n  }\n\n  renderFrozenLeftWithRightTable() {\n    const frozenRight$$1 = this.getTable().cloneNode(true);\n    this.getFrozenRightContent().appendChild(frozenRight$$1);\n    const oldColGroup = this.getFrozenRightContent().querySelector(colGroup);\n\n    if (oldColGroup) {\n      remove(oldColGroup);\n    }\n\n    const rightTable = this.getFrozenRightContent().querySelector('.' + table);\n    rightTable.insertBefore(this.getFrozenRightHeaderColGroup(), rightTable.querySelector(tbody));\n  }\n\n  renderFrozenRightEmptyRowAlone(tbody$$1) {\n    super.renderFrozenRightEmpty(tbody$$1);\n    this.getMovableContent().querySelector(tbody).innerHTML = '<tr><td></td></tr>';\n    addClass([this.parent.getMovableContentTbody().querySelector('tr')], ['e-emptyrow']);\n    this.getFrozenRightContent().querySelector('.e-emptyrow').querySelector('td').colSpan = this.parent.getVisibleFrozenRightCount();\n\n    if (this.parent.frozenRows) {\n      this.parent.getFrozenRightHeaderTbody().innerHTML = '';\n      this.parent.getMovableHeaderTbody().innerHTML = '';\n    }\n  }\n  /**\n   * @param {string} tableName - specfies the table name\n   * @returns {HTMLElement} returns the element\n   * @hidden\n   */\n\n\n  getFrozenHeader(tableName) {\n    if (tableName === frozenLeft) {\n      return this.parent.getHeaderContent().querySelector('.e-frozen-left-header').querySelector(tbody);\n    } else if (tableName === 'movable') {\n      return this.parent.getHeaderContent().querySelector('.' + movableHeader).querySelector(tbody);\n    } else {\n      return this.parent.getHeaderContent().querySelector('.e-frozen-right-header').querySelector(tbody);\n    }\n  }\n\n  renderFrozenLeftWithRightEmptyRow() {\n    this.getFrozenRightContent().querySelector(tbody).innerHTML = '<tr><td></td></tr>';\n    addClass([this.getFrozenRightContent().querySelector(tbody).querySelector('tr')], ['e-emptyrow']);\n\n    if (this.parent.frozenRows) {\n      this.parent.getHeaderContent().querySelector('.e-frozen-right-header').querySelector(tbody).innerHTML = '';\n    }\n  }\n\n  setFrozenRightContent(ele) {\n    this.frozenRigthContent = ele;\n  }\n\n  getFrozenRightContent() {\n    return this.frozenRigthContent;\n  }\n\n  getHeaderColGroup() {\n    let colGroup$$1 = this.parent.element.querySelector('.' + gridHeader).querySelector(colGroup).cloneNode(true);\n\n    if (!this.parent.getFrozenLeftColumnsCount()) {\n      const right = this.getFrozenRightHeaderColGroup();\n      colGroup$$1 = right && this.frzCount ? right.cloneNode(true) : colGroup$$1;\n      this.frzCount++;\n      this.isColGroupRefresh = true;\n    }\n\n    return colGroup$$1;\n  }\n\n  getFrozenRightHeaderColGroup() {\n    let col = this.parent.getHeaderContent().querySelector('.e-frozen-right-header').querySelector(colGroup);\n\n    if (!col) {\n      col = this.parent.getHeaderContent().querySelector(colGroup);\n    }\n\n    return col.cloneNode(true);\n  }\n\n  setColGroup(colGroup$$1) {\n    if (this.parent.getFrozenLeftColumnsCount()) {\n      return super.setColGroup(colGroup$$1);\n    } else {\n      colGroup$$1 = !this.isColGroupRefresh ? this.getFrozenRightHeaderColGroup() : colGroup$$1;\n\n      if (!isNullOrUndefined(colGroup$$1)) {\n        colGroup$$1.id = 'content-' + colGroup$$1.id;\n      }\n\n      this.isColGroupRefresh = false;\n\n      if (this.frzCount === 2) {\n        this.frzCount = 0;\n      }\n\n      return this.colgroup = colGroup$$1;\n    }\n  }\n\n  renderEmpty(tbody$$1) {\n    if (this.parent.getFrozenLeftColumnsCount()) {\n      super.renderEmpty(tbody$$1);\n      this.getFrozenContent().querySelector('.e-emptyrow').querySelector('td').colSpan = this.parent.getVisibleFrozenLeftCount();\n\n      if (this.parent.getFrozenRightColumnsCount()) {\n        this.renderFrozenLeftWithRightEmptyRow();\n      }\n    } else {\n      this.renderFrozenRightEmptyRowAlone(tbody$$1);\n    }\n\n    this.parent.notify(freezeRender, {\n      case: 'refreshHeight'\n    });\n  }\n\n  setHeightToContent(height) {\n    if (this.parent.getFrozenRightColumnsCount()) {\n      this.getFrozenRightContent().style.height = height.toString() + 'px';\n    }\n\n    if (this.parent.getFrozenLeftColumnsCount()) {\n      this.getFrozenContent().style.height = height.toString() + 'px';\n    }\n\n    this.getMovableContent().style.height = height.toString() + 'px';\n  }\n\n  actionComplete(args) {\n    super.actionComplete(args);\n  }\n\n  batchAdd(args) {\n    super.batchAdd(args);\n  }\n  /**\n   * @param {freezeTable} tableName - specfies the table name\n   * @returns {Element} - returns the element\n   * @hidden\n   */\n\n\n  getTbody(tableName) {\n    let tbody$$1;\n\n    if (tableName === frozenLeft) {\n      tbody$$1 = this.parent.getFrozenLeftContentTbody();\n    } else if (tableName === 'movable') {\n      tbody$$1 = this.parent.getMovableContentTbody();\n    } else if (tableName === frozenRight) {\n      tbody$$1 = this.parent.getFrozenRightContentTbody();\n    }\n\n    return tbody$$1;\n  }\n  /**\n   * @param {NotifyArgs} args - specfies the args\n   * @param {freezeTable} tableName - specfies the freeze table\n   * @returns {void}\n   * @hidden\n   */\n\n\n  setIsFrozen(args, tableName) {\n    args.isFrozen = tableName === frozenLeft || this.parent.getFrozenMode() === 'Right' && tableName === frozenRight;\n    args.renderFrozenRightContent = this.parent.getFrozenMode() === leftRight && tableName === frozenRight;\n    args.renderMovableContent = tableName === 'movable';\n  }\n  /**\n   * @param {Element} tbody - specfies the element\n   * @param {DocumentFragment | HTMLElement} frag - specfies the frag\n   * @param {NotifyArgs} args - specfies the args\n   * @param {freezeTable} tableName - specfies the tableName\n   * @returns {void}\n   * @hidden\n   */\n\n\n  appendContent(tbody$$1, frag, args, tableName) {\n    if (!isNullOrUndefined(this.parent.rowTemplate) && this.parent.isReact) {\n      tbody$$1 = frag;\n    } else {\n      tbody$$1.appendChild(frag);\n    }\n\n    if (this.parent.getFrozenMode() === 'Left') {\n      if (tableName === frozenLeft) {\n        this.isLoaded = false;\n        this.getFrozenContent().querySelector('table').appendChild(tbody$$1);\n        this.refreshContentRows(extend({}, args));\n      } else {\n        this.refreshTbody(tbody$$1);\n        this.isLoaded = true;\n        this.getMovableContent().querySelector('table').appendChild(tbody$$1);\n        this.refreshHeight();\n        this.refreshScrollOffset();\n      }\n    } else if (this.parent.getFrozenMode() === 'Right') {\n      if (tableName === 'movable') {\n        this.refreshTbody(tbody$$1);\n        this.isLoaded = true;\n        this.getMovableContent().querySelector('table').appendChild(tbody$$1);\n        this.refreshHeight();\n        this.refreshScrollOffset();\n      } else {\n        this.isLoaded = false;\n        this.getFrozenRightContent().querySelector('table').appendChild(tbody$$1);\n        this.refreshContentRows(extend({}, args));\n      }\n    } else if (this.parent.getFrozenMode() === leftRight) {\n      if (tableName === frozenLeft) {\n        this.isLoaded = false;\n        this.getFrozenContent().querySelector('table').appendChild(tbody$$1);\n        this.refreshContentRows(extend({}, args));\n      } else if (tableName === 'movable') {\n        this.refreshTbody(tbody$$1);\n        this.isLoaded = false;\n        this.getMovableContent().querySelector('table').appendChild(tbody$$1);\n        this.refreshContentRows(extend({}, args));\n      } else {\n        this.isLoaded = true;\n        this.getFrozenRightContent().querySelector('table').appendChild(tbody$$1);\n        this.refreshHeight();\n        this.refreshScrollOffset();\n      }\n    }\n\n    if (this.isInitialRender) {\n      this.parent.scrollModule.setHeight();\n      this.isInitialRender = false;\n    }\n\n    this.widthService.refreshFrozenScrollbar();\n  }\n\n  refreshHeight() {\n    if (!this.parent.allowTextWrap) {\n      this.parent.notify(freezeRender, {\n        case: 'refreshHeight'\n      });\n    }\n  }\n  /**\n   * @param {freezeTable} tableName - specifies the table\n   * @returns {void}\n   * @hidden\n   */\n\n\n  splitRows(tableName) {\n    const left = this.parent.getFrozenLeftColumnsCount();\n    const right = this.parent.getFrozenRightColumnsCount();\n\n    if (left && !right) {\n      if (tableName === frozenLeft) {\n        this.freezeRows = this.rows;\n        this.freezeRowElements = this.rowElements;\n      } else {\n        this.movableRows = this.rows;\n      }\n    } else if (!left && right) {\n      if (tableName === 'movable') {\n        this.movableRows = this.rows;\n      } else {\n        this.freezeRows = this.rows;\n        this.freezeRowElements = this.rowElements;\n      }\n    } else if (left && right) {\n      if (tableName === frozenLeft) {\n        this.freezeRows = this.rows;\n        this.freezeRowElements = this.rowElements;\n      } else if (tableName === 'movable') {\n        this.movableRows = this.rows;\n        this.movableRowElements = this.rowElements;\n      } else {\n        this.frozenRightRows = this.rows;\n        this.frozenRightRowElements = this.rowElements;\n      }\n    }\n  }\n  /**\n   * Get the Freeze pane movable content table data row elements\n   *\n   * @returns {Element} returns the element\n   */\n\n\n  getMovableRowElements() {\n    if (this.parent.getFrozenMode() !== leftRight) {\n      return this.rowElements;\n    } else {\n      return this.movableRowElements;\n    }\n  }\n  /**\n   * Get the Freeze pane frozen right content table data row elements\n   *\n   * @returns {Element} returns the Element\n   */\n\n\n  getFrozenRightRowElements() {\n    if (this.parent.getFrozenMode() !== leftRight) {\n      return this.freezeRowElements;\n    } else {\n      return this.frozenRightRowElements;\n    }\n  }\n  /**\n   * Get the frozen right row collection in the Freeze pane Grid.\n   *\n   * @returns {Row[] | HTMLCollectionOf<HTMLTableRowElement>} returns the row object\n   */\n\n\n  getFrozenRightRows() {\n    if (this.parent.getFrozenMode() === leftRight) {\n      if (this.parent.enableInfiniteScrolling) {\n        return this.rightFreezeRows;\n      }\n\n      return this.frozenRightRows;\n    } else {\n      return this.getRows();\n    }\n  }\n  /**\n   * @param {number} index - specifies the index\n   * @returns {Element} returns the element\n   * @hidden\n   */\n\n\n  getFrozenRightRowByIndex(index) {\n    return this.parent.getFrozenRightDataRows()[index];\n  }\n  /**\n   * Get the Row collection in the Grid.\n   *\n   * @returns {Row[] | HTMLCollectionOf<HTMLTableRowElement>} returns the row object\n   */\n\n\n  getRows() {\n    const infiniteRows = this.getInfiniteRows();\n    return infiniteRows.length ? infiniteRows : this.freezeRows;\n  }\n  /**\n   * Get the content table data row elements\n   *\n   * @returns {Element} returns the element\n   */\n\n\n  getRowElements() {\n    return this.freezeRowElements;\n  }\n\n}\n/**\n * VirtualFreezeRenderer is used to render the virtual table within the frozen and movable content table\n *\n * @hidden\n */\n\n\nclass VirtualFreezeRenderer extends FreezeContentRender {\n  constructor(parent, locator) {\n    super(parent, locator);\n    /** @hidden */\n\n    this.frzRows = [];\n    /** @hidden */\n\n    this.mvblRows = [];\n    /** @hidden */\n\n    this.frRows = [];\n    this.serviceLoc = locator;\n    this.eventListener('on');\n    this.rowModelGenerator = new RowModelGenerator(this.parent);\n  }\n\n  eventListener(action) {\n    this.parent[action](getVirtualData, this.getVirtualData, this);\n    this.parent[action](setFreezeSelection, this.setFreezeSelection, this);\n    this.parent[action](refreshVirtualFrozenRows, this.refreshVirtualFrozenRows, this);\n    this.parent.addEventListener(actionComplete, this.actionComplete.bind(this));\n  }\n\n  actionComplete(args) {\n    if (args.requestType === 'delete' && this.parent.frozenRows) {\n      for (let i = 0; i < this.parent.frozenRows; i++) {\n        setCache(this, i);\n      }\n    }\n  }\n\n  refreshVirtualFrozenRows(args) {\n    const gObj = this.parent;\n\n    if (args.requestType === 'delete' && gObj.frozenRows) {\n      args.isFrozenRowsRender = true;\n      const query = gObj.renderModule.data.generateQuery(true).clone();\n      query.page(1, gObj.pageSettings.pageSize);\n      gObj.renderModule.data.getData({}, query).then(e => {\n        renderFrozenRows(args, e.result, gObj.getSelectedRowIndexes(), gObj, this.rowModelGenerator, this.serviceLoc, this.virtualRenderer, this);\n      });\n    }\n  }\n\n  getVirtualData(data) {\n    this.virtualRenderer.getVirtualData(data);\n  }\n\n  setFreezeSelection(args) {\n    setFreezeSelection$1(args, this.virtualRenderer);\n  }\n  /**\n   * @returns {void}\n   * @hidden\n   */\n\n\n  renderTable() {\n    this.freezeRowGenerator = new FreezeRowModelGenerator(this.parent);\n    this.virtualRenderer = new VirtualContentRenderer(this.parent, this.serviceLoc);\n    this.virtualRenderer.header = this.serviceLoc.getService('rendererFactory').getRenderer(RenderType.Header).virtualHdrRenderer;\n    super.renderTable();\n    this.virtualRenderer.setPanel(this.parent.getContent());\n    this.scrollbar = this.parent.getContent().querySelector('.e-movablescrollbar');\n    const movableCont = this.getMovableContent();\n    const minHeight = this.parent.height;\n    this.virtualRenderer.virtualEle.content = this.virtualRenderer.content = this.getPanel().querySelector('.' + content);\n    this.virtualRenderer.virtualEle.content.style.overflowX = 'hidden';\n    this.virtualRenderer.virtualEle.renderFrozenWrapper(minHeight);\n    this.virtualRenderer.virtualEle.renderFrozenPlaceHolder();\n\n    if (this.parent.enableColumnVirtualization) {\n      this.virtualRenderer.virtualEle.movableContent = this.virtualRenderer.movableContent = this.getPanel().querySelector('.' + movableContent);\n      this.virtualRenderer.virtualEle.renderMovableWrapper(minHeight);\n      this.virtualRenderer.virtualEle.renderMovablePlaceHolder();\n      const tbl = movableCont.querySelector('table');\n      this.virtualRenderer.virtualEle.movableTable = tbl;\n      this.virtualRenderer.virtualEle.movableWrapper.appendChild(tbl);\n      movableCont.appendChild(this.virtualRenderer.virtualEle.movableWrapper);\n      movableCont.appendChild(this.virtualRenderer.virtualEle.movablePlaceholder);\n    }\n\n    this.virtualRenderer.virtualEle.wrapper.appendChild(this.getFrozenContent());\n    this.virtualRenderer.virtualEle.wrapper.appendChild(movableCont);\n    this.virtualRenderer.virtualEle.table = this.getTable();\n    setDebounce(this.parent, this.virtualRenderer, this.scrollbar, this.getMovableContent());\n  }\n  /**\n   * @param {HTMLElement} target - specifies the target\n   * @param {DocumentFragment} newChild - specifies the newChild\n   * @param {NotifyArgs} e - specifies the notifyargs\n   * @returns {void}\n   * @hidden\n   */\n\n\n  appendContent(target, newChild, e) {\n    appendContent(this.virtualRenderer, this.widthService, target, newChild, e);\n  }\n  /**\n   * @param {Object[]} data - specifies the data\n   * @param {NotifyArgs} notifyArgs - specifies the notifyargs\n   * @returns {Row<Column>[]} returns the row\n   * @hidden\n   */\n\n\n  generateRows(data, notifyArgs) {\n    if (!this.firstPageRecords) {\n      this.firstPageRecords = data;\n    }\n\n    return generateRows(this.virtualRenderer, data, notifyArgs, this.freezeRowGenerator, this.parent);\n  }\n  /**\n   * @param {number} index - specifies the index\n   * @returns {Element} returns the element\n   * @hidden\n   */\n\n\n  getRowByIndex(index) {\n    return this.virtualRenderer.getRowByIndex(index);\n  }\n  /**\n   * @param {number} index - specifies the index\n   * @returns {Element} returns the element\n   * @hidden\n   */\n\n\n  getMovableRowByIndex(index) {\n    return this.virtualRenderer.getMovableVirtualRowByIndex(index);\n  }\n\n  collectRows(tableName) {\n    return collectRows(tableName, this.virtualRenderer, this.parent);\n  }\n  /**\n   * @returns {HTMLCollection} returns the Htmlcollection\n   * @hidden\n   */\n\n\n  getMovableRows() {\n    return this.collectRows('movable');\n  }\n  /**\n   * @returns {HTMLCollectionOf<HTMLTableRowElement>} returns the html collection\n   * @hidden\n   */\n\n\n  getRows() {\n    return this.collectRows('frozen-left');\n  }\n  /**\n   * @returns {Element} returns the element\n   * @hidden\n   */\n\n\n  getColGroup() {\n    const mCol = this.parent.getMovableVirtualContent();\n    return this.isXaxis() ? mCol.querySelector(colGroup) : this.colgroup;\n  }\n  /**\n   * @param {NotifyArgs} args - specifies the args\n   * @returns {Row<Column>[]} returns the row\n   * @hidden\n   */\n\n\n  getReorderedFrozenRows(args) {\n    return getReorderedFrozenRows(args, this.virtualRenderer, this.parent, this.freezeRowGenerator, this.firstPageRecords);\n  }\n\n  isXaxis() {\n    return isXaxis(this.virtualRenderer);\n  }\n\n  getHeaderCells() {\n    return getHeaderCells(this.virtualRenderer, this.parent);\n  }\n\n  getVirtualFreezeHeader() {\n    return getVirtualFreezeHeader(this.virtualRenderer, this.parent);\n  }\n\n  ensureFrozenCols(columns) {\n    return ensureFrozenCols(columns, this.parent);\n  }\n  /**\n   * @param {number} index - specifies the index\n   * @returns {object} returns the object\n   * @hidden\n   */\n\n\n  getRowObjectByIndex(index) {\n    return this.virtualRenderer.getRowObjectByIndex(index);\n  }\n  /**\n   * Set the header colgroup element\n   *\n   * @param {Element} colGroup - specifies the colgroup\n   * @returns {Element} returns the element\n   */\n\n\n  setColGroup(colGroup$$1) {\n    return setColGroup(colGroup$$1, this.virtualRenderer, this);\n  }\n\n}\n/**\n * VirtualFreezeHdrRenderer is used to render the virtual table within the frozen and movable header table\n *\n * @hidden\n */\n\n\nclass VirtualFreezeHdrRenderer extends FreezeRender {\n  constructor(parent, locator) {\n    super(parent, locator);\n    this.serviceLoc = locator;\n  }\n  /**\n   * @returns {void}\n   * @hidden\n   */\n\n\n  renderTable() {\n    this.virtualHdrRenderer = new VirtualHeaderRenderer(this.parent, this.serviceLoc);\n    this.virtualHdrRenderer.gen.refreshColOffsets();\n    this.parent.setColumnIndexesInView(this.virtualHdrRenderer.gen.getColumnIndexes(this.getPanel().querySelector('.' + headerContent)));\n    this.virtualHdrRenderer.virtualEle.content = this.getPanel().querySelector('.' + headerContent);\n    this.virtualHdrRenderer.virtualEle.renderFrozenWrapper();\n    this.virtualHdrRenderer.virtualEle.renderFrozenPlaceHolder();\n\n    if (this.parent.enableColumnVirtualization) {\n      this.virtualHdrRenderer.virtualEle.movableContent = this.getPanel().querySelector('.' + movableHeader);\n      this.virtualHdrRenderer.virtualEle.renderMovableWrapper();\n      this.virtualHdrRenderer.virtualEle.renderMovablePlaceHolder();\n    }\n\n    super.renderTable();\n    this.virtualHdrRenderer.setPanel(this.parent.getHeaderContent());\n  }\n\n  rfshMovable() {\n    this.getFrozenHeader().appendChild(this.getTable());\n    this.virtualHdrRenderer.virtualEle.wrapper.appendChild(this.getFrozenHeader());\n\n    if (this.parent.enableColumnVirtualization) {\n      this.virtualHdrRenderer.virtualEle.movableWrapper.appendChild(this.createHeader(undefined, 'movable'));\n    } else {\n      this.getMovableHeader().appendChild(this.createTable());\n    }\n\n    this.virtualHdrRenderer.virtualEle.wrapper.appendChild(this.getMovableHeader());\n  }\n\n}\n/**\n * @param {NotifyArgs} args - specifies the args\n * @param {Object[]} data - specifies the data\n * @param {number[]}selectedIdx - specifies the selected index\n * @param {IGrid} parent - specifies the IGrid\n * @param {IModelGenerator} rowModelGenerator - specifies the rowModeGenerator\n * @param {ServiceLocator} locator - specifies the locator\n * @param {VirtualContentRenderer} virtualRenderer - specifies the virtual renderer\n * @param {VirtualFreezeRenderer} instance - specifies the instance\n * @returns {void}\n * @hidden\n */\n\n\nfunction renderFrozenRows(args, data, selectedIdx, parent, rowModelGenerator, locator, virtualRenderer, instance) {\n  parent.clearSelection();\n  args.startIndex = 0;\n  const rowRenderer = new RowRenderer(locator, null, parent);\n  let rows = rowModelGenerator.generateRows(data, args);\n\n  if (args.renderMovableContent) {\n    virtualRenderer.vgenerator.movableCache[1] = rows;\n    rows = parent.getMovableRowsObject();\n  } else if (!args.renderFrozenRightContent && !args.renderMovableContent) {\n    virtualRenderer.vgenerator.cache[1] = rows;\n    rows = parent.getRowsObject();\n  } else if (args.renderFrozenRightContent) {\n    virtualRenderer.vgenerator.frozenRightCache[1] = rows;\n    rows = parent.getFrozenRightRowsObject();\n  }\n\n  const hdr = !args.renderMovableContent && !args.renderFrozenRightContent ? parent.getHeaderContent().querySelector('.' + frozenHeader).querySelector(tbody) : args.renderMovableContent ? parent.getHeaderContent().querySelector('.' + movableHeader).querySelector(tbody) : parent.getHeaderContent().querySelector('.e-frozen-right-header').querySelector(tbody);\n  hdr.innerHTML = '';\n\n  for (let i = 0; i < parent.frozenRows; i++) {\n    hdr.appendChild(rowRenderer.render(rows[i], parent.getColumns()));\n\n    if (selectedIdx.indexOf(i) > -1) {\n      rows[i].isSelected = true;\n\n      for (let k = 0; k < rows[i].cells.length; k++) {\n        rows[i].cells[k].isSelected = true;\n      }\n    }\n  }\n\n  if (args.renderMovableContent) {\n    instance.mvblRows = virtualRenderer.vgenerator.movableCache[1];\n  } else if (!args.renderMovableContent && !args.renderFrozenRightContent) {\n    instance.frzRows = virtualRenderer.vgenerator.cache[1];\n  } else if (args.renderFrozenRightContent) {\n    instance.frRows = virtualRenderer.vgenerator.frozenRightCache[1];\n  }\n\n  args.renderMovableContent = !args.renderMovableContent && !args.renderFrozenRightContent;\n  args.renderFrozenRightContent = parent.getFrozenMode() === leftRight && !args.renderMovableContent && !args.renderFrozenRightContent;\n\n  if (args.renderMovableContent || args.renderFrozenRightContent) {\n    renderFrozenRows(args, data, selectedIdx, parent, rowModelGenerator, locator, virtualRenderer, instance);\n\n    if (!args.renderMovableContent && !args.renderFrozenRightContent) {\n      args.isFrozenRowsRender = false;\n    }\n  }\n}\n/**\n * @param {Row<Column>[]} data - specifies the data\n * @param {freezeTable} tableName -specifies the table\n * @param {IGrid} parent - specifies the IGrid\n * @returns {Row<Column>[]} returns the row\n * @hidden\n */\n\n\nfunction splitCells(data, tableName, parent) {\n  const rows = [];\n\n  for (let i = 0; i < data.length; i++) {\n    rows.push(extend({}, data[i]));\n    rows[i].cells = splitFrozenRowObjectCells(parent, rows[i].cells, tableName);\n  }\n\n  return rows;\n}\n/**\n * @param {freezeTable} tableName - specifies the freeze tabel\n * @param {VirtualContentRenderer} virtualRenderer - specifies the virtual renderer\n * @param {IGrid} parent - specifies the IGrid\n * @returns {Row<Column>[]} returns the row\n * @hidden\n */\n\n\nfunction collectRows(tableName, virtualRenderer, parent) {\n  let rows = [];\n  let cache;\n\n  if (tableName === frozenLeft) {\n    cache = virtualRenderer.vgenerator.cache;\n  } else if (tableName === 'movable') {\n    cache = virtualRenderer.vgenerator.movableCache;\n  } else if (tableName === frozenRight) {\n    cache = parent.getFrozenMode() === 'Right' ? virtualRenderer.vgenerator.cache : virtualRenderer.vgenerator.frozenRightCache;\n  }\n\n  const keys = Object.keys(cache);\n\n  for (let i = 0; i < keys.length; i++) {\n    rows = [...rows, ...splitCells(cache[keys[i]], tableName, parent)];\n  }\n\n  return rows;\n}\n/**\n * @param {object} args - specifies the args\n * @param {string} args.uid - specifirs the uid\n * @param {boolean} args.set - specifies the set\n * @param {boolean} args.clearAll - specifies the boolean to clearall\n * @param {VirtualContentRenderer} virtualRenderer - specifies the virtual renderer\n * @returns {void}\n * @hidden\n */\n\n\nfunction setFreezeSelection$1(args, virtualRenderer) {\n  const leftKeys = Object.keys(virtualRenderer.vgenerator.cache);\n  const movableKeys = Object.keys(virtualRenderer.vgenerator.movableCache);\n  const rightKeys = Object.keys(virtualRenderer.vgenerator.frozenRightCache);\n\n  for (let i = 0; i < leftKeys.length; i++) {\n    selectFreezeRows(args, virtualRenderer.vgenerator.cache[leftKeys[i]]);\n  }\n\n  for (let i = 0; i < movableKeys.length; i++) {\n    selectFreezeRows(args, virtualRenderer.vgenerator.movableCache[movableKeys[i]]);\n  }\n\n  for (let i = 0; i < rightKeys.length; i++) {\n    selectFreezeRows(args, virtualRenderer.vgenerator.frozenRightCache[rightKeys[i]]);\n  }\n}\n/**\n * @param {Object} args - specifies the args\n * @param {string} args.uid - specifirs the uid\n * @param {boolean} args.set - specifies the set\n * @param {boolean} args.clearAll - specifies the boolean to clearall\n * @param {Row<Column>[]} cache - specifies the cache\n * @returns {void}\n * @hidden\n */\n\n\nfunction selectFreezeRows(args, cache) {\n  const rows = cache.filter(row$$1 => args.clearAll || args.uid === row$$1.uid);\n\n  for (let j = 0; j < rows.length; j++) {\n    rows[j].isSelected = args.set;\n    const cells = rows[j].cells;\n\n    for (let k = 0; k < cells.length; k++) {\n      cells[k].isSelected = args.set;\n    }\n  }\n}\n/**\n * @param {VirtualContentRenderer} virtualRenderer - specifies the virtual renderer\n * @param {ColumnWidthService} widthService - specifies the width service\n * @param {HTMLElement} target - specifies the target\n * @param {DocumentFragment} newChild - specifies the newchild\n * @param {NotifyArgs} e - specifies the notifyargs\n * @returns {void}\n * @hidden\n */\n\n\nfunction appendContent(virtualRenderer, widthService, target, newChild, e) {\n  virtualRenderer.appendContent(target, newChild, e);\n  widthService.refreshFrozenScrollbar();\n}\n/**\n * @param {VirtualContentRenderer} virtualRenderer - specifies the virtual renderer\n * @param {object[]} data - specifies the data\n * @param {NotifyArgs} notifyArgs - specifies the notifyargs\n * @param {FreezeRowModelGenerator} freezeRowGenerator - specifies the freeze row generator\n * @param {IGrid} parent - specifies the IGrid\n * @returns {Row<Column>[]} returns the row\n * @hidden\n */\n\n\nfunction generateRows(virtualRenderer, data, notifyArgs, freezeRowGenerator, parent) {\n  const virtualRows = virtualRenderer.vgenerator.generateRows(data, notifyArgs);\n  let arr = [];\n  arr = virtualRows.map(row$$1 => extend({}, row$$1));\n  let rows = freezeRowGenerator.generateRows(data, notifyArgs, arr);\n\n  if (parent.frozenRows && notifyArgs.requestType === 'delete' && parent.pageSettings.currentPage === 1) {\n    rows = rows.slice(parent.frozenRows);\n  }\n\n  return rows;\n}\n/**\n * @param {NotifyArgs} args -specifies the args\n * @param {VirtualContentRenderer} virtualRenderer - specifies the virtual renderer\n * @param {IGrid} parent - specifies the IGrid\n * @param {FreezeRowModelGenerator} freezeRowGenerator - specifies the freezeRowGenerator\n * @param {Object[]} firstPageRecords - specifies the first page records\n * @returns {Row<Column>[]} returns the row\n * @hidden\n */\n\n\nfunction getReorderedFrozenRows(args, virtualRenderer, parent, freezeRowGenerator, firstPageRecords) {\n  const bIndex = args.virtualInfo.blockIndexes;\n  const colIndex = args.virtualInfo.columnIndexes;\n  const page = args.virtualInfo.page;\n  args.virtualInfo.blockIndexes = [1, 2];\n  args.virtualInfo.page = 1;\n\n  if (!args.renderMovableContent) {\n    args.virtualInfo.columnIndexes = [];\n  }\n\n  const firstRecordslength = parent.getCurrentViewRecords().length;\n  firstPageRecords = parent.renderModule.data.dataManager.dataSource.json.slice(0, firstRecordslength);\n  const virtualRows = virtualRenderer.vgenerator.generateRows(firstPageRecords, args);\n  const rows = splitReorderedRows(virtualRows, parent, args, freezeRowGenerator);\n  args.virtualInfo.blockIndexes = bIndex;\n  args.virtualInfo.columnIndexes = colIndex;\n  args.virtualInfo.page = page;\n  return rows.splice(0, parent.frozenRows);\n}\n/**\n * @param {Row<Column>[]} rows - specifies the row\n * @param {IGrid} parent - specifies the IGrid\n * @param {NotifyArgs} args - specifies the notify arguments\n * @param {FreezeRowModelGenerator} freezeRowGenerator - specifies the freezerowgenerator\n * @returns {Row<Column>[]} returns the row\n * @hidden\n */\n\n\nfunction splitReorderedRows( // eslint-disable-next-line @typescript-eslint/no-unused-vars\nrows, parent, args, freezeRowGenerator) {\n  let tableName;\n\n  if (args.renderMovableContent) {\n    tableName = 'movable';\n  } else if (args.renderFrozenRightContent) {\n    tableName = 'frozen-right';\n  } else {\n    tableName = 'frozen-left';\n  }\n\n  for (let i = 0, len = rows.length; i < len; i++) {\n    rows[i].cells = splitFrozenRowObjectCells(parent, rows[i].cells, tableName);\n  }\n\n  return rows;\n}\n/**\n * @param {VirtualContentRenderer} virtualRenderer - specifies the VirtualRenderer\n * @returns {boolean} returns the isXaxis\n * @hidden\n */\n\n\nfunction isXaxis(virtualRenderer) {\n  let value = false;\n\n  if (virtualRenderer) {\n    value = virtualRenderer.requestType === 'virtualscroll' && virtualRenderer.currentInfo.sentinelInfo.axis === 'X';\n  }\n\n  return value;\n}\n/**\n * @param {VirtualContentRenderer} virtualRenderer - specifies the virtualrenderer\n * @param {IGrid} parent - specifies the IGrid\n * @returns {Element[]} returns the element\n * @hidden\n */\n\n\nfunction getHeaderCells(virtualRenderer, parent) {\n  const content$$1 = isXaxis(virtualRenderer) ? parent.getMovableVirtualHeader() : parent.getHeaderContent();\n  return content$$1 ? [].slice.call(content$$1.querySelectorAll('.e-headercell:not(.e-stackedheadercell)')) : [];\n}\n/**\n * @param {VirtualContentRenderer} virtualRenderer - specifies the virtual Renderer\n * @param {IGrid} parent - specifies the IGrid\n * @returns {Element} returns the element\n * @hidden\n */\n\n\nfunction getVirtualFreezeHeader(virtualRenderer, parent) {\n  let headerTable;\n\n  if (isXaxis(virtualRenderer)) {\n    headerTable = parent.getMovableVirtualHeader().querySelector('.' + table);\n  } else {\n    headerTable = parent.getFrozenVirtualHeader().querySelector('.' + table);\n  }\n\n  return headerTable;\n}\n/**\n * @param {Column[]} columns - specifies the columns\n * @param {IGrid} parent - specifies the IGrid\n * @returns {Column[]} returns the column[]\n * @hidden\n */\n\n\nfunction ensureFrozenCols(columns, parent) {\n  const frozenCols = parent.columns.slice(0, parent.getFrozenColumns());\n  columns = frozenCols.concat(columns);\n  return columns;\n}\n/**\n * @param {Element} colGroup - specifies the colGroup\n * @param {VirtualContentRenderer} virtualRenderer - specifies the virtual renderer\n * @param {ColumnVirtualFreezeRenderer} instance - specifies the instances\n * @returns {Element} returns the element\n * @hidden\n */\n\n\nfunction setColGroup(colGroup$$1, virtualRenderer, instance) {\n  if (!isXaxis(virtualRenderer)) {\n    if (!isNullOrUndefined(colGroup$$1)) {\n      colGroup$$1.id = 'content-' + colGroup$$1.id;\n    }\n\n    instance.colgroup = colGroup$$1;\n  }\n\n  return instance.colgroup;\n}\n/**\n * @param {VirtualFreezeRenderer} instance - specifies the instance\n * @param {number} index - specifies the index\n * @returns {void}\n * @hidden\n */\n\n\nfunction setCache(instance, index) {\n  if (instance.virtualRenderer.vgenerator.cache[1]) {\n    instance.virtualRenderer.vgenerator.cache[1][index] = instance.frzRows[index];\n  } else {\n    instance.virtualRenderer.vgenerator.cache[1] = instance.frzRows;\n  }\n\n  if (instance.virtualRenderer.vgenerator.movableCache[1]) {\n    instance.virtualRenderer.vgenerator.movableCache[1][index] = instance.mvblRows[index];\n  } else {\n    instance.virtualRenderer.vgenerator.movableCache[1] = instance.mvblRows;\n  }\n}\n/**\n * @param {IGrid} parent - specifies the IGrid\n * @param {VirtualContentRenderer} virtualRenderer - specifies the virtualRenderer\n * @param {Element} scrollbar - specifies the scrollbr\n * @param {Element} mCont - specifies the mCont\n * @returns {void}\n * @hidden\n */\n\n\nfunction setDebounce(parent, virtualRenderer, scrollbar, mCont) {\n  const debounceEvent = parent.dataSource instanceof DataManager && !parent.dataSource.dataSource.offline;\n  const opt = {\n    container: virtualRenderer.content,\n    pageHeight: virtualRenderer.getBlockHeight() * 2,\n    debounceEvent: debounceEvent,\n    axes: parent.enableColumnVirtualization ? ['X', 'Y'] : ['Y'],\n    scrollbar: scrollbar,\n    movableContainer: mCont\n  };\n  virtualRenderer.observer = new InterSectionObserver(virtualRenderer.virtualEle.wrapper, opt, virtualRenderer.virtualEle.movableWrapper);\n}\n/**\n * ColumnVirtualFreezeRenderer is used to render the virtual table within the frozen and movable content table\n *\n * @hidden\n */\n\n\nclass ColumnVirtualFreezeRenderer extends ColumnFreezeContentRenderer {\n  constructor(parent, locator) {\n    super(parent, locator);\n    /** @hidden */\n\n    this.frRows = [];\n    /** @hidden */\n\n    this.frzRows = [];\n    /** @hidden */\n\n    this.mvblRows = [];\n    this.serviceLoc = locator;\n    this.eventListener('on');\n    this.rowModelGenerator = new RowModelGenerator(this.parent);\n  }\n\n  actionComplete(args) {\n    if (args.requestType === 'delete' && this.parent.frozenRows) {\n      for (let i = 0; i < this.parent.frozenRows; i++) {\n        if (this.virtualRenderer.vgenerator.frozenRightCache[1]) {\n          this.virtualRenderer.vgenerator.frozenRightCache[1][i] = this.frRows.length ? this.frRows[i] : this.frzRows[i];\n        } else {\n          this.virtualRenderer.vgenerator.frozenRightCache[1] = this.frRows.length ? this.frRows : this.frzRows;\n          break;\n        }\n\n        setCache(this, i);\n      }\n    }\n  }\n\n  eventListener(action) {\n    this.parent.addEventListener(actionComplete, this.actionComplete.bind(this));\n    this.parent[action](refreshVirtualFrozenRows, this.refreshVirtualFrozenRows, this);\n    this.parent[action](getVirtualData, this.getVirtualData, this);\n    this.parent[action](setFreezeSelection, this.setFreezeSelection, this);\n  }\n\n  refreshVirtualFrozenRows(args) {\n    if (args.requestType === 'delete' && this.parent.frozenRows) {\n      args.isFrozenRowsRender = true;\n      const query = this.parent.renderModule.data.generateQuery(true).clone();\n      query.page(1, this.parent.pageSettings.pageSize);\n      const selectedIdx = this.parent.getSelectedRowIndexes();\n      this.parent.renderModule.data.getData({}, query).then(e => {\n        renderFrozenRows(args, e.result, selectedIdx, this.parent, this.rowModelGenerator, this.serviceLoc, this.virtualRenderer, this);\n      });\n    }\n  }\n\n  setFreezeSelection(args) {\n    setFreezeSelection$1(args, this.virtualRenderer);\n  }\n\n  getVirtualData(data) {\n    this.virtualRenderer.getVirtualData(data);\n  }\n\n  renderNextFrozentPart(e, tableName) {\n    e.renderMovableContent = this.parent.getFrozenLeftCount() ? tableName === frozenLeft : tableName === frozenRight;\n    e.renderFrozenRightContent = this.parent.getFrozenMode() === leftRight && tableName === 'movable';\n\n    if (e.renderMovableContent || e.renderFrozenRightContent) {\n      this.refreshContentRows(extend({}, e));\n    }\n  }\n  /**\n   * @returns {void}\n   * @hidden\n   */\n\n\n  renderTable() {\n    this.virtualRenderer = new VirtualContentRenderer(this.parent, this.serviceLoc);\n    this.virtualRenderer.header = this.serviceLoc.getService('rendererFactory').getRenderer(RenderType.Header).virtualHdrRenderer;\n    this.freezeRowGenerator = new FreezeRowModelGenerator(this.parent);\n    super.renderTable();\n    this.virtualRenderer.setPanel(this.parent.getContent());\n    this.scrollbar = this.parent.getContent().querySelector('.e-movablescrollbar');\n    const frozenRightCont = this.getFrozenRightContent();\n    let frzCont = this.getFrozenContent();\n    const movableCont = this.getMovableContent();\n\n    if (this.parent.getFrozenMode() === 'Right') {\n      frzCont = frozenRightCont;\n    }\n\n    this.virtualRenderer.virtualEle.content = this.virtualRenderer.content = this.getPanel().querySelector('.' + content);\n    this.virtualRenderer.virtualEle.content.style.overflowX = 'hidden';\n    const minHeight = this.parent.height;\n    this.virtualRenderer.virtualEle.renderFrozenWrapper(minHeight);\n    this.virtualRenderer.virtualEle.renderFrozenPlaceHolder();\n    this.renderVirtualFrozenLeft(frzCont, movableCont);\n    this.renderVirtualFrozenRight(frzCont, movableCont);\n    this.renderVirtualFrozenLeftRight(frzCont, movableCont, frozenRightCont);\n    this.virtualRenderer.virtualEle.table = this.getTable();\n    setDebounce(this.parent, this.virtualRenderer, this.scrollbar, this.getMovableContent());\n  }\n\n  renderVirtualFrozenLeft(frzCont, movableCont) {\n    if (this.parent.getFrozenMode() === 'Left') {\n      this.virtualRenderer.virtualEle.wrapper.appendChild(frzCont);\n      this.virtualRenderer.virtualEle.wrapper.appendChild(movableCont);\n    }\n  }\n\n  renderVirtualFrozenRight(frzCont, movableCont) {\n    if (this.parent.getFrozenMode() === 'Right') {\n      this.virtualRenderer.virtualEle.wrapper.appendChild(movableCont);\n      this.virtualRenderer.virtualEle.wrapper.appendChild(frzCont);\n    }\n  }\n\n  renderVirtualFrozenLeftRight(frzCont, movableCont, frozenRightCont) {\n    if (this.parent.getFrozenMode() === leftRight) {\n      this.virtualRenderer.virtualEle.wrapper.appendChild(frzCont);\n      this.virtualRenderer.virtualEle.wrapper.appendChild(movableCont);\n      this.virtualRenderer.virtualEle.wrapper.appendChild(frozenRightCont);\n    }\n  }\n  /**\n   * @param {HTMLElement} target - specifies the target\n   * @param {DocumentFragment} newChild - specifies the newchild\n   * @param {NotifyArgs} e - specifies the NotifyArgs\n   * @returns {void}\n   * @hidden\n   */\n\n\n  appendContent(target, newChild, e) {\n    appendContent(this.virtualRenderer, this.widthService, target, newChild, e);\n    this.refreshScrollOffset();\n  }\n  /**\n   * @param {Object[]} data - specifies the data\n   * @param {NotifyArgs} e - specifies the notifyargs\n   * @returns {Row<Column>[]} returns the row\n   * @hidden\n   */\n\n\n  generateRows(data, e) {\n    if (!this.firstPageRecords) {\n      this.firstPageRecords = data;\n    }\n\n    return generateRows(this.virtualRenderer, data, e, this.freezeRowGenerator, this.parent);\n  }\n  /**\n   * @param {number} index - specifies the number\n   * @returns {Element} returns the element\n   * @hidden\n   */\n\n\n  getRowByIndex(index) {\n    return this.virtualRenderer.getRowByIndex(index);\n  }\n  /**\n   * @param {number} index - specifies the index\n   * @returns {Element} - returns the element\n   * @hidden\n   */\n\n\n  getFrozenRightRowByIndex(index) {\n    return this.virtualRenderer.getFrozenRightVirtualRowByIndex(index);\n  }\n\n  collectRows(tableName) {\n    return collectRows(tableName, this.virtualRenderer, this.parent);\n  }\n  /**\n   * @param {number} index - specifies the index\n   * @returns {Element} returns the element\n   * @hidden\n   */\n\n\n  getMovableRowByIndex(index) {\n    return this.virtualRenderer.getMovableVirtualRowByIndex(index);\n  }\n  /**\n   * @returns {Row<Column>[]} returns the row\n   * @hidden\n   */\n\n\n  getFrozenRightRows() {\n    return this.collectRows('frozen-right');\n  }\n  /**\n   * @returns {Row<Column>[]} returns the row\n   * @hidden\n   */\n\n\n  getMovableRows() {\n    return this.collectRows('movable');\n  }\n  /**\n   * @returns {Element} returns the element\n   * @hidden\n   */\n\n\n  getColGroup() {\n    const mCol = this.parent.getMovableVirtualContent();\n    return isXaxis(this.virtualRenderer) ? mCol.querySelector(colGroup) : this.colgroup;\n  }\n  /**\n   * @returns {Row<Column>[]} returns the row\n   * @hidden\n   */\n\n\n  getRows() {\n    return this.collectRows(this.parent.getFrozenMode() === 'Right' ? 'frozen-right' : 'frozen-left');\n  }\n  /**\n   * @param {NotifyArgs} args - specifies the args\n   * @returns {Row<Column>[]} returns the row object\n   * @hidden\n   */\n\n\n  getReorderedFrozenRows(args) {\n    return getReorderedFrozenRows(args, this.virtualRenderer, this.parent, this.freezeRowGenerator, this.firstPageRecords);\n  }\n\n  getHeaderCells() {\n    return getHeaderCells(this.virtualRenderer, this.parent);\n  }\n\n  isXaxis() {\n    return isXaxis(this.virtualRenderer);\n  }\n\n  getVirtualFreezeHeader() {\n    return getVirtualFreezeHeader(this.virtualRenderer, this.parent);\n  }\n  /**\n   * @param {number} index - specifies the index\n   * @returns {object} - returns the object\n   * @hidden\n   */\n\n\n  getRowObjectByIndex(index) {\n    return this.virtualRenderer.getRowObjectByIndex(index);\n  }\n\n  ensureFrozenCols(columns) {\n    return ensureFrozenCols(columns, this.parent);\n  }\n  /**\n   * Set the header colgroup element\n   *\n   * @param {Element} colGroup - specifies the colgroup\n   * @returns {Element} - returns the element\n   */\n\n\n  setColGroup(colGroup$$1) {\n    return setColGroup(colGroup$$1, this.virtualRenderer, this);\n  }\n\n}\n/**\n * `Freeze` module is used to handle Frozen rows and columns.\n *\n * @hidden\n */\n\n\nclass Freeze {\n  constructor(parent, locator) {\n    this.parent = parent;\n    this.locator = locator;\n    this.addEventListener();\n  }\n\n  getModuleName() {\n    return 'freeze';\n  }\n\n  addEventListener() {\n    if (this.parent.isDestroyed) {\n      return;\n    }\n\n    this.parent.on(initialLoad, this.instantiateRenderer, this);\n    this.parent.on(destroy, this.destroy, this);\n  }\n\n  instantiateRenderer() {\n    this.parent.log('limitation', this.getModuleName());\n    const renderer = this.locator.getService('rendererFactory');\n\n    if (this.parent.getFrozenColumns()) {\n      if (this.parent.enableColumnVirtualization) {\n        renderer.addRenderer(RenderType.Header, new VirtualFreezeHdrRenderer(this.parent, this.locator));\n      } else {\n        renderer.addRenderer(RenderType.Header, new FreezeRender(this.parent, this.locator));\n      }\n\n      if (this.parent.enableVirtualization) {\n        renderer.addRenderer(RenderType.Content, new VirtualFreezeRenderer(this.parent, this.locator));\n      } else {\n        renderer.addRenderer(RenderType.Content, new FreezeContentRender(this.parent, this.locator));\n      }\n    }\n\n    if (this.parent.getFrozenLeftColumnsCount() || this.parent.getFrozenRightColumnsCount()) {\n      renderer.addRenderer(RenderType.Header, new ColumnFreezeHeaderRenderer(this.parent, this.locator));\n\n      if (this.parent.enableVirtualization) {\n        renderer.addRenderer(RenderType.Content, new ColumnVirtualFreezeRenderer(this.parent, this.locator));\n      } else {\n        renderer.addRenderer(RenderType.Content, new ColumnFreezeContentRenderer(this.parent, this.locator));\n      }\n    }\n  }\n\n  removeEventListener() {\n    if (this.parent.isDestroyed) {\n      return;\n    }\n\n    this.parent.off(initialLoad, this.instantiateRenderer);\n    this.parent.off(destroy, this.destroy);\n  }\n\n  destroy() {\n    this.removeEventListener();\n  }\n\n}\n/**\n * 'column menu module used to handle column menu actions'\n *\n * @hidden\n */\n\n\nclass ColumnMenu {\n  constructor(parent, serviceLocator) {\n    this.defaultItems = {};\n    this.localeText = this.setLocaleKey();\n    this.disableItems = [];\n    this.hiddenItems = [];\n    this.isOpen = false; // default class names\n\n    this.GROUP = 'e-icon-group';\n    this.UNGROUP = 'e-icon-ungroup';\n    this.ASCENDING = 'e-icon-ascending';\n    this.DESCENDING = 'e-icon-descending';\n    this.ROOT = 'e-columnmenu';\n    this.FILTER = 'e-icon-filter';\n    this.POP = 'e-filter-popup';\n    this.WRAP = 'e-col-menu';\n    this.CHOOSER = '_chooser_';\n    this.parent = parent;\n    this.gridID = parent.element.id;\n    this.serviceLocator = serviceLocator;\n    this.addEventListener();\n  }\n\n  wireEvents() {\n    const elements = this.getColumnMenuHandlers();\n\n    for (let i = 0; i < elements.length; i++) {\n      EventHandler.add(elements[i], 'mousedown', this.columnMenuHandlerDown, this);\n    }\n  }\n\n  unwireEvents() {\n    const elements = this.getColumnMenuHandlers();\n\n    for (let i = 0; i < elements.length; i++) {\n      EventHandler.remove(elements[i], 'mousedown', this.columnMenuHandlerDown);\n    }\n  }\n  /**\n   * To destroy the resize\n   *\n   * @returns {void}\n   * @hidden\n   */\n\n\n  destroy() {\n    const gridElement = this.parent.element;\n\n    if (!gridElement || !gridElement.querySelector('.' + gridHeader) && !gridElement.querySelector('.' + gridContent)) {\n      return;\n    }\n\n    this.columnMenu.destroy();\n    this.removeEventListener();\n    this.unwireFilterEvents();\n    this.unwireEvents();\n\n    if (this.element.parentNode) {\n      remove(this.element);\n    }\n  }\n\n  columnMenuHandlerClick(e) {\n    if (e.target.classList.contains('e-columnmenu')) {\n      this.columnMenu.items = this.getItems();\n      this.columnMenu.dataBind();\n\n      if (this.isOpen && this.headerCell !== this.getHeaderCell(e) || document.querySelector('.e-grid-menu .e-menu-parent.e-ul')) {\n        this.columnMenu.close();\n        this.openColumnMenu(e);\n      } else if (!this.isOpen) {\n        this.openColumnMenu(e);\n      } else {\n        this.columnMenu.close();\n      }\n    }\n  }\n  /**\n   * @param {string} field - specifies the field name\n   * @returns {void}\n   * @hidden\n   */\n\n\n  openColumnMenuByField(field) {\n    this.openColumnMenu({\n      target: this.parent.getColumnHeaderByField(field).querySelector('.e-columnmenu')\n    });\n  }\n\n  openColumnMenu(e) {\n    let pos = {\n      top: 0,\n      left: 0\n    };\n    this.element.style.cssText = 'display:block;visibility:hidden';\n    const elePos = this.element.getBoundingClientRect();\n    this.element.style.cssText = 'display:none;visibility:visible';\n    this.headerCell = this.getHeaderCell(e);\n\n    if (Browser.isDevice) {\n      pos.top = window.innerHeight / 2 - elePos.height / 2;\n      pos.left = window.innerWidth / 2 - elePos.width / 2;\n    } else {\n      if (this.parent.enableRtl) {\n        pos = calculatePosition(this.headerCell, 'left', 'bottom');\n      } else {\n        pos = calculatePosition(this.headerCell, 'right', 'bottom');\n        pos.left -= elePos.width;\n      }\n    }\n\n    this.columnMenu.open(pos.top, pos.left);\n\n    if (e.preventDefault) {\n      e.preventDefault();\n    }\n\n    applyBiggerTheme(this.parent.element, this.columnMenu.element.parentElement);\n  }\n\n  columnMenuHandlerDown() {\n    this.isOpen = !(this.element.style.display === 'none' || this.element.style.display === '');\n  }\n\n  getColumnMenuHandlers() {\n    return [].slice.call(this.parent.getHeaderTable().getElementsByClassName(this.ROOT));\n  }\n  /**\n   * @returns {void}\n   * @hidden\n   */\n\n\n  addEventListener() {\n    if (this.parent.isDestroyed) {\n      return;\n    }\n\n    this.parent.on(headerRefreshed, this.wireEvents, this);\n    this.parent.on(uiUpdate, this.enableAfterRenderMenu, this);\n    this.parent.on(initialEnd, this.render, this);\n\n    if (this.isFilterItemAdded()) {\n      this.parent.on(filterDialogCreated, this.filterPosition, this);\n    }\n\n    this.parent.on(click, this.columnMenuHandlerClick, this);\n    this.parent.on(keyPressed, this.keyPressHandler, this);\n    this.parent.on(destroy, this.destroy, this);\n  }\n  /**\n   * @returns {void}\n   * @hidden\n   */\n\n\n  removeEventListener() {\n    if (this.parent.isDestroyed) {\n      return;\n    }\n\n    this.parent.off(headerRefreshed, this.unwireEvents);\n    this.parent.off(uiUpdate, this.enableAfterRenderMenu);\n    this.parent.off(initialEnd, this.render);\n\n    if (this.isFilterItemAdded()) {\n      this.parent.off(filterDialogCreated, this.filterPosition);\n    }\n\n    this.parent.off(click, this.columnMenuHandlerClick);\n    this.parent.off(keyPressed, this.keyPressHandler);\n    this.parent.off(destroy, this.destroy);\n  }\n\n  keyPressHandler(e) {\n    const gObj = this.parent;\n\n    if (e.action === 'altDownArrow') {\n      const element = gObj.focusModule.currentInfo.element;\n\n      if (element && element.classList.contains('e-headercell')) {\n        const column = gObj.getColumnByUid(element.firstElementChild.getAttribute('e-mappinguid'));\n        this.openColumnMenuByField(column.field);\n      }\n    }\n  }\n\n  enableAfterRenderMenu(e) {\n    if (e.module === this.getModuleName() && e.enable) {\n      if (this.columnMenu) {\n        this.columnMenu.destroy();\n        remove(this.element);\n      }\n\n      this.render();\n    }\n  }\n\n  render() {\n    this.l10n = this.serviceLocator.getService('localization');\n    this.element = this.parent.createElement('ul', {\n      id: this.gridID + '_columnmenu',\n      className: 'e-colmenu'\n    });\n    this.element.setAttribute('aria-label', this.l10n.getConstant('ColumnMenuDialogARIA'));\n    this.parent.element.appendChild(this.element);\n    this.columnMenu = new ContextMenu({\n      cssClass: 'e-grid-menu',\n      enableRtl: this.parent.enableRtl,\n      enablePersistence: this.parent.enablePersistence,\n      locale: this.parent.locale,\n      items: this.getItems(),\n      select: this.columnMenuItemClick.bind(this),\n      beforeOpen: this.columnMenuBeforeOpen.bind(this),\n      onOpen: this.columnMenuOnOpen.bind(this),\n      onClose: this.columnMenuOnClose.bind(this),\n      beforeItemRender: this.beforeMenuItemRender.bind(this),\n      beforeClose: this.columnMenuBeforeClose.bind(this)\n    });\n    this.columnMenu.appendTo(this.element);\n    this.wireFilterEvents();\n  }\n\n  wireFilterEvents() {\n    if (!Browser.isDevice && this.isFilterItemAdded()) {\n      EventHandler.add(this.element, 'mouseover', this.appendFilter, this);\n    }\n  }\n\n  unwireFilterEvents() {\n    if (!Browser.isDevice && this.isFilterItemAdded()) {\n      EventHandler.remove(this.element, 'mouseover', this.appendFilter);\n    }\n  }\n\n  beforeMenuItemRender(args) {\n    if (this.isChooserItem(args.item)) {\n      const field = this.getKeyFromId(args.item.id, this.CHOOSER);\n      const column = this.parent.columnModel.filter(col => col.field === field);\n      const check = createCheckBox(this.parent.createElement, false, {\n        label: args.item.text,\n        checked: column[0].visible\n      });\n\n      if (this.parent.enableRtl) {\n        check.classList.add('e-rtl');\n      }\n\n      args.element.innerHTML = '';\n      args.element.appendChild(check);\n    } else if (args.item.id && this.getKeyFromId(args.item.id) === 'Filter') {\n      args.element.appendChild(this.parent.createElement('span', {\n        className: 'e-icons e-caret'\n      }));\n      args.element.className += 'e-filter-item e-menu-caret-icon';\n    }\n  }\n\n  columnMenuBeforeClose(args) {\n    const colChooser = args.event ? closest(args.event.target, '.e-menu-item') : null;\n\n    if (!isNullOrUndefined(args.parentItem) && this.getKeyFromId(args.parentItem.id) === 'ColumnChooser' && colChooser && this.isChooserItem(colChooser)) {\n      args.cancel = true;\n    } else if (args.event && (closest(args.event.target, '.' + this.POP) || args.event.currentTarget && args.event.currentTarget.activeElement && parentsUntil(args.event.currentTarget.activeElement, 'e-filter-popup') || parentsUntil(args.event.target, 'e-popup') || parentsUntil(args.event.target, 'e-popup-wrapper')) && !Browser.isDevice) {\n      args.cancel = true;\n    }\n  }\n\n  isChooserItem(item) {\n    return item.id && item.id.indexOf('_colmenu_') >= 0 && this.getKeyFromId(item.id, this.CHOOSER).indexOf('_colmenu_') === -1;\n  }\n\n  columnMenuBeforeOpen(args) {\n    args.column = this.targetColumn = this.getColumn();\n    this.parent.trigger(columnMenuOpen, args);\n\n    for (const item of args.items) {\n      const key = this.getKeyFromId(item.id);\n      const dItem = this.defaultItems[key];\n\n      if (this.getDefaultItems().indexOf(key) !== -1 && this.ensureDisabledStatus(key) && !dItem.hide) {\n        this.disableItems.push(item.text);\n      }\n\n      if (item.hide) {\n        this.hiddenItems.push(item.text);\n      }\n    }\n\n    this.columnMenu.enableItems(this.disableItems, false);\n    this.columnMenu.hideItems(this.hiddenItems);\n  }\n\n  columnMenuOnOpen(args) {\n    if (args.element.className === 'e-menu-parent e-ul ') {\n      if (args.element.offsetHeight > window.innerHeight || this.parent.element.offsetHeight > window.innerHeight) {\n        args.element.style.maxHeight = window.innerHeight * 0.8 + 'px';\n        args.element.style.overflowY = 'auto';\n      }\n    }\n  }\n\n  ensureDisabledStatus(item) {\n    let status = false;\n\n    switch (item) {\n      case 'Group':\n        if (!this.parent.allowGrouping || this.parent.ensureModuleInjected(Group) && this.targetColumn && this.parent.groupSettings.columns.indexOf(this.targetColumn.field) >= 0 || this.targetColumn && !this.targetColumn.allowGrouping) {\n          status = true;\n        }\n\n        break;\n\n      case 'AutoFitAll':\n      case 'AutoFit':\n        status = !this.parent.ensureModuleInjected(Resize);\n        break;\n\n      case 'Ungroup':\n        if (!this.parent.ensureModuleInjected(Group) || this.parent.ensureModuleInjected(Group) && this.targetColumn && this.parent.groupSettings.columns.indexOf(this.targetColumn.field) < 0) {\n          status = true;\n        }\n\n        break;\n\n      case 'SortDescending':\n      case 'SortAscending':\n        if (this.parent.allowSorting && this.parent.ensureModuleInjected(Sort) && this.parent.sortSettings.columns.length > 0 && this.targetColumn && this.targetColumn.allowSorting) {\n          const sortColumns = this.parent.sortSettings.columns;\n\n          for (let i = 0; i < sortColumns.length; i++) {\n            if (sortColumns[i].field === this.targetColumn.field && sortColumns[i].direction.toLocaleLowerCase() === item.toLocaleLowerCase().replace('sort', '')) {\n              status = true;\n            }\n          }\n        } else if (!this.parent.allowSorting || !this.parent.ensureModuleInjected(Sort) || this.parent.allowSorting && this.targetColumn && !this.targetColumn.allowSorting) {\n          status = true;\n        }\n\n        break;\n\n      case 'Filter':\n        if (this.parent.allowFiltering && this.parent.filterSettings.type !== 'FilterBar' && this.parent.ensureModuleInjected(Filter) && this.targetColumn && this.targetColumn.allowFiltering) {\n          status = false;\n        } else if (this.parent.ensureModuleInjected(Filter) && this.parent.allowFiltering && this.targetColumn && (!this.targetColumn.allowFiltering || this.parent.filterSettings.type === 'FilterBar')) {\n          status = true;\n        }\n\n    }\n\n    return status;\n  }\n\n  columnMenuItemClick(args) {\n    const item = this.isChooserItem(args.item) ? 'ColumnChooser' : this.getKeyFromId(args.item.id);\n\n    switch (item) {\n      case 'AutoFit':\n        this.parent.autoFitColumns(this.targetColumn.field);\n        break;\n\n      case 'AutoFitAll':\n        this.parent.autoFitColumns([]);\n        break;\n\n      case 'Ungroup':\n        this.parent.ungroupColumn(this.targetColumn.field);\n        break;\n\n      case 'Group':\n        this.parent.groupColumn(this.targetColumn.field);\n        break;\n\n      case 'SortAscending':\n        this.parent.sortColumn(this.targetColumn.field, 'Ascending');\n        break;\n\n      case 'SortDescending':\n        this.parent.sortColumn(this.targetColumn.field, 'Descending');\n        break;\n\n      case 'ColumnChooser':\n        // eslint-disable-next-line no-case-declarations\n        const key = this.getKeyFromId(args.item.id, this.CHOOSER); // eslint-disable-next-line no-case-declarations\n\n        const checkbox = args.element.querySelector('.e-checkbox-wrapper .e-frame');\n\n        if (checkbox && checkbox.classList.contains('e-check')) {\n          checkbox.classList.remove('e-check');\n          this.parent.hideColumns(key, 'field');\n        } else if (checkbox) {\n          this.parent.showColumns(key, 'field');\n          checkbox.classList.add('e-check');\n        }\n\n        break;\n\n      case 'Filter':\n        this.getFilter(args.element, args.item.id);\n        break;\n    }\n\n    args.column = this.targetColumn;\n    this.parent.trigger(columnMenuClick, args);\n  }\n\n  columnMenuOnClose(args) {\n    const parent = 'parentObj';\n\n    if (args.items.length > 0 && args.items[0][parent] instanceof ContextMenu) {\n      this.columnMenu.enableItems(this.disableItems, false);\n      this.disableItems = [];\n      this.columnMenu.showItems(this.hiddenItems);\n      this.hiddenItems = [];\n\n      if (this.isFilterPopupOpen()) {\n        this.getFilter(args.element, args.element.id, true);\n      }\n    }\n\n    if (!this.parent.isFrozenGrid()) {\n      this.parent.notify(restoreFocus, {});\n    }\n  }\n\n  getDefaultItems() {\n    return ['AutoFitAll', 'AutoFit', 'SortAscending', 'SortDescending', 'Group', 'Ungroup', 'ColumnChooser', 'Filter'];\n  }\n\n  getItems() {\n    const items = [];\n    const defultItems = this.parent.columnMenuItems ? this.parent.columnMenuItems : this.getDefault();\n\n    for (const item of defultItems) {\n      if (typeof item === 'string') {\n        if (item === 'ColumnChooser') {\n          const col = this.getDefaultItem(item);\n          col.items = this.createChooserItems();\n          items.push(col);\n        } else {\n          items.push(this.getDefaultItem(item));\n        }\n      } else {\n        items.push(item);\n      }\n    }\n\n    return items;\n  }\n\n  getDefaultItem(item) {\n    let menuItem = {};\n\n    switch (item) {\n      case 'SortAscending':\n        menuItem = {\n          iconCss: this.ASCENDING\n        };\n        break;\n\n      case 'SortDescending':\n        menuItem = {\n          iconCss: this.DESCENDING\n        };\n        break;\n\n      case 'Group':\n        menuItem = {\n          iconCss: this.GROUP\n        };\n        break;\n\n      case 'Ungroup':\n        menuItem = {\n          iconCss: this.UNGROUP\n        };\n        break;\n\n      case 'Filter':\n        menuItem = {\n          iconCss: this.FILTER\n        };\n        break;\n    }\n\n    this.defaultItems[item] = {\n      text: this.getLocaleText(item),\n      id: this.generateID(item),\n      iconCss: menuItem.iconCss ? 'e-icons ' + menuItem.iconCss : null\n    };\n    return this.defaultItems[item];\n  }\n\n  getLocaleText(item) {\n    return this.l10n.getConstant(this.localeText[item]);\n  }\n\n  generateID(item, append$$1) {\n    return this.gridID + '_colmenu_' + (append$$1 ? append$$1 + item : item);\n  }\n\n  getKeyFromId(id, append$$1) {\n    return id.indexOf('_colmenu_') > 0 && id.replace(this.gridID + '_colmenu_' + (append$$1 ? append$$1 : ''), '');\n  }\n  /**\n   * @returns {HTMLElement} returns the HTMLElement\n   * @hidden\n   */\n\n\n  getColumnMenu() {\n    return this.element;\n  }\n\n  getModuleName() {\n    return 'columnMenu';\n  }\n\n  setLocaleKey() {\n    const localeKeys = {\n      'AutoFitAll': 'autoFitAll',\n      'AutoFit': 'autoFit',\n      'Group': 'Group',\n      'Ungroup': 'Ungroup',\n      'SortAscending': 'SortAscending',\n      'SortDescending': 'SortDescending',\n      'ColumnChooser': 'Columnchooser',\n      'Filter': 'FilterMenu'\n    };\n    return localeKeys;\n  }\n\n  getHeaderCell(e) {\n    return closest(e.target, 'th.e-headercell');\n  }\n\n  getColumn() {\n    if (this.headerCell) {\n      const uid = this.headerCell.querySelector('.e-headercelldiv').getAttribute('e-mappinguid');\n      return this.parent.getColumnByUid(uid);\n    }\n\n    return null;\n  }\n\n  createChooserItems() {\n    const items = [];\n\n    for (const col of this.parent.columnModel) {\n      if (col.showInColumnChooser && col.field) {\n        items.push({\n          id: this.generateID(col.field, this.CHOOSER),\n          text: col.headerText ? col.headerText : col.field\n        });\n      }\n    }\n\n    return items;\n  }\n\n  appendFilter(e) {\n    const filter = 'Filter';\n\n    if (!this.defaultItems[filter]) {\n      return;\n    } else {\n      const key = this.defaultItems[filter].id;\n\n      if (closest(e.target, '#' + key) && !this.isFilterPopupOpen()) {\n        this.getFilter(e.target, key);\n      } else if (!closest(e.target, '#' + key) && this.isFilterPopupOpen()) {\n        this.getFilter(e.target, key, true);\n      }\n    }\n  }\n\n  getFilter(target, id, isClose) {\n    const filterPopup = this.getFilterPop();\n\n    if (filterPopup) {\n      filterPopup.style.display = !Browser.isDevice && isClose ? 'none' : 'block';\n    } else {\n      this.parent.notify(filterOpen, {\n        col: this.targetColumn,\n        target: target,\n        isClose: isClose,\n        id: id\n      });\n    }\n  }\n\n  setPosition(li, ul) {\n    const gridPos = this.parent.element.getBoundingClientRect();\n    const liPos = li.getBoundingClientRect();\n    let left = liPos.left - gridPos.left;\n    let top = liPos.top - gridPos.top;\n\n    if (gridPos.height < top) {\n      top = top - ul.offsetHeight + liPos.height;\n    } else if (gridPos.height < top + ul.offsetHeight) {\n      top = gridPos.height - ul.offsetHeight;\n    }\n\n    if (window.innerHeight < ul.offsetHeight + top + gridPos.top) {\n      top = window.innerHeight - ul.offsetHeight - gridPos.top;\n    }\n\n    if (top + gridPos.top < 0) {\n      top = 0;\n    }\n\n    left += this.parent.enableRtl ? -ul.offsetWidth : liPos.width;\n\n    if (gridPos.width <= left + ul.offsetWidth) {\n      left -= liPos.width + ul.offsetWidth;\n\n      if (liPos.left < ul.offsetWidth) {\n        left = liPos.left + ul.offsetWidth / 2;\n      }\n    } else if (left < 0) {\n      left += ul.offsetWidth + liPos.width;\n    }\n\n    ul.style.top = top + 'px';\n    ul.style.left = left + 'px';\n  }\n\n  filterPosition() {\n    const filterPopup = this.getFilterPop();\n    filterPopup.classList.add(this.WRAP);\n\n    if (!Browser.isDevice) {\n      const disp = filterPopup.style.display;\n      filterPopup.style.cssText += 'display:block;visibility:hidden';\n      const li = this.element.querySelector('.' + this.FILTER);\n\n      if (li) {\n        this.setPosition(li.parentElement, filterPopup);\n        filterPopup.style.cssText += 'display:' + disp + ';visibility:visible';\n      }\n    }\n  }\n\n  getDefault() {\n    const items = [];\n\n    if (this.parent.ensureModuleInjected(Resize)) {\n      items.push('AutoFitAll');\n      items.push('AutoFit');\n    }\n\n    if (this.parent.allowGrouping && this.parent.ensureModuleInjected(Group)) {\n      items.push('Group');\n      items.push('Ungroup');\n    }\n\n    if (this.parent.allowSorting && this.parent.ensureModuleInjected(Sort)) {\n      items.push('SortAscending');\n      items.push('SortDescending');\n    }\n\n    items.push('ColumnChooser');\n\n    if (this.parent.allowFiltering && this.parent.filterSettings.type !== 'FilterBar' && this.parent.ensureModuleInjected(Filter)) {\n      items.push('Filter');\n    }\n\n    return items;\n  }\n\n  isFilterPopupOpen() {\n    const filterPopup = this.getFilterPop();\n    return filterPopup && filterPopup.style.display !== 'none';\n  }\n\n  getFilterPop() {\n    if (Browser.isDevice && this.targetColumn !== null && this.parent.filterSettings.type === 'Menu') {\n      return document.getElementById(this.targetColumn.uid + '-flmdlg');\n    }\n\n    return this.parent.element.querySelector('.' + this.POP);\n  }\n\n  isFilterItemAdded() {\n    return this.parent.columnMenuItems && this.parent.columnMenuItems.indexOf('Filter') >= 0 || !this.parent.columnMenuItems;\n  }\n\n}\n/**\n * `ForeignKey` module is used to handle foreign key column's actions.\n */\n\n\nclass ForeignKey extends Data {\n  constructor(parent, serviceLocator) {\n    super(parent, serviceLocator);\n    this.parent = parent;\n    this.serviceLocator = serviceLocator;\n    this.initEvent();\n  }\n\n  initEvent() {\n    if (this.parent.isDestroyed) {\n      return;\n    }\n\n    this.parent.on(initForeignKeyColumn, this.initForeignKeyColumns, this);\n    this.parent.on(getForeignKeyData, this.getForeignKeyData, this);\n    this.parent.on(generateQuery, this.generateQueryFormData, this);\n  }\n\n  initForeignKeyColumns(columns) {\n    for (let i = 0; i < columns.length; i++) {\n      columns[i].dataSource = columns[i].dataSource instanceof DataManager ? columns[i].dataSource : isNullOrUndefined(columns[i].dataSource) ? new DataManager() : 'result' in columns[i].dataSource ? columns[i].dataSource : new DataManager(columns[i].dataSource);\n    }\n  }\n\n  eventfPromise(args, query, key, column) {\n    const state = this.getStateEventArgument(query);\n    const def = new Deferred();\n    const deff = new Deferred();\n    state.action = args.action;\n    const dataModule = this.parent.getDataModule();\n\n    if (!isNullOrUndefined(args.action) && args.action.requestType && dataModule.foreignKeyDataState.isDataChanged !== false) {\n      dataModule.setForeignKeyDataState({\n        isPending: true,\n        resolver: deff.resolve\n      });\n      deff.promise.then(() => {\n        def.resolve(column.dataSource);\n      });\n      state.setColumnData = this.parent.setForeignKeyData.bind(this.parent);\n      this.parent.trigger(columnDataStateChange, state);\n    } else {\n      dataModule.setForeignKeyDataState({});\n      def.resolve(key);\n    }\n\n    return def;\n  }\n\n  getForeignKeyData(args) {\n    const foreignColumns = args.column ? [args.column] : this.parent.getForeignKeyColumns();\n    const allPromise = [];\n\n    for (let i = 0; i < foreignColumns.length; i++) {\n      let promise;\n      const query = args.isComplex ? this.genarateColumnQuery(foreignColumns[i]) : this.genarateQuery(foreignColumns[i], args.result.result, false, true);\n      query.params = this.parent.query.params;\n      const dataSource = foreignColumns[i].dataSource;\n\n      if (dataSource && 'result' in dataSource) {\n        const def = this.eventfPromise(args, query, dataSource, foreignColumns[i]);\n        promise = def.promise;\n      } else if (!dataSource.ready || dataSource.dataSource.offline) {\n        promise = dataSource.executeQuery(query);\n      } else {\n        promise = dataSource.ready.then(() => {\n          return dataSource.executeQuery(query);\n        });\n      }\n\n      allPromise.push(promise);\n    }\n\n    Promise.all(allPromise).then(responses => {\n      for (let i = 0; i < responses.length; i++) {\n        foreignColumns[i].columnData = responses[i].result;\n\n        if (foreignColumns[i].editType === 'dropdownedit' && 'result' in foreignColumns[i].dataSource) {\n          foreignColumns[i].edit.params = extend(foreignColumns[i].edit.params, {\n            dataSource: responses[i].result,\n            query: new Query(),\n            fields: {\n              value: foreignColumns[i].foreignKeyField || foreignColumns[i].field,\n              text: foreignColumns[i].foreignKeyValue\n            }\n          });\n        }\n      }\n\n      args.promise.resolve(args.result);\n    }).catch(e => {\n      this.parent.log(['actionfailure', 'foreign_key_failure']);\n\n      if (args.promise && args.promise.reject) {\n        args.promise.reject(e);\n      }\n\n      return e;\n    });\n  }\n\n  generateQueryFormData(args) {\n    args.predicate.predicate = this.genarateQuery(args.column, args.column.columnData, true);\n  }\n\n  genarateQuery(column, e, fromData, needQuery) {\n    const gObj = this.parent;\n    const predicates = [];\n    const query = new Query();\n    let field = fromData ? column.foreignKeyField : column.field;\n\n    if (gObj.allowPaging || gObj.enableVirtualization || fromData) {\n      e = new DataManager(gObj.allowGrouping && gObj.groupSettings.columns.length && !fromData ? e.records : e).executeLocal(new Query().select(field));\n      const filteredValue = DataUtil.distinct(e, field, false);\n      field = fromData ? column.field : column.foreignKeyField;\n\n      for (let i = 0; i < filteredValue.length; i++) {\n        if (filteredValue[i] && filteredValue[i].getDay) {\n          predicates.push(getDatePredicate({\n            field: field,\n            operator: 'equal',\n            value: filteredValue[i],\n            matchCase: false\n          }));\n        } else {\n          predicates.push(new Predicate(field, 'equal', filteredValue[i], false));\n        }\n      }\n    }\n\n    if (needQuery) {\n      return predicates.length ? query.where(Predicate.or(predicates)) : query;\n    }\n\n    return predicates.length ? Predicate.or(predicates) : {\n      predicates: []\n    };\n  }\n\n  genarateColumnQuery(column) {\n    const gObj = this.parent;\n    let query = new Query();\n    const queryColumn = this.isFiltered(column);\n\n    if (queryColumn.isTrue) {\n      query = this.filterQuery(query, queryColumn.column, true);\n    }\n\n    if (gObj.searchSettings.key.length) {\n      const sSettings = gObj.searchSettings;\n\n      if (column.dataSource instanceof DataManager && column.dataSource.adaptor.getModuleName && column.dataSource.adaptor.getModuleName() === 'ODataV4Adaptor') {\n        query = this.searchQuery(query, column, true);\n      } else {\n        query.search(sSettings.key, column.foreignKeyValue, sSettings.operator, sSettings.ignoreCase);\n      }\n    }\n\n    return query;\n  }\n\n  isFiltered(column) {\n    const filterColumn = this.parent.filterSettings.columns.filter(fColumn => {\n      return fColumn.field === column.foreignKeyValue && fColumn.uid === column.uid;\n    });\n    return {\n      column: filterColumn,\n      isTrue: !!filterColumn.length\n    };\n  }\n\n  getModuleName() {\n    return 'foreignKey';\n  }\n\n  destroy() {\n    this.destroyEvent();\n  }\n\n  destroyEvent() {\n    if (this.parent.isDestroyed) {\n      return;\n    }\n\n    this.parent.off(initForeignKeyColumn, this.initForeignKeyColumns);\n    this.parent.off(getForeignKeyData, this.getForeignKeyData);\n    this.parent.off(generateQuery, this.generateQueryFormData);\n  }\n\n}\n/**\n *\n * `Logger` class\n */\n\n\nconst BASE_DOC_URL = 'https://ej2.syncfusion.com/documentation/grid';\nconst DOC_URL = 'https://ej2.syncfusion.com/documentation/';\nconst WARNING = '[EJ2Grid.Warning]';\nconst ERROR = '[EJ2Grid.Error]';\nconst INFO = '[EJ2Grid.Info]';\n\nclass Logger {\n  constructor(parent) {\n    this.parent = parent;\n    this.parent.on('initial-end', this.patchadaptor, this);\n  }\n\n  getModuleName() {\n    return 'logger';\n  }\n\n  log(types, args) {\n    if (!(types instanceof Array)) {\n      types = [types];\n    }\n\n    const type = types;\n\n    for (let i = 0; i < type.length; i++) {\n      const item = detailLists[type[i]];\n      const cOp = item.check(args, this.parent);\n\n      if (cOp.success) {\n        // eslint-disable-next-line no-console\n        console[item.logType](item.generateMessage(args, this.parent, cOp.options));\n      }\n    }\n  }\n\n  patchadaptor() {\n    const adaptor = this.parent.getDataModule().dataManager.adaptor;\n    const original = adaptor.beforeSend;\n\n    if (original) {\n      adaptor.beforeSend = (dm, request, settings) => {\n        original.call(adaptor, dm, request, settings);\n      };\n    }\n  }\n\n  destroy() {\n    if (this.parent.isDestroyed) {\n      return;\n    }\n\n    this.parent.off('initial-end', this.patchadaptor);\n  }\n\n}\n\nconst detailLists = {\n  // eslint-disable-next-line camelcase\n  module_missing: {\n    type: 'module_missing',\n    logType: 'warn',\n\n    check(args, parent) {\n      const injected = parent.getInjectedModules().map(m => m.prototype.getModuleName()); // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n      const modules = parent.requiredModules().map(m => m.member).filter(name => injected.indexOf(name) === -1);\n      return {\n        success: modules.filter(m => m !== 'resize').length > 0,\n        options: modules\n      };\n    },\n\n    generateMessage(args, parent, modules) {\n      modules = modules.filter(m => m !== 'resize').reduce((prev, cur) => prev + `* ${cur}\\n`, '');\n      return WARNING + ': MODULES MISSING\\n' + 'The following modules are not injected:.\\n' + `${modules}` + `Refer to ${BASE_DOC_URL}/module.html for documentation on importing feature modules.`;\n    }\n\n  },\n  // eslint-disable-next-line camelcase\n  promise_enabled: {\n    type: 'promise_enabled',\n    logType: 'error',\n\n    check() {\n      return {\n        success: typeof Promise === 'undefined'\n      };\n    },\n\n    generateMessage() {\n      return ERROR + ': PROMISE UNDEFINED\\n' + 'Promise object is not present in the global environment,' + 'please use polyfil to support Promise object in your environment.\\n' + `Refer to ${DOC_URL}/base/browser.html?#required-polyfills for more information.`;\n    }\n\n  },\n  // eslint-disable-next-line camelcase\n  primary_column_missing: {\n    type: 'primary_column_missing',\n    logType: 'warn',\n\n    check(args, parent) {\n      return {\n        success: parent.getColumns().filter(column => column.isPrimaryKey).length === 0\n      };\n    },\n\n    generateMessage() {\n      return WARNING + ': PRIMARY KEY MISSING\\n' + 'Editing is enabled but primary key column is not specified.\\n' + `Refer to ${BASE_DOC_URL}/api-column.html?#isprimarykey for documentation on providing primary key columns.`;\n    }\n\n  },\n  // eslint-disable-next-line camelcase\n  selection_key_missing: {\n    type: 'selection_key_missing',\n    logType: 'warn',\n\n    check(args, parent) {\n      return {\n        success: parent.selectionSettings.persistSelection && parent.getColumns().filter(column => column.isPrimaryKey).length === 0\n      };\n    },\n\n    generateMessage() {\n      return WARNING + ': PRIMARY KEY MISSING\\n' + 'selectionSettings.persistSelection property is enabled. It requires one primary key column to persist selection.\\n' + `Refer to ${BASE_DOC_URL}/api-column.html?#isprimarykey for documentation on providing primary key columns.`;\n    }\n\n  },\n  actionfailure: {\n    type: 'actionfailure',\n    logType: 'error',\n\n    check() {\n      return {\n        success: true\n      };\n    },\n\n    generateMessage(args, parent) {\n      let message = '';\n      const formatError = formatErrorHandler(args, parent);\n      const ajaxError = ajaxErrorHandler(args, parent);\n\n      if (ajaxError !== '') {\n        message = ajaxError;\n      } else if (formatError !== '') {\n        message = formatError;\n      } else {\n        message = args.error;\n      }\n\n      return WARNING + ': ' + message;\n    }\n\n  },\n  // eslint-disable-next-line camelcase\n  locale_missing: {\n    type: 'locale_missing',\n    logType: 'warn',\n\n    check(args, parent) {\n      const lObj = DataUtil.getObject(`locale.${parent.locale}.grid`, L10n);\n      return {\n        success: parent.locale !== 'en-US' && isNullOrUndefined(lObj)\n      };\n    },\n\n    generateMessage(args, parent) {\n      return WARNING + ': LOCALE CONFIG MISSING\\n' + `Locale configuration for '${parent.locale}' is not provided.\\n` + `Refer to ${BASE_DOC_URL}/globalization-and-localization.html?#localization \n             for documentation on setting locale configuration.`;\n    }\n\n  },\n  limitation: {\n    type: 'limitation',\n    logType: 'warn',\n\n    check(args, parent) {\n      const name = args;\n      let opt;\n\n      switch (name) {\n        case 'freeze':\n          opt = {\n            success: parent.allowGrouping || !isUndefined(parent.detailTemplate) || !isUndefined(parent.childGrid) || !isUndefined(parent.rowTemplate) || parent.enableVirtualization,\n            options: {\n              name: 'freeze'\n            }\n          };\n          break;\n\n        case 'virtualization':\n          opt = {\n            success: !isUndefined(parent.detailTemplate) || !isUndefined(parent.childGrid) || parent.frozenRows !== 0 || parent.frozenColumns !== 0,\n            options: {\n              name: 'virtualization'\n            }\n          };\n          break;\n\n        default:\n          opt = {\n            success: false\n          };\n          break;\n      }\n\n      return opt;\n    },\n\n    generateMessage(args, parent, options) {\n      const name = options.name;\n      let opt;\n\n      switch (name) {\n        case 'freeze':\n          opt = 'Frozen rows and columns do not support the following features:\\n' + '* Virtualization\\n' + '* Row Template\\n' + '* Details Template\\n' + '* Hierarchy Grid\\n' + '* Grouping';\n          break;\n\n        case 'virtualization':\n          opt = 'Virtualization does not support the following features.\\n' + '* Freeze rows and columns.\\n' + '* Details Template.\\n' + '* Hierarchy Grid.\\n';\n          break;\n\n        default:\n          opt = '';\n          break;\n      }\n\n      return WARNING + `: ${name.toUpperCase()} LIMITATIONS\\n` + opt;\n    }\n\n  },\n  // eslint-disable-next-line camelcase\n  check_datasource_columns: {\n    type: 'check_datasource_columns',\n    logType: 'warn',\n\n    check(args, parent) {\n      return {\n        success: !(parent.columns.length || parent.dataSource instanceof DataManager || parent.dataSource.length)\n      };\n    },\n\n    generateMessage() {\n      return WARNING + ': GRID CONFIG MISSING\\n' + 'dataSource and columns are not provided in the grid. ' + 'At least one of either must be provided for grid configuration.\\n' + `Refer to ${BASE_DOC_URL}/columns.html for documentation on configuring the grid data and columns.`;\n    }\n\n  },\n  // eslint-disable-next-line camelcase\n  virtual_height: {\n    type: 'virtual_height',\n    logType: 'error',\n\n    check(args, parent) {\n      return {\n        success: isNullOrUndefined(parent.height) || parent.height === 'auto'\n      };\n    },\n\n    generateMessage() {\n      return ERROR + ': GRID HEIGHT MISSING \\n' + 'height property is required to use virtualization.\\n' + `Refer to ${BASE_DOC_URL}/virtual.html for documentation on configuring the virtual grid.`;\n    }\n\n  },\n  // eslint-disable-next-line camelcase\n  grid_remote_edit: {\n    type: 'grid_remote_edit',\n    logType: 'error',\n\n    check(args) {\n      return {\n        success: Array.isArray(args) || Array.isArray(args.result)\n      };\n    },\n\n    generateMessage() {\n      return ERROR + ': RETRUN VALUE MISSING  \\n' + 'Remote service returns invalid data. \\n' + `Refer to ${BASE_DOC_URL}/edit.html for documentation on configuring editing with remote data.`;\n    }\n\n  },\n  // eslint-disable-next-line camelcase\n  grid_sort_comparer: {\n    type: 'grid_sort_comparer',\n    logType: 'warn',\n\n    check(args, parent) {\n      return {\n        success: parent.getDataModule().isRemote()\n      };\n    },\n\n    generateMessage() {\n      return WARNING + ': SORT COMPARER NOT WORKING  \\n' + 'Sort comparer will not work with remote data.' + `Refer to ${BASE_DOC_URL}/sorting/#custom-sort-comparer for documentation on using the sort comparer.`;\n    }\n\n  },\n  // eslint-disable-next-line camelcase\n  resize_min_max: {\n    type: 'resize_min_max',\n    logType: 'info',\n\n    check(args) {\n      return {\n        success: args.column.minWidth && args.column.minWidth >= args.width || args.column.maxWidth && args.column.maxWidth <= args.width\n      };\n    },\n\n    generateMessage() {\n      return INFO + ': RESIZING COLUMN REACHED MIN OR MAX  \\n' + 'The column resizing width is at its min or max.';\n    }\n\n  },\n  // eslint-disable-next-line camelcase\n  action_disabled_column: {\n    type: 'action_disabled_column',\n    logType: 'info',\n\n    check(args) {\n      const success = true;\n      let fn;\n\n      switch (args.moduleName) {\n        case 'reorder':\n          if (isNullOrUndefined(args.destColumn)) {\n            fn = `reordering action is disabled for the ${args.column.headerText} column`;\n          } else {\n            fn = `reordering action is disabled for the ${args.column.allowReordering ? args.destColumn.headerText : args.column.headerText} column`;\n          }\n\n          break;\n\n        case 'group':\n          fn = `grouping action is disabled for the ${args.columnName} column.`;\n          break;\n\n        case 'filter':\n          fn = `filtering action is disabled for the ${args.columnName} column.`;\n          break;\n\n        case 'sort':\n          fn = `sorting action is disabled for the ${args.columnName} column.`;\n          break;\n      }\n\n      return {\n        success: success,\n        options: {\n          fn\n        }\n      };\n    },\n\n    generateMessage(args, parent, options) {\n      return INFO + `: ACTION DISABLED \\n ${options.fn}`;\n    }\n\n  },\n  // eslint-disable-next-line camelcase\n  exporting_begin: {\n    type: 'exporting_begin',\n    logType: 'info',\n\n    check(args) {\n      return {\n        success: true,\n        options: {\n          args\n        }\n      };\n    },\n\n    generateMessage(args, parent, options) {\n      return INFO + `: EXPORTNIG INPROGRESS \\n Grid ${options.args}ing is in progress`;\n    }\n\n  },\n  // eslint-disable-next-line camelcase\n  exporting_complete: {\n    type: 'exporting_complete',\n    logType: 'info',\n\n    check(args) {\n      return {\n        success: true,\n        options: {\n          args\n        }\n      };\n    },\n\n    generateMessage(args, parent, options) {\n      return INFO + `: EXPORTNIG COMPLETED \\n Grid ${options.args}ing is complete`;\n    }\n\n  },\n  // eslint-disable-next-line camelcase\n  foreign_key_failure: {\n    type: 'foreign_key_failure',\n    logType: 'error',\n\n    check() {\n      return {\n        success: true\n      };\n    },\n\n    generateMessage() {\n      return ERROR + ': FOREIGNKEY CONFIG \\n  Grid foreign key column needs a valid data source/service.' + `Refer to ${BASE_DOC_URL}/columns/#foreign-key-column for documentation on configuring foreign key columns.`;\n    }\n\n  },\n  // eslint-disable-next-line camelcase\n  initial_action: {\n    type: 'initial_action',\n    logType: 'error',\n\n    check(args) {\n      const success = true;\n      let fn;\n\n      switch (args.moduleName) {\n        case 'group':\n          fn = `The ${args.columnName} column is not available in the grid's column model.` + 'Please provide a valid field name to group the column';\n          break;\n\n        case 'filter':\n          fn = `The ${args.columnName} column is not available in the grid's column model.` + 'Please provide a valid field name to filter the column.';\n          break;\n\n        case 'sort':\n          fn = `The ${args.columnName} column is not available in the grid's column model.` + 'Please provide a valid field name to sort the column.';\n          break;\n      }\n\n      return {\n        success: success,\n        options: {\n          fn\n        }\n      };\n    },\n\n    generateMessage(args, parent, options) {\n      return ERROR + `: INITIAL ACTION FAILURE \\n ${options.fn}`;\n    }\n\n  },\n  // eslint-disable-next-line camelcase\n  frozen_rows_columns: {\n    type: 'frozen_rows_columns',\n    logType: 'error',\n\n    check(args, parent) {\n      return {\n        success: parent.getColumns().length <= parent.frozenColumns || parent.frozenRows >= parent.currentViewData.length\n      };\n    },\n\n    generateMessage(args, parent) {\n      return ERROR + `: OUT OF RANGE ERROR-\\n ${parent.getColumns().length <= parent.frozenColumns ? 'FROZEN COLUMNS,' : ''}` + `${parent.frozenRows >= parent.currentViewData.length ? 'FROZEN ROWS' : ''} invalid`;\n    }\n\n  },\n  // eslint-disable-next-line camelcase\n  column_type_missing: {\n    type: 'column_type_missing',\n    logType: 'error',\n\n    check(args) {\n      return {\n        success: isNullOrUndefined(args.column.type),\n        options: args.column.headerText\n      };\n    },\n\n    generateMessage(args, parent, options) {\n      return ERROR + `: COLUMN TYPE MISSING-\\n  ${options} column type was invalid or not defined.` + `Please go through below help link: ${DOC_URL}/grid/columns/#column-type`;\n    }\n\n  },\n  // eslint-disable-next-line camelcase\n  datasource_syntax_mismatch: {\n    type: 'datasource_syntax_mismatch',\n    logType: 'warn',\n\n    check(args) {\n      return {\n        success: args.dataState.dataSource && !(args.dataState.dataSource instanceof DataManager || 'result' in args.dataState.dataSource || args.dataState.dataSource instanceof Array) && !isNullOrUndefined(args.dataState.dataStateChange)\n      };\n    },\n\n    generateMessage() {\n      return WARNING + ': DATASOURCE SYNTAX WARNING\\n' + 'DataSource should be in the form of {result: Object[], count: number}' + 'when dataStateChangeEvent used';\n    }\n\n  }\n};\n\nconst formatErrorHandler = args => {\n  const error = args.error;\n\n  if (error.indexOf && error.indexOf('Format options') !== 0) {\n    return '';\n  }\n\n  return 'INVALID FORMAT\\n' + 'For more information, refer to the following documentation links:\\n' + `Number format: ${DOC_URL}/base/intl.html?#supported-format-string.\\n` + `Date format: ${DOC_URL}/base/intl.html?#manipulating-datetime.\\n` + `Message: ${error}`;\n};\n\nconst ajaxErrorHandler = args => {\n  const error = DataUtil.getObject('error.error', args);\n\n  if (isNullOrUndefined(error)) {\n    return '';\n  }\n\n  let jsonResult = '';\n\n  try {\n    jsonResult = JSON.parse(error.responseText);\n  } catch (_a) {\n    jsonResult = '';\n  }\n\n  return 'XMLHTTPREQUEST FAILED\\n' + `Url: ${error.responseURL}\\n` + `Status: ${error.status} - ${error.statusText}\\n` + `${jsonResult !== '' ? 'Message: ' + jsonResult : ''}`;\n};\n/**\n * Infinite Scrolling class\n *\n * @hidden\n */\n\n\nclass InfiniteScroll {\n  /**\n   * Constructor for the Grid infinite scrolling.\n   *\n   * @param {IGrid} parent - specifies the IGrid\n   * @param {ServiceLocator} serviceLocator - specifies the ServiceLocator\n   * @hidden\n   */\n  constructor(parent, serviceLocator) {\n    this.infiniteCache = {};\n    this.infiniteCurrentViewData = {};\n    this.infiniteFrozenCache = {};\n    this.isDownScroll = false;\n    this.isUpScroll = false;\n    this.isScroll = true;\n    this.enableContinuousScroll = false;\n    this.initialRender = true;\n    this.isRemove = false;\n    this.isInitialCollapse = false;\n    this.prevScrollTop = 0;\n    this.actions = ['filtering', 'searching', 'grouping', 'ungrouping', 'reorder', 'sorting', 'refresh'];\n    this.keys = [downArrow, upArrow, enter, shiftEnter];\n    this.rowTop = 0;\n    this.isInitialMovableRender = true;\n    this.virtualInfiniteData = {};\n    this.isCancel = false;\n    this.emptyRowData = {};\n    this.isNormaledit = false;\n    this.isInfiniteScroll = false;\n    this.isLastPage = false;\n    this.isInitialRender = true;\n    this.isFocusScroll = false;\n    this.isGroupCollapse = false;\n    this.parent = parent;\n    this.serviceLocator = serviceLocator;\n    this.isNormaledit = this.parent.editSettings.mode === 'Normal';\n    this.addEventListener();\n    this.widthService = serviceLocator.getService('widthService');\n    this.rowModelGenerator = this.parent.isFrozenGrid() ? new FreezeRowModelGenerator(this.parent) : new RowModelGenerator(this.parent);\n  }\n\n  getModuleName() {\n    return 'infiniteScroll';\n  }\n  /**\n   * @returns {void}\n   * @hidden\n   */\n\n\n  addEventListener() {\n    this.parent.on(dataReady, this.onDataReady, this);\n    this.parent.on(dataSourceModified, this.dataSourceModified, this);\n    this.parent.on(infinitePageQuery, this.infinitePageQuery, this);\n    this.parent.on(infiniteScrollHandler, this.infiniteScrollHandler, this);\n    this.parent.on(beforeCellFocused, this.infiniteCellFocus, this);\n    this.parent.on(appendInfiniteContent, this.appendInfiniteRows, this);\n    this.parent.on(removeInfiniteRows, this.removeInfiniteCacheRows, this);\n    this.parent.on(resetInfiniteBlocks, this.resetInfiniteBlocks, this);\n    this.parent.on(setInfiniteCache, this.setCache, this);\n    this.parent.on(initialCollapse, this.ensureIntialCollapse, this);\n    this.parent.on(keyPressed, this.infiniteCellFocus, this);\n    this.parent.on(infiniteShowHide, this.setDisplayNone, this);\n    this.parent.on(virtualScrollEditActionBegin, this.editActionBegin, this);\n    this.parent.on(getVirtualData, this.getVirtualInfiniteData, this);\n    this.parent.on(editReset, this.resetInfiniteEdit, this);\n    this.parent.on(virtualScrollEditSuccess, this.infiniteEditSuccess, this);\n    this.parent.on(refreshVirtualCache, this.refreshInfiniteCache, this);\n    this.parent.on(infiniteEditHandler, this.infiniteEditHandler, this);\n    this.parent.on(virtualScrollAddActionBegin, this.infiniteAddActionBegin, this);\n    this.parent.on(modelChanged, this.modelChanged, this);\n    this.parent.on(refreshInfiniteCurrentViewData, this.refreshInfiniteCurrentViewData, this);\n    this.parent.on(destroy, this.destroy, this);\n    this.parent.on(contentReady, this.selectNewRow, this);\n    this.parent.on(captionActionComplete, this.captionActionComplete, this);\n    this.parent.on(setVirtualPageQuery, this.setGroupCollapsePageQuery, this);\n    this.actionBeginFunction = this.actionBegin.bind(this);\n    this.actionCompleteFunction = this.actionComplete.bind(this);\n    this.dataBoundFunction = this.dataBound.bind(this);\n    this.parent.on(deleteComplete, this.deleteComplate, this);\n    this.parent.addEventListener(actionBegin, this.actionBeginFunction);\n    this.parent.addEventListener(actionComplete, this.actionCompleteFunction);\n    this.parent.addEventListener(dataBound, this.dataBoundFunction);\n  }\n  /**\n   * @returns {void}\n   * @hidden\n   */\n\n\n  removeEventListener() {\n    if (this.parent.isDestroyed) {\n      return;\n    }\n\n    this.parent.off(dataReady, this.onDataReady);\n    this.parent.off(dataSourceModified, this.dataSourceModified);\n    this.parent.off(infinitePageQuery, this.infinitePageQuery);\n    this.parent.off(infiniteScrollHandler, this.infiniteScrollHandler);\n    this.parent.off(beforeCellFocused, this.infiniteCellFocus);\n    this.parent.off(appendInfiniteContent, this.appendInfiniteRows);\n    this.parent.off(removeInfiniteRows, this.removeInfiniteCacheRows);\n    this.parent.off(resetInfiniteBlocks, this.resetInfiniteBlocks);\n    this.parent.off(setInfiniteCache, this.setCache);\n    this.parent.off(initialCollapse, this.ensureIntialCollapse);\n    this.parent.off(keyPressed, this.infiniteCellFocus);\n    this.parent.off(infiniteShowHide, this.setDisplayNone);\n    this.parent.off(virtualScrollEditActionBegin, this.editActionBegin);\n    this.parent.off(getVirtualData, this.getVirtualInfiniteData);\n    this.parent.off(editReset, this.resetInfiniteEdit);\n    this.parent.off(virtualScrollEditSuccess, this.infiniteEditSuccess);\n    this.parent.off(refreshVirtualCache, this.refreshInfiniteCache);\n    this.parent.off(infiniteEditHandler, this.infiniteEditHandler);\n    this.parent.off(virtualScrollAddActionBegin, this.infiniteAddActionBegin);\n    this.parent.off(modelChanged, this.modelChanged);\n    this.parent.off(refreshInfiniteCurrentViewData, this.refreshInfiniteCurrentViewData);\n    this.parent.off(destroy, this.destroy);\n    this.parent.off(contentReady, this.selectNewRow);\n    this.parent.off(captionActionComplete, this.captionActionComplete);\n    this.parent.off(setVirtualPageQuery, this.setGroupCollapsePageQuery);\n    this.parent.removeEventListener(actionBegin, this.actionBeginFunction);\n    this.parent.removeEventListener(actionComplete, this.actionCompleteFunction);\n    this.parent.removeEventListener(dataBound, this.dataBoundFunction);\n  }\n\n  dataBound() {\n    if (this.groupCaptionAction === 'collapse') {\n      this.groupCaptionAction = 'refresh';\n      this.makeGroupCollapseRequest();\n    } else if (this.groupCaptionAction === 'refresh') {\n      this.parent.hideSpinner();\n      this.groupCaptionAction = this.empty;\n    }\n  }\n\n  setGroupCollapsePageQuery(args) {\n    const gObj = this.parent;\n\n    if (!gObj.infiniteScrollSettings.enableCache && this.isGroupCollapse) {\n      args.skipPage = true;\n      this.isGroupCollapse = false;\n\n      if (this.groupCaptionAction === 'collapse') {\n        const captionRow = gObj.getRowObjectFromUID(this.parentCapUid);\n        const rowObjs = gObj.getRowsObject();\n        let childCount = 0;\n\n        for (let i = rowObjs.length - 1; i >= 0; i--) {\n          if (rowObjs[i].indent === captionRow.indent) {\n            break;\n          }\n\n          if (rowObjs[i].isDataRow) {\n            childCount++;\n          }\n        }\n\n        const key = getGroupKeysAndFields(rowObjs.indexOf(captionRow), rowObjs);\n        let pred = generateExpandPredicates(key.fields, key.keys, this);\n        const predicateList = getPredicates(pred);\n        pred = predicateList[predicateList.length - 1];\n\n        for (let i = predicateList.length - 2; i >= 0; i--) {\n          pred = pred.and(predicateList[i]);\n        }\n\n        args.query.where(pred);\n        args.query.skip(childCount);\n        this.parentCapUid = this.empty;\n      } else {\n        const rows = gObj.getRows();\n        const size = gObj.pageSettings.pageSize;\n        const skip = getRowIndexFromElement(rows[rows.length - 1]) + 1;\n        let additionalCnt = skip - skip % size + size - skip;\n\n        if (skip % size === 0) {\n          additionalCnt = 0;\n        }\n\n        args.query.skip(skip);\n        args.query.take(gObj.infiniteScrollSettings.initialBlocks * gObj.pageSettings.pageSize + additionalCnt);\n      }\n    }\n  }\n\n  captionActionComplete(args) {\n    const gObj = this.parent;\n\n    if (!gObj.infiniteScrollSettings.enableCache && args.isCollapse) {\n      const contetRect = gObj.getContent().firstElementChild.getBoundingClientRect();\n      const tableReact = gObj.contentModule.getTable().getBoundingClientRect();\n\n      if (Math.round(tableReact.bottom - gObj.getRowHeight()) <= Math.round(contetRect.bottom)) {\n        this.parentCapUid = args.parentUid;\n        this.groupCaptionAction = 'collapse';\n        gObj.showSpinner();\n        const caption = gObj.getRowObjectFromUID(args.parentUid);\n        const childCount = this.getCaptionChildCount(caption);\n\n        if (!childCount) {\n          this.groupCaptionAction = 'refresh';\n          this.makeGroupCollapseRequest();\n        } else {\n          this.makeGroupCollapseRequest(args.parentUid);\n        }\n      }\n    }\n  }\n\n  makeGroupCollapseRequest(parentUid) {\n    const gObj = this.parent;\n    const rows = gObj.getRows();\n    const index = getRowIndexFromElement(rows[rows.length - 1]);\n    const prevPage = this.parent.pageSettings.currentPage;\n    this.parent.pageSettings.currentPage = Math.ceil(index / this.parent.pageSettings.pageSize) + 1;\n\n    if (this.parent.pageSettings.currentPage > this.maxPage) {\n      gObj.hideSpinner();\n      return;\n    }\n\n    const scrollArg = {\n      requestType: 'infiniteScroll',\n      currentPage: this.parent.pageSettings.currentPage,\n      prevPage: prevPage,\n      startIndex: index + 1,\n      direction: 'down',\n      isCaptionCollapse: true,\n      parentUid: parentUid\n    };\n    this.isGroupCollapse = true;\n    this.parent.notify('model-changed', scrollArg);\n  }\n\n  getCaptionChildCount(caption) {\n    const rowObj = this.parent.getRowsObject();\n    const index = rowObj.indexOf(caption);\n    let make = false;\n\n    for (let i = index; i < rowObj.length; i++) {\n      if ((rowObj[i].indent === caption.indent || rowObj[i].indent < caption.indent) && rowObj[i].data.key !== caption.data.key) {\n        break;\n      }\n\n      if (rowObj[i].isCaptionRow && !this.childCheck(rowObj, rowObj[i], i)) {\n        make = true;\n        break;\n      }\n    }\n\n    return make;\n  }\n\n  childCheck(rowObj, row$$1, index) {\n    let childCount = 0;\n\n    for (let i = index + 1; i < rowObj.length; i++) {\n      if (rowObj[i].indent === row$$1.indent) {\n        break;\n      }\n\n      if (rowObj[i].indent === row$$1.indent + 1 && rowObj[i].parentUid === row$$1.uid) {\n        childCount++;\n      }\n    }\n\n    return row$$1.data.count === childCount;\n  }\n\n  updateCurrentViewData() {\n    const gObj = this.parent;\n\n    if (gObj.groupSettings.columns.length) {\n      return;\n    }\n\n    const keys = Object.keys(this.infiniteCurrentViewData);\n    gObj.currentViewData = [];\n    const page = gObj.pageSettings.currentPage;\n    const isCache = gObj.infiniteScrollSettings.enableCache;\n    const blocks = gObj.infiniteScrollSettings.maxBlocks;\n    const isMiddlePage = isCache && (page > blocks || this.isUpScroll && page > 1);\n    const start = isMiddlePage ? this.isUpScroll ? page : page - blocks + 1 : 1;\n    const end = isMiddlePage ? start + blocks - 1 : isCache ? blocks : keys.length;\n\n    for (let i = start; i <= end; i++) {\n      if (this.infiniteCurrentViewData[i]) {\n        gObj.currentViewData = gObj.currentViewData.concat(this.infiniteCurrentViewData[i]);\n      }\n    }\n  }\n\n  refreshInfiniteCurrentViewData(e) {\n    const page = this.parent.pageSettings.currentPage;\n    const size = this.parent.pageSettings.pageSize;\n    const blocks = this.parent.infiniteScrollSettings.initialBlocks;\n    const keys = Object.keys(this.infiniteCurrentViewData);\n    const cache = this.parent.infiniteScrollSettings.enableCache;\n\n    if (!this.parent.groupSettings.columns.length) {\n      const isAdd = e.args.requestType === 'save';\n      const isDelete = e.args.requestType === 'delete';\n\n      if (!cache && (isAdd || isDelete)) {\n        if (isAdd) {\n          this.infiniteCurrentViewData[1] = e.data.concat(this.infiniteCurrentViewData[1]);\n        } else {\n          this.infiniteCurrentViewData[keys[keys.length - 1]].push(e.data[0]);\n        }\n      } else {\n        if (blocks > 1 && e.data.length === blocks * size) {\n          this.setInitialCache(e.data.slice(), {}, cache && e.args.requestType === 'delete', true);\n        } else {\n          this.infiniteCurrentViewData[page] = e.data.slice();\n        }\n      }\n    }\n  }\n\n  deleteComplate() {\n    if (this.parent.isFrozenGrid() && !this.parent.infiniteScrollSettings.enableCache) {\n      this.parent.contentModule.refreshScrollOffset();\n    }\n  }\n\n  modelChanged(args) {\n    const rows = this.parent.getRows();\n\n    if (rows && rows.length && args.requestType !== 'infiniteScroll' && (args.requestType === 'delete' || this.requestType === 'add')) {\n      this.firstIndex = getRowIndexFromElement(rows[0]);\n      this.firstBlock = Math.ceil((this.firstIndex + 1) / this.parent.pageSettings.pageSize);\n      this.lastIndex = getRowIndexFromElement(rows[rows.length - 1]);\n\n      if (args.requestType === 'delete') {\n        const rowObj = this.parent.getRowsObject();\n        args.startIndex = this.parent.infiniteScrollSettings.enableCache ? (this.firstBlock - 1) * this.parent.pageSettings.pageSize : rowObj[rowObj.length - 1].index;\n      } else {\n        args.startIndex = this.firstIndex;\n      }\n\n      if (!this.parent.infiniteScrollSettings.enableCache && this.parent.pageSettings.currentPage === this.maxPage && args.requestType === 'delete') {\n        this.isLastPage = true;\n        this.lastIndex = this.lastIndex - 1;\n      }\n    }\n  }\n\n  infiniteAddActionBegin(args) {\n    if (this.isNormaledit) {\n      this.isAdd = true;\n\n      if (this.parent.infiniteScrollSettings.enableCache) {\n        if (!Object.keys(this.emptyRowData).length) {\n          this.createEmptyRowdata();\n        }\n\n        if (this.parent.pageSettings.currentPage > 1) {\n          args.startEdit = false;\n          this.resetInfiniteBlocks({}, true);\n          this.makeRequest({\n            currentPage: 1\n          });\n        }\n      }\n    }\n  }\n\n  infiniteEditHandler(args) {\n    if (!this.parent.infiniteScrollSettings.enableCache && (args.e.requestType === 'delete' || args.e.requestType === 'save' && this.requestType === 'add')) {\n      const frozenCols = this.parent.isFrozenGrid();\n      const rowElms = this.parent.getRows();\n      const rows = this.parent.getRowsObject();\n\n      if (this.ensureRowAvailability(rows, args.result[0])) {\n        if (rowElms.length) {\n          this.resetRowIndex(rows, args.e, rowElms, this.requestType === 'add', true);\n\n          if (frozenCols) {\n            const rows = this.parent.getMovableRowsObject();\n            this.resetRowIndex(rows, args.e, this.parent.getMovableDataRows(), this.requestType === 'add');\n\n            if (this.parent.getFrozenMode() === leftRight) {\n              const frRows = this.parent.getFrozenRightRowsObject();\n              this.resetRowIndex(frRows, args.e, this.parent.getFrozenRightRows(), this.requestType === 'add');\n            }\n          }\n        }\n\n        if (!this.isLastPage) {\n          this.createRow(rows, args);\n        } else {\n          this.isLastPage = false;\n          this.parent.pageSettings.currentPage = this.maxPage;\n\n          if (this.parent.selectionModule.index < this.parent.frozenRows) {\n            remove(rowElms[this.parent.frozenRows - 1]);\n            this.createRow([rows[this.parent.frozenRows - 1]], args, false, true);\n\n            if (frozenCols) {\n              const movableRows = this.parent.getMovableDataRows();\n              remove(movableRows[this.parent.frozenRows]);\n              this.createRow([this.parent.getMovableRowsObject()[this.parent.frozenRows - 1]], args, true, true);\n\n              if (this.parent.getFrozenMode() === leftRight) {\n                const rightRows = this.parent.getFrozenRightDataRows();\n                remove(rightRows[this.parent.frozenRows]);\n                this.createRow([this.parent.getFrozenRightRowsObject()[this.parent.frozenRows - 1]], args, false, true, true);\n              }\n            }\n\n            setRowElements(this.parent);\n          }\n        }\n      }\n\n      this.parent.hideSpinner();\n      this.parent.notify(refreshInfinitePersistSelection, {});\n\n      if (this.requestType === 'delete') {\n        this.parent.notify(deleteComplete, args.e);\n      } else {\n        this.parent.notify(saveComplete, args.e);\n      }\n    }\n\n    this.parent.notify(freezeRender, {\n      case: 'refreshHeight'\n    });\n  }\n\n  createRow(rows, args, isMovable, isFrozenRows, isFrozenRight) {\n    const row$$1 = !isFrozenRows ? this.generateRows(args.result, args.e) : rows;\n    const rowRenderer = new RowRenderer(this.serviceLocator, null, this.parent);\n    let tbody$$1;\n\n    if (isFrozenRight) {\n      tbody$$1 = this.parent.element.querySelector('.e-frozen-right-content').querySelector(tbody);\n    } else {\n      tbody$$1 = !this.parent.isFrozenGrid() ? this.parent.getContent().querySelector(tbody) : isMovable ? this.parent.getMovableVirtualContent().querySelector(tbody) : this.parent.getFrozenVirtualContent().querySelector(tbody);\n    }\n\n    if (this.parent.frozenRows) {\n      tbody$$1 = isFrozenRows && this.requestType !== 'add' || !isFrozenRows && this.requestType === 'add' ? !this.parent.isFrozenGrid() ? this.parent.getHeaderContent().querySelector(tbody) : isMovable ? this.parent.getMovableVirtualHeader().querySelector(tbody) : isFrozenRight ? this.parent.element.querySelector('.e-frozen-right-header').querySelector(tbody) : this.parent.getFrozenVirtualHeader().querySelector(tbody) : tbody$$1;\n    }\n\n    const notifyArgs = {\n      rows: rows,\n      cancel: false,\n      args: args,\n      isMovable: isMovable,\n      isFrozenRows: isFrozenRows,\n      isFrozenRight: isFrozenRows,\n      row: row$$1\n    };\n    this.parent.notify(infiniteCrudCancel, notifyArgs);\n\n    if (!notifyArgs.cancel) {\n      for (let i = row$$1.length - 1; i >= 0; i--) {\n        if (this.requestType === 'delete') {\n          tbody$$1.appendChild(rowRenderer.render(row$$1[i], this.parent.getColumns()));\n        } else {\n          tbody$$1.insertBefore(rowRenderer.render(row$$1[i], this.parent.getColumns()), tbody$$1.firstElementChild);\n        }\n      }\n    }\n\n    if (!isFrozenRows && this.parent.frozenRows && (this.parent.selectionModule.index < this.parent.frozenRows || this.requestType === 'add')) {\n      const rowElems = isMovable ? this.parent.getMovableDataRows() : isFrozenRight ? this.parent.getFrozenRightDataRows() : this.parent.getRows();\n      const index = (isMovable || isFrozenRight) && this.requestType === 'add' ? this.parent.frozenRows : this.parent.frozenRows - 1;\n      remove(rowElems[index]);\n      this.createRow([rows[this.parent.frozenRows - 1]], args, isMovable, true, isFrozenRight);\n    }\n\n    if (!this.parent.infiniteScrollSettings.enableCache && !isFrozenRows) {\n      if (isFrozenRight) {\n        setRowElements(this.parent);\n        this.parent.contentModule.rightFreezeRows = this.requestType === 'add' ? row$$1.concat(rows) : rows.concat(row$$1);\n      } else if (!this.parent.isFrozenGrid() || isMovable) {\n        setRowElements(this.parent);\n        this.parent.contentModule.visibleRows = this.requestType === 'add' ? row$$1.concat(rows) : rows.concat(row$$1);\n\n        if (this.parent.getFrozenMode() === leftRight) {\n          args.e.renderMovableContent = true;\n          this.createRow(this.parent.getFrozenRightRowsObject(), args, false, false, true);\n        }\n      } else {\n        this.parent.contentModule.visibleFrozenRows = this.requestType === 'add' ? row$$1.concat(rows) : rows.concat(row$$1);\n        args.e.isFrozen = true;\n        this.createRow(this.parent.getMovableRowsObject(), args, true);\n      }\n    }\n  }\n\n  ensureRowAvailability(rows, data) {\n    let resume = true;\n\n    if (this.parent.frozenRows && !this.parent.infiniteScrollSettings.enableCache && this.parent.sortSettings.columns && this.requestType === 'add') {\n      const key = this.parent.getPrimaryKeyFieldNames()[0];\n\n      for (let i = 0; i < rows.length; i++) {\n        if (rows[i].data[key] === data[key]) {\n          resume = false;\n          break;\n        }\n      }\n    }\n\n    return resume;\n  }\n\n  generateRows(data, args) {\n    return this.rowModelGenerator.generateRows(data, args);\n  }\n\n  resetRowIndex(rows, args, rowElms, isAdd, isFrozen) {\n    const keyField = this.parent.getPrimaryKeyFieldNames()[0];\n    const isRemove = !(rowElms.length % this.parent.pageSettings.pageSize);\n\n    if (isAdd) {\n      if (isRemove) {\n        if (isFrozen && !this.parent.groupSettings.columns.length) {\n          this.swapCurrentViewData(1, true);\n        }\n\n        remove(rowElms[rows.length - 1]);\n        rowElms.splice(rows.length - 1, 1);\n        rows.splice(rows.length - 1, 1);\n      }\n    } else {\n      rows.filter((e, index) => {\n        if (e.data[keyField] === args.data[0][keyField]) {\n          if (isFrozen && !this.parent.groupSettings.columns.length) {\n            const page = Math.ceil((index + 1) / this.parent.pageSettings.pageSize);\n            this.resetInfiniteCurrentViewData(page, index);\n          }\n\n          rows.splice(index, 1);\n          remove(rowElms[index]);\n          rowElms.splice(index, 1);\n        }\n      });\n    }\n\n    const startIndex = isAdd ? 1 : 0;\n    resetRowIndex(this.parent, rows, rowElms, startIndex);\n  }\n\n  resetInfiniteCurrentViewData(page, index) {\n    index = index - (page - 1) * this.parent.pageSettings.pageSize;\n    this.infiniteCurrentViewData[page].splice(index, 1);\n    this.swapCurrentViewData(page, false);\n  }\n\n  swapCurrentViewData(page, isAdd) {\n    const keys = Object.keys(this.infiniteCurrentViewData);\n    const end = isAdd ? keys.length + 1 : keys.length;\n\n    for (let i = page; i < end; i++) {\n      if (this.infiniteCurrentViewData[i + 1]) {\n        const pageIndex = isAdd ? i : i + 1;\n        const index = isAdd ? this.infiniteCurrentViewData[i].length - 1 : 0;\n        const data = this.infiniteCurrentViewData[pageIndex].splice(index, 1);\n\n        if (isAdd) {\n          this.infiniteCurrentViewData[i + 1] = data.concat(this.infiniteCurrentViewData[i + 1]);\n\n          if (i + 1 === end - 1) {\n            this.infiniteCurrentViewData[i + 1].splice(this.infiniteCurrentViewData[i + 1].length - 1, 1);\n          }\n        } else {\n          this.infiniteCurrentViewData[i].push(data[0]);\n        }\n      }\n    }\n\n    this.updateCurrentViewData();\n  }\n\n  setDisplayNone(args) {\n    if (this.parent.infiniteScrollSettings.enableCache) {\n      const frozenCols = this.parent.isFrozenGrid();\n      const keys = frozenCols ? Object.keys(this.infiniteFrozenCache) : Object.keys(this.infiniteCache);\n\n      for (let i = 1; i <= keys.length; i++) {\n        const cache = frozenCols ? args.isFreeze ? this.infiniteFrozenCache[i][0] : this.infiniteFrozenCache[i][1] : this.infiniteCache[i];\n        cache.filter(e => {\n          e.cells[args.index].visible = args.visible === '';\n        });\n      }\n\n      this.resetContentModuleCache(frozenCols ? this.infiniteFrozenCache : this.infiniteCache);\n    }\n  }\n\n  refreshInfiniteCache(args) {\n    this.getEditedRowObject().data = args.data;\n  }\n\n  getEditedRowObject() {\n    const rowObjects = this.parent.getRowsObject();\n    let editedrow;\n\n    for (let i = 0; i < rowObjects.length; i++) {\n      if (rowObjects[i].index === this.editRowIndex) {\n        editedrow = rowObjects[i];\n      }\n    }\n\n    return editedrow;\n  }\n\n  infiniteEditSuccess(args) {\n    if (this.isNormaledit) {\n      if (!this.isAdd && args.data) {\n        this.updateCurrentViewRecords(args.data);\n      }\n\n      this.isAdd = false;\n    }\n  }\n\n  updateCurrentViewRecords(data) {\n    const index = getEditedDataIndex(this.parent, data);\n\n    if (!isNullOrUndefined(index)) {\n      this.parent.getCurrentViewRecords()[index] = data;\n    }\n  }\n\n  actionBegin(args) {\n    if (args.requestType === 'add' || args.requestType === 'delete') {\n      this.requestType = args.requestType;\n    } else if (args.action === 'add' && args.requestType === 'save') {\n      this.requestType = args.action;\n    }\n\n    if (this.parent.isFrozenGrid() && !args.cancel && args.requestType === 'searching' || args.requestType === 'sorting' || args.requestType === 'filtering') {\n      this.isInitialRender = true;\n    }\n  }\n\n  actionComplete(args) {\n    if (args.requestType === 'delete' || args.requestType === 'save' || args.requestType === 'cancel') {\n      this.requestType = this.empty;\n      this.isCancel = args.requestType === 'cancel' || args.requestType === 'save';\n      this.isAdd = this.isEdit = false;\n\n      if (this.isNormaledit) {\n        this.editRowIndex = this.empty;\n        this.virtualInfiniteData = {};\n        this.parent.editModule.previousVirtualData = {};\n      }\n    }\n  }\n\n  resetInfiniteEdit() {\n    if (this.parent.enableInfiniteScrolling && this.isNormaledit) {\n      if (this.parent.editSettings.allowEditing && this.isEdit || this.parent.editSettings.allowAdding && this.isAdd) {\n        this.parent.isEdit = true;\n      }\n    }\n  }\n\n  getVirtualInfiniteData(data) {\n    data.virtualData = this.virtualInfiniteData;\n    data.isAdd = this.isAdd;\n    data.isCancel = this.isCancel;\n  }\n\n  editActionBegin(e) {\n    this.isEdit = true;\n    this.editRowIndex = e.index;\n    const rowObject = extend({}, this.getEditedRowObject().data);\n    e.data = Object.keys(this.virtualInfiniteData).length ? this.virtualInfiniteData : rowObject;\n  }\n\n  dataSourceModified() {\n    this.resetInfiniteBlocks({\n      requestType: this.empty\n    }, true);\n  }\n\n  onDataReady(e) {\n    if (!isNullOrUndefined(e.count) && e.requestType !== 'infiniteScroll') {\n      this.maxPage = Math.ceil(e.count / this.parent.pageSettings.pageSize);\n    }\n  }\n\n  ensureIntialCollapse(isExpand) {\n    this.isInitialCollapse = !isExpand;\n  }\n\n  infiniteScrollHandler(e) {\n    this.restoreInfiniteEdit();\n    this.restoreInfiniteAdd();\n    const targetEle = e.target;\n    const isInfinite = targetEle.classList.contains(content);\n\n    if (isInfinite && this.parent.enableInfiniteScrolling && !e.isLeft) {\n      const scrollEle = this.parent.getContent().firstElementChild;\n      this.prevScrollTop = scrollEle.scrollTop;\n      const rows = this.parent.getRows();\n\n      if (!rows.length) {\n        return;\n      }\n\n      const index = getRowIndexFromElement(rows[rows.length - 1]) + 1;\n      const prevPage = this.parent.pageSettings.currentPage;\n      let args;\n      const offset = targetEle.scrollHeight - targetEle.scrollTop;\n      const round = Math.round(targetEle.scrollHeight - targetEle.scrollTop);\n      let floor = offset < targetEle.clientHeight ? Math.ceil(offset) : Math.floor(offset);\n\n      if (floor > targetEle.clientHeight) {\n        floor = floor - 1;\n      }\n\n      const isBottom = floor === targetEle.clientHeight || round === targetEle.clientHeight;\n\n      if (!isNullOrUndefined(this.groupCaptionAction)) {\n        return;\n      }\n\n      if (this.isScroll && isBottom && (this.parent.pageSettings.currentPage <= this.maxPage - 1 || this.enableContinuousScroll)) {\n        if (this.parent.infiniteScrollSettings.enableCache) {\n          this.isUpScroll = false;\n          this.isDownScroll = true;\n        }\n\n        const rows = [].slice.call(scrollEle.querySelectorAll('.e-row:not(.e-addedrow)'));\n        const row$$1 = rows[rows.length - 1];\n        const rowIndex = getRowIndexFromElement(row$$1);\n        this.parent.pageSettings.currentPage = Math.ceil(rowIndex / this.parent.pageSettings.pageSize) + 1;\n        args = {\n          requestType: 'infiniteScroll',\n          currentPage: this.parent.pageSettings.currentPage,\n          prevPage: prevPage,\n          startIndex: index,\n          direction: 'down'\n        };\n        this.makeRequest(args);\n      }\n\n      if (this.isScroll && this.parent.infiniteScrollSettings.enableCache && targetEle.scrollTop === 0 && this.parent.pageSettings.currentPage !== 1) {\n        if (this.parent.infiniteScrollSettings.enableCache) {\n          this.isDownScroll = false;\n          this.isUpScroll = true;\n        }\n\n        const row$$1 = [].slice.call(scrollEle.getElementsByClassName(row));\n        const rowIndex = getRowIndexFromElement(row$$1[this.parent.pageSettings.pageSize - 1]);\n        const startIndex = getRowIndexFromElement(row$$1[0]) - this.parent.pageSettings.pageSize;\n        this.parent.pageSettings.currentPage = Math.ceil(rowIndex / this.parent.pageSettings.pageSize) - 1;\n\n        if (this.parent.pageSettings.currentPage) {\n          args = {\n            requestType: 'infiniteScroll',\n            currentPage: this.parent.pageSettings.currentPage,\n            prevPage: prevPage,\n            startIndex: startIndex,\n            direction: 'up'\n          };\n          this.makeRequest(args);\n        }\n      }\n\n      if (this.parent.infiniteScrollSettings.enableCache && !this.isScroll && isNullOrUndefined(args)) {\n        if (this.isDownScroll || this.isUpScroll) {\n          scrollEle.scrollTop = this.top;\n        }\n      }\n    }\n  }\n\n  makeRequest(args) {\n    if (this.parent.pageSettings.currentPage !== args.prevPage) {\n      const initBlocks = this.parent.infiniteScrollSettings.initialBlocks;\n\n      if (initBlocks < this.maxPage && this.parent.pageSettings.currentPage <= this.maxPage) {\n        this.isInfiniteScroll = true;\n\n        if (isNullOrUndefined(this.infiniteCache[args.currentPage])) {\n          setTimeout(() => {\n            this.getVirtualInfiniteEditedData();\n            this.parent.notify('model-changed', args);\n          }, 100);\n        } else {\n          setTimeout(() => {\n            this.getVirtualInfiniteEditedData();\n            this.parent.notify(refreshInfiniteModeBlocks, args);\n          }, 100);\n        }\n      } else {\n        this.parent.pageSettings.currentPage = this.maxPage;\n      }\n    }\n  }\n\n  infinitePageQuery(query) {\n    if (this.initialRender) {\n      this.initialRender = false;\n      this.intialPageQuery(query);\n    } else {\n      if (!this.isInfiniteScroll && (this.requestType === 'delete' || this.requestType === 'add')) {\n        this.editPageQuery(query);\n      } else {\n        query.page(this.parent.pageSettings.currentPage, this.parent.pageSettings.pageSize);\n      }\n    }\n  }\n\n  editPageQuery(query) {\n    const initialBlocks = this.parent.infiniteScrollSettings.initialBlocks;\n    const isCache = this.parent.infiniteScrollSettings.enableCache;\n\n    if (isCache) {\n      this.infiniteCache = {};\n      this.infiniteFrozenCache = {};\n      this.infiniteCurrentViewData = {};\n      query.skip(this.firstIndex);\n      query.take(initialBlocks * this.parent.pageSettings.pageSize);\n    } else {\n      if (this.parent.editSettings.mode === 'Dialog') {\n        this.parent.clearSelection();\n      }\n\n      const index = this.requestType === 'delete' ? this.lastIndex : this.firstIndex;\n      query.skip(index);\n      query.take(1);\n    }\n  }\n\n  intialPageQuery(query) {\n    if (this.parent.infiniteScrollSettings.enableCache && this.parent.infiniteScrollSettings.initialBlocks > this.parent.infiniteScrollSettings.maxBlocks) {\n      this.parent.infiniteScrollSettings.initialBlocks = this.parent.infiniteScrollSettings.maxBlocks;\n    }\n\n    const pageSize = this.parent.pageSettings.pageSize * this.parent.infiniteScrollSettings.initialBlocks;\n    query.page(1, pageSize);\n  }\n\n  scrollToLastFocusedCell(e) {\n    const gObj = this.parent;\n    const rowIdx = this.lastFocusInfo.rowIdx + (e.keyArgs.action === upArrow ? -1 : 1);\n    const cellIdx = this.lastFocusInfo.cellIdx;\n    let row$$1 = gObj.getRowByIndex(rowIdx);\n    const content$$1 = gObj.getContent().firstElementChild;\n\n    if (!row$$1) {\n      const rowRenderer = new RowRenderer(this.serviceLocator, null, this.parent);\n      const page = Math.floor(rowIdx / this.parent.pageSettings.pageSize) + 1;\n      gObj.pageSettings.currentPage = page;\n      const cols = gObj.getColumns();\n      remove(gObj.getContent().querySelector('tbody'));\n      gObj.getContent().querySelector('table').appendChild(gObj.createElement('tbody'));\n      let focusRows = [];\n\n      for (let i = page === 1 || this.maxPage === page ? 0 : -1, k = 0; k < gObj.infiniteScrollSettings.maxBlocks; this.maxPage === page ? i-- : i++, k++) {\n        const rows = this.infiniteCache[page + i];\n\n        if (rows) {\n          focusRows = focusRows.concat(rows);\n\n          for (let j = 0; j < rows.length; j++) {\n            gObj.getContent().querySelector('tbody').appendChild(rowRenderer.render(rows[j], cols));\n          }\n        }\n      }\n\n      gObj.notify(contentReady, {\n        rows: focusRows,\n        args: {}\n      });\n      setRowElements(gObj);\n    }\n\n    row$$1 = gObj.getRowByIndex(rowIdx);\n    const target = row$$1.cells[cellIdx];\n    gObj.focusModule.isInfiniteScroll = true;\n    gObj.focusModule.onClick({\n      target\n    }, true);\n    gObj.selectRow(rowIdx);\n    target.focus();\n    this.isFocusScroll = false;\n    e.cancel = true;\n  }\n\n  setLastCellFocusInfo(e) {\n    const cell = e.byClick && e.clickArgs.target || e.byKey && e.keyArgs.target || (!this.isFocusScroll && e).target;\n\n    if (cell && cell.classList.contains('e-rowcell')) {\n      const cellIdx = parseInt(cell.getAttribute('aria-colindex'), 10);\n      const rowIdx = parseInt(cell.parentElement.getAttribute('aria-rowindex'));\n      this.lastFocusInfo = {\n        rowIdx: rowIdx,\n        cellIdx: cellIdx\n      };\n    }\n  }\n\n  infiniteCellFocus(e) {\n    const gObj = this.parent;\n    const cache = gObj.infiniteScrollSettings.enableCache;\n\n    if (e.byKey) {\n      if (cache && this.isFocusScroll) {\n        this.scrollToLastFocusedCell(e);\n        return;\n      }\n\n      const cell = document.activeElement;\n      let rowIndex = getRowIndexFromElement(cell.parentElement);\n      this.cellIndex = parseInt(cell.getAttribute(ariaColIndex), 10);\n      const content$$1 = gObj.getContent().firstElementChild;\n      const totalRowsCount = this.maxPage * gObj.pageSettings.pageSize - 1;\n      const visibleRowCount = Math.floor(content$$1.offsetHeight / this.parent.getRowHeight());\n      const contentRect = content$$1.getBoundingClientRect();\n\n      if (!isNaN(rowIndex)) {\n        if (e.keyArgs.action === downArrow || e.keyArgs.action === enter) {\n          this.rowIndex = rowIndex += 1;\n          const row$$1 = gObj.getRowByIndex(rowIndex);\n          const rowRect = row$$1 && row$$1.getBoundingClientRect();\n\n          if (cache) {\n            rowIndex = cell.parentElement.rowIndex + 1;\n          }\n\n          if (this.isFocusScroll || !row$$1 && rowIndex < totalRowsCount || rowRect && rowRect.bottom >= contentRect.bottom) {\n            if (!this.isFocusScroll) {\n              this.pressedKey = e.keyArgs.action;\n            }\n\n            this.isFocusScroll = false;\n            content$$1.scrollTop = (rowIndex - visibleRowCount + 1) * this.parent.getRowHeight();\n          } else if (!cache && row$$1) {\n            if (rowRect && (rowRect.bottom >= contentRect.bottom || rowRect.top < contentRect.top)) {\n              row$$1.cells[this.cellIndex].scrollIntoView();\n            }\n          }\n        } else if (e.keyArgs.action === upArrow || e.keyArgs.action === shiftEnter) {\n          this.rowIndex = rowIndex -= 1;\n          const row$$1 = gObj.getRowByIndex(rowIndex);\n          const rowRect = row$$1 && row$$1.getBoundingClientRect();\n\n          if (cache) {\n            rowIndex = cell.parentElement.rowIndex - 1;\n          }\n\n          if (!row$$1 || rowRect.top <= contentRect.top) {\n            this.pressedKey = e.keyArgs.action;\n            content$$1.scrollTop = rowIndex * this.parent.getRowHeight();\n          }\n        }\n      }\n    } else if (e.key === 'PageDown' || e.key === 'PageUp') {\n      this.pressedKey = e.key;\n    }\n\n    this.setLastCellFocusInfo(e);\n  }\n\n  createEmptyRowdata() {\n    this.parent.getColumns().filter(e => {\n      this.emptyRowData[e.field] = this.empty;\n    });\n  }\n\n  getVirtualInfiniteEditedData() {\n    const editForm = this.parent.element.querySelector('.' + editedRow);\n    const addForm = this.parent.element.querySelector('.' + addedRow);\n    const gridForm = this.parent.element.querySelector('.e-gridform');\n\n    if (this.parent.infiniteScrollSettings.enableCache && (editForm || addForm)) {\n      const rowData = editForm ? extend({}, this.getEditedRowObject().data) : extend({}, this.emptyRowData);\n      this.virtualInfiniteData = this.parent.editModule.getCurrentEditedData(gridForm, rowData);\n\n      if (this.parent.isFrozenGrid()) {\n        this.virtualInfiniteData = this.parent.editModule.getCurrentEditedData(this.parent.getMovableVirtualContent().querySelector('.e-gridform'), rowData);\n      }\n    }\n  }\n\n  restoreInfiniteEdit() {\n    const content$$1 = this.parent.getContent().firstElementChild;\n    const frozenEdit = this.parent.frozenRows ? this.editRowIndex >= this.parent.frozenRows : true;\n\n    if (this.isNormaledit && this.parent.infiniteScrollSettings.enableCache && frozenEdit) {\n      if (this.parent.editSettings.allowEditing && !isNullOrUndefined(this.editRowIndex)) {\n        const row$$1 = this.parent.getRowByIndex(this.editRowIndex);\n\n        if (Object.keys(this.virtualInfiniteData).length && row$$1 && !this.parent.getContent().querySelector('.' + editedRow)) {\n          const top = row$$1.getBoundingClientRect().top;\n\n          if (top < content$$1.offsetHeight && top > this.parent.getRowHeight()) {\n            this.parent.isEdit = false;\n            this.parent.editModule.startEdit(row$$1);\n          }\n        }\n      }\n    }\n  }\n\n  restoreInfiniteAdd() {\n    const content$$1 = this.parent.getContent().firstElementChild;\n\n    if (this.parent.getCurrentViewRecords().length && this.parent.getRowByIndex(0) && this.isNormaledit && this.parent.infiniteScrollSettings.enableCache && this.isAdd && !content$$1.querySelector('.' + addedRow)) {\n      const isTop = content$$1.scrollTop < this.parent.getRowHeight();\n\n      if (isTop) {\n        this.parent.isEdit = false;\n        this.parent.addRecord();\n      }\n    }\n  }\n\n  appendInfiniteRows(e) {\n    const frozenCols = this.parent.isFrozenGrid();\n    const scrollEle = this.parent.getContent().firstElementChild;\n    const isInfiniteScroll = this.parent.enableInfiniteScrolling && e.args.requestType === 'infiniteScroll';\n    const isMovable = this.parent.getFrozenMode() === leftRight && e.tableName === 'movable';\n\n    if (isInfiniteScroll && !e.args.isFrozen && !isMovable || !isInfiniteScroll) {\n      if (isInfiniteScroll && e.args.direction === 'up') {\n        e.tbody.insertBefore(e.frag, e.tbody.firstElementChild);\n      } else {\n        e.tbody.appendChild(e.frag);\n      }\n    }\n\n    if (!frozenCols) {\n      this.parent.contentModule.getTable().appendChild(e.tbody);\n      this.updateCurrentViewData();\n    } else {\n      if (isInfiniteScroll) {\n        if (e.tableName === frozenLeft || this.parent.getFrozenMode() === 'Right' && e.tableName === frozenRight) {\n          this.frozenFrag = e.frag;\n        } else if (this.parent.getFrozenMode() === leftRight && e.tableName === 'movable') {\n          this.movableFrag = e.frag;\n        } else {\n          const tbody$$1 = this.parent.getFrozenVirtualContent().querySelector(tbody);\n\n          if (e.args.direction === 'up') {\n            tbody$$1.insertBefore(this.frozenFrag, tbody$$1.firstElementChild);\n          } else {\n            tbody$$1.appendChild(this.frozenFrag);\n          }\n\n          if (e.tableName === frozenRight) {\n            this.parent.getMovableVirtualContent().querySelector(tbody).appendChild(this.movableFrag);\n            this.parent.element.querySelector('.e-frozen-right-content').querySelector(tbody).appendChild(e.frag);\n          } else {\n            this.parent.getMovableVirtualContent().querySelector('.' + table).appendChild(e.tbody);\n          }\n\n          this.parent.contentModule.refreshScrollOffset();\n          this.updateCurrentViewData();\n        }\n      } else {\n        let table$$1;\n\n        if (e.tableName === frozenLeft) {\n          table$$1 = this.parent.getFrozenVirtualContent().querySelector('.' + table);\n        } else if (e.tableName === 'movable') {\n          table$$1 = this.parent.getMovableVirtualContent().querySelector('.' + table);\n\n          if (this.parent.getFrozenMode() !== leftRight) {\n            this.parent.contentModule.refreshScrollOffset();\n            this.updateCurrentViewData();\n          }\n        } else {\n          table$$1 = this.parent.element.querySelector('.e-frozen-right-content').querySelector('.' + table);\n\n          if (this.parent.getFrozenMode() === leftRight) {\n            this.parent.contentModule.refreshScrollOffset();\n            this.updateCurrentViewData();\n          }\n        }\n\n        table$$1.appendChild(e.tbody);\n        this.widthService.refreshFrozenScrollbar();\n      }\n    }\n\n    if (this.isInitialRender && !e.args.isFrozen) {\n      this.isInitialRender = false;\n      this.parent.scrollModule.setHeight();\n    }\n\n    if (!e.args.isFrozen) {\n      this.rowTop = !this.rowTop ? this.parent.getRows()[0].getBoundingClientRect().top : this.rowTop;\n\n      if (isInfiniteScroll) {\n        if (this.parent.infiniteScrollSettings.enableCache && this.isRemove) {\n          scrollEle.scrollTop = this.top;\n        }\n\n        setRowElements(this.parent);\n      }\n\n      this.restoreInfiniteAdd();\n      this.isScroll = true;\n    }\n\n    this.isInfiniteScroll = false;\n  }\n\n  selectNewRow(args) {\n    const gObj = this.parent;\n    const row$$1 = gObj.getRowByIndex(this.rowIndex);\n    const cache = gObj.infiniteScrollSettings.enableCache;\n\n    if (row$$1 && this.keys.some(value => value === this.pressedKey)) {\n      const content$$1 = gObj.getContent().firstElementChild;\n      const rowHeight = gObj.getRowHeight();\n      const target = row$$1.cells[this.cellIndex];\n\n      if (this.pressedKey === downArrow || this.pressedKey === enter || cache && (this.pressedKey === upArrow || this.pressedKey === shiftEnter)) {\n        if (!cache && this.pressedKey !== upArrow && this.pressedKey !== shiftEnter) {\n          content$$1.scrollTop = content$$1.scrollTop + rowHeight;\n        }\n\n        gObj.focusModule.isInfiniteScroll = true;\n        gObj.focusModule.onClick({\n          target\n        }, true);\n        gObj.selectRow(this.rowIndex);\n      }\n    } else if (this.lastFocusInfo || this.pressedKey === pageDown || this.pressedKey === pageUp) {\n      const idx = cache ? 0 : this.lastFocusInfo.rowIdx;\n\n      if (gObj.getRowByIndex(idx)) {\n        const target = gObj.getCellFromIndex(idx, this.lastFocusInfo.cellIdx);\n\n        if (target) {\n          this.isFocusScroll = true;\n\n          if (!cache) {\n            gObj.focusModule.isInfiniteScroll = true;\n            gObj.focusModule.onClick({\n              target\n            }, true);\n          } else {\n            target.focus({\n              preventScroll: true\n            });\n          }\n        }\n      }\n    }\n\n    this.pressedKey = undefined;\n  }\n\n  removeInfiniteCacheRows(e) {\n    const isInfiniteScroll = this.parent.enableInfiniteScrolling && e.args.requestType === 'infiniteScroll';\n\n    if (!e.args.isFrozen && isInfiniteScroll && this.parent.infiniteScrollSettings.enableCache && this.isRemove) {\n      const rows = [].slice.call(this.parent.getContentTable().getElementsByClassName(row));\n\n      if (e.args.direction === 'down') {\n        if (this.parent.allowGrouping && this.parent.groupSettings.columns.length) {\n          const captionRows = [].slice.call(this.parent.getContentTable().querySelectorAll('tr'));\n          this.removeCaptionRows(captionRows, e.args);\n        }\n\n        const addRowCount = this.parent.element.querySelector('.' + addedRow) ? 0 : 1;\n        this.removeTopRows(rows, this.parent.pageSettings.pageSize - addRowCount);\n      }\n\n      if (e.args.direction === 'up') {\n        if (this.parent.allowGrouping && this.parent.groupSettings.columns.length) {\n          const captionRows = [].slice.call(this.parent.getContentTable().querySelectorAll('tr'));\n          this.removeCaptionRows(captionRows, e.args);\n        } else {\n          this.removeBottomRows(rows, rows.length - 1, e.args);\n        }\n      }\n\n      this.isScroll = false;\n      this.top = this.calculateScrollTop(e.args);\n    }\n  }\n\n  calculateScrollTop(args) {\n    let top = 0;\n    const scrollCnt = this.parent.getContent().firstElementChild;\n\n    if (args.direction === 'down') {\n      if (this.parent.allowGrouping && this.parent.groupSettings.columns.length && !this.isInitialCollapse) {\n        top = this.captionRowHeight();\n      }\n\n      const captionRows = [].slice.call(this.parent.getContent().firstElementChild.querySelectorAll('tr:not(.e-row)'));\n      let captionCount = 0;\n\n      if (this.isInitialCollapse && !isNullOrUndefined(captionRows)) {\n        captionCount = Math.round((captionRows.length - 1) / this.parent.groupSettings.columns.length);\n      }\n\n      const value = captionCount ? captionCount : this.parent.pageSettings.pageSize * (this.parent.infiniteScrollSettings.maxBlocks - 1);\n      let currentViewRowCount = 0;\n      let i = 0;\n\n      while (currentViewRowCount < scrollCnt.clientHeight) {\n        i++;\n        currentViewRowCount = i * this.parent.getRowHeight();\n      }\n\n      i = i - 1;\n      top += (value - i) * this.parent.getRowHeight();\n    }\n\n    if (args.direction === 'up') {\n      if (this.parent.allowGrouping && this.parent.groupSettings.columns.length && !this.isInitialCollapse) {\n        top = this.infiniteCache[this.parent.pageSettings.currentPage].length * this.parent.getRowHeight();\n      } else if (this.isInitialCollapse) {\n        const groupedData = this.infiniteCache[this.parent.pageSettings.currentPage];\n        let count = 0;\n\n        for (let i = 0; i < groupedData.length; i++) {\n          if (groupedData[i].isCaptionRow) {\n            count++;\n          }\n        }\n\n        top += Math.round(count / this.parent.groupSettings.columns.length) * this.parent.getRowHeight();\n      } else {\n        top += this.parent.pageSettings.pageSize * this.parent.getRowHeight() + getScrollBarWidth();\n      }\n    }\n\n    return top;\n  }\n\n  captionRowHeight() {\n    const rows = [].slice.call(this.parent.getContent().querySelectorAll('tr:not(.e-row)'));\n    return rows.length * this.parent.getRowHeight();\n  }\n\n  removeTopRows(rows, maxIndx) {\n    const frozeCols = this.parent.isFrozenGrid();\n    const frRows = this.parent.getFrozenMode() === leftRight ? [].slice.call(this.parent.element.querySelector('.e-frozen-right-content').getElementsByClassName(row)) : null;\n    const movableRows = frozeCols ? [].slice.call(this.parent.getMovableVirtualContent().getElementsByClassName(row)) : null;\n\n    for (let i = 0; i <= maxIndx; i++) {\n      if (this.parent.frozenRows && this.parent.pageSettings.currentPage === this.parent.infiniteScrollSettings.maxBlocks + 1 && i > maxIndx - this.parent.frozenRows) {\n        continue;\n      }\n\n      remove(rows[i]);\n\n      if (movableRows) {\n        remove(movableRows[i]);\n      }\n\n      if (frRows) {\n        remove(frRows[i]);\n      }\n    }\n  }\n\n  removeBottomRows(rows, maxIndx, args) {\n    let cnt = 0;\n    const frozeCols = this.parent.isFrozenGrid();\n    const movableRows = frozeCols ? [].slice.call(this.parent.getMovableVirtualContent().getElementsByClassName(row)) : null;\n    const frRows = this.parent.getFrozenMode() === leftRight ? [].slice.call(this.parent.element.querySelector('.e-frozen-right-content').getElementsByClassName(row)) : null;\n    const pageSize = this.parent.pageSettings.pageSize;\n\n    if (!frozeCols && this.infiniteCache[args.prevPage].length < pageSize) {\n      cnt = this.parent.pageSettings.pageSize - this.infiniteCache[args.prevPage].length;\n    }\n\n    if (frozeCols && this.infiniteFrozenCache[args.prevPage][1].length < pageSize) {\n      cnt = this.parent.pageSettings.pageSize - this.infiniteFrozenCache[args.prevPage][1].length;\n    }\n\n    for (let i = maxIndx; cnt < pageSize; i--) {\n      cnt++;\n      remove(rows[i]);\n\n      if (movableRows) {\n        remove(movableRows[i]);\n      }\n\n      if (frRows) {\n        remove(frRows[i]);\n      }\n    }\n  }\n\n  removeCaptionRows(rows, args) {\n    const rowElements = [].slice.call(this.parent.getContent().getElementsByClassName(row));\n\n    if (args.direction === 'down') {\n      const lastRow = rowElements[this.parent.pageSettings.pageSize - 1];\n      const lastRowIndex = getRowIndexFromElement(lastRow) - 1;\n      let k = 0;\n\n      for (let i = 0; k < lastRowIndex; i++) {\n        if (!rows[i].classList.contains(row)) {\n          remove(rows[i]);\n        } else {\n          k = getRowIndexFromElement(rows[i]);\n        }\n      }\n    }\n\n    if (args.direction === 'up') {\n      const lastIndex = getRowIndexFromElement(rowElements[rowElements.length - 1]);\n      const page = Math.ceil(lastIndex / this.parent.pageSettings.pageSize);\n      let startIndex = 0;\n\n      for (let i = this.parent.pageSettings.currentPage + 1; i < page; i++) {\n        startIndex += this.infiniteCache[i].length;\n      }\n\n      for (let i = startIndex; i < rows.length; i++) {\n        remove(rows[i]);\n      }\n    }\n  }\n\n  resetInfiniteBlocks(args, isDataModified) {\n    const isInfiniteScroll = this.parent.enableInfiniteScrolling && args.requestType !== 'infiniteScroll';\n\n    if (!this.initialRender && !isNullOrUndefined(this.parent.infiniteScrollModule) && isInfiniteScroll) {\n      if (this.actions.some(value => value === args.requestType) || isDataModified) {\n        const scrollEle = this.parent.getContent().firstElementChild;\n        this.initialRender = true;\n        scrollEle.scrollTop = 0;\n        this.parent.pageSettings.currentPage = 1;\n        this.infiniteCache = this.infiniteFrozenCache = {};\n        this.infiniteCurrentViewData = {};\n        this.resetContentModuleCache({});\n        this.isRemove = false;\n        this.top = 0;\n        this.isInitialMovableRender = true;\n        this.isInitialCollapse = false;\n        this.parent.contentModule.isRemove = this.isRemove;\n        this.parent.contentModule.isAddRows = this.isRemove;\n        this.parent.contentModule.visibleRows = [];\n        this.parent.contentModule.visibleFrozenRows = [];\n      }\n    }\n  }\n\n  setCache(e) {\n    if (this.parent.enableInfiniteScrolling && this.parent.infiniteScrollSettings.enableCache) {\n      const frozeCols = this.parent.isFrozenGrid();\n      const idx = e.args.isFrozen ? 1 : 0;\n      const isEdit = e.args.requestType !== 'infiniteScroll' && (this.requestType === 'delete' || this.requestType === 'add');\n      const currentPage = this.parent.pageSettings.currentPage;\n\n      if (frozeCols && this.isInitialMovableRender || !frozeCols && !Object.keys(this.infiniteCache).length || isEdit) {\n        this.isInitialMovableRender = !e.args.isFrozen;\n        this.setInitialCache(e.modelData, e.args, isEdit);\n      }\n\n      if (!frozeCols && isNullOrUndefined(this.infiniteCache[this.parent.pageSettings.currentPage])) {\n        this.infiniteCache[this.parent.pageSettings.currentPage] = e.modelData;\n        this.resetContentModuleCache(this.infiniteCache);\n      }\n\n      if (frozeCols) {\n        if (idx === 0 && isNullOrUndefined(this.infiniteFrozenCache[currentPage]) || !this.infiniteFrozenCache[currentPage][idx].length) {\n          this.createFrozenCache(currentPage);\n          this.infiniteFrozenCache[currentPage][idx] = e.modelData;\n\n          if (idx === 1) {\n            this.resetContentModuleCache(this.infiniteFrozenCache);\n          }\n        }\n      }\n\n      if (e.isInfiniteScroll && !this.isRemove) {\n        this.isRemove = (currentPage - 1) % this.parent.infiniteScrollSettings.maxBlocks === 0;\n        this.parent.contentModule.isRemove = this.isRemove;\n      }\n    }\n  }\n\n  setInitialCache(data, args, isEdit, isCurrentViewData) {\n    const frozenCols = this.parent.isFrozenGrid();\n    const idx = args.isFrozen ? 1 : 0;\n    let k = !isEdit ? 1 : this.firstBlock;\n\n    for (let i = 1; i <= this.parent.infiniteScrollSettings.initialBlocks; i++) {\n      const startIndex = (i - 1) * this.parent.pageSettings.pageSize;\n      const endIndex = i * this.parent.pageSettings.pageSize;\n\n      if (this.parent.allowGrouping && this.parent.groupSettings.columns.length && !isCurrentViewData) {\n        this.setInitialGroupCache(data, k, startIndex, endIndex);\n      } else {\n        if (isCurrentViewData) {\n          this.infiniteCurrentViewData[k] = data.slice(startIndex, endIndex);\n        } else {\n          if (frozenCols) {\n            this.createFrozenCache(k);\n            this.infiniteFrozenCache[k][idx] = data.slice(startIndex, endIndex);\n            this.resetContentModuleCache(this.infiniteFrozenCache);\n          } else {\n            this.infiniteCache[k] = data.slice(startIndex, endIndex);\n            this.resetContentModuleCache(this.infiniteCache);\n          }\n        }\n      }\n\n      k++;\n    }\n  }\n\n  createFrozenCache(index) {\n    if (!this.infiniteFrozenCache[index]) {\n      this.infiniteFrozenCache[index] = [[], []];\n    }\n  }\n\n  setInitialGroupCache(data, index, sIndex, eIndex) {\n    const pageData = [];\n    let startIndex = 0;\n\n    for (let i = 1; i <= Object.keys(this.infiniteCache).length; i++) {\n      startIndex += this.infiniteCache[i].length;\n    }\n\n    let k = sIndex;\n\n    for (let i = startIndex; i < data.length && k < eIndex; i++) {\n      if (data[i].index < eIndex || data[i].isCaptionRow) {\n        k = data[i].isCaptionRow ? k : data[i].index;\n        pageData.push(data[i]);\n      }\n\n      if (data[i].index >= eIndex || data[i].index === eIndex - 1) {\n        break;\n      }\n    }\n\n    this.infiniteCache[index] = pageData;\n    this.resetContentModuleCache(this.infiniteCache);\n  }\n\n  resetContentModuleCache(data) {\n    this.parent.contentModule.infiniteCache = data;\n  }\n  /**\n   * @returns {void}\n   * @hidden\n   */\n\n\n  destroy() {\n    this.removeEventListener();\n  }\n\n}\n/**\n * GroupLazyLoadRenderer is used to perform lazy load grouping\n *\n * @hidden\n */\n\n\nclass GroupLazyLoadRenderer extends ContentRender {\n  constructor(parent, locator) {\n    super(parent, locator);\n    this.childCount = 0;\n    this.scrollData = [];\n    this.isFirstChildRow = false;\n    this.groupCache = {};\n    this.startIndexes = {};\n    this.captionCounts = {};\n    this.rowsByUid = {};\n    this.objIdxByUid = {};\n    this.initialGroupCaptions = {};\n    this.requestType = ['paging', 'columnstate', 'reorder', 'cancel', 'save', 'beginEdit', 'add', 'delete', 'filterbeforeopen', 'filterchoicerequest'];\n    /** @hidden */\n\n    this.cacheMode = false;\n    /** @hidden */\n\n    this.cacheBlockSize = 5;\n    /** @hidden */\n\n    this.ignoreAccent = this.parent.allowFiltering ? this.parent.filterSettings.ignoreAccent : false;\n    /** @hidden */\n\n    this.allowCaseSensitive = false;\n    this.locator = locator;\n    this.groupGenerator = new GroupModelGenerator(this.parent);\n    this.summaryModelGen = new GroupSummaryModelGenerator(this.parent);\n    this.captionModelGen = new CaptionSummaryModelGenerator(this.parent);\n    this.rowRenderer = new RowRenderer(this.locator, null, this.parent);\n    this.eventListener();\n  }\n\n  eventListener() {\n    this.parent.addEventListener(actionBegin, this.actionBegin.bind(this));\n    this.parent.addEventListener(actionComplete, this.actionComplete.bind(this));\n    this.parent.on(initialEnd, this.setLazyLoadPageSize, this);\n    this.parent.on(setGroupCache, this.setCache, this);\n    this.parent.on(lazyLoadScrollHandler, this.scrollHandler, this);\n    this.parent.on(columnVisibilityChanged, this.setVisible, this);\n    this.parent.on(groupCollapse, this.collapseShortcut, this);\n  }\n  /**\n   * @param {HTMLTableRowElement} tr - specifies the table row element\n   * @returns {void}\n   * @hidden\n   */\n\n\n  captionExpand(tr) {\n    const page = this.parent.pageSettings.currentPage;\n    const rowsObject = this.groupCache[page];\n    const uid = tr.getAttribute('data-uid');\n    const oriIndex = this.getRowObjectIndexByUid(uid);\n    const isRowExist = rowsObject[oriIndex + 1] ? rowsObject[oriIndex].indent < rowsObject[oriIndex + 1].indent : false;\n    const data = rowsObject[oriIndex];\n    const key = getGroupKeysAndFields(oriIndex, rowsObject);\n    const e = {\n      captionRowElement: tr,\n      groupInfo: data,\n      enableCaching: true,\n      cancel: false\n    };\n    this.parent.trigger(lazyLoadGroupExpand, e, args => {\n      if (args.cancel) {\n        return;\n      }\n\n      args.keys = key.keys;\n      args.fields = key.fields;\n      args.rowIndex = tr.rowIndex;\n      args.makeRequest = !args.enableCaching || !isRowExist;\n\n      if (!args.enableCaching && isRowExist) {\n        this.clearCache([uid]);\n      }\n\n      args.skip = 0;\n      args.take = this.pageSize;\n      data.isExpand = this.rowsByUid[page][data.uid].isExpand = true;\n      this.captionRowExpand(args);\n    });\n  }\n  /**\n   * @param {HTMLTableRowElement} tr - specifies the table row element\n   * @returns {void}\n   * @hidden\n   */\n\n\n  captionCollapse(tr) {\n    const cache = this.groupCache[this.parent.pageSettings.currentPage];\n    const rowIdx = tr.rowIndex;\n    const uid = tr.getAttribute('data-uid');\n    const captionIndex = this.getRowObjectIndexByUid(uid);\n    const e = {\n      captionRowElement: tr,\n      groupInfo: cache[captionIndex],\n      cancel: false\n    };\n    this.parent.trigger(lazyLoadGroupCollapse, e, args => {\n      if (args.cancel) {\n        return;\n      }\n\n      args.isExpand = false;\n      this.removeRows(captionIndex, rowIdx);\n    });\n  }\n  /**\n   * @returns {void}\n   * @hidden */\n\n\n  setLazyLoadPageSize() {\n    const scrollEle = this.parent.getContent().firstElementChild;\n    const blockSize = Math.floor(scrollEle.offsetHeight / this.parent.getRowHeight()) - 1;\n    this.pageSize = this.pageSize ? this.pageSize : blockSize * 3;\n    this.blockSize = Math.ceil(this.pageSize / 2);\n  }\n  /**\n   * @returns {void}\n   * @hidden */\n\n\n  clearLazyGroupCache() {\n    this.clearCache();\n  }\n\n  clearCache(uids) {\n    uids = uids ? uids : this.getInitialCaptionIndexes();\n    const cache = this.groupCache[this.parent.pageSettings.currentPage];\n\n    if (uids.length) {\n      for (let i = 0; i < uids.length; i++) {\n        const capIdx = this.getRowObjectIndexByUid(uids[i]);\n        const capRow = cache[capIdx];\n\n        if (!capRow) {\n          continue;\n        }\n\n        if (this.captionCounts[this.parent.pageSettings.currentPage][capRow.uid]) {\n          for (let i = capIdx + 1; i < cache.length; i++) {\n            if (cache[i].indent === capRow.indent || cache[i].indent < capRow.indent) {\n              delete this.captionCounts[this.parent.pageSettings.currentPage][capRow.uid];\n              break;\n            }\n\n            if (cache[i].isCaptionRow) {\n              delete this.captionCounts[this.parent.pageSettings.currentPage][cache[i].uid];\n            }\n          }\n        }\n\n        if (capRow.isExpand) {\n          const tr = this.parent.getRowElementByUID(capRow.uid);\n\n          if (!tr) {\n            return;\n          }\n\n          this.parent.groupModule.expandCollapseRows(tr.querySelector('.e-recordplusexpand'));\n        }\n\n        const child = this.getNextChilds(capIdx);\n\n        if (!child.length) {\n          continue;\n        }\n\n        let subChild = [];\n\n        if (child[child.length - 1].isCaptionRow) {\n          subChild = this.getChildRowsByParentIndex(cache.indexOf(child[child.length - 1]), false, false, null, true, true);\n        }\n\n        const start = cache.indexOf(child[0]);\n        const end = subChild.length ? cache.indexOf(subChild[subChild.length - 1]) : cache.indexOf(child[child.length - 1]);\n        cache.splice(start, end - (start - 1));\n        this.refreshCaches();\n      }\n    }\n  }\n\n  refreshCaches() {\n    const page = this.parent.pageSettings.currentPage;\n    const cache = this.groupCache[page];\n    this.rowsByUid = {};\n    this.objIdxByUid = {};\n\n    for (let i = 0; i < cache.length; i++) {\n      this.maintainRows(cache[i], i);\n    }\n  }\n\n  getInitialCaptionIndexes() {\n    const page = this.parent.pageSettings.currentPage;\n    const uids = [];\n\n    for (let i = 0; i < this.initialGroupCaptions[page].length; i++) {\n      uids.push(this.initialGroupCaptions[page][i].uid);\n    }\n\n    return uids;\n  }\n  /**\n   * @param {string} uid - specifies the uid\n   * @returns {number} returns the row object uid\n   * @hidden\n   */\n\n\n  getRowObjectIndexByUid(uid) {\n    return this.objIdxByUid[this.parent.pageSettings.currentPage][uid];\n  }\n\n  collapseShortcut(args) {\n    if (this.parent.groupSettings.columns.length && args.target && parentsUntil(args.target, content) && args.target.parentElement.tagName === 'TR') {\n      if (!args.collapse && parentsUntil(args.target, row)) {\n        return;\n      }\n\n      const row$$1 = args.target.parentElement;\n      const uid = row$$1.getAttribute('data-uid');\n\n      if (args.collapse) {\n        const rowObj = this.getRowByUid(uid);\n        const capRow = this.getRowByUid(rowObj.parentUid);\n\n        if (capRow.isCaptionRow && capRow.isExpand) {\n          const capEle = this.getRowElementByUid(rowObj.parentUid);\n          this.parent.groupModule.expandCollapseRows(capEle.cells[rowObj.indent - 1]);\n        }\n      } else {\n        const capRow = this.getRowByUid(uid);\n\n        if (capRow.isCaptionRow && !capRow.isExpand) {\n          const capEle = this.getRowElementByUid(uid);\n          this.parent.groupModule.expandCollapseRows(capEle.cells[capRow.indent]);\n        }\n      }\n    }\n  }\n\n  getRowByUid(uid) {\n    return this.rowsByUid[this.parent.pageSettings.currentPage][uid];\n  }\n\n  actionBegin(args) {\n    if (!args.cancel) {\n      if (!this.requestType.some(value => value === args.requestType)) {\n        this.groupCache = {};\n        this.resetRowMaintenance();\n      }\n\n      if (args.requestType === 'reorder' && this.parent.groupSettings.columns.length) {\n        const keys = Object.keys(this.groupCache);\n\n        for (let j = 0; j < keys.length; j++) {\n          const cache = this.groupCache[keys[j]];\n\n          for (let i = 0; i < cache.length; i++) {\n            if (cache[i].isCaptionRow && !this.captionModelGen.isEmpty()) {\n              this.changeCaptionRow(cache[i], null, keys[j]);\n            }\n\n            if (cache[i].isDataRow) {\n              const from = args.fromIndex + cache[i].indent;\n              const to = args.toIndex + cache[i].indent;\n              this.moveCells(cache[i].cells, from, to);\n            }\n          }\n        }\n      }\n\n      if (args.requestType === 'delete' || args.action === 'add' && args.requestType === 'save') {\n        this.groupCache = {};\n        this.resetRowMaintenance();\n      }\n    }\n  }\n\n  actionComplete(args) {\n    if (!args.cancel && args.requestType !== 'columnstate' && args.requestType !== 'beginEdit' && args.requestType !== 'delete' && args.requestType !== 'save' && args.requestType !== 'reorder') {\n      this.scrollReset();\n    }\n  }\n\n  resetRowMaintenance() {\n    this.startIndexes = {};\n    this.captionCounts = {};\n    this.rowsByUid = {};\n    this.objIdxByUid = {};\n    this.initialGroupCaptions = {};\n  }\n\n  moveCells(arr, from, to) {\n    if (from >= arr.length) {\n      let k = from - arr.length;\n\n      while (k-- + 1) {\n        arr.push(undefined);\n      }\n    }\n\n    arr.splice(from, 0, arr.splice(to, 1)[0]);\n  }\n\n  removeRows(idx, trIdx) {\n    const page = this.parent.pageSettings.currentPage;\n    const rows = this.groupCache[page];\n    const trs = [].slice.call(this.parent.getContent().querySelectorAll('tr'));\n    let aggUid;\n\n    if (this.parent.aggregates.length) {\n      const agg = this.getAggregateByCaptionIndex(idx);\n      aggUid = agg.length ? agg[agg.length - 1].uid : undefined;\n    }\n\n    const indent = rows[idx].indent;\n    this.addClass(this.getNextChilds(idx));\n    rows[idx].isExpand = this.rowsByUid[page][rows[idx].uid].isExpand = false;\n    let capUid;\n\n    for (let i = idx + 1; i < rows.length; i++) {\n      if (rows[i].indent === indent || rows[i].indent < indent) {\n        capUid = rows[i].uid;\n        break;\n      }\n\n      if (rows[i].isCaptionRow && rows[i].isExpand) {\n        this.addClass(this.getNextChilds(i));\n      }\n    }\n\n    for (let i = trIdx + 1; i < trs.length; i++) {\n      if (trs[i].getAttribute('data-uid') === capUid) {\n        break;\n      } else if (trs[i].getAttribute('data-uid') === aggUid) {\n        remove(trs[i]);\n        break;\n      } else {\n        remove(trs[i]);\n      }\n    }\n  }\n\n  addClass(rows) {\n    const last = rows[this.blockSize];\n\n    if (last) {\n      last.lazyLoadCssClass = 'e-lazyload-middle-down';\n    }\n  }\n\n  getNextChilds(index, rowObjects) {\n    const group = this.groupCache[this.parent.pageSettings.currentPage];\n    const rows = rowObjects ? rowObjects : group;\n    const indent = group[index].indent + 1;\n    const childRows = [];\n\n    for (let i = rowObjects ? 0 : index + 1; i < rows.length; i++) {\n      if (rows[i].indent < indent) {\n        break;\n      }\n\n      if (rows[i].indent === indent) {\n        childRows.push(rows[i]);\n      }\n    }\n\n    return childRows;\n  }\n\n  lazyLoadHandler(args) {\n    this.setStartIndexes();\n    const tr = this.parent.getContent().querySelectorAll('tr')[args.index];\n    const uid = tr.getAttribute('data-uid');\n    const captionIndex = this.getRowObjectIndexByUid(uid);\n    const captionRow = this.groupCache[this.parent.pageSettings.currentPage][captionIndex];\n    let rows = args.isRowExist ? args.isScroll ? this.scrollData : this.getChildRowsByParentIndex(captionIndex, true, true, null, true) : [];\n    this.scrollData = [];\n\n    if (!args.isRowExist) {\n      this.setRowIndexes(captionIndex, captionRow);\n      this.refreshCaptionRowCount(this.groupCache[this.parent.pageSettings.currentPage][captionIndex], args.count);\n\n      if (Object.keys(args.data).indexOf('GroupGuid') !== -1) {\n        for (let i = 0; i < args.data.length; i++) {\n          const data = this.groupGenerator.generateCaptionRow(args.data[i], args.level, captionRow.parentGid, undefined, 0, captionRow.uid);\n          rows.push(data);\n\n          if (this.parent.aggregates.length) {\n            rows = rows.concat(this.summaryModelGen.generateRows(args.data[i], {\n              level: args.level + 1,\n              parentUid: data.uid\n            }));\n          }\n        }\n      } else {\n        this.groupGenerator.index = this.getStartIndex(captionIndex, args.isScroll);\n        rows = this.groupGenerator.generateDataRows(args.data, args.level, captionRow.parentGid, 0, captionRow.uid);\n      }\n    }\n\n    const trIdx = args.isScroll ? this.rowIndex : args.index;\n    const nxtChild = this.getNextChilds(captionIndex, rows);\n    const lastRow = !args.up ? this.hasLastChildRow(args.isScroll, args.count, nxtChild.length) : true;\n\n    if (!args.isRowExist && !lastRow) {\n      nxtChild[this.blockSize].lazyLoadCssClass = 'e-lazyload-middle-down';\n    }\n\n    if (!lastRow) {\n      nxtChild[nxtChild.length - 1].lazyLoadCssClass = 'e-not-lazyload-end';\n    }\n\n    const aggregates = !args.isScroll && !args.isRowExist ? this.getAggregateByCaptionIndex(captionIndex) : [];\n\n    if (!args.up) {\n      if (!args.isRowExist) {\n        this.refreshRowObjects(rows, args.isScroll ? this.rowObjectIndex : captionIndex);\n      }\n    }\n\n    this.render(trIdx, rows, lastRow, aggregates);\n\n    if (this.isFirstChildRow && !args.up) {\n      this.parent.getContent().firstElementChild.scrollTop = rows.length * this.parent.getRowHeight();\n    }\n\n    this.isFirstChildRow = false;\n    this.rowIndex = undefined;\n    this.rowObjectIndex = undefined;\n    this.childCount = 0;\n  }\n\n  setRowIndexes(capIdx, row$$1) {\n    if (!this.captionCounts[this.parent.pageSettings.currentPage]) {\n      this.captionCounts[this.parent.pageSettings.currentPage] = {};\n    }\n\n    if (row$$1.isCaptionRow) {\n      this.captionCounts[this.parent.pageSettings.currentPage][row$$1.uid] = row$$1.data.count;\n    }\n  }\n\n  getStartIndex(capIdx, isScroll) {\n    const page = this.parent.pageSettings.currentPage;\n    const cache = this.groupCache[page];\n\n    if (isScroll) {\n      return cache[this.rowObjectIndex].index + 1;\n    }\n\n    let count = 0;\n    let idx = 0;\n    const prevCapRow = this.getRowByUid(cache[capIdx].parentUid);\n\n    if (prevCapRow) {\n      idx = this.prevCaptionCount(prevCapRow);\n    }\n\n    if (cache[capIdx].indent > 0) {\n      for (let i = capIdx - 1; i >= 0; i--) {\n        if (cache[i].indent < cache[capIdx].indent) {\n          break;\n        }\n\n        if (cache[i].isCaptionRow && cache[i].indent === cache[capIdx].indent) {\n          count = count + cache[i].data.count;\n        }\n      }\n    }\n\n    const index = count + idx + this.startIndexes[page][cache[capIdx].parentGid];\n    return index;\n  }\n\n  prevCaptionCount(prevCapRow) {\n    const page = this.parent.pageSettings.currentPage;\n    const cache = this.groupCache[page];\n    let idx = 0;\n\n    for (let i = cache.indexOf(prevCapRow) - 1; i >= 0; i--) {\n      if (cache[i].indent === 0) {\n        break;\n      }\n\n      if (cache[i].indent < prevCapRow.indent) {\n        break;\n      }\n\n      if (cache[i].isCaptionRow && cache[i].indent === prevCapRow.indent) {\n        const count = this.captionCounts[page][cache[i].uid];\n        idx = idx + (count ? count : cache[i].data.count);\n      }\n    }\n\n    const capRow = this.getRowByUid(prevCapRow.parentUid);\n\n    if (capRow) {\n      idx = idx + this.prevCaptionCount(capRow);\n    }\n\n    return idx;\n  }\n\n  setStartIndexes() {\n    const cache = this.groupCache[this.parent.pageSettings.currentPage];\n\n    if (!this.startIndexes[this.parent.pageSettings.currentPage]) {\n      const indexes = [];\n      let idx;\n\n      for (let i = 0; i < cache.length; i++) {\n        if (cache[i].isCaptionRow) {\n          if (!indexes.length) {\n            indexes.push(0);\n          } else {\n            indexes.push(cache[idx].data.count + indexes[indexes.length - 1]);\n          }\n\n          idx = i;\n        }\n      }\n\n      this.startIndexes[this.parent.pageSettings.currentPage] = indexes;\n    }\n  }\n\n  hasLastChildRow(isScroll, captionCount, rowCount) {\n    return isScroll ? captionCount === this.childCount + rowCount : captionCount === rowCount;\n  }\n\n  refreshCaptionRowCount(row$$1, count) {\n    row$$1.data.count = count;\n  }\n\n  render(trIdx, rows, hasLastChildRow, aggregates) {\n    const tr = this.parent.getContent().querySelectorAll('tr')[trIdx];\n\n    if (tr && aggregates.length) {\n      for (let i = aggregates.length - 1; i >= 0; i--) {\n        tr.insertAdjacentElement('afterend', this.rowRenderer.render(aggregates[i], this.parent.getColumns()));\n      }\n    }\n\n    if (tr && rows.length) {\n      for (let i = rows.length - 1; i >= 0; i--) {\n        if (this.confirmRowRendering(rows[i])) {\n          tr.insertAdjacentElement('afterend', this.rowRenderer.render(rows[i], this.parent.getColumns()));\n        }\n      }\n    }\n  }\n  /**\n   * @param {Row<Column>} row - specifies the row\n   * @param {number} index - specifies the index\n   * @returns {void}\n   * @hidden\n   */\n\n\n  maintainRows(row$$1, index) {\n    const page = this.parent.pageSettings.currentPage;\n\n    if (!this.rowsByUid[page]) {\n      this.rowsByUid[page] = {};\n      this.objIdxByUid[page] = {};\n    }\n\n    if (row$$1.uid) {\n      this.rowsByUid[page][row$$1.uid] = row$$1;\n    }\n\n    this.objIdxByUid[page][row$$1.uid] = index;\n  }\n\n  confirmRowRendering(row$$1) {\n    let check = true;\n\n    if (isNullOrUndefined(row$$1.indent) && !row$$1.isDataRow && !row$$1.isCaptionRow) {\n      const cap = this.getRowByUid(row$$1.parentUid);\n\n      if (cap.isCaptionRow && !cap.isExpand) {\n        check = false;\n      }\n    }\n\n    return check;\n  }\n\n  refreshRowObjects(newRows, index) {\n    const page = this.parent.pageSettings.currentPage;\n    const rowsObject = this.groupCache[page];\n    this.rowsByUid[page] = {};\n    this.objIdxByUid[page] = {};\n    const newRowsObject = [];\n    let k = 0;\n\n    for (let i = 0; i < rowsObject.length; i++) {\n      if (i === index) {\n        this.maintainRows(rowsObject[i], k);\n        newRowsObject.push(rowsObject[i]);\n        k++;\n\n        for (let j = 0; j < newRows.length; j++) {\n          this.maintainRows(newRows[j], k);\n          newRowsObject.push(newRows[j]);\n          k++;\n        }\n      } else {\n        this.maintainRows(rowsObject[i], k);\n        newRowsObject.push(rowsObject[i]);\n        k++;\n      }\n    }\n\n    this.groupCache[this.parent.pageSettings.currentPage] = extend([], newRowsObject);\n    this.updateCurrentViewData();\n  }\n\n  getAggregateByCaptionIndex(index) {\n    const cache = this.groupCache[this.parent.pageSettings.currentPage];\n    const parent = cache[index];\n    const indent = parent.indent;\n    const uid = parent.uid;\n    const agg = [];\n\n    for (let i = index + 1; i < cache.length; i++) {\n      if (cache[i].indent === indent) {\n        break;\n      }\n\n      if (isNullOrUndefined(cache[i].indent) && cache[i].parentUid === uid) {\n        agg.push(cache[i]);\n      }\n    }\n\n    return agg;\n  }\n\n  getChildRowsByParentIndex(index, deep, block, data, includeAgg, includeCollapseAgg) {\n    const cache = data ? data : this.groupCache[this.parent.pageSettings.currentPage];\n    const parentRow = cache[index];\n    let agg = [];\n\n    if (!parentRow.isCaptionRow || parentRow.isCaptionRow && !parentRow.isExpand && !includeCollapseAgg) {\n      return [];\n    }\n\n    if (includeAgg && this.parent.aggregates.length) {\n      agg = this.getAggregateByCaptionIndex(index);\n    }\n\n    const indent = parentRow.indent;\n    const uid = parentRow.uid;\n    let rows = [];\n    let count = 0;\n\n    for (let i = index + 1; i < cache.length; i++) {\n      if (cache[i].parentUid === uid) {\n        if (isNullOrUndefined(cache[i].indent)) {\n          continue;\n        }\n\n        count++;\n        rows.push(cache[i]);\n\n        if (deep && cache[i].isCaptionRow) {\n          rows = rows.concat(this.getChildRowsByParentIndex(i, deep, block, data, includeAgg));\n        }\n\n        if (block && count === this.pageSize) {\n          break;\n        }\n      }\n\n      if (cache[i].indent === indent) {\n        break;\n      }\n    }\n\n    return rows.concat(agg);\n  }\n  /**\n   * @param {boolean} isReorder - specifies the isreorder\n   * @returns {Row<Column>[]} returns the row\n   * @hidden\n   */\n\n\n  initialGroupRows(isReorder) {\n    let rows = [];\n    const cache = this.groupCache[this.parent.pageSettings.currentPage];\n\n    if (isReorder) {\n      return this.getRenderedRowsObject();\n    }\n\n    for (let i = 0; i < cache.length; i++) {\n      if (cache[i].indent === 0) {\n        rows.push(cache[i]);\n        rows = rows.concat(this.getChildRowsByParentIndex(i, true, true, cache, true));\n      }\n    }\n\n    return rows;\n  }\n  /**\n   * @returns {Row<Column>[]} retruns the row\n   * @hidden */\n\n\n  getRenderedRowsObject() {\n    const rows = [];\n    const trs = [].slice.call(this.parent.getContent().querySelectorAll('tr'));\n\n    for (let i = 0; i < trs.length; i++) {\n      rows.push(this.getRowByUid(trs[i].getAttribute('data-uid')));\n    }\n\n    return rows;\n  }\n\n  getCacheRowsOnDownScroll(index) {\n    let rows = [];\n    const rowsObject = this.groupCache[this.parent.pageSettings.currentPage];\n    let k = index;\n\n    for (let i = 0; i < this.pageSize; i++) {\n      if (!rowsObject[k] || rowsObject[k].indent < rowsObject[index].indent) {\n        break;\n      }\n\n      if (rowsObject[k].indent === rowsObject[index].indent) {\n        rows.push(rowsObject[k]);\n\n        if (rowsObject[k].isCaptionRow && rowsObject[k].isExpand) {\n          rows = rows.concat(this.getChildRowsByParentIndex(k, true, true, null, true));\n        }\n      }\n\n      if (rowsObject[k].indent > rowsObject[index].indent || isNullOrUndefined(rowsObject[k].indent)) {\n        i--;\n      }\n\n      k++;\n    }\n\n    return rows;\n  }\n\n  getCacheRowsOnUpScroll(start, end, index) {\n    let rows = [];\n    const rowsObject = this.groupCache[this.parent.pageSettings.currentPage];\n    let str = false;\n\n    for (let i = 0; i < rowsObject.length; i++) {\n      if (str && (!rowsObject[i] || rowsObject[i].indent < rowsObject[index].indent || rowsObject[i].uid === end)) {\n        break;\n      }\n\n      if (!str && rowsObject[i].uid === start) {\n        str = true;\n      }\n\n      if (str && rowsObject[i].indent === rowsObject[index].indent) {\n        rows.push(rowsObject[i]);\n\n        if (rowsObject[i].isCaptionRow && rowsObject[i].isExpand) {\n          rows = rows.concat(this.getChildRowsByParentIndex(i, true, true, null, true));\n        }\n      }\n    }\n\n    return rows;\n  }\n\n  scrollHandler(e) {\n    if (this.parent.isDestroyed || this.childCount) {\n      return;\n    }\n\n    const downTrs = [].slice.call(this.parent.getContent().getElementsByClassName('e-lazyload-middle-down'));\n    const upTrs = [].slice.call(this.parent.getContent().getElementsByClassName('e-lazyload-middle-up'));\n    const endTrs = [].slice.call(this.parent.getContent().getElementsByClassName('e-not-lazyload-end'));\n    let tr;\n    let lazyLoadDown = false;\n    let lazyLoadUp = false;\n    let lazyLoadEnd = false;\n\n    if (e.scrollDown && downTrs.length) {\n      const result = this.findRowElements(downTrs);\n      tr = result.tr;\n      lazyLoadDown = result.entered;\n    }\n\n    if (!e.scrollDown && endTrs) {\n      for (let i = 0; i < endTrs.length; i++) {\n        const top = endTrs[i].getBoundingClientRect().top;\n        const scrollHeight = this.parent.getContent().scrollHeight;\n\n        if (top > 0 && top < scrollHeight) {\n          tr = endTrs[i];\n          lazyLoadEnd = true;\n          this.rowIndex = tr.rowIndex;\n          break;\n        }\n      }\n    }\n\n    if (!e.scrollDown && upTrs.length && !lazyLoadEnd) {\n      const result = this.findRowElements(upTrs);\n      tr = result.tr;\n      lazyLoadUp = result.entered;\n    }\n\n    if (tr) {\n      if (lazyLoadDown && e.scrollDown && lazyLoadDown && tr) {\n        this.scrollDownHandler(tr);\n      }\n\n      if (!e.scrollDown && lazyLoadEnd && tr) {\n        this.scrollUpEndRowHandler(tr);\n      }\n\n      if (this.cacheMode && !e.scrollDown && !lazyLoadEnd && lazyLoadUp && tr) {\n        this.scrollUpHandler(tr);\n      }\n    }\n  }\n\n  scrollUpEndRowHandler(tr) {\n    const page = this.parent.pageSettings.currentPage;\n    const rows = this.groupCache[page];\n    const uid = tr.getAttribute('data-uid');\n    let index = this.rowObjectIndex = this.getRowObjectIndexByUid(uid);\n    const idx = index;\n    const childRow = rows[index];\n    const parentCapRow = this.getRowByUid(childRow.parentUid);\n    const capRowObjIdx = this.getRowObjectIndexByUid(parentCapRow.uid);\n    const captionRowEle = this.parent.getContent().querySelector('tr[data-uid=' + parentCapRow.uid + ']');\n    const capRowEleIndex = captionRowEle.rowIndex;\n    const child = this.getChildRowsByParentIndex(capRowObjIdx);\n    const childIdx = child.indexOf(childRow);\n    const currentPage = Math.ceil(childIdx / this.pageSize);\n\n    if (currentPage === 1) {\n      return;\n    }\n\n    this.childCount = currentPage * this.pageSize;\n    index = this.getCurrentBlockEndIndex(childRow, index);\n\n    if (this.childCount < parentCapRow.data.count) {\n      tr.classList.remove('e-not-lazyload-end');\n      childRow.lazyLoadCssClass = '';\n      const isRowExist = rows[index + 1] ? childRow.indent === rows[index + 1].indent : false;\n      this.scrollData = isRowExist ? this.getCacheRowsOnDownScroll(index + 1) : [];\n      const key = getGroupKeysAndFields(capRowObjIdx, rows);\n      const args = {\n        rowIndex: capRowEleIndex,\n        makeRequest: !isRowExist,\n        groupInfo: parentCapRow,\n        fields: key.fields,\n        keys: key.keys,\n        skip: this.childCount,\n        take: this.pageSize,\n        isScroll: true\n      };\n\n      if (this.cacheMode && this.childCount >= this.pageSize * this.cacheBlockSize) {\n        const child = this.getChildRowsByParentIndex(capRowObjIdx);\n        const currenBlock = Math.ceil(child.indexOf(rows[idx]) / this.pageSize);\n        const removeBlock = currenBlock - (this.cacheBlockSize - 1);\n        this.removeBlock(uid, isRowExist, removeBlock, child);\n        args.cachedRowIndex = removeBlock * this.pageSize;\n      }\n\n      this.captionRowExpand(args);\n    } else {\n      this.childCount = 0;\n    }\n  }\n\n  scrollDownHandler(tr) {\n    const page = this.parent.pageSettings.currentPage;\n    const rows = this.groupCache[page];\n    const uid = tr.getAttribute('data-uid');\n    let index = this.getRowObjectIndexByUid(uid);\n    const idx = index;\n    const childRow = rows[index];\n    const parentCapRow = this.getRowByUid(childRow.parentUid);\n    const capRowObjIdx = this.getRowObjectIndexByUid(parentCapRow.uid);\n    const captionRowEle = this.getRowElementByUid(parentCapRow.uid);\n    const capRowEleIndex = captionRowEle.rowIndex;\n    const child = this.getChildRowsByParentIndex(capRowObjIdx);\n    const childIdx = child.indexOf(childRow);\n    const currentPage = Math.ceil(childIdx / this.pageSize);\n    this.childCount = currentPage * this.pageSize;\n    index = this.rowObjectIndex = this.getRowObjectIndexByUid(child[this.childCount - 1].uid);\n    const lastchild = rows[index];\n    const lastRow = this.getRowElementByUid(lastchild.uid);\n    this.rowIndex = lastRow.rowIndex;\n    index = this.getCurrentBlockEndIndex(lastchild, index);\n\n    if (this.childCount < parentCapRow.data.count) {\n      const isRowExist = rows[index + 1] ? childRow.indent === rows[index + 1].indent : false;\n\n      if (isRowExist && !isNullOrUndefined(this.getRowElementByUid(rows[index + 1].uid))) {\n        this.childCount = 0;\n        return;\n      }\n\n      if (currentPage > 1 || !this.cacheMode) {\n        tr.classList.remove('e-lazyload-middle-down');\n        lastRow.classList.remove('e-not-lazyload-end');\n        lastchild.lazyLoadCssClass = '';\n      }\n\n      this.scrollData = isRowExist ? this.getCacheRowsOnDownScroll(this.rowObjectIndex + 1) : [];\n      const query = getGroupKeysAndFields(capRowObjIdx, rows);\n      const args = {\n        rowIndex: capRowEleIndex,\n        makeRequest: !isRowExist,\n        groupInfo: parentCapRow,\n        fields: query.fields,\n        keys: query.keys,\n        skip: this.childCount,\n        take: this.pageSize,\n        isScroll: true\n      };\n\n      if (this.cacheMode && this.childCount - this.pageSize >= this.pageSize * this.cacheBlockSize) {\n        const child = this.getChildRowsByParentIndex(capRowObjIdx);\n        const currenBlock = Math.ceil(child.indexOf(rows[idx]) / this.pageSize) - 1;\n        const removeBlock = currenBlock - (this.cacheBlockSize - 1) + 1;\n        this.removeBlock(uid, isRowExist, removeBlock, child, lastchild);\n        args.cachedRowIndex = removeBlock * this.pageSize;\n      }\n\n      this.captionRowExpand(args);\n    } else {\n      this.childCount = 0;\n    }\n  }\n\n  getCurrentBlockEndIndex(row$$1, index) {\n    const page = this.parent.pageSettings.currentPage;\n    const rows = this.groupCache[page];\n\n    if (row$$1.isCaptionRow) {\n      if (row$$1.isExpand) {\n        const childCount = this.getChildRowsByParentIndex(index, true).length;\n        this.rowIndex = this.rowIndex + childCount;\n      }\n\n      const agg = this.getAggregateByCaptionIndex(index);\n      this.rowObjectIndex = this.rowObjectIndex + agg.length;\n      let idx = index;\n\n      for (let i = idx + 1; i < rows.length; i++) {\n        if (rows[i].indent === rows[index].indent || rows[i].indent < rows[index].indent) {\n          index = idx;\n          break;\n        } else {\n          idx++;\n        }\n      }\n    }\n\n    return index;\n  }\n\n  removeBlock(uid, isRowExist, removeBlock, child, lastchild) {\n    const page = this.parent.pageSettings.currentPage;\n    const rows = this.groupCache[page];\n    const uid1 = child[(removeBlock + 1) * this.pageSize - 1 - this.blockSize].uid;\n    const uid2 = child[removeBlock * this.pageSize - this.pageSize].uid;\n    const uid3 = child[removeBlock * this.pageSize].uid;\n    const firstIdx = this.getRowObjectIndexByUid(uid1);\n    rows[firstIdx].lazyLoadCssClass = 'e-lazyload-middle-up';\n    this.getRowElementByUid(uid1).classList.add('e-lazyload-middle-up');\n\n    if (lastchild) {\n      this.getRowElementByUid(uid3).classList.add('e-not-lazyload-first');\n      this.getRowByUid(uid3).lazyLoadCssClass = 'e-not-lazyload-first';\n      this.getRowByUid(uid2).lazyLoadCssClass = '';\n    }\n\n    if (isRowExist) {\n      this.removeTopRows(lastchild ? lastchild.uid : uid, uid2, uid3);\n    } else {\n      this.uid1 = uid2;\n      this.uid2 = uid3;\n      this.uid3 = lastchild ? lastchild.uid : uid;\n    }\n  }\n\n  scrollUpHandler(tr) {\n    const page = this.parent.pageSettings.currentPage;\n    const rows = this.groupCache[page];\n    const uid = tr.getAttribute('data-uid');\n    const row$$1 = this.getRowByUid(uid);\n    const index = this.rowObjectIndex = this.getRowObjectIndexByUid(uid);\n    const parentCapRow = this.getRowByUid(row$$1.parentUid);\n    const capRowObjIdx = this.rowIndex = this.getRowObjectIndexByUid(parentCapRow.uid);\n    const captionRowEle = this.parent.getRowElementByUID(parentCapRow.uid);\n    const capRowEleIndex = captionRowEle.rowIndex;\n    const child = this.getChildRowsByParentIndex(capRowObjIdx);\n    const childIdx = child.indexOf(rows[index]);\n    const currenBlock = Math.floor(childIdx / this.pageSize);\n    let idx = this.blockSize;\n\n    if (this.blockSize * 2 > this.pageSize) {\n      idx = this.blockSize * 2 - this.pageSize;\n      idx = this.blockSize - idx;\n    }\n\n    const start = child[childIdx - (idx - 1) - this.pageSize].uid;\n    const end = child[childIdx - (idx - 1)].uid;\n    this.scrollData = this.getCacheRowsOnUpScroll(start, end, index - (idx - 1));\n    this.isFirstChildRow = currenBlock > 1;\n\n    if (this.isFirstChildRow) {\n      this.scrollData[0].lazyLoadCssClass = 'e-not-lazyload-first';\n    }\n\n    this.getRowByUid(end).lazyLoadCssClass = '';\n    this.getRowElementByUid(end).classList.remove('e-not-lazyload-first');\n    const removeBlock = currenBlock + this.cacheBlockSize;\n\n    if (child.length !== parentCapRow.data.count && removeBlock * this.pageSize > child.length) {\n      this.isFirstChildRow = false;\n      this.scrollData[0].lazyLoadCssClass = '';\n      this.getRowElementByUid(end).classList.add('e-not-lazyload-first');\n      return;\n    }\n\n    const count = removeBlock * this.pageSize > parentCapRow.data.count ? parentCapRow.data.count : removeBlock * this.pageSize;\n    const size = removeBlock * this.pageSize > parentCapRow.data.count ? this.pageSize - (this.pageSize * removeBlock - parentCapRow.data.count) : this.pageSize;\n    const childRows = this.getChildRowsByParentIndex(rows.indexOf(child[count - 1]), true, false, null, true);\n    const uid1 = childRows.length ? childRows[childRows.length - 1].uid : child[count - 1].uid;\n    const uid2 = child[count - size].uid;\n    const uid3 = child[count - size - 1].uid;\n    const lastIdx = this.objIdxByUid[page][uid2] - idx;\n\n    if (rows[lastIdx].lazyLoadCssClass === 'e-lazyload-middle-down') {\n      const trEle = this.getRowElementByUid(rows[lastIdx].uid);\n\n      if (trEle) {\n        trEle.classList.add('e-lazyload-middle-down');\n      }\n    }\n\n    this.getRowByUid(uid1).lazyLoadCssClass = '';\n    this.getRowByUid(uid3).lazyLoadCssClass = 'e-not-lazyload-end';\n    this.getRowElementByUid(uid3).classList.add('e-not-lazyload-end');\n    this.removeBottomRows(uid1, uid2, uid3);\n    this.rowIndex = tr.rowIndex - idx;\n\n    if (tr.classList.length > 1) {\n      tr.classList.remove('e-lazyload-middle-up');\n    } else {\n      tr.removeAttribute('class');\n    }\n\n    if (!isNullOrUndefined(this.getRowElementByUid(start))) {\n      this.childCount = 0;\n      this.scrollData = [];\n      return;\n    }\n\n    const key = getGroupKeysAndFields(this.getRowObjectIndexByUid(parentCapRow.uid), rows);\n    const args = {\n      rowIndex: capRowEleIndex,\n      makeRequest: false,\n      groupInfo: parentCapRow,\n      fields: key.fields,\n      keys: key.keys,\n      skip: this.childCount,\n      take: this.pageSize,\n      isScroll: true,\n      scrollUp: true\n    };\n    this.captionRowExpand(args);\n  }\n\n  findRowElements(rows) {\n    let entered = false;\n    let tr;\n\n    for (let i = 0; i < rows.length; i++) {\n      const rowIdx = rows[i].rowIndex;\n\n      if (isRowEnteredInGrid(rowIdx, this.parent)) {\n        entered = true;\n        this.rowIndex = rowIdx;\n        tr = rows[i];\n        break;\n      }\n    }\n\n    return {\n      entered,\n      tr\n    };\n  }\n\n  getRowElementByUid(uid) {\n    return this.parent.getContent().querySelector('tr[data-uid=' + uid + ']');\n  }\n\n  removeTopRows(uid1, uid2, uid3) {\n    const trs = [].slice.call(this.parent.getContent().querySelectorAll('tr'));\n    let start = false;\n\n    for (let i = 0; i < trs.length; i++) {\n      if (trs[i].getAttribute('data-uid') === uid3) {\n        const tr = this.parent.getContent().querySelector('tr[data-uid=' + uid1 + ']');\n\n        if (tr) {\n          this.rowIndex = tr.rowIndex;\n        }\n\n        break;\n      }\n\n      if (trs[i].getAttribute('data-uid') === uid2) {\n        start = true;\n      }\n\n      if (start) {\n        remove(trs[i]);\n      }\n    }\n  } // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  removeBottomRows(uid1, uid2, uid3) {\n    const trs = [].slice.call(this.parent.getContent().querySelectorAll('tr'));\n    let trigger = false;\n\n    for (let i = 0; i < trs.length; i++) {\n      if (trs[i].getAttribute('data-uid') === uid2) {\n        trigger = true;\n      }\n\n      if (trigger) {\n        remove(trs[i]);\n\n        if (trs[i].getAttribute('data-uid') === uid1) {\n          break;\n        }\n      }\n    }\n  }\n\n  setCache(e) {\n    const page = this.parent.pageSettings.currentPage;\n    this.groupCache[page] = this.initialGroupCaptions[page] = extend([], e.data);\n  }\n\n  captionRowExpand(args) {\n    const captionRow = args.groupInfo;\n    const level = this.parent.groupSettings.columns.indexOf(captionRow.data.field) + 1;\n    const pred = generateExpandPredicates(args.fields, args.keys, this);\n    const predicateList = getPredicates(pred);\n    const lazyLoad = {\n      level: level,\n      skip: args.skip,\n      take: args.take,\n      where: predicateList\n    };\n\n    if (args.makeRequest) {\n      const query = this.parent.renderModule.data.generateQuery(true);\n\n      if (!query.isCountRequired) {\n        query.isCountRequired = true;\n      }\n\n      query.lazyLoad.push({\n        key: 'onDemandGroupInfo',\n        value: lazyLoad\n      });\n      this.parent.showSpinner();\n      this.parent.renderModule.data.getData({}, query).then(e => {\n        this.parent.hideSpinner();\n\n        if (e.result.length === 0) {\n          return;\n        }\n\n        if (this.cacheMode && this.uid1 && this.uid2) {\n          this.removeTopRows(this.uid3, this.uid1, this.uid2);\n          this.uid1 = this.uid2 = this.uid3 = undefined;\n        }\n\n        this.lazyLoadHandler({\n          data: e.result,\n          count: e.count,\n          level: level,\n          index: args.rowIndex,\n          isRowExist: false,\n          isScroll: args.isScroll,\n          up: false,\n          rowIndex: args.cachedRowIndex\n        });\n      }).catch(e => this.parent.renderModule.dataManagerFailure(e, {\n        requestType: 'grouping'\n      }));\n    } else {\n      this.lazyLoadHandler({\n        data: null,\n        count: args.groupInfo.data.count,\n        level: level,\n        index: args.rowIndex,\n        isRowExist: true,\n        isScroll: args.isScroll,\n        up: args.scrollUp,\n        rowIndex: args.cachedRowIndex\n      });\n    }\n  }\n\n  scrollReset(top) {\n    this.parent.getContent().firstElementChild.scrollTop = top ? this.parent.getContent().firstElementChild.scrollTop + top : 0;\n  }\n\n  updateCurrentViewData() {\n    const records = [];\n    this.getRows().filter(row$$1 => {\n      if (row$$1.isDataRow) {\n        records[row$$1.index] = row$$1.data;\n      }\n    });\n    this.parent.currentViewData = records.length ? records : this.parent.currentViewData;\n  }\n  /**\n   * @returns {Row<Column>[]} returns the row\n   * @hidden */\n\n\n  getGroupCache() {\n    return this.groupCache;\n  }\n  /**\n   * @returns {Row<Column>[]} returns the row\n   * @hidden */\n\n\n  getRows() {\n    return this.groupCache[this.parent.pageSettings.currentPage] || [];\n  }\n  /**\n   * @returns {Element} returns the element\n   * @hidden */\n\n\n  getRowElements() {\n    return [].slice.call(this.parent.getContent().getElementsByClassName(row));\n  }\n  /**\n   * @param {number} index - specifies the index\n   * @returns {Element} returns the element\n   * @hidden\n   */\n\n\n  getRowByIndex(index) {\n    const tr = [].slice.call(this.parent.getContent().getElementsByClassName(row));\n    let row$$1;\n\n    for (let i = 0; !isNullOrUndefined(index) && i < tr.length; i++) {\n      if (tr[i].getAttribute(ariaRowIndex) === index.toString()) {\n        row$$1 = tr[i];\n        break;\n      }\n    }\n\n    return row$$1;\n  }\n  /**\n   * Tucntion to set the column visibility\n   *\n   * @param {Column[]} columns - specifies the column\n   * @returns {void}\n   * @hidden\n   */\n\n\n  setVisible(columns) {\n    const gObj = this.parent;\n    const rows = this.getRows();\n    let testRow;\n    rows.some(r => {\n      if (r.isDataRow) {\n        testRow = r;\n      }\n\n      return r.isDataRow;\n    });\n    const contentrows = this.getRows().filter(row$$1 => !row$$1.isDetailRow);\n\n    for (let i = 0; i < columns.length; i++) {\n      const column = columns[i];\n      const idx = this.parent.getNormalizedColumnIndex(column.uid);\n      const colIdx = this.parent.getColumnIndexByUid(column.uid);\n      const displayVal = column.visible === true ? '' : 'none';\n\n      if (idx !== -1 && testRow && idx < testRow.cells.length) {\n        setStyleAttribute(this.getColGroup().childNodes[idx], {\n          'display': displayVal\n        });\n      }\n\n      this.setDisplayNone(gObj.getDataRows(), colIdx, displayVal, contentrows, idx);\n\n      if (!this.parent.invokedFromMedia && column.hideAtMedia) {\n        this.parent.updateMediaColumns(column);\n      }\n\n      this.parent.invokedFromMedia = false;\n    }\n  }\n  /**\n   * Function to set display.\n   *\n   * @param {Object} tr - specifies the row object\n   * @param {number} idx - specifies the index\n   * @param {string} displayVal - specifies the display value\n   * @param {Row<Column>[]} rows - specifies the array of rows\n   * @param {number} oriIdx - specifies the index\n   * @returns {void}\n   * @hidden\n   */\n\n\n  setDisplayNone(tr, idx, displayVal, rows, oriIdx) {\n    if (!this.parent.groupSettings.columns.length) {\n      setDisplayValue(tr, idx, displayVal, rows);\n    } else {\n      const keys = Object.keys(this.groupCache);\n\n      for (let j = 0; j < keys.length; j++) {\n        const uids = this.rowsByUid[keys[j]];\n        const idxs = Object.keys(uids);\n\n        for (let i = 0; i < idxs.length; i++) {\n          const tr = this.parent.getContent().querySelector('tr[data-uid=' + idxs[i] + ']');\n          const row$$1 = uids[idxs[i]];\n\n          if (row$$1.isCaptionRow) {\n            if (!this.captionModelGen.isEmpty()) {\n              this.changeCaptionRow(row$$1, tr, keys[j]);\n            } else {\n              row$$1.cells[row$$1.indent + 1].colSpan = displayVal === '' ? row$$1.cells[row$$1.indent + 1].colSpan + 1 : row$$1.cells[row$$1.indent + 1].colSpan - 1;\n\n              if (tr) {\n                tr.cells[row$$1.indent + 1].colSpan = row$$1.cells[row$$1.indent + 1].colSpan;\n              }\n            }\n          }\n\n          if (row$$1.isDataRow) {\n            this.showAndHideCells(tr, idx, displayVal, false);\n            row$$1.cells[oriIdx].visible = displayVal === '' ? true : false;\n          }\n\n          if (!row$$1.isCaptionRow && !row$$1.isDataRow && isNullOrUndefined(row$$1.indent)) {\n            row$$1.cells[oriIdx].visible = displayVal === '' ? true : false;\n            row$$1.visible = row$$1.cells.some(cell => cell.isDataCell && cell.visible);\n            this.showAndHideCells(tr, idx, displayVal, true, row$$1);\n          }\n        }\n      }\n    }\n  }\n\n  changeCaptionRow(row$$1, tr, index) {\n    const capRow = row$$1;\n    const captionData = row$$1.data;\n    const data = this.groupGenerator.generateCaptionRow(captionData, capRow.indent, capRow.parentGid, undefined, capRow.tIndex, capRow.parentUid);\n    data.uid = row$$1.uid;\n    data.isExpand = row$$1.isExpand;\n    data.lazyLoadCssClass = row$$1.lazyLoadCssClass;\n    this.rowsByUid[index][row$$1.uid] = data;\n    this.groupCache[index][this.objIdxByUid[index][row$$1.uid]] = data;\n\n    if (tr) {\n      const tbody$$1 = this.parent.getContentTable().querySelector(tbody);\n      tbody$$1.replaceChild(this.rowRenderer.render(data, this.parent.getColumns()), tr);\n    }\n  }\n\n  showAndHideCells(tr, idx, displayVal, isSummary, row$$1) {\n    if (tr) {\n      const cls = isSummary ? 'td.e-summarycell' : 'td.e-rowcell';\n      setStyleAttribute(tr.querySelectorAll(cls)[idx], {\n        'display': displayVal\n      });\n\n      if (tr.querySelectorAll(cls)[idx].classList.contains('e-hide')) {\n        removeClass([tr.querySelectorAll(cls)[idx]], ['e-hide']);\n      }\n\n      if (isSummary) {\n        if (row$$1.visible && tr.classList.contains('e-hide')) {\n          removeClass([tr], ['e-hide']);\n        } else if (!row$$1.visible) {\n          addClass([tr], ['e-hide']);\n        }\n      }\n    }\n  }\n\n}\n/**\n * Group lazy load class\n */\n\n\nclass LazyLoadGroup {\n  /**\n   * Constructor for Grid group lazy load module\n   *\n   * @param {IGrid} parent - specifies the IGrid\n   * @param {ServiceLocator} serviceLocator - specifies the ServiceLocator\n   * @hidden\n   */\n  constructor(parent, serviceLocator) {\n    this.parent = parent;\n    this.serviceLocator = serviceLocator;\n    this.addEventListener();\n  }\n  /**\n   * For internal use only - Get the module name.\n   *\n   * @returns {string} returns the module name\n   * @private\n   */\n\n\n  getModuleName() {\n    return 'lazyLoadGroup';\n  }\n  /**\n   * @returns {void}\n   * @hidden\n   */\n\n\n  addEventListener() {\n    if (this.parent.isDestroyed) {\n      return;\n    }\n\n    this.parent.on(initialLoad, this.instantiateRenderer, this);\n    this.parent.on(destroy, this.destroy, this);\n  }\n  /**\n   * @returns {void}\n   * @hidden\n   */\n\n\n  removeEventListener() {\n    if (this.parent.isDestroyed) {\n      return;\n    }\n\n    this.parent.off(initialLoad, this.instantiateRenderer);\n    this.parent.off(destroy, this.destroy);\n  }\n\n  instantiateRenderer() {\n    if (this.parent.height === 'auto') {\n      this.parent.height = this.parent.pageSettings.pageSize * this.parent.getRowHeight();\n    }\n\n    const renderer = this.serviceLocator.getService('rendererFactory');\n\n    if (this.parent.groupSettings.enableLazyLoading) {\n      renderer.addRenderer(RenderType.Content, new GroupLazyLoadRenderer(this.parent, this.serviceLocator));\n    }\n  }\n  /**\n   * @returns {void}\n   * @hidden\n   */\n\n\n  destroy() {\n    this.removeEventListener();\n  }\n\n}\n/**\n * Action export\n */\n\n/**\n * Models\n */\n\n/**\n * `AutoCompleteEditCell` is used to handle autocomplete cell type editing.\n *\n * @hidden\n */\n\n\nclass AutoCompleteEditCell extends EditCellBase {\n  write(args) {\n    this.column = args.column;\n    const isInlineEdit = this.parent.editSettings.mode !== 'Dialog';\n    this.object = new AutoComplete(extend({\n      dataSource: this.parent.dataSource instanceof DataManager ? this.parent.dataSource : new DataManager(this.parent.dataSource),\n      query: new Query().select(args.column.field),\n      enabled: isEditable(args.column, args.requestType, args.element),\n      fields: {\n        value: args.column.field\n      },\n      value: getObject(args.column.field, args.rowData),\n      // enableRtl: this.parentect.enableRtl,\n      actionComplete: this.selectedValues.bind(this),\n      placeholder: isInlineEdit ? '' : args.column.headerText,\n      floatLabelType: isInlineEdit ? 'Never' : 'Always'\n    }, args.column.edit.params));\n    this.object.appendTo(args.element);\n    /* tslint:disable-next-line:no-any */\n\n    args.element.setAttribute('name', getComplexFieldID(args.column.field));\n  }\n\n  selectedValues(valObj) {\n    valObj.result = DataUtil.distinct(valObj.result, this.object.fields.value, true);\n\n    if (this.column.dataSource) {\n      this.column.dataSource.dataSource.json = valObj.result;\n    }\n  }\n\n}\n/**\n * `ComboBoxEditCell` is used to handle ComboBoxEdit cell type editing.\n *\n * @hidden\n */\n\n\nclass ComboboxEditCell extends EditCellBase {\n  write(args) {\n    this.column = args.column;\n    const isInlineMode = this.parent.editSettings.mode !== 'Dialog';\n    this.obj = new ComboBox(extend({\n      dataSource: this.parent.dataSource instanceof DataManager ? this.parent.dataSource : new DataManager(this.parent.dataSource),\n      query: new Query().select(args.column.field),\n      fields: {\n        value: args.column.field\n      },\n      value: getObject(args.column.field, args.rowData),\n      enableRtl: this.parent.enableRtl,\n      actionComplete: this.finalValue.bind(this),\n      placeholder: isInlineMode ? '' : args.column.headerText,\n      floatLabelType: isInlineMode ? 'Never' : 'Always',\n      enabled: isEditable(args.column, args.requestType, args.element)\n    }, args.column.edit.params));\n    this.obj.appendTo(args.element);\n  }\n\n  finalValue(val) {\n    val.result = DataUtil.distinct(val.result, this.obj.fields.value, true);\n\n    if (this.column.dataSource) {\n      this.column.dataSource.dataSource.json = val.result;\n    }\n  }\n\n}\n/**\n * `MultiSelectEditCell` is used to handle multiselect dropdown cell type editing.\n *\n * @hidden\n */\n\n\nclass MultiSelectEditCell extends EditCellBase {\n  write(args) {\n    this.column = args.column;\n    const isInline = this.parent.editSettings.mode !== 'Dialog';\n    this.obj = new MultiSelect(extend({\n      fields: {\n        text: args.column.field,\n        value: args.column.field\n      },\n      value: getValue(args.column.field, args.rowData),\n      enableRtl: this.parent.enableRtl,\n      placeholder: isInline ? '' : args.column.headerText,\n      popupHeight: '200px',\n      floatLabelType: isInline ? 'Never' : 'Always'\n    }, args.column.edit.params));\n    this.obj.appendTo(args.element);\n    args.element.setAttribute('name', getComplexFieldID(args.column.field));\n  }\n\n}\n/**\n * `TimePickerEditCell` is used to handle Timepicker cell type editing.\n *\n * @hidden\n */\n\n\nclass TimePickerEditCell extends EditCellBase {\n  write(args) {\n    const isInlineEdit = this.parent.editSettings.mode !== 'Dialog';\n    let rowDataValue = getObject(args.column.field, args.rowData);\n    rowDataValue = rowDataValue ? new Date(rowDataValue) : null;\n    this.obj = new TimePicker(extend({\n      floatLabelType: isInlineEdit ? 'Never' : 'Always',\n      value: rowDataValue,\n      placeholder: isInlineEdit ? '' : args.column.headerText,\n      enableRtl: this.parent.enableRtl,\n      enabled: isEditable(args.column, args.requestType, args.element)\n    }, args.column.edit.params));\n    this.obj.appendTo(args.element);\n  }\n\n}\n/**\n * `ToggleEditCell` is used to handle boolean cell type editing.\n *\n * @hidden\n */\n\n\nclass ToggleEditCell extends EditCellBase {\n  constructor() {\n    super(...arguments);\n    this.activeClasses = ['e-selectionbackground', 'e-active'];\n  }\n\n  create(args) {\n    let clsNames = 'e-field e-boolcell';\n\n    if (args.column.type === 'checkbox') {\n      clsNames = 'e-field e-boolcell e-edit-checkselect';\n    }\n\n    return createEditElement(this.parent, args.column, clsNames, {\n      type: 'checkbox',\n      value: args.value\n    });\n  }\n\n  read(element) {\n    return element.checked;\n  }\n\n  write(args) {\n    const chkBoxElement = !isNullOrUndefined(args.row) && args.row.querySelector('.e-edit-checkselect');\n    const data = getObject(args.column.field, args.rowData);\n    let checkState = data && JSON.parse(data.toString().toLowerCase());\n\n    if (!isNullOrUndefined(chkBoxElement)) {\n      this.editType = this.parent.editSettings.mode;\n      this.editRow = args.row;\n\n      if (args.requestType !== 'add') {\n        const row$$1 = this.parent.getRowObjectFromUID(args.row.getAttribute('data-uid'));\n        checkState = row$$1 ? row$$1.isSelected : false;\n      }\n\n      addRemoveActiveClasses([].slice.call(args.row.getElementsByClassName(rowCell)), checkState, ...this.activeClasses);\n    }\n\n    this.obj = new Switch(extend({\n      label: this.parent.editSettings.mode !== 'Dialog' ? ' ' : args.column.headerText,\n      checked: checkState,\n      disabled: !isEditable(args.column, args.requestType, args.element),\n      enableRtl: this.parent.enableRtl,\n      change: this.switchModeChange.bind(this)\n    }, args.column.edit.params));\n    this.obj.appendTo(args.element);\n  }\n\n  switchModeChange(args) {\n    if (this.editRow && this.editType !== 'Dialog') {\n      let addClass$$1 = false;\n\n      if (!args.checked) {\n        this.editRow.removeAttribute('aria-selected');\n      } else {\n        addClass$$1 = true;\n        this.editRow.setAttribute('aria-selected', addClass$$1.toString());\n      }\n\n      addRemoveActiveClasses([].slice.call(this.editRow.getElementsByClassName(rowCell)), addClass$$1, ...this.activeClasses);\n    }\n  }\n\n}\n/**\n * `MaskedTextBoxCellEdit` is used to handle masked input cell type editing.\n *\n * @hidden\n */\n\n\nclass MaskedTextBoxCellEdit extends EditCellBase {\n  write(args) {\n    this.column = args.column;\n    const isInlineEdit = this.parent.editSettings.mode !== 'Dialog';\n    this.obj = new MaskedTextBox(extend({\n      fields: {\n        value: args.column.field\n      },\n      value: getObject(args.column.field, args.rowData),\n      floatLabelType: isInlineEdit ? 'Never' : 'Always',\n      mask: '000-000-0000',\n      enabled: isEditable(args.column, args.requestType, args.element)\n    }, args.column.edit.params));\n    this.obj.appendTo(args.element);\n  }\n\n}\n/**\n * Models\n */\n\n/**\n * Services\n */\n\n/**\n * Grid component exported items\n */\n\n/**\n * Pager component exported items\n */\n\n/**\n * Export Grid components\n */\n\n\nexport { CheckBoxFilterBase, ExcelFilterBase, SortDescriptor, SortSettings, Predicate$1 as Predicate, InfiniteScrollSettings, FilterSettings, SelectionSettings, SearchSettings, RowDropSettings, TextWrapSettings, ResizeSettings, GroupSettings, EditSettings, Grid, CellType, RenderType, ToolbarItem, ResponsiveDialogAction, ResponsiveToolbarAction, doesImplementInterface, valueAccessor, headerValueAccessor, getUpdateUsingRaf, isExportColumns, updateColumnTypeForExportColumns, updatecloneRow, getCollapsedRowsCount, recursive, iterateArrayOrObject, iterateExtend, templateCompiler, setStyleAndAttributes, extend$1 as extend, setColumnIndex, prepareColumns, setCssInGridPopUp, getActualProperties, parentsUntil, getElementIndex, inArray, getActualPropFromColl, removeElement, getPosition, getUid, appendChildren, parents, calculateAggregate, getScrollBarWidth, getRowHeight, getActualRowHeight, isComplexField, getComplexFieldID, setComplexFieldID, isEditable, isActionPrevent, wrap, setFormatter, addRemoveActiveClasses, distinctStringValues, getFilterMenuPostion, getZIndexCalcualtion, toogleCheckbox, setChecked, createCboxWithWrap, removeAddCboxClasses, refreshForeignData, getForeignData, getColumnByForeignKeyValue, getDatePredicate, renderMovable, isGroupAdaptive, getObject, getCustomDateFormat, getExpandedState, getPrintGridModel, extendObjWithFn, measureColumnDepth, checkDepth, refreshFilteredColsUid, Global, getTransformValues, applyBiggerTheme, alignFrozenEditForm, ensureLastRow, ensureFirstRow, isRowEnteredInGrid, getEditedDataIndex, eventPromise, getStateEventArgument, ispercentageWidth, resetRowIndex, compareChanges, setRowElements, splitFrozenRowObjectCells, gridActionHandler, getGridRowObjects, getGridRowElements, sliceElements, getCellsByTableName, getCellByColAndRowIndex, setValidationRuels, getMovableTbody, getFrozenRightTbody, setRowsInTbody, getNumberFormat, addBiggerDialog, performComplexDataOperation, setDisplayValue, addRemoveEventListener, createEditElement, getColumnModelByUid, getColumnModelByFieldName, registerEventHandlers, removeEventHandlers, clearReactVueTemplates, getRowIndexFromElement, generateExpandPredicates, getPredicates, getGroupKeysAndFields, created, destroyed, load, rowDataBound, queryCellInfo, headerCellInfo, actionBegin, actionComplete, actionFailure, dataBound, rowSelecting, rowSelected, rowDeselecting, rowDeselected, cellSelecting, cellSelected, cellDeselecting, cellDeselected, columnSelecting, columnSelected, columnDeselecting, columnDeselected, columnDragStart, columnDrag, columnDrop, rowDragStartHelper, rowDragStart, rowDrag, rowDrop, beforePrint, printComplete, detailDataBound, toolbarClick, batchAdd, batchCancel, batchDelete, beforeBatchAdd, beforeBatchDelete, beforeBatchSave, beginEdit, cellEdit, cellSave, cellSaved, endAdd, endDelete, endEdit, recordDoubleClick, recordClick, beforeDataBound, beforeOpenColumnChooser, beforeOpenAdaptiveDialog, resizeStart, onResize, resizeStop, checkBoxChange, beforeCopy, beforePaste, beforeAutoFill, filterChoiceRequest, filterAfterOpen, filterBeforeOpen, filterSearchBegin, commandClick, exportGroupCaption, lazyLoadGroupExpand, lazyLoadGroupCollapse, initialLoad, initialEnd, dataReady, contentReady, uiUpdate, onEmpty, inBoundModelChanged, modelChanged, colGroupRefresh, headerRefreshed, pageBegin, pageComplete, sortBegin, sortComplete, filterBegin, filterComplete, searchBegin, searchComplete, reorderBegin, reorderComplete, rowDragAndDropBegin, rowDragAndDropComplete, groupBegin, groupComplete, ungroupBegin, ungroupComplete, groupAggregates, refreshFooterRenderer, refreshAggregateCell, refreshAggregates, rowSelectionBegin, rowSelectionComplete, columnSelectionBegin, columnSelectionComplete, cellSelectionBegin, cellSelectionComplete, beforeCellFocused, cellFocused, keyPressed, click, destroy, columnVisibilityChanged, scroll, columnWidthChanged, columnPositionChanged, rowDragAndDrop, rowsAdded, rowsRemoved, columnDragStop, headerDrop, dataSourceModified, refreshComplete, refreshVirtualBlock, dblclick, toolbarRefresh, bulkSave, autoCol, tooltipDestroy, updateData, editBegin, editComplete, addBegin, addComplete, saveComplete, deleteBegin, deleteComplete, preventBatch, dialogDestroy, crudAction, addDeleteAction, destroyForm, doubleTap, beforeExcelExport, excelExportComplete, excelQueryCellInfo, excelHeaderQueryCellInfo, exportDetailDataBound, beforePdfExport, pdfExportComplete, pdfQueryCellInfo, pdfHeaderQueryCellInfo, accessPredicate, contextMenuClick, freezeRender, freezeRefresh, contextMenuOpen, columnMenuClick, columnMenuOpen, filterOpen, filterDialogCreated, filterMenuClose, initForeignKeyColumn, getForeignKeyData, generateQuery, showEmptyGrid, foreignKeyData, columnDataStateChange, dataStateChange, dataSourceChanged, rtlUpdated, beforeFragAppend, frozenHeight, textWrapRefresh, recordAdded, cancelBegin, editNextValCell, hierarchyPrint, expandChildGrid, printGridInit, exportRowDataBound, exportDataBound, rowPositionChanged, columnChooserOpened, batchForm, beforeStartEdit, beforeBatchCancel, batchEditFormRendered, partialRefresh, beforeCustomFilterOpen, selectVirtualRow, columnsPrepared, cBoxFltrBegin, cBoxFltrComplete, fltrPrevent, beforeFltrcMenuOpen, valCustomPlacement, filterCboxValue, componentRendered, restoreFocus, detailStateChange, detailIndentCellInfo, virtaulKeyHandler, virtaulCellFocus, virtualScrollEditActionBegin, virtualScrollEditSuccess, virtualScrollEditCancel, virtualScrollEdit, refreshVirtualCache, editReset, virtualScrollAddActionBegin, getVirtualData, refreshInfiniteModeBlocks, resetInfiniteBlocks, infiniteScrollHandler, infinitePageQuery, infiniteShowHide, appendInfiniteContent, removeInfiniteRows, setInfiniteCache, infiniteEditHandler, initialCollapse, getAggregateQuery, closeFilterDialog, columnChooserCancelBtnClick, getFilterBarOperator, resetColumns, pdfAggregateQueryCellInfo, excelAggregateQueryCellInfo, setGroupCache, lazyLoadScrollHandler, groupCollapse, beforeCheckboxRenderer, refreshHandlers, refreshFrozenColumns, setReorderDestinationElement, refreshVirtualFrozenHeight, setFreezeSelection, setInfiniteFrozenHeight, setInfiniteColFrozenHeight, beforeRefreshOnDataChange, immutableBatchCancel, refreshVirtualFrozenRows, checkScrollReset, refreshFrozenHeight, setHeightToFrozenElement, preventFrozenScrollRefresh, nextCellIndex, refreshInfiniteCurrentViewData, infiniteCrudCancel, filterDialogClose, refreshCustomFilterOkBtn, refreshCustomFilterClearBtn, renderResponsiveCmenu, filterCmenuSelect, customFilterClose, setFullScreenDialog, refreshExpandandCollapse, rowModeChange, enterKeyHandler, refreshVirtualMaxPage, setVirtualPageQuery, selectRowOnContextOpen, pagerRefresh, closeInline, closeBatch, closeEdit, resetVirtualFocus, afterContentRender, refreshVirtualEditFormCells, scrollToEdit, beforeCheckboxRendererQuery, createVirtualValidationForm, validateVirtualForm, destroyChildGrid, stickyScrollComplete, captionActionComplete, refreshInfinitePersistSelection, rowCell, gridHeader, gridContent, gridFooter, headerContent, movableContent, movableHeader, frozenContent, frozenHeader, content, table, row, gridChkBox, editedRow, addedRow, changedRecords, addedRecords, deletedRecords, leftRight, frozenRight, frozenLeft, ariaColIndex, ariaRowIndex, tbody, colGroup, open, change, focus, create, beforeOpen, downArrow, upArrow, pageUp, pageDown, enter, shiftEnter, tab, shiftTab, Data, Sort, Page, Selection, Filter, Search, Scroll, resizeClassList, Resize, Reorder, RowDD, Group, getCloneProperties, Print, DetailRow, Toolbar$1 as Toolbar, Aggregate, summaryIterator, VirtualScroll, Edit, BatchEdit, InlineEdit, NormalEdit, DialogEdit, ColumnChooser, ExcelExport, PdfExport, ExportHelper, ExportValueFormatter, Clipboard, CommandColumn, CheckBoxFilter, menuClass, ContextMenu$1 as ContextMenu, Freeze, ColumnMenu, ExcelFilter, ForeignKey, Logger, detailLists, InfiniteScroll, LazyLoadGroup, Column, CommandColumnModel, GridColumn, StackedColumn, Row, Cell, HeaderRender, ContentRender, RowRenderer, CellRenderer, HeaderCellRenderer, FilterCellRenderer, StackedHeaderCellRenderer, Render, IndentCellRenderer, GroupCaptionCellRenderer, GroupCaptionEmptyCellRenderer, BatchEditRender, DialogEditRender, InlineEditRender, EditRender, BooleanEditCell, DefaultEditCell, DropDownEditCell, NumericEditCell, DatePickerEditCell, CommandColumnRenderer, FreezeContentRender, FreezeRender, StringFilterUI, NumberFilterUI, DateFilterUI, BooleanFilterUI, FlMenuOptrUI, AutoCompleteEditCell, ComboboxEditCell, MultiSelectEditCell, TimePickerEditCell, ToggleEditCell, MaskedTextBoxCellEdit, VirtualContentRenderer, VirtualHeaderRenderer, VirtualElementHandler, GroupLazyLoadRenderer, ColumnFreezeHeaderRenderer, ColumnFreezeContentRenderer, ResponsiveDialogRenderer, EditCellBase, CellRendererFactory, ServiceLocator, RowModelGenerator, GroupModelGenerator, FreezeRowModelGenerator, ValueFormatter, VirtualRowModelGenerator, InterSectionObserver, Pager, ExternalMessage, NumericContainer, PagerMessage, PagerDropDown }; //# sourceMappingURL=ej2-grids.es2015.js.map","map":null,"metadata":{},"sourceType":"module"}